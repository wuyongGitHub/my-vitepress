import { defineComponent as c1, useAttrs as lF, computed as Vp, resolveComponent as uF, createBlock as cF, openBlock as Ia, mergeProps as fF, unref as Wi, withCtx as hF, renderSlot as dF, ref as Ir, onMounted as Rg, onUnmounted as uI, createElementBlock as Lo, normalizeStyle as qu, createCommentVNode as uv, createElementVNode as br, reactive as pF, watch as Fp, nextTick as vF, withModifiers as gF, toDisplayString as Tn, normalizeClass as mF, onBeforeUnmount as yF } from "vue";
const _F = /* @__PURE__ */ c1({
  name: "WyButton",
  __name: "Button",
  setup(r) {
    const t = lF(), e = Vp(() => ["wy-button"]), n = (i) => {
      var a;
      typeof t.onClick == "function" && t.onClick(i), console.log("[Button Click]", {
        type: t.type,
        text: (a = i.target.textContent) == null ? void 0 : a.trim()
      });
    };
    return (i, a) => {
      const o = uF("ElButton");
      return Ia(), cF(o, fF(Wi(t), {
        class: [Wi(t).class, e.value],
        onClick: n
      }), {
        default: hF(() => [
          dF(i.$slots, "default", {}, void 0, !0)
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
}), Ig = (r, t) => {
  const e = r.__vccOpts || r;
  for (const [n, i] of t)
    e[n] = i;
  return e;
}, xF = /* @__PURE__ */ Ig(_F, [["__scopeId", "data-v-1a19201c"]]), Dh = (r) => (r.install = (t) => {
  const e = r.name;
  e && t.component(e, r);
}, r), SF = Dh(xF);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const f1 = "164", qut = { ROTATE: 0, DOLLY: 1, PAN: 2 }, Kut = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, bF = 0, Xw = 1, wF = 2, cI = 1, MF = 2, wa = 3, Fo = 0, bn = 1, Aa = 2, Ro = 0, Uu = 1, Yw = 2, $w = 3, Zw = 4, TF = 5, Us = 100, AF = 101, EF = 102, CF = 103, DF = 104, LF = 200, RF = 201, IF = 202, PF = 203, z_ = 204, U_ = 205, NF = 206, OF = 207, kF = 208, BF = 209, VF = 210, FF = 211, zF = 212, UF = 213, GF = 214, HF = 0, WF = 1, XF = 2, cv = 3, YF = 4, $F = 5, ZF = 6, qF = 7, fI = 0, KF = 1, jF = 2, Io = 0, JF = 1, QF = 2, tz = 3, ez = 4, rz = 5, nz = 6, iz = 7, hI = 300, Ku = 301, ju = 302, G_ = 303, H_ = 304, Pg = 306, W_ = 1e3, $s = 1001, X_ = 1002, Sn = 1003, az = 1004, Qh = 1005, vi = 1006, Lm = 1007, Zs = 1008, zo = 1009, oz = 1010, sz = 1011, dI = 1012, pI = 1013, Ju = 1014, Ca = 1015, Ng = 1016, vI = 1017, gI = 1018, Lh = 1020, lz = 35902, uz = 1021, cz = 1022, Xi = 1023, fz = 1024, hz = 1025, Gu = 1026, th = 1027, mI = 1028, yI = 1029, dz = 1030, _I = 1031, xI = 1033, Rm = 33776, Im = 33777, Pm = 33778, Nm = 33779, qw = 35840, Kw = 35841, jw = 35842, Jw = 35843, Qw = 36196, tM = 37492, eM = 37496, rM = 37808, nM = 37809, iM = 37810, aM = 37811, oM = 37812, sM = 37813, lM = 37814, uM = 37815, cM = 37816, fM = 37817, hM = 37818, dM = 37819, pM = 37820, vM = 37821, Om = 36492, gM = 36494, mM = 36495, pz = 36283, yM = 36284, _M = 36285, xM = 36286, vz = 3200, gz = 3201, mz = 0, yz = 1, xo = "", Vi = "srgb", qo = "srgb-linear", h1 = "display-p3", Og = "display-p3-linear", fv = "linear", qe = "srgb", hv = "rec709", dv = "p3", Ol = 7680, SM = 519, _z = 512, xz = 513, Sz = 514, SI = 515, bz = 516, wz = 517, Mz = 518, Tz = 519, bM = 35044, wM = "300 es", Da = 2e3, pv = 2001;
class gc {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[t];
    if (i !== void 0) {
      const a = i.indexOf(e);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const i = n.slice(0);
      for (let a = 0, o = i.length; a < o; a++)
        i[a].call(this, t);
      t.target = null;
    }
  }
}
const Yr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], zp = Math.PI / 180, Y_ = 180 / Math.PI;
function Rh() {
  const r = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Yr[r & 255] + Yr[r >> 8 & 255] + Yr[r >> 16 & 255] + Yr[r >> 24 & 255] + "-" + Yr[t & 255] + Yr[t >> 8 & 255] + "-" + Yr[t >> 16 & 15 | 64] + Yr[t >> 24 & 255] + "-" + Yr[e & 63 | 128] + Yr[e >> 8 & 255] + "-" + Yr[e >> 16 & 255] + Yr[e >> 24 & 255] + Yr[n & 255] + Yr[n >> 8 & 255] + Yr[n >> 16 & 255] + Yr[n >> 24 & 255]).toLowerCase();
}
function on(r, t, e) {
  return Math.max(t, Math.min(e, r));
}
function Az(r, t) {
  return (r % t + t) % t;
}
function km(r, t, e) {
  return (1 - e) * r + e * t;
}
function Vc(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vn(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const jut = {
  DEG2RAD: zp
};
class Ce {
  constructor(t = 0, e = 0) {
    Ce.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, i = t.elements;
    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(on(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const n = Math.cos(e), i = Math.sin(e), a = this.x - t.x, o = this.y - t.y;
    return this.x = a * n - o * i + t.x, this.y = a * i + o * n + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ye {
  constructor(t, e, n, i, a, o, s, l, u) {
    ye.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, n, i, a, o, s, l, u);
  }
  set(t, e, n, i, a, o, s, l, u) {
    const c = this.elements;
    return c[0] = t, c[1] = i, c[2] = s, c[3] = e, c[4] = a, c[5] = l, c[6] = n, c[7] = o, c[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, i = e.elements, a = this.elements, o = n[0], s = n[3], l = n[6], u = n[1], c = n[4], f = n[7], h = n[2], d = n[5], p = n[8], g = i[0], v = i[3], m = i[6], y = i[1], _ = i[4], x = i[7], b = i[2], S = i[5], w = i[8];
    return a[0] = o * g + s * y + l * b, a[3] = o * v + s * _ + l * S, a[6] = o * m + s * x + l * w, a[1] = u * g + c * y + f * b, a[4] = u * v + c * _ + f * S, a[7] = u * m + c * x + f * w, a[2] = h * g + d * y + p * b, a[5] = h * v + d * _ + p * S, a[8] = h * m + d * x + p * w, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8];
    return e * o * c - e * s * u - n * a * c + n * s * l + i * a * u - i * o * l;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8], f = c * o - s * u, h = s * l - c * a, d = u * a - o * l, p = e * f + n * h + i * d;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / p;
    return t[0] = f * g, t[1] = (i * u - c * n) * g, t[2] = (s * n - i * o) * g, t[3] = h * g, t[4] = (c * e - i * l) * g, t[5] = (i * a - s * e) * g, t[6] = d * g, t[7] = (n * l - u * e) * g, t[8] = (o * e - n * a) * g, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, n, i, a, o, s) {
    const l = Math.cos(a), u = Math.sin(a);
    return this.set(
      n * l,
      n * u,
      -n * (l * o + u * s) + o + t,
      -i * u,
      i * l,
      -i * (-u * o + l * s) + s + e,
      0,
      0,
      1
    ), this;
  }
  //
  scale(t, e) {
    return this.premultiply(Bm.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(Bm.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(Bm.makeTranslation(t, e)), this;
  }
  // for 2D Transforms
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(
      1,
      0,
      t.x,
      0,
      1,
      t.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      t,
      0,
      1,
      e,
      0,
      0,
      1
    ), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      -n,
      0,
      n,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e) {
    return this.set(
      t,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let i = 0; i < 9; i++)
      if (e[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Bm = /* @__PURE__ */ new ye();
function bI(r) {
  for (let t = r.length - 1; t >= 0; --t)
    if (r[t] >= 65535)
      return !0;
  return !1;
}
function vv(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function Ez() {
  const r = vv("canvas");
  return r.style.display = "block", r;
}
const MM = {};
function Cz(r) {
  r in MM || (MM[r] = !0, console.warn(r));
}
const TM = /* @__PURE__ */ new ye().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), AM = /* @__PURE__ */ new ye().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), td = {
  [qo]: {
    transfer: fv,
    primaries: hv,
    toReference: (r) => r,
    fromReference: (r) => r
  },
  [Vi]: {
    transfer: qe,
    primaries: hv,
    toReference: (r) => r.convertSRGBToLinear(),
    fromReference: (r) => r.convertLinearToSRGB()
  },
  [Og]: {
    transfer: fv,
    primaries: dv,
    toReference: (r) => r.applyMatrix3(AM),
    fromReference: (r) => r.applyMatrix3(TM)
  },
  [h1]: {
    transfer: qe,
    primaries: dv,
    toReference: (r) => r.convertSRGBToLinear().applyMatrix3(AM),
    fromReference: (r) => r.applyMatrix3(TM).convertLinearToSRGB()
  }
}, Dz = /* @__PURE__ */ new Set([qo, Og]), Fe = {
  enabled: !0,
  _workingColorSpace: qo,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(r) {
    if (!Dz.has(r))
      throw new Error(`Unsupported working color space, "${r}".`);
    this._workingColorSpace = r;
  },
  convert: function(r, t, e) {
    if (this.enabled === !1 || t === e || !t || !e)
      return r;
    const n = td[t].toReference, i = td[e].fromReference;
    return i(n(r));
  },
  fromWorkingColorSpace: function(r, t) {
    return this.convert(r, this._workingColorSpace, t);
  },
  toWorkingColorSpace: function(r, t) {
    return this.convert(r, t, this._workingColorSpace);
  },
  getPrimaries: function(r) {
    return td[r].primaries;
  },
  getTransfer: function(r) {
    return r === xo ? fv : td[r].transfer;
  }
};
function Hu(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Vm(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let kl;
class Lz {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      kl === void 0 && (kl = vv("canvas")), kl.width = t.width, kl.height = t.height;
      const n = kl.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = kl;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      const e = vv("canvas");
      e.width = t.width, e.height = t.height;
      const n = e.getContext("2d");
      n.drawImage(t, 0, 0, t.width, t.height);
      const i = n.getImageData(0, 0, t.width, t.height), a = i.data;
      for (let o = 0; o < a.length; o++)
        a[o] = Hu(a[o] / 255) * 255;
      return n.putImageData(i, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let n = 0; n < e.length; n++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(Hu(e[n] / 255) * 255) : e[n] = Hu(e[n]);
      return {
        data: e,
        width: t.width,
        height: t.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
}
let Rz = 0;
class wI {
  constructor(t = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Rz++ }), this.uuid = Rh(), this.data = t, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let a;
      if (Array.isArray(i)) {
        a = [];
        for (let o = 0, s = i.length; o < s; o++)
          i[o].isDataTexture ? a.push(Fm(i[o].image)) : a.push(Fm(i[o]));
      } else
        a = Fm(i);
      n.url = a;
    }
    return e || (t.images[this.uuid] = n), n;
  }
}
function Fm(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Lz.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Iz = 0;
class ln extends gc {
  constructor(t = ln.DEFAULT_IMAGE, e = ln.DEFAULT_MAPPING, n = $s, i = $s, a = vi, o = Zs, s = Xi, l = zo, u = ln.DEFAULT_ANISOTROPY, c = xo) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Iz++ }), this.uuid = Rh(), this.name = "", this.source = new wI(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = a, this.minFilter = o, this.anisotropy = u, this.format = s, this.internalFormat = null, this.type = l, this.offset = new Ce(0, 0), this.repeat = new Ce(1, 1), this.center = new Ce(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ye(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== hI)
      return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case W_:
          t.x = t.x - Math.floor(t.x);
          break;
        case $s:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case X_:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case W_:
          t.y = t.y - Math.floor(t.y);
          break;
        case $s:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case X_:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
}
ln.DEFAULT_IMAGE = null;
ln.DEFAULT_MAPPING = hI;
ln.DEFAULT_ANISOTROPY = 1;
class Nr {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    Nr.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, i) {
    return this.x = t, this.y = e, this.z = n, this.w = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, i = this.z, a = this.w, o = t.elements;
    return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * a, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * a, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * a, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * a, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, a;
    const l = t.elements, u = l[0], c = l[4], f = l[8], h = l[1], d = l[5], p = l[9], g = l[2], v = l[6], m = l[10];
    if (Math.abs(c - h) < 0.01 && Math.abs(f - g) < 0.01 && Math.abs(p - v) < 0.01) {
      if (Math.abs(c + h) < 0.1 && Math.abs(f + g) < 0.1 && Math.abs(p + v) < 0.1 && Math.abs(u + d + m - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const _ = (u + 1) / 2, x = (d + 1) / 2, b = (m + 1) / 2, S = (c + h) / 4, w = (f + g) / 4, A = (p + v) / 4;
      return _ > x && _ > b ? _ < 0.01 ? (n = 0, i = 0.707106781, a = 0.707106781) : (n = Math.sqrt(_), i = S / n, a = w / n) : x > b ? x < 0.01 ? (n = 0.707106781, i = 0, a = 0.707106781) : (i = Math.sqrt(x), n = S / i, a = A / i) : b < 0.01 ? (n = 0.707106781, i = 0.707106781, a = 0) : (a = Math.sqrt(b), n = w / a, i = A / a), this.set(n, i, a, e), this;
    }
    let y = Math.sqrt((v - p) * (v - p) + (f - g) * (f - g) + (h - c) * (h - c));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (v - p) / y, this.y = (f - g) / y, this.z = (h - c) / y, this.w = Math.acos((u + d + m - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Pz extends gc {
  constructor(t = 1, e = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Nr(0, 0, t, e), this.scissorTest = !1, this.viewport = new Nr(0, 0, t, e);
    const i = { width: t, height: e, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: vi,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new ln(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let s = 0; s < o; s++)
      this.textures[s] = a.clone(), this.textures[s].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      this.width = t, this.height = e, this.depth = n;
      for (let i = 0, a = this.textures.length; i < a; i++)
        this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
    for (let n = 0, i = t.textures.length; n < i; n++)
      this.textures[n] = t.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const e = Object.assign({}, t.texture.image);
    return this.texture.source = new wI(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class fl extends Pz {
  constructor(t = 1, e = 1, n = {}) {
    super(t, e, n), this.isWebGLRenderTarget = !0;
  }
}
class MI extends ln {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = Sn, this.minFilter = Sn, this.wrapR = $s, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Nz extends ln {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = Sn, this.minFilter = Sn, this.wrapR = $s, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Ih {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i;
  }
  static slerpFlat(t, e, n, i, a, o, s) {
    let l = n[i + 0], u = n[i + 1], c = n[i + 2], f = n[i + 3];
    const h = a[o + 0], d = a[o + 1], p = a[o + 2], g = a[o + 3];
    if (s === 0) {
      t[e + 0] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = f;
      return;
    }
    if (s === 1) {
      t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, t[e + 3] = g;
      return;
    }
    if (f !== g || l !== h || u !== d || c !== p) {
      let v = 1 - s;
      const m = l * h + u * d + c * p + f * g, y = m >= 0 ? 1 : -1, _ = 1 - m * m;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), S = Math.atan2(b, m * y);
        v = Math.sin(v * S) / b, s = Math.sin(s * S) / b;
      }
      const x = s * y;
      if (l = l * v + h * x, u = u * v + d * x, c = c * v + p * x, f = f * v + g * x, v === 1 - s) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + f * f);
        l *= b, u *= b, c *= b, f *= b;
      }
    }
    t[e] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = f;
  }
  static multiplyQuaternionsFlat(t, e, n, i, a, o) {
    const s = n[i], l = n[i + 1], u = n[i + 2], c = n[i + 3], f = a[o], h = a[o + 1], d = a[o + 2], p = a[o + 3];
    return t[e] = s * p + c * f + l * d - u * h, t[e + 1] = l * p + c * h + u * f - s * d, t[e + 2] = u * p + c * d + s * h - l * f, t[e + 3] = c * p - s * f - l * h - u * d, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, n, i) {
    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const n = t._x, i = t._y, a = t._z, o = t._order, s = Math.cos, l = Math.sin, u = s(n / 2), c = s(i / 2), f = s(a / 2), h = l(n / 2), d = l(i / 2), p = l(a / 2);
    switch (o) {
      case "XYZ":
        this._x = h * c * f + u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "YXZ":
        this._x = h * c * f + u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f + h * d * p;
        break;
      case "ZXY":
        this._x = h * c * f - u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "ZYX":
        this._x = h * c * f - u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f + h * d * p;
        break;
      case "YZX":
        this._x = h * c * f + u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "XZY":
        this._x = h * c * f - u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f + h * d * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2, i = Math.sin(n);
    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, n = e[0], i = e[4], a = e[8], o = e[1], s = e[5], l = e[9], u = e[2], c = e[6], f = e[10], h = n + s + f;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      this._w = 0.25 / d, this._x = (c - l) * d, this._y = (a - u) * d, this._z = (o - i) * d;
    } else if (n > s && n > f) {
      const d = 2 * Math.sqrt(1 + n - s - f);
      this._w = (c - l) / d, this._x = 0.25 * d, this._y = (i + o) / d, this._z = (a + u) / d;
    } else if (s > f) {
      const d = 2 * Math.sqrt(1 + s - n - f);
      this._w = (a - u) / d, this._x = (i + o) / d, this._y = 0.25 * d, this._z = (l + c) / d;
    } else {
      const d = 2 * Math.sqrt(1 + f - n - s);
      this._w = (o - i) / d, this._x = (a + u) / d, this._y = (l + c) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(on(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (n === 0)
      return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x, i = t._y, a = t._z, o = t._w, s = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = n * c + o * s + i * u - a * l, this._y = i * c + o * l + a * s - n * u, this._z = a * c + o * u + n * l - i * s, this._w = o * c - n * s - i * l - a * u, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const n = this._x, i = this._y, a = this._z, o = this._w;
    let s = o * t._w + n * t._x + i * t._y + a * t._z;
    if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1)
      return this._w = o, this._x = n, this._y = i, this._z = a, this;
    const l = 1 - s * s;
    if (l <= Number.EPSILON) {
      const d = 1 - e;
      return this._w = d * o + e * this._w, this._x = d * n + e * this._x, this._y = d * i + e * this._y, this._z = d * a + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, s), f = Math.sin((1 - e) * c) / u, h = Math.sin(e * c) / u;
    return this._w = o * f + this._w * h, this._x = n * f + this._x * h, this._y = i * f + this._y * h, this._z = a * f + this._z * h, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      i * Math.sin(t),
      i * Math.cos(t),
      a * Math.sin(e),
      a * Math.cos(e)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class K {
  constructor(t = 0, e = 0, n = 0) {
    K.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n;
  }
  set(t, e, n) {
    return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(EM.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(EM.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements;
    return this.x = a[0] * e + a[3] * n + a[6] * i, this.y = a[1] * e + a[4] * n + a[7] * i, this.z = a[2] * e + a[5] * n + a[8] * i, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements, o = 1 / (a[3] * e + a[7] * n + a[11] * i + a[15]);
    return this.x = (a[0] * e + a[4] * n + a[8] * i + a[12]) * o, this.y = (a[1] * e + a[5] * n + a[9] * i + a[13]) * o, this.z = (a[2] * e + a[6] * n + a[10] * i + a[14]) * o, this;
  }
  applyQuaternion(t) {
    const e = this.x, n = this.y, i = this.z, a = t.x, o = t.y, s = t.z, l = t.w, u = 2 * (o * i - s * n), c = 2 * (s * e - a * i), f = 2 * (a * n - o * e);
    return this.x = e + l * u + o * f - s * c, this.y = n + l * c + s * u - a * f, this.z = i + l * f + a * c - o * u, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements;
    return this.x = a[0] * e + a[4] * n + a[8] * i, this.y = a[1] * e + a[5] * n + a[9] * i, this.z = a[2] * e + a[6] * n + a[10] * i, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x, i = t.y, a = t.z, o = e.x, s = e.y, l = e.z;
    return this.x = i * l - a * s, this.y = a * o - n * l, this.z = n * s - i * o, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return zm.copy(this).projectOnVector(t), this.sub(zm);
  }
  reflect(t) {
    return this.sub(zm.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(on(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
    return e * e + n * n + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t;
    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, n = Math.sqrt(1 - e * e);
    return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const zm = /* @__PURE__ */ new K(), EM = /* @__PURE__ */ new Ih();
class bl {
  constructor(t = new K(1 / 0, 1 / 0, 1 / 0), e = new K(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e += 3)
      this.expandByPoint(li.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, n = t.count; e < n; e++)
      this.expandByPoint(li.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++)
      this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = li.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const n = t.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (e === !0 && a !== void 0 && t.isInstancedMesh !== !0)
        for (let o = 0, s = a.count; o < s; o++)
          t.isMesh === !0 ? t.getVertexPosition(o, li) : li.fromBufferAttribute(a, o), li.applyMatrix4(t.matrixWorld), this.expandByPoint(li);
      else
        t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), ed.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), ed.copy(n.boundingBox)), ed.applyMatrix4(t.matrixWorld), this.union(ed);
    }
    const i = t.children;
    for (let a = 0, o = i.length; a < o; a++)
      this.expandByObject(i[a], e);
    return this;
  }
  containsPoint(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, li), li.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, n;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Fc), rd.subVectors(this.max, Fc), Bl.subVectors(t.a, Fc), Vl.subVectors(t.b, Fc), Fl.subVectors(t.c, Fc), to.subVectors(Vl, Bl), eo.subVectors(Fl, Vl), es.subVectors(Bl, Fl);
    let e = [
      0,
      -to.z,
      to.y,
      0,
      -eo.z,
      eo.y,
      0,
      -es.z,
      es.y,
      to.z,
      0,
      -to.x,
      eo.z,
      0,
      -eo.x,
      es.z,
      0,
      -es.x,
      -to.y,
      to.x,
      0,
      -eo.y,
      eo.x,
      0,
      -es.y,
      es.x,
      0
    ];
    return !Um(e, Bl, Vl, Fl, rd) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Um(e, Bl, Vl, Fl, rd)) ? !1 : (nd.crossVectors(to, eo), e = [nd.x, nd.y, nd.z], Um(e, Bl, Vl, Fl, rd));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, li).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(li).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (da[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), da[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), da[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), da[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), da[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), da[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), da[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), da[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(da), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const da = [
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K(),
  /* @__PURE__ */ new K()
], li = /* @__PURE__ */ new K(), ed = /* @__PURE__ */ new bl(), Bl = /* @__PURE__ */ new K(), Vl = /* @__PURE__ */ new K(), Fl = /* @__PURE__ */ new K(), to = /* @__PURE__ */ new K(), eo = /* @__PURE__ */ new K(), es = /* @__PURE__ */ new K(), Fc = /* @__PURE__ */ new K(), rd = /* @__PURE__ */ new K(), nd = /* @__PURE__ */ new K(), rs = /* @__PURE__ */ new K();
function Um(r, t, e, n, i) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    rs.fromArray(r, a);
    const s = i.x * Math.abs(rs.x) + i.y * Math.abs(rs.y) + i.z * Math.abs(rs.z), l = t.dot(rs), u = e.dot(rs), c = n.dot(rs);
    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s)
      return !1;
  }
  return !0;
}
const Oz = /* @__PURE__ */ new bl(), zc = /* @__PURE__ */ new K(), Gm = /* @__PURE__ */ new K();
class mc {
  constructor(t = new K(), e = -1) {
    this.isSphere = !0, this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : Oz.setFromPoints(t).getCenter(n);
    let i = 0;
    for (let a = 0, o = t.length; a < o; a++)
      i = Math.max(i, n.distanceToSquared(t[a]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    zc.subVectors(t, this.center);
    const e = zc.lengthSq();
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(zc, i / n), this.radius += i;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (Gm.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(zc.copy(t.center).add(Gm)), this.expandByPoint(zc.copy(t.center).sub(Gm))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const pa = /* @__PURE__ */ new K(), Hm = /* @__PURE__ */ new K(), id = /* @__PURE__ */ new K(), ro = /* @__PURE__ */ new K(), Wm = /* @__PURE__ */ new K(), ad = /* @__PURE__ */ new K(), Xm = /* @__PURE__ */ new K();
class d1 {
  constructor(t = new K(), e = new K(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, pa)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = pa.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (pa.copy(this.origin).addScaledVector(this.direction, e), pa.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, i) {
    Hm.copy(t).add(e).multiplyScalar(0.5), id.copy(e).sub(t).normalize(), ro.copy(this.origin).sub(Hm);
    const a = t.distanceTo(e) * 0.5, o = -this.direction.dot(id), s = ro.dot(this.direction), l = -ro.dot(id), u = ro.lengthSq(), c = Math.abs(1 - o * o);
    let f, h, d, p;
    if (c > 0)
      if (f = o * l - s, h = o * s - l, p = a * c, f >= 0)
        if (h >= -p)
          if (h <= p) {
            const g = 1 / c;
            f *= g, h *= g, d = f * (f + o * h + 2 * s) + h * (o * f + h + 2 * l) + u;
          } else
            h = a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
        else
          h = -a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
      else
        h <= -p ? (f = Math.max(0, -(-o * a + s)), h = f > 0 ? -a : Math.min(Math.max(-a, -l), a), d = -f * f + h * (h + 2 * l) + u) : h <= p ? (f = 0, h = Math.min(Math.max(-a, -l), a), d = h * (h + 2 * l) + u) : (f = Math.max(0, -(o * a + s)), h = f > 0 ? a : Math.min(Math.max(-a, -l), a), d = -f * f + h * (h + 2 * l) + u);
    else
      h = o > 0 ? -a : a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
    return n && n.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(Hm).addScaledVector(id, h), d;
  }
  intersectSphere(t, e) {
    pa.subVectors(t.center, this.origin);
    const n = pa.dot(this.direction), i = pa.dot(pa) - n * n, a = t.radius * t.radius;
    if (i > a)
      return null;
    const o = Math.sqrt(a - i), s = n - o, l = n + o;
    return l < 0 ? null : s < 0 ? this.at(l, e) : this.at(s, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, i, a, o, s, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, f = 1 / this.direction.z, h = this.origin;
    return u >= 0 ? (n = (t.min.x - h.x) * u, i = (t.max.x - h.x) * u) : (n = (t.max.x - h.x) * u, i = (t.min.x - h.x) * u), c >= 0 ? (a = (t.min.y - h.y) * c, o = (t.max.y - h.y) * c) : (a = (t.max.y - h.y) * c, o = (t.min.y - h.y) * c), n > o || a > i || ((a > n || isNaN(n)) && (n = a), (o < i || isNaN(i)) && (i = o), f >= 0 ? (s = (t.min.z - h.z) * f, l = (t.max.z - h.z) * f) : (s = (t.max.z - h.z) * f, l = (t.min.z - h.z) * f), n > l || s > i) || ((s > n || n !== n) && (n = s), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, e);
  }
  intersectsBox(t) {
    return this.intersectBox(t, pa) !== null;
  }
  intersectTriangle(t, e, n, i, a) {
    Wm.subVectors(e, t), ad.subVectors(n, t), Xm.crossVectors(Wm, ad);
    let o = this.direction.dot(Xm), s;
    if (o > 0) {
      if (i)
        return null;
      s = 1;
    } else if (o < 0)
      s = -1, o = -o;
    else
      return null;
    ro.subVectors(this.origin, t);
    const l = s * this.direction.dot(ad.crossVectors(ro, ad));
    if (l < 0)
      return null;
    const u = s * this.direction.dot(Wm.cross(ro));
    if (u < 0 || l + u > o)
      return null;
    const c = -s * ro.dot(Xm);
    return c < 0 ? null : this.at(c / o, a);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $e {
  constructor(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v) {
    $e.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v);
  }
  set(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v) {
    const m = this.elements;
    return m[0] = t, m[4] = e, m[8] = n, m[12] = i, m[1] = a, m[5] = o, m[9] = s, m[13] = l, m[2] = u, m[6] = c, m[10] = f, m[14] = h, m[3] = d, m[7] = p, m[11] = g, m[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new $e().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
  }
  copyPosition(t) {
    const e = this.elements, n = t.elements;
    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[3],
      e[6],
      0,
      e[1],
      e[4],
      e[7],
      0,
      e[2],
      e[5],
      e[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, n) {
    return this.set(
      t.x,
      e.x,
      n.x,
      0,
      t.y,
      e.y,
      n.y,
      0,
      t.z,
      e.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(t) {
    const e = this.elements, n = t.elements, i = 1 / zl.setFromMatrixColumn(t, 0).length(), a = 1 / zl.setFromMatrixColumn(t, 1).length(), o = 1 / zl.setFromMatrixColumn(t, 2).length();
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * a, e[5] = n[5] * a, e[6] = n[6] * a, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, n = t.x, i = t.y, a = t.z, o = Math.cos(n), s = Math.sin(n), l = Math.cos(i), u = Math.sin(i), c = Math.cos(a), f = Math.sin(a);
    if (t.order === "XYZ") {
      const h = o * c, d = o * f, p = s * c, g = s * f;
      e[0] = l * c, e[4] = -l * f, e[8] = u, e[1] = d + p * u, e[5] = h - g * u, e[9] = -s * l, e[2] = g - h * u, e[6] = p + d * u, e[10] = o * l;
    } else if (t.order === "YXZ") {
      const h = l * c, d = l * f, p = u * c, g = u * f;
      e[0] = h + g * s, e[4] = p * s - d, e[8] = o * u, e[1] = o * f, e[5] = o * c, e[9] = -s, e[2] = d * s - p, e[6] = g + h * s, e[10] = o * l;
    } else if (t.order === "ZXY") {
      const h = l * c, d = l * f, p = u * c, g = u * f;
      e[0] = h - g * s, e[4] = -o * f, e[8] = p + d * s, e[1] = d + p * s, e[5] = o * c, e[9] = g - h * s, e[2] = -o * u, e[6] = s, e[10] = o * l;
    } else if (t.order === "ZYX") {
      const h = o * c, d = o * f, p = s * c, g = s * f;
      e[0] = l * c, e[4] = p * u - d, e[8] = h * u + g, e[1] = l * f, e[5] = g * u + h, e[9] = d * u - p, e[2] = -u, e[6] = s * l, e[10] = o * l;
    } else if (t.order === "YZX") {
      const h = o * l, d = o * u, p = s * l, g = s * u;
      e[0] = l * c, e[4] = g - h * f, e[8] = p * f + d, e[1] = f, e[5] = o * c, e[9] = -s * c, e[2] = -u * c, e[6] = d * f + p, e[10] = h - g * f;
    } else if (t.order === "XZY") {
      const h = o * l, d = o * u, p = s * l, g = s * u;
      e[0] = l * c, e[4] = -f, e[8] = u * c, e[1] = h * f + g, e[5] = o * c, e[9] = d * f - p, e[2] = p * f - d, e[6] = s * c, e[10] = g * f + h;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(kz, t, Bz);
  }
  lookAt(t, e, n) {
    const i = this.elements;
    return An.subVectors(t, e), An.lengthSq() === 0 && (An.z = 1), An.normalize(), no.crossVectors(n, An), no.lengthSq() === 0 && (Math.abs(n.z) === 1 ? An.x += 1e-4 : An.z += 1e-4, An.normalize(), no.crossVectors(n, An)), no.normalize(), od.crossVectors(An, no), i[0] = no.x, i[4] = od.x, i[8] = An.x, i[1] = no.y, i[5] = od.y, i[9] = An.y, i[2] = no.z, i[6] = od.z, i[10] = An.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, i = e.elements, a = this.elements, o = n[0], s = n[4], l = n[8], u = n[12], c = n[1], f = n[5], h = n[9], d = n[13], p = n[2], g = n[6], v = n[10], m = n[14], y = n[3], _ = n[7], x = n[11], b = n[15], S = i[0], w = i[4], A = i[8], T = i[12], M = i[1], C = i[5], R = i[9], E = i[13], D = i[2], I = i[6], P = i[10], O = i[14], N = i[3], B = i[7], F = i[11], G = i[15];
    return a[0] = o * S + s * M + l * D + u * N, a[4] = o * w + s * C + l * I + u * B, a[8] = o * A + s * R + l * P + u * F, a[12] = o * T + s * E + l * O + u * G, a[1] = c * S + f * M + h * D + d * N, a[5] = c * w + f * C + h * I + d * B, a[9] = c * A + f * R + h * P + d * F, a[13] = c * T + f * E + h * O + d * G, a[2] = p * S + g * M + v * D + m * N, a[6] = p * w + g * C + v * I + m * B, a[10] = p * A + g * R + v * P + m * F, a[14] = p * T + g * E + v * O + m * G, a[3] = y * S + _ * M + x * D + b * N, a[7] = y * w + _ * C + x * I + b * B, a[11] = y * A + _ * R + x * P + b * F, a[15] = y * T + _ * E + x * O + b * G, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[4], i = t[8], a = t[12], o = t[1], s = t[5], l = t[9], u = t[13], c = t[2], f = t[6], h = t[10], d = t[14], p = t[3], g = t[7], v = t[11], m = t[15];
    return p * (+a * l * f - i * u * f - a * s * h + n * u * h + i * s * d - n * l * d) + g * (+e * l * d - e * u * h + a * o * h - i * o * d + i * u * c - a * l * c) + v * (+e * u * f - e * s * d - a * o * f + n * o * d + a * s * c - n * u * c) + m * (-i * s * c - e * l * f + e * s * h + i * o * f - n * o * h + n * l * c);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, n) {
    const i = this.elements;
    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8], f = t[9], h = t[10], d = t[11], p = t[12], g = t[13], v = t[14], m = t[15], y = f * v * u - g * h * u + g * l * d - s * v * d - f * l * m + s * h * m, _ = p * h * u - c * v * u - p * l * d + o * v * d + c * l * m - o * h * m, x = c * g * u - p * f * u + p * s * d - o * g * d - c * s * m + o * f * m, b = p * f * l - c * g * l - p * s * h + o * g * h + c * s * v - o * f * v, S = e * y + n * _ + i * x + a * b;
    if (S === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return t[0] = y * w, t[1] = (g * h * a - f * v * a - g * i * d + n * v * d + f * i * m - n * h * m) * w, t[2] = (s * v * a - g * l * a + g * i * u - n * v * u - s * i * m + n * l * m) * w, t[3] = (f * l * a - s * h * a - f * i * u + n * h * u + s * i * d - n * l * d) * w, t[4] = _ * w, t[5] = (c * v * a - p * h * a + p * i * d - e * v * d - c * i * m + e * h * m) * w, t[6] = (p * l * a - o * v * a - p * i * u + e * v * u + o * i * m - e * l * m) * w, t[7] = (o * h * a - c * l * a + c * i * u - e * h * u - o * i * d + e * l * d) * w, t[8] = x * w, t[9] = (p * f * a - c * g * a - p * n * d + e * g * d + c * n * m - e * f * m) * w, t[10] = (o * g * a - p * s * a + p * n * u - e * g * u - o * n * m + e * s * m) * w, t[11] = (c * s * a - o * f * a - c * n * u + e * f * u + o * n * d - e * s * d) * w, t[12] = b * w, t[13] = (c * g * i - p * f * i + p * n * h - e * g * h - c * n * v + e * f * v) * w, t[14] = (p * s * i - o * g * i - p * n * l + e * g * l + o * n * v - e * s * v) * w, t[15] = (o * f * i - c * s * i + c * n * l - e * f * l - o * n * h + e * s * h) * w, this;
  }
  scale(t) {
    const e = this.elements, n = t.x, i = t.y, a = t.z;
    return e[0] *= n, e[4] *= i, e[8] *= a, e[1] *= n, e[5] *= i, e[9] *= a, e[2] *= n, e[6] *= i, e[10] *= a, e[3] *= n, e[7] *= i, e[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  }
  makeTranslation(t, e, n) {
    return t.isVector3 ? this.set(
      1,
      0,
      0,
      t.x,
      0,
      1,
      0,
      t.y,
      0,
      0,
      1,
      t.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e), i = Math.sin(e), a = 1 - n, o = t.x, s = t.y, l = t.z, u = a * o, c = a * s;
    return this.set(
      u * o + n,
      u * s - i * l,
      u * l + i * s,
      0,
      u * s + i * l,
      c * s + n,
      c * l - i * o,
      0,
      u * l - i * s,
      c * l + i * o,
      a * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e, n) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(t, e, n, i, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      t,
      1,
      o,
      0,
      e,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(t, e, n) {
    const i = this.elements, a = e._x, o = e._y, s = e._z, l = e._w, u = a + a, c = o + o, f = s + s, h = a * u, d = a * c, p = a * f, g = o * c, v = o * f, m = s * f, y = l * u, _ = l * c, x = l * f, b = n.x, S = n.y, w = n.z;
    return i[0] = (1 - (g + m)) * b, i[1] = (d + x) * b, i[2] = (p - _) * b, i[3] = 0, i[4] = (d - x) * S, i[5] = (1 - (h + m)) * S, i[6] = (v + y) * S, i[7] = 0, i[8] = (p + _) * w, i[9] = (v - y) * w, i[10] = (1 - (h + g)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
  }
  decompose(t, e, n) {
    const i = this.elements;
    let a = zl.set(i[0], i[1], i[2]).length();
    const o = zl.set(i[4], i[5], i[6]).length(), s = zl.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (a = -a), t.x = i[12], t.y = i[13], t.z = i[14], ui.copy(this);
    const u = 1 / a, c = 1 / o, f = 1 / s;
    return ui.elements[0] *= u, ui.elements[1] *= u, ui.elements[2] *= u, ui.elements[4] *= c, ui.elements[5] *= c, ui.elements[6] *= c, ui.elements[8] *= f, ui.elements[9] *= f, ui.elements[10] *= f, e.setFromRotationMatrix(ui), n.x = a, n.y = o, n.z = s, this;
  }
  makePerspective(t, e, n, i, a, o, s = Da) {
    const l = this.elements, u = 2 * a / (e - t), c = 2 * a / (n - i), f = (e + t) / (e - t), h = (n + i) / (n - i);
    let d, p;
    if (s === Da)
      d = -(o + a) / (o - a), p = -2 * o * a / (o - a);
    else if (s === pv)
      d = -o / (o - a), p = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
    return l[0] = u, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = c, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = d, l[14] = p, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(t, e, n, i, a, o, s = Da) {
    const l = this.elements, u = 1 / (e - t), c = 1 / (n - i), f = 1 / (o - a), h = (e + t) * u, d = (n + i) * c;
    let p, g;
    if (s === Da)
      p = (o + a) * f, g = -2 * f;
    else if (s === pv)
      p = a * f, g = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
    return l[0] = 2 * u, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -d, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -p, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let i = 0; i < 16; i++)
      if (e[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
  }
}
const zl = /* @__PURE__ */ new K(), ui = /* @__PURE__ */ new $e(), kz = /* @__PURE__ */ new K(0, 0, 0), Bz = /* @__PURE__ */ new K(1, 1, 1), no = /* @__PURE__ */ new K(), od = /* @__PURE__ */ new K(), An = /* @__PURE__ */ new K(), CM = /* @__PURE__ */ new $e(), DM = /* @__PURE__ */ new Ih();
class Fa {
  constructor(t = 0, e = 0, n = 0, i = Fa.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, n, i = this._order) {
    return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements, a = i[0], o = i[4], s = i[8], l = i[1], u = i[5], c = i[9], f = i[2], h = i[6], d = i[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(on(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(h, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-on(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-f, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(on(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-f, d), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, a));
        break;
      case "ZYX":
        this._y = Math.asin(-on(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, u));
        break;
      case "YZX":
        this._z = Math.asin(on(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-f, a)) : (this._x = 0, this._y = Math.atan2(s, d));
        break;
      case "XZY":
        this._z = Math.asin(-on(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(h, u), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-c, d), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return CM.makeRotationFromQuaternion(t), this.setFromRotationMatrix(CM, e, n);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return DM.setFromEuler(this), this.setFromQuaternion(DM, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Fa.DEFAULT_ORDER = "XYZ";
class p1 {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
}
let Vz = 0;
const LM = /* @__PURE__ */ new K(), Ul = /* @__PURE__ */ new Ih(), va = /* @__PURE__ */ new $e(), sd = /* @__PURE__ */ new K(), Uc = /* @__PURE__ */ new K(), Fz = /* @__PURE__ */ new K(), zz = /* @__PURE__ */ new Ih(), RM = /* @__PURE__ */ new K(1, 0, 0), IM = /* @__PURE__ */ new K(0, 1, 0), PM = /* @__PURE__ */ new K(0, 0, 1), NM = { type: "added" }, Uz = { type: "removed" }, Gl = { type: "childadded", child: null }, Ym = { type: "childremoved", child: null };
class Or extends gc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Vz++ }), this.uuid = Rh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Or.DEFAULT_UP.clone();
    const t = new K(), e = new Fa(), n = new Ih(), i = new K(1, 1, 1);
    function a() {
      n.setFromEuler(e, !1);
    }
    function o() {
      e.setFromQuaternion(n, void 0, !1);
    }
    e._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new $e()
      },
      normalMatrix: {
        value: new ye()
      }
    }), this.matrix = new $e(), this.matrixWorld = new $e(), this.matrixAutoUpdate = Or.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new p1(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return Ul.setFromAxisAngle(t, e), this.quaternion.multiply(Ul), this;
  }
  rotateOnWorldAxis(t, e) {
    return Ul.setFromAxisAngle(t, e), this.quaternion.premultiply(Ul), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(RM, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(IM, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(PM, t);
  }
  translateOnAxis(t, e) {
    return LM.copy(t).applyQuaternion(this.quaternion), this.position.add(LM.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(RM, t);
  }
  translateY(t) {
    return this.translateOnAxis(IM, t);
  }
  translateZ(t) {
    return this.translateOnAxis(PM, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(va.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, n) {
    t.isVector3 ? sd.copy(t) : sd.set(t, e, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Uc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? va.lookAt(Uc, sd, this.up) : va.lookAt(sd, Uc, this.up), this.quaternion.setFromRotationMatrix(va), i && (va.extractRotation(i.matrixWorld), Ul.setFromRotationMatrix(va), this.quaternion.premultiply(Ul.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(NM), Gl.child = t, this.dispatchEvent(Gl), Gl.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Uz), Ym.child = t, this.dispatchEvent(Ym), Ym.child = null), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), va.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), va.multiply(t.parent.matrixWorld)), t.applyMatrix4(va), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(NM), Gl.child = t, this.dispatchEvent(Gl), Gl.child = null, this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e)
      return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(t, e);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(t, e, n = []) {
    this[t] === e && n.push(this);
    const i = this.children;
    for (let a = 0, o = i.length; a < o; a++)
      i[a].getObjectsByProperty(t, e, n);
    return n;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uc, t, Fz), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uc, zz, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++)
      e[n].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1)
      return;
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++)
      e[n].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n];
      (a.matrixWorldAutoUpdate === !0 || t === !0) && a.updateMatrixWorld(t);
    }
  }
  updateWorldMatrix(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const i = this.children;
      for (let a = 0, o = i.length; a < o; a++) {
        const s = i[a];
        s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((s) => ({
      boxInitialized: s.boxInitialized,
      boxMin: s.box.min.toArray(),
      boxMax: s.box.max.toArray(),
      sphereInitialized: s.sphereInitialized,
      sphereRadius: s.sphere.radius,
      sphereCenter: s.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function a(s, l) {
      return s[l.uuid] === void 0 && (s[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(t.geometries, this.geometry);
      const s = this.geometry.parameters;
      if (s !== void 0 && s.shapes !== void 0) {
        const l = s.shapes;
        if (Array.isArray(l))
          for (let u = 0, c = l.length; u < c; u++) {
            const f = l[u];
            a(t.shapes, f);
          }
        else
          a(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const s = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          s.push(a(t.materials, this.material[l]));
        i.material = s;
      } else
        i.material = a(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let s = 0; s < this.animations.length; s++) {
        const l = this.animations[s];
        i.animations.push(a(t.animations, l));
      }
    }
    if (e) {
      const s = o(t.geometries), l = o(t.materials), u = o(t.textures), c = o(t.images), f = o(t.shapes), h = o(t.skeletons), d = o(t.animations), p = o(t.nodes);
      s.length > 0 && (n.geometries = s), l.length > 0 && (n.materials = l), u.length > 0 && (n.textures = u), c.length > 0 && (n.images = c), f.length > 0 && (n.shapes = f), h.length > 0 && (n.skeletons = h), d.length > 0 && (n.animations = d), p.length > 0 && (n.nodes = p);
    }
    return n.object = i, n;
    function o(s) {
      const l = [];
      for (const u in s) {
        const c = s[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Or.DEFAULT_UP = /* @__PURE__ */ new K(0, 1, 0);
Or.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Or.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ci = /* @__PURE__ */ new K(), ga = /* @__PURE__ */ new K(), $m = /* @__PURE__ */ new K(), ma = /* @__PURE__ */ new K(), Hl = /* @__PURE__ */ new K(), Wl = /* @__PURE__ */ new K(), OM = /* @__PURE__ */ new K(), Zm = /* @__PURE__ */ new K(), qm = /* @__PURE__ */ new K(), Km = /* @__PURE__ */ new K();
let ld = class Eu {
  constructor(t = new K(), e = new K(), n = new K()) {
    this.a = t, this.b = e, this.c = n;
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), ci.subVectors(t, e), i.cross(ci);
    const a = i.lengthSq();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(t, e, n, i, a) {
    ci.subVectors(i, e), ga.subVectors(n, e), $m.subVectors(t, e);
    const o = ci.dot(ci), s = ci.dot(ga), l = ci.dot($m), u = ga.dot(ga), c = ga.dot($m), f = o * u - s * s;
    if (f === 0)
      return a.set(0, 0, 0), null;
    const h = 1 / f, d = (u * l - s * c) * h, p = (o * c - s * l) * h;
    return a.set(1 - d - p, p, d);
  }
  static containsPoint(t, e, n, i) {
    return this.getBarycoord(t, e, n, i, ma) === null ? !1 : ma.x >= 0 && ma.y >= 0 && ma.x + ma.y <= 1;
  }
  static getInterpolation(t, e, n, i, a, o, s, l) {
    return this.getBarycoord(t, e, n, i, ma) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(a, ma.x), l.addScaledVector(o, ma.y), l.addScaledVector(s, ma.z), l);
  }
  static isFrontFacing(t, e, n, i) {
    return ci.subVectors(n, e), ga.subVectors(t, e), ci.cross(ga).dot(i) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return ci.subVectors(this.c, this.b), ga.subVectors(this.a, this.b), ci.cross(ga).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return Eu.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return Eu.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, n, i, a) {
    return Eu.getInterpolation(t, this.a, this.b, this.c, e, n, i, a);
  }
  containsPoint(t) {
    return Eu.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return Eu.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const n = this.a, i = this.b, a = this.c;
    let o, s;
    Hl.subVectors(i, n), Wl.subVectors(a, n), Zm.subVectors(t, n);
    const l = Hl.dot(Zm), u = Wl.dot(Zm);
    if (l <= 0 && u <= 0)
      return e.copy(n);
    qm.subVectors(t, i);
    const c = Hl.dot(qm), f = Wl.dot(qm);
    if (c >= 0 && f <= c)
      return e.copy(i);
    const h = l * f - c * u;
    if (h <= 0 && l >= 0 && c <= 0)
      return o = l / (l - c), e.copy(n).addScaledVector(Hl, o);
    Km.subVectors(t, a);
    const d = Hl.dot(Km), p = Wl.dot(Km);
    if (p >= 0 && d <= p)
      return e.copy(a);
    const g = d * u - l * p;
    if (g <= 0 && u >= 0 && p <= 0)
      return s = u / (u - p), e.copy(n).addScaledVector(Wl, s);
    const v = c * p - d * f;
    if (v <= 0 && f - c >= 0 && d - p >= 0)
      return OM.subVectors(a, i), s = (f - c) / (f - c + (d - p)), e.copy(i).addScaledVector(OM, s);
    const m = 1 / (v + g + h);
    return o = g * m, s = h * m, e.copy(n).addScaledVector(Hl, o).addScaledVector(Wl, s);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
};
const TI = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, io = { h: 0, s: 0, l: 0 }, ud = { h: 0, s: 0, l: 0 };
function jm(r, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? r + (t - r) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? r + (t - r) * 6 * (2 / 3 - e) : r;
}
class le {
  constructor(t, e, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n);
  }
  set(t, e, n) {
    if (e === void 0 && n === void 0) {
      const i = t;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(t, e, n);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = Vi) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Fe.toWorkingColorSpace(this, e), this;
  }
  setRGB(t, e, n, i = Fe.workingColorSpace) {
    return this.r = t, this.g = e, this.b = n, Fe.toWorkingColorSpace(this, i), this;
  }
  setHSL(t, e, n, i = Fe.workingColorSpace) {
    if (t = Az(t, 1), e = on(e, 0, 1), n = on(n, 0, 1), e === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + e) : n + e - n * e, o = 2 * n - a;
      this.r = jm(o, a, t + 1 / 3), this.g = jm(o, a, t), this.b = jm(o, a, t - 1 / 3);
    }
    return Fe.toWorkingColorSpace(this, i), this;
  }
  setStyle(t, e = Vi) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let a;
      const o = i[1], s = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              e
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const a = i[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          e
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0)
      return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = Vi) {
    const n = TI[t.toLowerCase()];
    return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = Hu(t.r), this.g = Hu(t.g), this.b = Hu(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Vm(t.r), this.g = Vm(t.g), this.b = Vm(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = Vi) {
    return Fe.fromWorkingColorSpace($r.copy(this), t), Math.round(on($r.r * 255, 0, 255)) * 65536 + Math.round(on($r.g * 255, 0, 255)) * 256 + Math.round(on($r.b * 255, 0, 255));
  }
  getHexString(t = Vi) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = Fe.workingColorSpace) {
    Fe.fromWorkingColorSpace($r.copy(this), e);
    const n = $r.r, i = $r.g, a = $r.b, o = Math.max(n, i, a), s = Math.min(n, i, a);
    let l, u;
    const c = (s + o) / 2;
    if (s === o)
      l = 0, u = 0;
    else {
      const f = o - s;
      switch (u = c <= 0.5 ? f / (o + s) : f / (2 - o - s), o) {
        case n:
          l = (i - a) / f + (i < a ? 6 : 0);
          break;
        case i:
          l = (a - n) / f + 2;
          break;
        case a:
          l = (n - i) / f + 4;
          break;
      }
      l /= 6;
    }
    return t.h = l, t.s = u, t.l = c, t;
  }
  getRGB(t, e = Fe.workingColorSpace) {
    return Fe.fromWorkingColorSpace($r.copy(this), e), t.r = $r.r, t.g = $r.g, t.b = $r.b, t;
  }
  getStyle(t = Vi) {
    Fe.fromWorkingColorSpace($r.copy(this), t);
    const e = $r.r, n = $r.g, i = $r.b;
    return t !== Vi ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(t, e, n) {
    return this.getHSL(io), this.setHSL(io.h + t, io.s + e, io.l + n);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, n) {
    return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
  }
  lerpHSL(t, e) {
    this.getHSL(io), t.getHSL(ud);
    const n = km(io.h, ud.h, e), i = km(io.s, ud.s, e), a = km(io.l, ud.l, e);
    return this.setHSL(n, i, a), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    const e = this.r, n = this.g, i = this.b, a = t.elements;
    return this.r = a[0] * e + a[3] * n + a[6] * i, this.g = a[1] * e + a[4] * n + a[7] * i, this.b = a[2] * e + a[5] * n + a[8] * i, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const $r = /* @__PURE__ */ new le();
le.NAMES = TI;
let Gz = 0;
class Ph extends gc {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Gz++ }), this.uuid = Rh(), this.name = "", this.type = "Material", this.blending = Uu, this.side = Fo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = z_, this.blendDst = U_, this.blendEquation = Us, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new le(0, 0, 0), this.blendAlpha = 0, this.depthFunc = cv, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = SM, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ol, this.stencilZFail = Ol, this.stencilZPass = Ol, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n;
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Uu && (n.blending = this.blending), this.side !== Fo && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== z_ && (n.blendSrc = this.blendSrc), this.blendDst !== U_ && (n.blendDst = this.blendDst), this.blendEquation !== Us && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== cv && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== SM && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Ol && (n.stencilFail = this.stencilFail), this.stencilZFail !== Ol && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Ol && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(a) {
      const o = [];
      for (const s in a) {
        const l = a[s];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (e) {
      const a = i(t.textures), o = i(t.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const i = e.length;
      n = new Array(i);
      for (let a = 0; a !== i; ++a)
        n[a] = e[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class v1 extends Ph {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Fa(), this.combine = fI, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
const vr = /* @__PURE__ */ new K(), cd = /* @__PURE__ */ new Ce();
class ni {
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = bM, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Ca, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  get updateRange() {
    return Cz("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        cd.fromBufferAttribute(this, e), cd.applyMatrix3(t), this.setXY(e, cd.x, cd.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        vr.fromBufferAttribute(this, e), vr.applyMatrix3(t), this.setXYZ(e, vr.x, vr.y, vr.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      vr.fromBufferAttribute(this, e), vr.applyMatrix4(t), this.setXYZ(e, vr.x, vr.y, vr.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      vr.fromBufferAttribute(this, e), vr.applyNormalMatrix(t), this.setXYZ(e, vr.x, vr.y, vr.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      vr.fromBufferAttribute(this, e), vr.transformDirection(t), this.setXYZ(e, vr.x, vr.y, vr.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let n = this.array[t * this.itemSize + e];
    return this.normalized && (n = Vc(n, this.array)), n;
  }
  setComponent(t, e, n) {
    return this.normalized && (n = vn(n, this.array)), this.array[t * this.itemSize + e] = n, this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = Vc(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = Vc(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = Vc(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = Vc(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = vn(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, n) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
  }
  setXYZ(t, e, n, i) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), i = vn(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
  }
  setXYZW(t, e, n, i, a) {
    return t *= this.itemSize, this.normalized && (e = vn(e, this.array), n = vn(n, this.array), i = vn(i, this.array), a = vn(a, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = a, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (t.name = this.name), this.usage !== bM && (t.usage = this.usage), t;
  }
}
class AI extends ni {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
class EI extends ni {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n);
  }
}
class kn extends ni {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n);
  }
}
let Hz = 0;
const Un = /* @__PURE__ */ new $e(), Jm = /* @__PURE__ */ new Or(), Xl = /* @__PURE__ */ new K(), En = /* @__PURE__ */ new bl(), Gc = /* @__PURE__ */ new bl(), Dr = /* @__PURE__ */ new K();
class ca extends gc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Hz++ }), this.uuid = Rh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (bI(t) ? EI : AI)(t, 1) : this.index = t, this;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new ye().getNormalMatrix(t);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(t), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return Un.makeRotationFromQuaternion(t), this.applyMatrix4(Un), this;
  }
  rotateX(t) {
    return Un.makeRotationX(t), this.applyMatrix4(Un), this;
  }
  rotateY(t) {
    return Un.makeRotationY(t), this.applyMatrix4(Un), this;
  }
  rotateZ(t) {
    return Un.makeRotationZ(t), this.applyMatrix4(Un), this;
  }
  translate(t, e, n) {
    return Un.makeTranslation(t, e, n), this.applyMatrix4(Un), this;
  }
  scale(t, e, n) {
    return Un.makeScale(t, e, n), this.applyMatrix4(Un), this;
  }
  lookAt(t) {
    return Jm.lookAt(t), Jm.updateMatrix(), this.applyMatrix4(Jm.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Xl).negate(), this.translate(Xl.x, Xl.y, Xl.z), this;
  }
  setFromPoints(t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      e.push(a.x, a.y, a.z || 0);
    }
    return this.setAttribute("position", new kn(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bl());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new K(-1 / 0, -1 / 0, -1 / 0),
        new K(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, i = e.length; n < i; n++) {
          const a = e[n];
          En.setFromBufferAttribute(a), this.morphTargetsRelative ? (Dr.addVectors(this.boundingBox.min, En.min), this.boundingBox.expandByPoint(Dr), Dr.addVectors(this.boundingBox.max, En.max), this.boundingBox.expandByPoint(Dr)) : (this.boundingBox.expandByPoint(En.min), this.boundingBox.expandByPoint(En.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mc());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new K(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if (En.setFromBufferAttribute(t), e)
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a];
          Gc.setFromBufferAttribute(s), this.morphTargetsRelative ? (Dr.addVectors(En.min, Gc.min), En.expandByPoint(Dr), Dr.addVectors(En.max, Gc.max), En.expandByPoint(Dr)) : (En.expandByPoint(Gc.min), En.expandByPoint(Gc.max));
        }
      En.getCenter(n);
      let i = 0;
      for (let a = 0, o = t.count; a < o; a++)
        Dr.fromBufferAttribute(t, a), i = Math.max(i, n.distanceToSquared(Dr));
      if (e)
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a], l = this.morphTargetsRelative;
          for (let u = 0, c = s.count; u < c; u++)
            Dr.fromBufferAttribute(s, u), l && (Xl.fromBufferAttribute(t, u), Dr.add(Xl)), i = Math.max(i, n.distanceToSquared(Dr));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.position, i = e.normal, a = e.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ni(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), s = [], l = [];
    for (let A = 0; A < n.count; A++)
      s[A] = new K(), l[A] = new K();
    const u = new K(), c = new K(), f = new K(), h = new Ce(), d = new Ce(), p = new Ce(), g = new K(), v = new K();
    function m(A, T, M) {
      u.fromBufferAttribute(n, A), c.fromBufferAttribute(n, T), f.fromBufferAttribute(n, M), h.fromBufferAttribute(a, A), d.fromBufferAttribute(a, T), p.fromBufferAttribute(a, M), c.sub(u), f.sub(u), d.sub(h), p.sub(h);
      const C = 1 / (d.x * p.y - p.x * d.y);
      isFinite(C) && (g.copy(c).multiplyScalar(p.y).addScaledVector(f, -d.y).multiplyScalar(C), v.copy(f).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(C), s[A].add(g), s[T].add(g), s[M].add(g), l[A].add(v), l[T].add(v), l[M].add(v));
    }
    let y = this.groups;
    y.length === 0 && (y = [{
      start: 0,
      count: t.count
    }]);
    for (let A = 0, T = y.length; A < T; ++A) {
      const M = y[A], C = M.start, R = M.count;
      for (let E = C, D = C + R; E < D; E += 3)
        m(
          t.getX(E + 0),
          t.getX(E + 1),
          t.getX(E + 2)
        );
    }
    const _ = new K(), x = new K(), b = new K(), S = new K();
    function w(A) {
      b.fromBufferAttribute(i, A), S.copy(b);
      const T = s[A];
      _.copy(T), _.sub(b.multiplyScalar(b.dot(T))).normalize(), x.crossVectors(S, T);
      const C = x.dot(l[A]) < 0 ? -1 : 1;
      o.setXYZW(A, _.x, _.y, _.z, C);
    }
    for (let A = 0, T = y.length; A < T; ++A) {
      const M = y[A], C = M.start, R = M.count;
      for (let E = C, D = C + R; E < D; E += 3)
        w(t.getX(E + 0)), w(t.getX(E + 1)), w(t.getX(E + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ni(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let h = 0, d = n.count; h < d; h++)
          n.setXYZ(h, 0, 0, 0);
      const i = new K(), a = new K(), o = new K(), s = new K(), l = new K(), u = new K(), c = new K(), f = new K();
      if (t)
        for (let h = 0, d = t.count; h < d; h += 3) {
          const p = t.getX(h + 0), g = t.getX(h + 1), v = t.getX(h + 2);
          i.fromBufferAttribute(e, p), a.fromBufferAttribute(e, g), o.fromBufferAttribute(e, v), c.subVectors(o, a), f.subVectors(i, a), c.cross(f), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, g), u.fromBufferAttribute(n, v), s.add(c), l.add(c), u.add(c), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z);
        }
      else
        for (let h = 0, d = e.count; h < d; h += 3)
          i.fromBufferAttribute(e, h + 0), a.fromBufferAttribute(e, h + 1), o.fromBufferAttribute(e, h + 2), c.subVectors(o, a), f.subVectors(i, a), c.cross(f), n.setXYZ(h + 0, c.x, c.y, c.z), n.setXYZ(h + 1, c.x, c.y, c.z), n.setXYZ(h + 2, c.x, c.y, c.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      Dr.fromBufferAttribute(t, e), Dr.normalize(), t.setXYZ(e, Dr.x, Dr.y, Dr.z);
  }
  toNonIndexed() {
    function t(s, l) {
      const u = s.array, c = s.itemSize, f = s.normalized, h = new u.constructor(l.length * c);
      let d = 0, p = 0;
      for (let g = 0, v = l.length; g < v; g++) {
        s.isInterleavedBufferAttribute ? d = l[g] * s.data.stride + s.offset : d = l[g] * c;
        for (let m = 0; m < c; m++)
          h[p++] = u[d++];
      }
      return new ni(h, c, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new ca(), n = this.index.array, i = this.attributes;
    for (const s in i) {
      const l = i[s], u = t(l, n);
      e.setAttribute(s, u);
    }
    const a = this.morphAttributes;
    for (const s in a) {
      const l = [], u = a[s];
      for (let c = 0, f = u.length; c < f; c++) {
        const h = u[c], d = t(h, n);
        l.push(d);
      }
      e.morphAttributes[s] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let s = 0, l = o.length; s < l; s++) {
      const u = o[s];
      e.addGroup(u.start, u.count, u.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const u in l)
        l[u] !== void 0 && (t[u] = l[u]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const u = n[l];
      t.data.attributes[l] = u.toJSON(t.data);
    }
    const i = {};
    let a = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l], c = [];
      for (let f = 0, h = u.length; f < h; f++) {
        const d = u[f];
        c.push(d.toJSON(t.data));
      }
      c.length > 0 && (i[l] = c, a = !0);
    }
    a && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const s = this.boundingSphere;
    return s !== null && (t.data.boundingSphere = {
      center: s.center.toArray(),
      radius: s.radius
    }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const i = t.attributes;
    for (const u in i) {
      const c = i[u];
      this.setAttribute(u, c.clone(e));
    }
    const a = t.morphAttributes;
    for (const u in a) {
      const c = [], f = a[u];
      for (let h = 0, d = f.length; h < d; h++)
        c.push(f[h].clone(e));
      this.morphAttributes[u] = c;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let u = 0, c = o.length; u < c; u++) {
      const f = o[u];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const s = t.boundingBox;
    s !== null && (this.boundingBox = s.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const kM = /* @__PURE__ */ new $e(), ns = /* @__PURE__ */ new d1(), fd = /* @__PURE__ */ new mc(), BM = /* @__PURE__ */ new K(), Yl = /* @__PURE__ */ new K(), $l = /* @__PURE__ */ new K(), Zl = /* @__PURE__ */ new K(), Qm = /* @__PURE__ */ new K(), hd = /* @__PURE__ */ new K(), dd = /* @__PURE__ */ new Ce(), pd = /* @__PURE__ */ new Ce(), vd = /* @__PURE__ */ new Ce(), VM = /* @__PURE__ */ new K(), FM = /* @__PURE__ */ new K(), zM = /* @__PURE__ */ new K(), gd = /* @__PURE__ */ new K(), md = /* @__PURE__ */ new K();
class Pn extends Or {
  constructor(t = new ca(), e = new v1()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const i = e[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry, i = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    e.fromBufferAttribute(i, t);
    const s = this.morphTargetInfluences;
    if (a && s) {
      hd.set(0, 0, 0);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = s[l], f = a[l];
        c !== 0 && (Qm.fromBufferAttribute(f, t), o ? hd.addScaledVector(Qm, c) : hd.addScaledVector(Qm.sub(e), c));
      }
      e.add(hd);
    }
    return e;
  }
  raycast(t, e) {
    const n = this.geometry, i = this.material, a = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), fd.copy(n.boundingSphere), fd.applyMatrix4(a), ns.copy(t.ray).recast(t.near), !(fd.containsPoint(ns.origin) === !1 && (ns.intersectSphere(fd, BM) === null || ns.origin.distanceToSquared(BM) > (t.far - t.near) ** 2)) && (kM.copy(a).invert(), ns.copy(t.ray).applyMatrix4(kM), !(n.boundingBox !== null && ns.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(t, e, ns)));
  }
  _computeIntersections(t, e, n) {
    let i;
    const a = this.geometry, o = this.material, s = a.index, l = a.attributes.position, u = a.attributes.uv, c = a.attributes.uv1, f = a.attributes.normal, h = a.groups, d = a.drawRange;
    if (s !== null)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const v = h[p], m = o[v.materialIndex], y = Math.max(v.start, d.start), _ = Math.min(s.count, Math.min(v.start + v.count, d.start + d.count));
          for (let x = y, b = _; x < b; x += 3) {
            const S = s.getX(x), w = s.getX(x + 1), A = s.getX(x + 2);
            i = yd(this, m, t, n, u, c, f, S, w, A), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = v.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, d.start), g = Math.min(s.count, d.start + d.count);
        for (let v = p, m = g; v < m; v += 3) {
          const y = s.getX(v), _ = s.getX(v + 1), x = s.getX(v + 2);
          i = yd(this, o, t, n, u, c, f, y, _, x), i && (i.faceIndex = Math.floor(v / 3), e.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const v = h[p], m = o[v.materialIndex], y = Math.max(v.start, d.start), _ = Math.min(l.count, Math.min(v.start + v.count, d.start + d.count));
          for (let x = y, b = _; x < b; x += 3) {
            const S = x, w = x + 1, A = x + 2;
            i = yd(this, m, t, n, u, c, f, S, w, A), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = v.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, d.start), g = Math.min(l.count, d.start + d.count);
        for (let v = p, m = g; v < m; v += 3) {
          const y = v, _ = v + 1, x = v + 2;
          i = yd(this, o, t, n, u, c, f, y, _, x), i && (i.faceIndex = Math.floor(v / 3), e.push(i));
        }
      }
  }
}
function Wz(r, t, e, n, i, a, o, s) {
  let l;
  if (t.side === bn ? l = n.intersectTriangle(o, a, i, !0, s) : l = n.intersectTriangle(i, a, o, t.side === Fo, s), l === null)
    return null;
  md.copy(s), md.applyMatrix4(r.matrixWorld);
  const u = e.ray.origin.distanceTo(md);
  return u < e.near || u > e.far ? null : {
    distance: u,
    point: md.clone(),
    object: r
  };
}
function yd(r, t, e, n, i, a, o, s, l, u) {
  r.getVertexPosition(s, Yl), r.getVertexPosition(l, $l), r.getVertexPosition(u, Zl);
  const c = Wz(r, t, e, n, Yl, $l, Zl, gd);
  if (c) {
    i && (dd.fromBufferAttribute(i, s), pd.fromBufferAttribute(i, l), vd.fromBufferAttribute(i, u), c.uv = ld.getInterpolation(gd, Yl, $l, Zl, dd, pd, vd, new Ce())), a && (dd.fromBufferAttribute(a, s), pd.fromBufferAttribute(a, l), vd.fromBufferAttribute(a, u), c.uv1 = ld.getInterpolation(gd, Yl, $l, Zl, dd, pd, vd, new Ce())), o && (VM.fromBufferAttribute(o, s), FM.fromBufferAttribute(o, l), zM.fromBufferAttribute(o, u), c.normal = ld.getInterpolation(gd, Yl, $l, Zl, VM, FM, zM, new K()), c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
    const f = {
      a: s,
      b: l,
      c: u,
      normal: new K(),
      materialIndex: 0
    };
    ld.getNormal(Yl, $l, Zl, f.normal), c.face = f;
  }
  return c;
}
class wl extends ca {
  constructor(t = 1, e = 1, n = 1, i = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: n,
      widthSegments: i,
      heightSegments: a,
      depthSegments: o
    };
    const s = this;
    i = Math.floor(i), a = Math.floor(a), o = Math.floor(o);
    const l = [], u = [], c = [], f = [];
    let h = 0, d = 0;
    p("z", "y", "x", -1, -1, n, e, t, o, a, 0), p("z", "y", "x", 1, -1, n, e, -t, o, a, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, a, 4), p("x", "y", "z", -1, -1, t, e, -n, i, a, 5), this.setIndex(l), this.setAttribute("position", new kn(u, 3)), this.setAttribute("normal", new kn(c, 3)), this.setAttribute("uv", new kn(f, 2));
    function p(g, v, m, y, _, x, b, S, w, A, T) {
      const M = x / w, C = b / A, R = x / 2, E = b / 2, D = S / 2, I = w + 1, P = A + 1;
      let O = 0, N = 0;
      const B = new K();
      for (let F = 0; F < P; F++) {
        const G = F * C - E;
        for (let W = 0; W < I; W++) {
          const J = W * M - R;
          B[g] = J * y, B[v] = G * _, B[m] = D, u.push(B.x, B.y, B.z), B[g] = 0, B[v] = 0, B[m] = S > 0 ? 1 : -1, c.push(B.x, B.y, B.z), f.push(W / w), f.push(1 - F / A), O += 1;
        }
      }
      for (let F = 0; F < A; F++)
        for (let G = 0; G < w; G++) {
          const W = h + G + I * F, J = h + G + I * (F + 1), U = h + (G + 1) + I * (F + 1), Y = h + (G + 1) + I * F;
          l.push(W, J, Y), l.push(J, U, Y), N += 6;
        }
      s.addGroup(d, N, T), d += N, h += O;
    }
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new wl(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
}
function Qu(r) {
  const t = {};
  for (const e in r) {
    t[e] = {};
    for (const n in r[e]) {
      const i = r[e][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = i.clone() : Array.isArray(i) ? t[e][n] = i.slice() : t[e][n] = i;
    }
  }
  return t;
}
function en(r) {
  const t = {};
  for (let e = 0; e < r.length; e++) {
    const n = Qu(r[e]);
    for (const i in n)
      t[i] = n[i];
  }
  return t;
}
function Xz(r) {
  const t = [];
  for (let e = 0; e < r.length; e++)
    t.push(r[e].clone());
  return t;
}
function CI(r) {
  const t = r.getRenderTarget();
  return t === null ? r.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : Fe.workingColorSpace;
}
const Yz = { clone: Qu, merge: en };
var $z = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Zz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class za extends Ph {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = $z, this.fragmentShader = Zz, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Qu(t.uniforms), this.uniformsGroups = Xz(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? e.uniforms[i] = {
        type: "t",
        value: o.toJSON(t).uuid
      } : o && o.isColor ? e.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? e.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? e.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? e.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? e.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? e.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : e.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }
}
class DI extends Or {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new $e(), this.projectionMatrix = new $e(), this.projectionMatrixInverse = new $e(), this.coordinateSystem = Da;
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ao = /* @__PURE__ */ new K(), UM = /* @__PURE__ */ new Ce(), GM = /* @__PURE__ */ new Ce();
class Rn extends DI {
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = Y_ * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const t = Math.tan(zp * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return Y_ * 2 * Math.atan(
      Math.tan(zp * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(t, e, n) {
    ao.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(ao.x, ao.y).multiplyScalar(-t / ao.z), ao.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(ao.x, ao.y).multiplyScalar(-t / ao.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(t, e) {
    return this.getViewBounds(t, UM, GM), e.subVectors(GM, UM);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(t, e, n, i, a, o) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = t * Math.tan(zp * 0.5 * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, a = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, u = o.fullHeight;
      a += o.offsetX * i / l, e -= o.offsetY * n / u, i *= o.width / l, n *= o.height / u;
    }
    const s = this.filmOffset;
    s !== 0 && (a += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
}
const ql = -90, Kl = 1;
class qz extends Or {
  constructor(t, e, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new Rn(ql, Kl, t, e);
    i.layers = this.layers, this.add(i);
    const a = new Rn(ql, Kl, t, e);
    a.layers = this.layers, this.add(a);
    const o = new Rn(ql, Kl, t, e);
    o.layers = this.layers, this.add(o);
    const s = new Rn(ql, Kl, t, e);
    s.layers = this.layers, this.add(s);
    const l = new Rn(ql, Kl, t, e);
    l.layers = this.layers, this.add(l);
    const u = new Rn(ql, Kl, t, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem, e = this.children.concat(), [n, i, a, o, s, l] = e;
    for (const u of e)
      this.remove(u);
    if (t === Da)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (t === pv)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, s, l, u, c] = this.children, f = t.getRenderTarget(), h = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), p = t.xr.enabled;
    t.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, i), t.render(e, a), t.setRenderTarget(n, 1, i), t.render(e, o), t.setRenderTarget(n, 2, i), t.render(e, s), t.setRenderTarget(n, 3, i), t.render(e, l), t.setRenderTarget(n, 4, i), t.render(e, u), n.texture.generateMipmaps = g, t.setRenderTarget(n, 5, i), t.render(e, c), t.setRenderTarget(f, h, d), t.xr.enabled = p, n.texture.needsPMREMUpdate = !0;
  }
}
class LI extends ln {
  constructor(t, e, n, i, a, o, s, l, u, c) {
    t = t !== void 0 ? t : [], e = e !== void 0 ? e : Ku, super(t, e, n, i, a, o, s, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class Kz extends fl {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
    const n = { width: t, height: t, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new LI(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : vi;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new wl(5, 5, 5), a = new za({
      name: "CubemapFromEquirect",
      uniforms: Qu(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: bn,
      blending: Ro
    });
    a.uniforms.tEquirect.value = e;
    const o = new Pn(i, a), s = e.minFilter;
    return e.minFilter === Zs && (e.minFilter = vi), new qz(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(t, e, n, i) {
    const a = t.getRenderTarget();
    for (let o = 0; o < 6; o++)
      t.setRenderTarget(this, o), t.clear(e, n, i);
    t.setRenderTarget(a);
  }
}
const ty = /* @__PURE__ */ new K(), jz = /* @__PURE__ */ new K(), Jz = /* @__PURE__ */ new ye();
class Ps {
  constructor(t = new K(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const i = ty.subVectors(n, e).cross(jz.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const n = t.delta(ty), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const a = -(t.start.dot(this.normal) + this.constant) / i;
    return a < 0 || a > 1 ? null : e.copy(t.start).addScaledVector(n, a);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
    return e < 0 && n > 0 || n < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const n = e || Jz.getNormalMatrix(t), i = this.coplanarPoint(ty).applyMatrix4(t), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(a), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const is = /* @__PURE__ */ new mc(), _d = /* @__PURE__ */ new K();
class g1 {
  constructor(t = new Ps(), e = new Ps(), n = new Ps(), i = new Ps(), a = new Ps(), o = new Ps()) {
    this.planes = [t, e, n, i, a, o];
  }
  set(t, e, n, i, a, o) {
    const s = this.planes;
    return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(a), s[5].copy(o), this;
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t, e = Da) {
    const n = this.planes, i = t.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], f = i[6], h = i[7], d = i[8], p = i[9], g = i[10], v = i[11], m = i[12], y = i[13], _ = i[14], x = i[15];
    if (n[0].setComponents(l - a, h - u, v - d, x - m).normalize(), n[1].setComponents(l + a, h + u, v + d, x + m).normalize(), n[2].setComponents(l + o, h + c, v + p, x + y).normalize(), n[3].setComponents(l - o, h - c, v - p, x - y).normalize(), n[4].setComponents(l - s, h - f, v - g, x - _).normalize(), e === Da)
      n[5].setComponents(l + s, h + f, v + g, x + _).normalize();
    else if (e === pv)
      n[5].setComponents(s, f, g, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(), is.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), is.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(is);
  }
  intersectsSprite(t) {
    return is.center.set(0, 0, 0), is.radius = 0.7071067811865476, is.applyMatrix4(t.matrixWorld), this.intersectsSphere(is);
  }
  intersectsSphere(t) {
    const e = this.planes, n = t.center, i = -t.radius;
    for (let a = 0; a < 6; a++)
      if (e[a].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (_d.x = i.normal.x > 0 ? t.max.x : t.min.x, _d.y = i.normal.y > 0 ? t.max.y : t.min.y, _d.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(_d) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      if (e[n].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function RI() {
  let r = null, t = !1, e = null, n = null;
  function i(a, o) {
    e(a, o), n = r.requestAnimationFrame(i);
  }
  return {
    start: function() {
      t !== !0 && e !== null && (n = r.requestAnimationFrame(i), t = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), t = !1;
    },
    setAnimationLoop: function(a) {
      e = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function Qz(r) {
  const t = /* @__PURE__ */ new WeakMap();
  function e(s, l) {
    const u = s.array, c = s.usage, f = u.byteLength, h = r.createBuffer();
    r.bindBuffer(l, h), r.bufferData(l, u, c), s.onUploadCallback();
    let d;
    if (u instanceof Float32Array)
      d = r.FLOAT;
    else if (u instanceof Uint16Array)
      s.isFloat16BufferAttribute ? d = r.HALF_FLOAT : d = r.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      d = r.SHORT;
    else if (u instanceof Uint32Array)
      d = r.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      d = r.INT;
    else if (u instanceof Int8Array)
      d = r.BYTE;
    else if (u instanceof Uint8Array)
      d = r.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      d = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: h,
      type: d,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: s.version,
      size: f
    };
  }
  function n(s, l, u) {
    const c = l.array, f = l._updateRange, h = l.updateRanges;
    if (r.bindBuffer(u, s), f.count === -1 && h.length === 0 && r.bufferSubData(u, 0, c), h.length !== 0) {
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        r.bufferSubData(
          u,
          g.start * c.BYTES_PER_ELEMENT,
          c,
          g.start,
          g.count
        );
      }
      l.clearUpdateRanges();
    }
    f.count !== -1 && (r.bufferSubData(
      u,
      f.offset * c.BYTES_PER_ELEMENT,
      c,
      f.offset,
      f.count
    ), f.count = -1), l.onUploadCallback();
  }
  function i(s) {
    return s.isInterleavedBufferAttribute && (s = s.data), t.get(s);
  }
  function a(s) {
    s.isInterleavedBufferAttribute && (s = s.data);
    const l = t.get(s);
    l && (r.deleteBuffer(l.buffer), t.delete(s));
  }
  function o(s, l) {
    if (s.isGLBufferAttribute) {
      const c = t.get(s);
      (!c || c.version < s.version) && t.set(s, {
        buffer: s.buffer,
        type: s.type,
        bytesPerElement: s.elementSize,
        version: s.version
      });
      return;
    }
    s.isInterleavedBufferAttribute && (s = s.data);
    const u = t.get(s);
    if (u === void 0)
      t.set(s, e(s, l));
    else if (u.version < s.version) {
      if (u.size !== s.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(u.buffer, s, l), u.version = s.version;
    }
  }
  return {
    get: i,
    remove: a,
    update: o
  };
}
class kg extends ca {
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i
    };
    const a = t / 2, o = e / 2, s = Math.floor(n), l = Math.floor(i), u = s + 1, c = l + 1, f = t / s, h = e / l, d = [], p = [], g = [], v = [];
    for (let m = 0; m < c; m++) {
      const y = m * h - o;
      for (let _ = 0; _ < u; _++) {
        const x = _ * f - a;
        p.push(x, -y, 0), g.push(0, 0, 1), v.push(_ / s), v.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++)
      for (let y = 0; y < s; y++) {
        const _ = y + u * m, x = y + u * (m + 1), b = y + 1 + u * (m + 1), S = y + 1 + u * m;
        d.push(_, x, S), d.push(x, b, S);
      }
    this.setIndex(d), this.setAttribute("position", new kn(p, 3)), this.setAttribute("normal", new kn(g, 3)), this.setAttribute("uv", new kn(v, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new kg(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
var tU = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, eU = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, rU = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, nU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, iU = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, aU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, oU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, sU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, lU = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, uU = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, cU = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, fU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, hU = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, dU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, pU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, vU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, gU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, mU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, yU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, _U = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, xU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, SU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, bU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, wU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, MU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, TU = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, AU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, EU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, CU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, DU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, LU = "gl_FragColor = linearToOutputTexel( gl_FragColor );", RU = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, IU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, PU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, NU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, OU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, kU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, BU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, VU = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, FU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, zU = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, UU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, GU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, HU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, WU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, XU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, YU = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, $U = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, ZU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, qU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, KU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, jU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, JU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, QU = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, tG = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, eG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, rG = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, nG = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, iG = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, aG = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, oG = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, sG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, lG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, uG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, cG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, fG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, hG = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, dG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, pG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, vG = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, gG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, mG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, yG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, _G = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, xG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, SG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, bG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, wG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, MG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, TG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, AG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, EG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, CG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, DG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, LG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, RG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, IG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, PG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, NG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, OG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, kG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, BG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, VG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, FG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, zG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, UG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, GG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, HG = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, WG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, XG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, YG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, $G = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, ZG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, qG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, KG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, jG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, JG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const QG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, t5 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, e5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, r5 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, n5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, i5 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, a5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, o5 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, s5 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, l5 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, u5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, c5 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, f5 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, h5 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, d5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, p5 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, v5 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, g5 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, m5 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, y5 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _5 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, x5 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, S5 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, b5 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, w5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, M5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, T5 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, A5 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, E5 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, C5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, D5 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, L5 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, R5 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, I5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, me = {
  alphahash_fragment: tU,
  alphahash_pars_fragment: eU,
  alphamap_fragment: rU,
  alphamap_pars_fragment: nU,
  alphatest_fragment: iU,
  alphatest_pars_fragment: aU,
  aomap_fragment: oU,
  aomap_pars_fragment: sU,
  batching_pars_vertex: lU,
  batching_vertex: uU,
  begin_vertex: cU,
  beginnormal_vertex: fU,
  bsdfs: hU,
  iridescence_fragment: dU,
  bumpmap_pars_fragment: pU,
  clipping_planes_fragment: vU,
  clipping_planes_pars_fragment: gU,
  clipping_planes_pars_vertex: mU,
  clipping_planes_vertex: yU,
  color_fragment: _U,
  color_pars_fragment: xU,
  color_pars_vertex: SU,
  color_vertex: bU,
  common: wU,
  cube_uv_reflection_fragment: MU,
  defaultnormal_vertex: TU,
  displacementmap_pars_vertex: AU,
  displacementmap_vertex: EU,
  emissivemap_fragment: CU,
  emissivemap_pars_fragment: DU,
  colorspace_fragment: LU,
  colorspace_pars_fragment: RU,
  envmap_fragment: IU,
  envmap_common_pars_fragment: PU,
  envmap_pars_fragment: NU,
  envmap_pars_vertex: OU,
  envmap_physical_pars_fragment: YU,
  envmap_vertex: kU,
  fog_vertex: BU,
  fog_pars_vertex: VU,
  fog_fragment: FU,
  fog_pars_fragment: zU,
  gradientmap_pars_fragment: UU,
  lightmap_pars_fragment: GU,
  lights_lambert_fragment: HU,
  lights_lambert_pars_fragment: WU,
  lights_pars_begin: XU,
  lights_toon_fragment: $U,
  lights_toon_pars_fragment: ZU,
  lights_phong_fragment: qU,
  lights_phong_pars_fragment: KU,
  lights_physical_fragment: jU,
  lights_physical_pars_fragment: JU,
  lights_fragment_begin: QU,
  lights_fragment_maps: tG,
  lights_fragment_end: eG,
  logdepthbuf_fragment: rG,
  logdepthbuf_pars_fragment: nG,
  logdepthbuf_pars_vertex: iG,
  logdepthbuf_vertex: aG,
  map_fragment: oG,
  map_pars_fragment: sG,
  map_particle_fragment: lG,
  map_particle_pars_fragment: uG,
  metalnessmap_fragment: cG,
  metalnessmap_pars_fragment: fG,
  morphinstance_vertex: hG,
  morphcolor_vertex: dG,
  morphnormal_vertex: pG,
  morphtarget_pars_vertex: vG,
  morphtarget_vertex: gG,
  normal_fragment_begin: mG,
  normal_fragment_maps: yG,
  normal_pars_fragment: _G,
  normal_pars_vertex: xG,
  normal_vertex: SG,
  normalmap_pars_fragment: bG,
  clearcoat_normal_fragment_begin: wG,
  clearcoat_normal_fragment_maps: MG,
  clearcoat_pars_fragment: TG,
  iridescence_pars_fragment: AG,
  opaque_fragment: EG,
  packing: CG,
  premultiplied_alpha_fragment: DG,
  project_vertex: LG,
  dithering_fragment: RG,
  dithering_pars_fragment: IG,
  roughnessmap_fragment: PG,
  roughnessmap_pars_fragment: NG,
  shadowmap_pars_fragment: OG,
  shadowmap_pars_vertex: kG,
  shadowmap_vertex: BG,
  shadowmask_pars_fragment: VG,
  skinbase_vertex: FG,
  skinning_pars_vertex: zG,
  skinning_vertex: UG,
  skinnormal_vertex: GG,
  specularmap_fragment: HG,
  specularmap_pars_fragment: WG,
  tonemapping_fragment: XG,
  tonemapping_pars_fragment: YG,
  transmission_fragment: $G,
  transmission_pars_fragment: ZG,
  uv_pars_fragment: qG,
  uv_pars_vertex: KG,
  uv_vertex: jG,
  worldpos_vertex: JG,
  background_vert: QG,
  background_frag: t5,
  backgroundCube_vert: e5,
  backgroundCube_frag: r5,
  cube_vert: n5,
  cube_frag: i5,
  depth_vert: a5,
  depth_frag: o5,
  distanceRGBA_vert: s5,
  distanceRGBA_frag: l5,
  equirect_vert: u5,
  equirect_frag: c5,
  linedashed_vert: f5,
  linedashed_frag: h5,
  meshbasic_vert: d5,
  meshbasic_frag: p5,
  meshlambert_vert: v5,
  meshlambert_frag: g5,
  meshmatcap_vert: m5,
  meshmatcap_frag: y5,
  meshnormal_vert: _5,
  meshnormal_frag: x5,
  meshphong_vert: S5,
  meshphong_frag: b5,
  meshphysical_vert: w5,
  meshphysical_frag: M5,
  meshtoon_vert: T5,
  meshtoon_frag: A5,
  points_vert: E5,
  points_frag: C5,
  shadow_vert: D5,
  shadow_frag: L5,
  sprite_vert: R5,
  sprite_frag: I5
}, Et = {
  common: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ye() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new ye() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new ye() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new ye() },
    normalScale: { value: /* @__PURE__ */ new Ce(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new ye() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new le(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ye() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ce(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ye() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 }
  }
}, zi = {
  basic: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.specularmap,
      Et.envmap,
      Et.aomap,
      Et.lightmap,
      Et.fog
    ]),
    vertexShader: me.meshbasic_vert,
    fragmentShader: me.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.specularmap,
      Et.envmap,
      Et.aomap,
      Et.lightmap,
      Et.emissivemap,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      Et.fog,
      Et.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) }
      }
    ]),
    vertexShader: me.meshlambert_vert,
    fragmentShader: me.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.specularmap,
      Et.envmap,
      Et.aomap,
      Et.lightmap,
      Et.emissivemap,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      Et.fog,
      Et.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) },
        specular: { value: /* @__PURE__ */ new le(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: me.meshphong_vert,
    fragmentShader: me.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.envmap,
      Et.aomap,
      Et.lightmap,
      Et.emissivemap,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      Et.roughnessmap,
      Et.metalnessmap,
      Et.fog,
      Et.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: me.meshphysical_vert,
    fragmentShader: me.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.aomap,
      Et.lightmap,
      Et.emissivemap,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      Et.gradientmap,
      Et.fog,
      Et.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) }
      }
    ]),
    vertexShader: me.meshtoon_vert,
    fragmentShader: me.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      Et.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: me.meshmatcap_vert,
    fragmentShader: me.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ en([
      Et.points,
      Et.fog
    ]),
    vertexShader: me.points_vert,
    fragmentShader: me.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: me.linedashed_vert,
    fragmentShader: me.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.displacementmap
    ]),
    vertexShader: me.depth_vert,
    fragmentShader: me.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.bumpmap,
      Et.normalmap,
      Et.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: me.meshnormal_vert,
    fragmentShader: me.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ en([
      Et.sprite,
      Et.fog
    ]),
    vertexShader: me.sprite_vert,
    fragmentShader: me.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ye() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: me.background_vert,
    fragmentShader: me.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new ye() }
    },
    vertexShader: me.backgroundCube_vert,
    fragmentShader: me.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: me.cube_vert,
    fragmentShader: me.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: me.equirect_vert,
    fragmentShader: me.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ en([
      Et.common,
      Et.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new K() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: me.distanceRGBA_vert,
    fragmentShader: me.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ en([
      Et.lights,
      Et.fog,
      {
        color: { value: /* @__PURE__ */ new le(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: me.shadow_vert,
    fragmentShader: me.shadow_frag
  }
};
zi.physical = {
  uniforms: /* @__PURE__ */ en([
    zi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new ye() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new ye() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ce(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new ye() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new ye() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new ye() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new le(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new ye() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new ye() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new ye() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ce() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new ye() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new le(0) },
      specularColor: { value: /* @__PURE__ */ new le(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new ye() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new ye() },
      anisotropyVector: { value: /* @__PURE__ */ new Ce() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new ye() }
    }
  ]),
  vertexShader: me.meshphysical_vert,
  fragmentShader: me.meshphysical_frag
};
const xd = { r: 0, b: 0, g: 0 }, as = /* @__PURE__ */ new Fa(), P5 = /* @__PURE__ */ new $e();
function N5(r, t, e, n, i, a, o) {
  const s = new le(0);
  let l = a === !0 ? 0 : 1, u, c, f = null, h = 0, d = null;
  function p(y) {
    let _ = y.isScene === !0 ? y.background : null;
    return _ && _.isTexture && (_ = (y.backgroundBlurriness > 0 ? e : t).get(_)), _;
  }
  function g(y) {
    let _ = !1;
    const x = p(y);
    x === null ? m(s, l) : x && x.isColor && (m(x, 1), _ = !0);
    const b = r.xr.getEnvironmentBlendMode();
    b === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : b === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || _) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil);
  }
  function v(y, _) {
    const x = p(_);
    x && (x.isCubeTexture || x.mapping === Pg) ? (c === void 0 && (c = new Pn(
      new wl(1, 1, 1),
      new za({
        name: "BackgroundCubeMaterial",
        uniforms: Qu(zi.backgroundCube.uniforms),
        vertexShader: zi.backgroundCube.vertexShader,
        fragmentShader: zi.backgroundCube.fragmentShader,
        side: bn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(b, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(c)), as.copy(_.backgroundRotation), as.x *= -1, as.y *= -1, as.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (as.y *= -1, as.z *= -1), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(P5.makeRotationFromEuler(as)), c.material.toneMapped = Fe.getTransfer(x.colorSpace) !== qe, (f !== x || h !== x.version || d !== r.toneMapping) && (c.material.needsUpdate = !0, f = x, h = x.version, d = r.toneMapping), c.layers.enableAll(), y.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new Pn(
      new kg(2, 2),
      new za({
        name: "BackgroundMaterial",
        uniforms: Qu(zi.background.uniforms),
        vertexShader: zi.background.vertexShader,
        fragmentShader: zi.background.fragmentShader,
        side: Fo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, u.material.toneMapped = Fe.getTransfer(x.colorSpace) !== qe, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (f !== x || h !== x.version || d !== r.toneMapping) && (u.material.needsUpdate = !0, f = x, h = x.version, d = r.toneMapping), u.layers.enableAll(), y.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function m(y, _) {
    y.getRGB(xd, CI(r)), n.buffers.color.setClear(xd.r, xd.g, xd.b, _, o);
  }
  return {
    getClearColor: function() {
      return s;
    },
    setClearColor: function(y, _ = 1) {
      s.set(y), l = _, m(s, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(y) {
      l = y, m(s, l);
    },
    render: g,
    addToRenderList: v
  };
}
function O5(r, t) {
  const e = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, i = h(null);
  let a = i, o = !1;
  function s(M, C, R, E, D) {
    let I = !1;
    const P = f(E, R, C);
    a !== P && (a = P, u(a.object)), I = d(M, E, R, D), I && p(M, E, R, D), D !== null && t.update(D, r.ELEMENT_ARRAY_BUFFER), (I || o) && (o = !1, x(M, C, R, E), D !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(D).buffer));
  }
  function l() {
    return r.createVertexArray();
  }
  function u(M) {
    return r.bindVertexArray(M);
  }
  function c(M) {
    return r.deleteVertexArray(M);
  }
  function f(M, C, R) {
    const E = R.wireframe === !0;
    let D = n[M.id];
    D === void 0 && (D = {}, n[M.id] = D);
    let I = D[C.id];
    I === void 0 && (I = {}, D[C.id] = I);
    let P = I[E];
    return P === void 0 && (P = h(l()), I[E] = P), P;
  }
  function h(M) {
    const C = [], R = [], E = [];
    for (let D = 0; D < e; D++)
      C[D] = 0, R[D] = 0, E[D] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: C,
      enabledAttributes: R,
      attributeDivisors: E,
      object: M,
      attributes: {},
      index: null
    };
  }
  function d(M, C, R, E) {
    const D = a.attributes, I = C.attributes;
    let P = 0;
    const O = R.getAttributes();
    for (const N in O)
      if (O[N].location >= 0) {
        const F = D[N];
        let G = I[N];
        if (G === void 0 && (N === "instanceMatrix" && M.instanceMatrix && (G = M.instanceMatrix), N === "instanceColor" && M.instanceColor && (G = M.instanceColor)), F === void 0 || F.attribute !== G || G && F.data !== G.data)
          return !0;
        P++;
      }
    return a.attributesNum !== P || a.index !== E;
  }
  function p(M, C, R, E) {
    const D = {}, I = C.attributes;
    let P = 0;
    const O = R.getAttributes();
    for (const N in O)
      if (O[N].location >= 0) {
        let F = I[N];
        F === void 0 && (N === "instanceMatrix" && M.instanceMatrix && (F = M.instanceMatrix), N === "instanceColor" && M.instanceColor && (F = M.instanceColor));
        const G = {};
        G.attribute = F, F && F.data && (G.data = F.data), D[N] = G, P++;
      }
    a.attributes = D, a.attributesNum = P, a.index = E;
  }
  function g() {
    const M = a.newAttributes;
    for (let C = 0, R = M.length; C < R; C++)
      M[C] = 0;
  }
  function v(M) {
    m(M, 0);
  }
  function m(M, C) {
    const R = a.newAttributes, E = a.enabledAttributes, D = a.attributeDivisors;
    R[M] = 1, E[M] === 0 && (r.enableVertexAttribArray(M), E[M] = 1), D[M] !== C && (r.vertexAttribDivisor(M, C), D[M] = C);
  }
  function y() {
    const M = a.newAttributes, C = a.enabledAttributes;
    for (let R = 0, E = C.length; R < E; R++)
      C[R] !== M[R] && (r.disableVertexAttribArray(R), C[R] = 0);
  }
  function _(M, C, R, E, D, I, P) {
    P === !0 ? r.vertexAttribIPointer(M, C, R, D, I) : r.vertexAttribPointer(M, C, R, E, D, I);
  }
  function x(M, C, R, E) {
    g();
    const D = E.attributes, I = R.getAttributes(), P = C.defaultAttributeValues;
    for (const O in I) {
      const N = I[O];
      if (N.location >= 0) {
        let B = D[O];
        if (B === void 0 && (O === "instanceMatrix" && M.instanceMatrix && (B = M.instanceMatrix), O === "instanceColor" && M.instanceColor && (B = M.instanceColor)), B !== void 0) {
          const F = B.normalized, G = B.itemSize, W = t.get(B);
          if (W === void 0)
            continue;
          const J = W.buffer, U = W.type, Y = W.bytesPerElement, at = U === r.INT || U === r.UNSIGNED_INT || B.gpuType === pI;
          if (B.isInterleavedBufferAttribute) {
            const st = B.data, ut = st.stride, lt = B.offset;
            if (st.isInstancedInterleavedBuffer) {
              for (let H = 0; H < N.locationSize; H++)
                m(N.location + H, st.meshPerAttribute);
              M.isInstancedMesh !== !0 && E._maxInstanceCount === void 0 && (E._maxInstanceCount = st.meshPerAttribute * st.count);
            } else
              for (let H = 0; H < N.locationSize; H++)
                v(N.location + H);
            r.bindBuffer(r.ARRAY_BUFFER, J);
            for (let H = 0; H < N.locationSize; H++)
              _(
                N.location + H,
                G / N.locationSize,
                U,
                F,
                ut * Y,
                (lt + G / N.locationSize * H) * Y,
                at
              );
          } else {
            if (B.isInstancedBufferAttribute) {
              for (let st = 0; st < N.locationSize; st++)
                m(N.location + st, B.meshPerAttribute);
              M.isInstancedMesh !== !0 && E._maxInstanceCount === void 0 && (E._maxInstanceCount = B.meshPerAttribute * B.count);
            } else
              for (let st = 0; st < N.locationSize; st++)
                v(N.location + st);
            r.bindBuffer(r.ARRAY_BUFFER, J);
            for (let st = 0; st < N.locationSize; st++)
              _(
                N.location + st,
                G / N.locationSize,
                U,
                F,
                G * Y,
                G / N.locationSize * st * Y,
                at
              );
          }
        } else if (P !== void 0) {
          const F = P[O];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                r.vertexAttrib2fv(N.location, F);
                break;
              case 3:
                r.vertexAttrib3fv(N.location, F);
                break;
              case 4:
                r.vertexAttrib4fv(N.location, F);
                break;
              default:
                r.vertexAttrib1fv(N.location, F);
            }
        }
      }
    }
    y();
  }
  function b() {
    A();
    for (const M in n) {
      const C = n[M];
      for (const R in C) {
        const E = C[R];
        for (const D in E)
          c(E[D].object), delete E[D];
        delete C[R];
      }
      delete n[M];
    }
  }
  function S(M) {
    if (n[M.id] === void 0)
      return;
    const C = n[M.id];
    for (const R in C) {
      const E = C[R];
      for (const D in E)
        c(E[D].object), delete E[D];
      delete C[R];
    }
    delete n[M.id];
  }
  function w(M) {
    for (const C in n) {
      const R = n[C];
      if (R[M.id] === void 0)
        continue;
      const E = R[M.id];
      for (const D in E)
        c(E[D].object), delete E[D];
      delete R[M.id];
    }
  }
  function A() {
    T(), o = !0, a !== i && (a = i, u(a.object));
  }
  function T() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: s,
    reset: A,
    resetDefaultState: T,
    dispose: b,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: w,
    initAttributes: g,
    enableAttribute: v,
    disableUnusedAttributes: y
  };
}
function k5(r, t, e) {
  let n;
  function i(u) {
    n = u;
  }
  function a(u, c) {
    r.drawArrays(n, u, c), e.update(c, n, 1);
  }
  function o(u, c, f) {
    f !== 0 && (r.drawArraysInstanced(n, u, c, f), e.update(c, n, f));
  }
  function s(u, c, f) {
    if (f === 0)
      return;
    const h = t.get("WEBGL_multi_draw");
    if (h === null)
      for (let d = 0; d < f; d++)
        this.render(u[d], c[d]);
    else {
      h.multiDrawArraysWEBGL(n, u, 0, c, 0, f);
      let d = 0;
      for (let p = 0; p < f; p++)
        d += c[p];
      e.update(d, n, 1);
    }
  }
  function l(u, c, f, h) {
    if (f === 0)
      return;
    const d = t.get("WEBGL_multi_draw");
    if (d === null)
      for (let p = 0; p < u.length; p++)
        o(u[p], c[p], h[p]);
    else {
      d.multiDrawArraysInstancedWEBGL(n, u, 0, c, 0, h, 0, f);
      let p = 0;
      for (let g = 0; g < f; g++)
        p += c[g];
      for (let g = 0; g < h.length; g++)
        e.update(p, n, h[g]);
    }
  }
  this.setMode = i, this.render = a, this.renderInstances = o, this.renderMultiDraw = s, this.renderMultiDrawInstances = l;
}
function B5(r, t, e, n) {
  let i;
  function a() {
    if (i !== void 0)
      return i;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const S = t.get("EXT_texture_filter_anisotropic");
      i = r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function o(S) {
    return !(S !== Xi && n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function s(S) {
    const w = S === Ng && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
    return !(S !== zo && n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    S !== Ca && !w);
  }
  function l(S) {
    if (S === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      S = "mediump";
    }
    return S === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = e.precision !== void 0 ? e.precision : "highp";
  const c = l(u);
  c !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", c, "instead."), u = c);
  const f = e.logarithmicDepthBuffer === !0, h = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), d = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), p = r.getParameter(r.MAX_TEXTURE_SIZE), g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), v = r.getParameter(r.MAX_VERTEX_ATTRIBS), m = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), y = r.getParameter(r.MAX_VARYING_VECTORS), _ = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), x = d > 0, b = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: s,
    precision: u,
    logarithmicDepthBuffer: f,
    maxTextures: h,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: g,
    maxAttributes: v,
    maxVertexUniforms: m,
    maxVaryings: y,
    maxFragmentUniforms: _,
    vertexTextures: x,
    maxSamples: b
  };
}
function V5(r) {
  const t = this;
  let e = null, n = 0, i = !1, a = !1;
  const o = new Ps(), s = new ye(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, h) {
    const d = f.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = h, n = f.length, d;
  }, this.beginShadows = function() {
    a = !0, c(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(f, h) {
    e = c(f, h, 0);
  }, this.setState = function(f, h, d) {
    const p = f.clippingPlanes, g = f.clipIntersection, v = f.clipShadows, m = r.get(f);
    if (!i || p === null || p.length === 0 || a && !v)
      a ? c(null) : u();
    else {
      const y = a ? 0 : n, _ = y * 4;
      let x = m.clippingState || null;
      l.value = x, x = c(p, h, _, d);
      for (let b = 0; b !== _; ++b)
        x[b] = e[b];
      m.clippingState = x, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
  function u() {
    l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
  }
  function c(f, h, d, p) {
    const g = f !== null ? f.length : 0;
    let v = null;
    if (g !== 0) {
      if (v = l.value, p !== !0 || v === null) {
        const m = d + g * 4, y = h.matrixWorldInverse;
        s.getNormalMatrix(y), (v === null || v.length < m) && (v = new Float32Array(m));
        for (let _ = 0, x = d; _ !== g; ++_, x += 4)
          o.copy(f[_]).applyMatrix4(y, s), o.normal.toArray(v, x), v[x + 3] = o.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return t.numPlanes = g, t.numIntersection = 0, v;
  }
}
function F5(r) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o, s) {
    return s === G_ ? o.mapping = Ku : s === H_ && (o.mapping = ju), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const s = o.mapping;
      if (s === G_ || s === H_)
        if (t.has(o)) {
          const l = t.get(o).texture;
          return e(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new Kz(l.height);
            return u.fromEquirectangularTexture(r, o), t.set(o, u), o.addEventListener("dispose", i), e(u.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const s = o.target;
    s.removeEventListener("dispose", i);
    const l = t.get(s);
    l !== void 0 && (t.delete(s), l.dispose());
  }
  function a() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
class II extends DI {
  constructor(t = -1, e = 1, n = 1, i = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, n, i, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let a = n - t, o = n + t, s = i + e, l = i - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += u * this.view.offsetX, o = a + u * this.view.width, s -= c * this.view.offsetY, l = s - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, s, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
}
const Iu = 4, HM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Gs = 20, ey = /* @__PURE__ */ new II(), WM = /* @__PURE__ */ new le();
let ry = null, ny = 0, iy = 0, ay = !1;
const Ns = (1 + Math.sqrt(5)) / 2, jl = 1 / Ns, XM = [
  /* @__PURE__ */ new K(-Ns, jl, 0),
  /* @__PURE__ */ new K(Ns, jl, 0),
  /* @__PURE__ */ new K(-jl, 0, Ns),
  /* @__PURE__ */ new K(jl, 0, Ns),
  /* @__PURE__ */ new K(0, Ns, -jl),
  /* @__PURE__ */ new K(0, Ns, jl),
  /* @__PURE__ */ new K(-1, 1, -1),
  /* @__PURE__ */ new K(1, 1, -1),
  /* @__PURE__ */ new K(-1, 1, 1),
  /* @__PURE__ */ new K(1, 1, 1)
];
class YM {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ry = this._renderer.getRenderTarget(), ny = this._renderer.getActiveCubeFace(), iy = this._renderer.getActiveMipmapLevel(), ay = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(t, n, i, a), e > 0 && this._blur(a, 0, 0, e), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = qM(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = ZM(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(ry, ny, iy), this._renderer.xr.enabled = ay, t.scissorTest = !1, Sd(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === Ku || t.mapping === ju ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), ry = this._renderer.getRenderTarget(), ny = this._renderer.getActiveCubeFace(), iy = this._renderer.getActiveMipmapLevel(), ay = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = e || this._allocateTargets();
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = {
      magFilter: vi,
      minFilter: vi,
      generateMipmaps: !1,
      type: Ng,
      format: Xi,
      colorSpace: qo,
      depthBuffer: !1
    }, i = $M(t, e, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = $M(t, e, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = z5(a)), this._blurMaterial = U5(a, t, e);
    }
    return i;
  }
  _compileMaterial(t) {
    const e = new Pn(this._lodPlanes[0], t);
    this._renderer.compile(e, ey);
  }
  _sceneToCubeUV(t, e, n, i) {
    const s = new Rn(90, 1, e, n), l = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], c = this._renderer, f = c.autoClear, h = c.toneMapping;
    c.getClearColor(WM), c.toneMapping = Io, c.autoClear = !1;
    const d = new v1({
      name: "PMREM.Background",
      side: bn,
      depthWrite: !1,
      depthTest: !1
    }), p = new Pn(new wl(), d);
    let g = !1;
    const v = t.background;
    v ? v.isColor && (d.color.copy(v), t.background = null, g = !0) : (d.color.copy(WM), g = !0);
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0 ? (s.up.set(0, l[m], 0), s.lookAt(u[m], 0, 0)) : y === 1 ? (s.up.set(0, 0, l[m]), s.lookAt(0, u[m], 0)) : (s.up.set(0, l[m], 0), s.lookAt(0, 0, u[m]));
      const _ = this._cubeSize;
      Sd(i, y * _, m > 2 ? _ : 0, _, _), c.setRenderTarget(i), g && c.render(p, s), c.render(t, s);
    }
    p.geometry.dispose(), p.material.dispose(), c.toneMapping = h, c.autoClear = f, t.background = v;
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer, i = t.mapping === Ku || t.mapping === ju;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = qM()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ZM());
    const a = i ? this._cubemapMaterial : this._equirectMaterial, o = new Pn(this._lodPlanes[0], a), s = a.uniforms;
    s.envMap.value = t;
    const l = this._cubeSize;
    Sd(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(o, ey);
  }
  _applyPMREM(t) {
    const e = this._renderer, n = e.autoClear;
    e.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let a = 1; a < i; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), s = XM[(i - a - 1) % XM.length];
      this._blur(t, a - 1, a, o, s);
    }
    e.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(t, e, n, i, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      t,
      o,
      e,
      n,
      i,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      t,
      n,
      n,
      i,
      "longitudinal",
      a
    );
  }
  _halfBlur(t, e, n, i, a, o, s) {
    const l = this._renderer, u = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, f = new Pn(this._lodPlanes[i], u), h = u.uniforms, d = this._sizeLods[n] - 1, p = isFinite(a) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Gs - 1), g = a / p, v = isFinite(a) ? 1 + Math.floor(c * g) : Gs;
    v > Gs && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Gs}`);
    const m = [];
    let y = 0;
    for (let w = 0; w < Gs; ++w) {
      const A = w / g, T = Math.exp(-A * A / 2);
      m.push(T), w === 0 ? y += T : w < v && (y += 2 * T);
    }
    for (let w = 0; w < m.length; w++)
      m[w] = m[w] / y;
    h.envMap.value = t.texture, h.samples.value = v, h.weights.value = m, h.latitudinal.value = o === "latitudinal", s && (h.poleAxis.value = s);
    const { _lodMax: _ } = this;
    h.dTheta.value = p, h.mipInt.value = _ - n;
    const x = this._sizeLods[i], b = 3 * x * (i > _ - Iu ? i - _ + Iu : 0), S = 4 * (this._cubeSize - x);
    Sd(e, b, S, 3 * x, 2 * x), l.setRenderTarget(e), l.render(f, ey);
  }
}
function z5(r) {
  const t = [], e = [], n = [];
  let i = r;
  const a = r - Iu + 1 + HM.length;
  for (let o = 0; o < a; o++) {
    const s = Math.pow(2, i);
    e.push(s);
    let l = 1 / s;
    o > r - Iu ? l = HM[o - r + Iu - 1] : o === 0 && (l = 0), n.push(l);
    const u = 1 / (s - 2), c = -u, f = 1 + u, h = [c, c, f, c, f, f, c, c, f, f, c, f], d = 6, p = 6, g = 3, v = 2, m = 1, y = new Float32Array(g * p * d), _ = new Float32Array(v * p * d), x = new Float32Array(m * p * d);
    for (let S = 0; S < d; S++) {
      const w = S % 3 * 2 / 3 - 1, A = S > 2 ? 0 : -1, T = [
        w,
        A,
        0,
        w + 2 / 3,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A + 1,
        0
      ];
      y.set(T, g * p * S), _.set(h, v * p * S);
      const M = [S, S, S, S, S, S];
      x.set(M, m * p * S);
    }
    const b = new ca();
    b.setAttribute("position", new ni(y, g)), b.setAttribute("uv", new ni(_, v)), b.setAttribute("faceIndex", new ni(x, m)), t.push(b), i > Iu && i--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: n };
}
function $M(r, t, e) {
  const n = new fl(r, t, e);
  return n.texture.mapping = Pg, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Sd(r, t, e, n, i) {
  r.viewport.set(t, e, n, i), r.scissor.set(t, e, n, i);
}
function U5(r, t, e) {
  const n = new Float32Array(Gs), i = new K(0, 1, 0);
  return new za({
    name: "SphericalGaussianBlur",
    defines: {
      n: Gs,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: m1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Ro,
    depthTest: !1,
    depthWrite: !1
  });
}
function ZM() {
  return new za({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: m1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Ro,
    depthTest: !1,
    depthWrite: !1
  });
}
function qM() {
  return new za({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: m1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Ro,
    depthTest: !1,
    depthWrite: !1
  });
}
function m1() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function G5(r) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function n(s) {
    if (s && s.isTexture) {
      const l = s.mapping, u = l === G_ || l === H_, c = l === Ku || l === ju;
      if (u || c) {
        let f = t.get(s);
        const h = f !== void 0 ? f.texture.pmremVersion : 0;
        if (s.isRenderTargetTexture && s.pmremVersion !== h)
          return e === null && (e = new YM(r)), f = u ? e.fromEquirectangular(s, f) : e.fromCubemap(s, f), f.texture.pmremVersion = s.pmremVersion, t.set(s, f), f.texture;
        if (f !== void 0)
          return f.texture;
        {
          const d = s.image;
          return u && d && d.height > 0 || c && d && i(d) ? (e === null && (e = new YM(r)), f = u ? e.fromEquirectangular(s) : e.fromCubemap(s), f.texture.pmremVersion = s.pmremVersion, t.set(s, f), s.addEventListener("dispose", a), f.texture) : null;
        }
      }
    }
    return s;
  }
  function i(s) {
    let l = 0;
    const u = 6;
    for (let c = 0; c < u; c++)
      s[c] !== void 0 && l++;
    return l === u;
  }
  function a(s) {
    const l = s.target;
    l.removeEventListener("dispose", a);
    const u = t.get(l);
    u !== void 0 && (t.delete(l), u.dispose());
  }
  function o() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function H5(r) {
  const t = {};
  function e(n) {
    if (t[n] !== void 0)
      return t[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return t[n] = i, i;
  }
  return {
    has: function(n) {
      return e(n) !== null;
    },
    init: function() {
      e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const i = e(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function W5(r, t, e, n) {
  const i = {}, a = /* @__PURE__ */ new WeakMap();
  function o(f) {
    const h = f.target;
    h.index !== null && t.remove(h.index);
    for (const p in h.attributes)
      t.remove(h.attributes[p]);
    for (const p in h.morphAttributes) {
      const g = h.morphAttributes[p];
      for (let v = 0, m = g.length; v < m; v++)
        t.remove(g[v]);
    }
    h.removeEventListener("dispose", o), delete i[h.id];
    const d = a.get(h);
    d && (t.remove(d), a.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, e.memory.geometries--;
  }
  function s(f, h) {
    return i[h.id] === !0 || (h.addEventListener("dispose", o), i[h.id] = !0, e.memory.geometries++), h;
  }
  function l(f) {
    const h = f.attributes;
    for (const p in h)
      t.update(h[p], r.ARRAY_BUFFER);
    const d = f.morphAttributes;
    for (const p in d) {
      const g = d[p];
      for (let v = 0, m = g.length; v < m; v++)
        t.update(g[v], r.ARRAY_BUFFER);
    }
  }
  function u(f) {
    const h = [], d = f.index, p = f.attributes.position;
    let g = 0;
    if (d !== null) {
      const y = d.array;
      g = d.version;
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const b = y[_ + 0], S = y[_ + 1], w = y[_ + 2];
        h.push(b, S, S, w, w, b);
      }
    } else if (p !== void 0) {
      const y = p.array;
      g = p.version;
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const b = _ + 0, S = _ + 1, w = _ + 2;
        h.push(b, S, S, w, w, b);
      }
    } else
      return;
    const v = new (bI(h) ? EI : AI)(h, 1);
    v.version = g;
    const m = a.get(f);
    m && t.remove(m), a.set(f, v);
  }
  function c(f) {
    const h = a.get(f);
    if (h) {
      const d = f.index;
      d !== null && h.version < d.version && u(f);
    } else
      u(f);
    return a.get(f);
  }
  return {
    get: s,
    update: l,
    getWireframeAttribute: c
  };
}
function X5(r, t, e) {
  let n;
  function i(h) {
    n = h;
  }
  let a, o;
  function s(h) {
    a = h.type, o = h.bytesPerElement;
  }
  function l(h, d) {
    r.drawElements(n, d, a, h * o), e.update(d, n, 1);
  }
  function u(h, d, p) {
    p !== 0 && (r.drawElementsInstanced(n, d, a, h * o, p), e.update(d, n, p));
  }
  function c(h, d, p) {
    if (p === 0)
      return;
    const g = t.get("WEBGL_multi_draw");
    if (g === null)
      for (let v = 0; v < p; v++)
        this.render(h[v] / o, d[v]);
    else {
      g.multiDrawElementsWEBGL(n, d, 0, a, h, 0, p);
      let v = 0;
      for (let m = 0; m < p; m++)
        v += d[m];
      e.update(v, n, 1);
    }
  }
  function f(h, d, p, g) {
    if (p === 0)
      return;
    const v = t.get("WEBGL_multi_draw");
    if (v === null)
      for (let m = 0; m < h.length; m++)
        u(h[m] / o, d[m], g[m]);
    else {
      v.multiDrawElementsInstancedWEBGL(n, d, 0, a, h, 0, g, 0, p);
      let m = 0;
      for (let y = 0; y < p; y++)
        m += d[y];
      for (let y = 0; y < g.length; y++)
        e.update(m, n, g[y]);
    }
  }
  this.setMode = i, this.setIndex = s, this.render = l, this.renderInstances = u, this.renderMultiDraw = c, this.renderMultiDrawInstances = f;
}
function Y5(r) {
  const t = {
    geometries: 0,
    textures: 0
  }, e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, s) {
    switch (e.calls++, o) {
      case r.TRIANGLES:
        e.triangles += s * (a / 3);
        break;
      case r.LINES:
        e.lines += s * (a / 2);
        break;
      case r.LINE_STRIP:
        e.lines += s * (a - 1);
        break;
      case r.LINE_LOOP:
        e.lines += s * a;
        break;
      case r.POINTS:
        e.points += s * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function $5(r, t, e) {
  const n = /* @__PURE__ */ new WeakMap(), i = new Nr();
  function a(o, s, l) {
    const u = o.morphTargetInfluences, c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color, f = c !== void 0 ? c.length : 0;
    let h = n.get(s);
    if (h === void 0 || h.count !== f) {
      let T = function() {
        w.dispose(), n.delete(s), s.removeEventListener("dispose", T);
      };
      h !== void 0 && h.texture.dispose();
      const d = s.morphAttributes.position !== void 0, p = s.morphAttributes.normal !== void 0, g = s.morphAttributes.color !== void 0, v = s.morphAttributes.position || [], m = s.morphAttributes.normal || [], y = s.morphAttributes.color || [];
      let _ = 0;
      d === !0 && (_ = 1), p === !0 && (_ = 2), g === !0 && (_ = 3);
      let x = s.attributes.position.count * _, b = 1;
      x > t.maxTextureSize && (b = Math.ceil(x / t.maxTextureSize), x = t.maxTextureSize);
      const S = new Float32Array(x * b * 4 * f), w = new MI(S, x, b, f);
      w.type = Ca, w.needsUpdate = !0;
      const A = _ * 4;
      for (let M = 0; M < f; M++) {
        const C = v[M], R = m[M], E = y[M], D = x * b * 4 * M;
        for (let I = 0; I < C.count; I++) {
          const P = I * A;
          d === !0 && (i.fromBufferAttribute(C, I), S[D + P + 0] = i.x, S[D + P + 1] = i.y, S[D + P + 2] = i.z, S[D + P + 3] = 0), p === !0 && (i.fromBufferAttribute(R, I), S[D + P + 4] = i.x, S[D + P + 5] = i.y, S[D + P + 6] = i.z, S[D + P + 7] = 0), g === !0 && (i.fromBufferAttribute(E, I), S[D + P + 8] = i.x, S[D + P + 9] = i.y, S[D + P + 10] = i.z, S[D + P + 11] = E.itemSize === 4 ? i.w : 1);
        }
      }
      h = {
        count: f,
        texture: w,
        size: new Ce(x, b)
      }, n.set(s, h), s.addEventListener("dispose", T);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(r, "morphTexture", o.morphTexture, e);
    else {
      let d = 0;
      for (let g = 0; g < u.length; g++)
        d += u[g];
      const p = s.morphTargetsRelative ? 1 : 1 - d;
      l.getUniforms().setValue(r, "morphTargetBaseInfluence", p), l.getUniforms().setValue(r, "morphTargetInfluences", u);
    }
    l.getUniforms().setValue(r, "morphTargetsTexture", h.texture, e), l.getUniforms().setValue(r, "morphTargetsTextureSize", h.size);
  }
  return {
    update: a
  };
}
function Z5(r, t, e, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function a(l) {
    const u = n.render.frame, c = l.geometry, f = t.get(l, c);
    if (i.get(f) !== u && (t.update(f), i.set(f, u)), l.isInstancedMesh && (l.hasEventListener("dispose", s) === !1 && l.addEventListener("dispose", s), i.get(l) !== u && (e.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, u))), l.isSkinnedMesh) {
      const h = l.skeleton;
      i.get(h) !== u && (h.update(), i.set(h, u));
    }
    return f;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function s(l) {
    const u = l.target;
    u.removeEventListener("dispose", s), e.remove(u.instanceMatrix), u.instanceColor !== null && e.remove(u.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
class PI extends ln {
  constructor(t, e, n, i, a, o, s, l, u, c) {
    if (c = c !== void 0 ? c : Gu, c !== Gu && c !== th)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && c === Gu && (n = Ju), n === void 0 && c === th && (n = Lh), super(null, i, a, o, s, l, c, n, u), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = s !== void 0 ? s : Sn, this.minFilter = l !== void 0 ? l : Sn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(t) {
    return super.copy(t), this.compareFunction = t.compareFunction, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
}
const NI = /* @__PURE__ */ new ln(), OI = /* @__PURE__ */ new PI(1, 1);
OI.compareFunction = SI;
const kI = /* @__PURE__ */ new MI(), BI = /* @__PURE__ */ new Nz(), VI = /* @__PURE__ */ new LI(), KM = [], jM = [], JM = new Float32Array(16), QM = new Float32Array(9), tT = new Float32Array(4);
function yc(r, t, e) {
  const n = r[0];
  if (n <= 0 || n > 0)
    return r;
  const i = t * e;
  let a = KM[i];
  if (a === void 0 && (a = new Float32Array(i), KM[i] = a), t !== 0) {
    n.toArray(a, 0);
    for (let o = 1, s = 0; o !== t; ++o)
      s += e, r[o].toArray(a, s);
  }
  return a;
}
function Ar(r, t) {
  if (r.length !== t.length)
    return !1;
  for (let e = 0, n = r.length; e < n; e++)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function Er(r, t) {
  for (let e = 0, n = t.length; e < n; e++)
    r[e] = t[e];
}
function Bg(r, t) {
  let e = jM[t];
  e === void 0 && (e = new Int32Array(t), jM[t] = e);
  for (let n = 0; n !== t; ++n)
    e[n] = r.allocateTextureUnit();
  return e;
}
function q5(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1f(this.addr, t), e[0] = t);
}
function K5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Ar(e, t))
      return;
    r.uniform2fv(this.addr, t), Er(e, t);
  }
}
function j5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (r.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (Ar(e, t))
      return;
    r.uniform3fv(this.addr, t), Er(e, t);
  }
}
function J5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Ar(e, t))
      return;
    r.uniform4fv(this.addr, t), Er(e, t);
  }
}
function Q5(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Ar(e, t))
      return;
    r.uniformMatrix2fv(this.addr, !1, t), Er(e, t);
  } else {
    if (Ar(e, n))
      return;
    tT.set(n), r.uniformMatrix2fv(this.addr, !1, tT), Er(e, n);
  }
}
function tH(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Ar(e, t))
      return;
    r.uniformMatrix3fv(this.addr, !1, t), Er(e, t);
  } else {
    if (Ar(e, n))
      return;
    QM.set(n), r.uniformMatrix3fv(this.addr, !1, QM), Er(e, n);
  }
}
function eH(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Ar(e, t))
      return;
    r.uniformMatrix4fv(this.addr, !1, t), Er(e, t);
  } else {
    if (Ar(e, n))
      return;
    JM.set(n), r.uniformMatrix4fv(this.addr, !1, JM), Er(e, n);
  }
}
function rH(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1i(this.addr, t), e[0] = t);
}
function nH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Ar(e, t))
      return;
    r.uniform2iv(this.addr, t), Er(e, t);
  }
}
function iH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Ar(e, t))
      return;
    r.uniform3iv(this.addr, t), Er(e, t);
  }
}
function aH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Ar(e, t))
      return;
    r.uniform4iv(this.addr, t), Er(e, t);
  }
}
function oH(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1ui(this.addr, t), e[0] = t);
}
function sH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Ar(e, t))
      return;
    r.uniform2uiv(this.addr, t), Er(e, t);
  }
}
function lH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Ar(e, t))
      return;
    r.uniform3uiv(this.addr, t), Er(e, t);
  }
}
function uH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Ar(e, t))
      return;
    r.uniform4uiv(this.addr, t), Er(e, t);
  }
}
function cH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
  const a = this.type === r.SAMPLER_2D_SHADOW ? OI : NI;
  e.setTexture2D(t || a, i);
}
function fH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture3D(t || BI, i);
}
function hH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTextureCube(t || VI, i);
}
function dH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture2DArray(t || kI, i);
}
function pH(r) {
  switch (r) {
    case 5126:
      return q5;
    case 35664:
      return K5;
    case 35665:
      return j5;
    case 35666:
      return J5;
    case 35674:
      return Q5;
    case 35675:
      return tH;
    case 35676:
      return eH;
    case 5124:
    case 35670:
      return rH;
    case 35667:
    case 35671:
      return nH;
    case 35668:
    case 35672:
      return iH;
    case 35669:
    case 35673:
      return aH;
    case 5125:
      return oH;
    case 36294:
      return sH;
    case 36295:
      return lH;
    case 36296:
      return uH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return cH;
    case 35679:
    case 36299:
    case 36307:
      return fH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return hH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return dH;
  }
}
function vH(r, t) {
  r.uniform1fv(this.addr, t);
}
function gH(r, t) {
  const e = yc(t, this.size, 2);
  r.uniform2fv(this.addr, e);
}
function mH(r, t) {
  const e = yc(t, this.size, 3);
  r.uniform3fv(this.addr, e);
}
function yH(r, t) {
  const e = yc(t, this.size, 4);
  r.uniform4fv(this.addr, e);
}
function _H(r, t) {
  const e = yc(t, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, e);
}
function xH(r, t) {
  const e = yc(t, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, e);
}
function SH(r, t) {
  const e = yc(t, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, e);
}
function bH(r, t) {
  r.uniform1iv(this.addr, t);
}
function wH(r, t) {
  r.uniform2iv(this.addr, t);
}
function MH(r, t) {
  r.uniform3iv(this.addr, t);
}
function TH(r, t) {
  r.uniform4iv(this.addr, t);
}
function AH(r, t) {
  r.uniform1uiv(this.addr, t);
}
function EH(r, t) {
  r.uniform2uiv(this.addr, t);
}
function CH(r, t) {
  r.uniform3uiv(this.addr, t);
}
function DH(r, t) {
  r.uniform4uiv(this.addr, t);
}
function LH(r, t, e) {
  const n = this.cache, i = t.length, a = Bg(e, i);
  Ar(n, a) || (r.uniform1iv(this.addr, a), Er(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture2D(t[o] || NI, a[o]);
}
function RH(r, t, e) {
  const n = this.cache, i = t.length, a = Bg(e, i);
  Ar(n, a) || (r.uniform1iv(this.addr, a), Er(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture3D(t[o] || BI, a[o]);
}
function IH(r, t, e) {
  const n = this.cache, i = t.length, a = Bg(e, i);
  Ar(n, a) || (r.uniform1iv(this.addr, a), Er(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTextureCube(t[o] || VI, a[o]);
}
function PH(r, t, e) {
  const n = this.cache, i = t.length, a = Bg(e, i);
  Ar(n, a) || (r.uniform1iv(this.addr, a), Er(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture2DArray(t[o] || kI, a[o]);
}
function NH(r) {
  switch (r) {
    case 5126:
      return vH;
    case 35664:
      return gH;
    case 35665:
      return mH;
    case 35666:
      return yH;
    case 35674:
      return _H;
    case 35675:
      return xH;
    case 35676:
      return SH;
    case 5124:
    case 35670:
      return bH;
    case 35667:
    case 35671:
      return wH;
    case 35668:
    case 35672:
      return MH;
    case 35669:
    case 35673:
      return TH;
    case 5125:
      return AH;
    case 36294:
      return EH;
    case 36295:
      return CH;
    case 36296:
      return DH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return LH;
    case 35679:
    case 36299:
    case 36307:
      return RH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return IH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return PH;
  }
}
class OH {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = pH(e.type);
  }
}
class kH {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = NH(e.type);
  }
}
class BH {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, n) {
    const i = this.seq;
    for (let a = 0, o = i.length; a !== o; ++a) {
      const s = i[a];
      s.setValue(t, e[s.id], n);
    }
  }
}
const oy = /(\w+)(\])?(\[|\.)?/g;
function eT(r, t) {
  r.seq.push(t), r.map[t.id] = t;
}
function VH(r, t, e) {
  const n = r.name, i = n.length;
  for (oy.lastIndex = 0; ; ) {
    const a = oy.exec(n), o = oy.lastIndex;
    let s = a[1];
    const l = a[2] === "]", u = a[3];
    if (l && (s = s | 0), u === void 0 || u === "[" && o + 2 === i) {
      eT(e, u === void 0 ? new OH(s, r, t) : new kH(s, r, t));
      break;
    } else {
      let f = e.map[s];
      f === void 0 && (f = new BH(s), eT(e, f)), e = f;
    }
  }
}
class Up {
  constructor(t, e) {
    this.seq = [], this.map = {};
    const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const a = t.getActiveUniform(e, i), o = t.getUniformLocation(e, a.name);
      VH(a, o, this);
    }
  }
  setValue(t, e, n, i) {
    const a = this.map[e];
    a !== void 0 && a.setValue(t, n, i);
  }
  setOptional(t, e, n) {
    const i = e[n];
    i !== void 0 && this.setValue(t, n, i);
  }
  static upload(t, e, n, i) {
    for (let a = 0, o = e.length; a !== o; ++a) {
      const s = e[a], l = n[s.id];
      l.needsUpdate !== !1 && s.setValue(t, l.value, i);
    }
  }
  static seqWithValue(t, e) {
    const n = [];
    for (let i = 0, a = t.length; i !== a; ++i) {
      const o = t[i];
      o.id in e && n.push(o);
    }
    return n;
  }
}
function rT(r, t, e) {
  const n = r.createShader(t);
  return r.shaderSource(n, e), r.compileShader(n), n;
}
const FH = 37297;
let zH = 0;
function UH(r, t) {
  const e = r.split(`
`), n = [], i = Math.max(t - 6, 0), a = Math.min(t + 6, e.length);
  for (let o = i; o < a; o++) {
    const s = o + 1;
    n.push(`${s === t ? ">" : " "} ${s}: ${e[o]}`);
  }
  return n.join(`
`);
}
function GH(r) {
  const t = Fe.getPrimaries(Fe.workingColorSpace), e = Fe.getPrimaries(r);
  let n;
  switch (t === e ? n = "" : t === dv && e === hv ? n = "LinearDisplayP3ToLinearSRGB" : t === hv && e === dv && (n = "LinearSRGBToLinearDisplayP3"), r) {
    case qo:
    case Og:
      return [n, "LinearTransferOETF"];
    case Vi:
    case h1:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", r), [n, "LinearTransferOETF"];
  }
}
function nT(r, t, e) {
  const n = r.getShaderParameter(t, r.COMPILE_STATUS), i = r.getShaderInfoLog(t).trim();
  if (n && i === "")
    return "";
  const a = /ERROR: 0:(\d+)/.exec(i);
  if (a) {
    const o = parseInt(a[1]);
    return e.toUpperCase() + `

` + i + `

` + UH(r.getShaderSource(t), o);
  } else
    return i;
}
function HH(r, t) {
  const e = GH(t);
  return `vec4 ${r}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`;
}
function WH(r, t) {
  let e;
  switch (t) {
    case JF:
      e = "Linear";
      break;
    case QF:
      e = "Reinhard";
      break;
    case tz:
      e = "OptimizedCineon";
      break;
    case ez:
      e = "ACESFilmic";
      break;
    case nz:
      e = "AgX";
      break;
    case iz:
      e = "Neutral";
      break;
    case rz:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
function XH(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Tf).join(`
`);
}
function YH(r) {
  const t = [];
  for (const e in r) {
    const n = r[e];
    n !== !1 && t.push("#define " + e + " " + n);
  }
  return t.join(`
`);
}
function $H(r, t) {
  const e = {}, n = r.getProgramParameter(t, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const a = r.getActiveAttrib(t, i), o = a.name;
    let s = 1;
    a.type === r.FLOAT_MAT2 && (s = 2), a.type === r.FLOAT_MAT3 && (s = 3), a.type === r.FLOAT_MAT4 && (s = 4), e[o] = {
      type: a.type,
      location: r.getAttribLocation(t, o),
      locationSize: s
    };
  }
  return e;
}
function Tf(r) {
  return r !== "";
}
function iT(r, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function aT(r, t) {
  return r.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
const ZH = /^[ \t]*#include +<([\w\d./]+)>/gm;
function $_(r) {
  return r.replace(ZH, KH);
}
const qH = /* @__PURE__ */ new Map();
function KH(r, t) {
  let e = me[t];
  if (e === void 0) {
    const n = qH.get(t);
    if (n !== void 0)
      e = me[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n);
    else
      throw new Error("Can not resolve #include <" + t + ">");
  }
  return $_(e);
}
const jH = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function oT(r) {
  return r.replace(jH, JH);
}
function JH(r, t, e, n) {
  let i = "";
  for (let a = parseInt(t); a < parseInt(e); a++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return i;
}
function sT(r) {
  let t = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? t += `
#define HIGH_PRECISION` : r.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
function QH(r) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === cI ? t = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === MF ? t = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === wa && (t = "SHADOWMAP_TYPE_VSM"), t;
}
function t4(r) {
  let t = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case Ku:
      case ju:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case Pg:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function e4(r) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case ju:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function r4(r) {
  let t = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case fI:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case KF:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case jF:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function n4(r) {
  const t = r.envMapCubeUVHeight;
  if (t === null)
    return null;
  const e = Math.log2(t) - 2, n = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: n, maxMip: e };
}
function i4(r, t, e, n) {
  const i = r.getContext(), a = e.defines;
  let o = e.vertexShader, s = e.fragmentShader;
  const l = QH(e), u = t4(e), c = e4(e), f = r4(e), h = n4(e), d = XH(e), p = YH(a), g = i.createProgram();
  let v, m, y = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Tf).join(`
`), v.length > 0 && (v += `
`), m = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Tf).join(`
`), m.length > 0 && (m += `
`)) : (v = [
    sT(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    e.batching ? "#define USE_BATCHING" : "",
    e.instancing ? "#define USE_INSTANCING" : "",
    e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + c : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    e.mapUv ? "#define MAP_UV " + e.mapUv : "",
    e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
    e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
    e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
    e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
    e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
    e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
    e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
    e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
    e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
    e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
    e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
    e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
    e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
    e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
    e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
    e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
    e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
    e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
    e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
    e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
    e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
    e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
    //
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.skinning ? "#define USE_SKINNING" : "",
    e.morphTargets ? "#define USE_MORPHTARGETS" : "",
    e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    e.morphColors ? "#define USE_MORPHCOLORS" : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Tf).join(`
`), m = [
    sT(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    e.map ? "#define USE_MAP" : "",
    e.matcap ? "#define USE_MATCAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + u : "",
    e.envMap ? "#define " + c : "",
    e.envMap ? "#define " + f : "",
    h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
    h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
    h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoat ? "#define USE_CLEARCOAT" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.dispersion ? "#define USE_DISPERSION" : "",
    e.iridescence ? "#define USE_IRIDESCENCE" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaTest ? "#define USE_ALPHATEST" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.sheen ? "#define USE_SHEEN" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.gradientMap ? "#define USE_GRADIENTMAP" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    e.toneMapping !== Io ? "#define TONE_MAPPING" : "",
    e.toneMapping !== Io ? me.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    e.toneMapping !== Io ? WH("toneMapping", e.toneMapping) : "",
    e.dithering ? "#define DITHERING" : "",
    e.opaque ? "#define OPAQUE" : "",
    me.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    HH("linearToOutputTexel", e.outputColorSpace),
    e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
    `
`
  ].filter(Tf).join(`
`)), o = $_(o), o = iT(o, e), o = aT(o, e), s = $_(s), s = iT(s, e), s = aT(s, e), o = oT(o), s = oT(s), e.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, v = [
    d,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, m = [
    "#define varying in",
    e.glslVersion === wM ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    e.glslVersion === wM ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + m);
  const _ = y + v + o, x = y + m + s, b = rT(i, i.VERTEX_SHADER, _), S = rT(i, i.FRAGMENT_SHADER, x);
  i.attachShader(g, b), i.attachShader(g, S), e.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, e.index0AttributeName) : e.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g);
  function w(C) {
    if (r.debug.checkShaderErrors) {
      const R = i.getProgramInfoLog(g).trim(), E = i.getShaderInfoLog(b).trim(), D = i.getShaderInfoLog(S).trim();
      let I = !0, P = !0;
      if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
        if (I = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(i, g, b, S);
        else {
          const O = nT(i, b, "vertex"), N = nT(i, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + `

Material Name: ` + C.name + `
Material Type: ` + C.type + `

Program Info Log: ` + R + `
` + O + `
` + N
          );
        }
      else
        R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (E === "" || D === "") && (P = !1);
      P && (C.diagnostics = {
        runnable: I,
        programLog: R,
        vertexShader: {
          log: E,
          prefix: v
        },
        fragmentShader: {
          log: D,
          prefix: m
        }
      });
    }
    i.deleteShader(b), i.deleteShader(S), A = new Up(i, g), T = $H(i, g);
  }
  let A;
  this.getUniforms = function() {
    return A === void 0 && w(this), A;
  };
  let T;
  this.getAttributes = function() {
    return T === void 0 && w(this), T;
  };
  let M = e.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return M === !1 && (M = i.getProgramParameter(g, FH)), M;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0;
  }, this.type = e.shaderType, this.name = e.shaderName, this.id = zH++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = b, this.fragmentShader = S, this;
}
let a4 = 0;
class o4 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    const e = t.vertexShader, n = t.fragmentShader, i = this._getShaderStage(e), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(t);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const n of e)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let n = e.get(t);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), e.set(t, n)), n;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let n = e.get(t);
    return n === void 0 && (n = new s4(t), e.set(t, n)), n;
  }
}
class s4 {
  constructor(t) {
    this.id = a4++, this.code = t, this.usedTimes = 0;
  }
}
function l4(r, t, e, n, i, a, o) {
  const s = new p1(), l = new o4(), u = /* @__PURE__ */ new Set(), c = [], f = i.logarithmicDepthBuffer, h = i.vertexTextures;
  let d = i.precision;
  const p = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function g(T) {
    return u.add(T), T === 0 ? "uv" : `uv${T}`;
  }
  function v(T, M, C, R, E) {
    const D = R.fog, I = E.geometry, P = T.isMeshStandardMaterial ? R.environment : null, O = (T.isMeshStandardMaterial ? e : t).get(T.envMap || P), N = O && O.mapping === Pg ? O.image.height : null, B = p[T.type];
    T.precision !== null && (d = i.getMaxPrecision(T.precision), d !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", d, "instead."));
    const F = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color, G = F !== void 0 ? F.length : 0;
    let W = 0;
    I.morphAttributes.position !== void 0 && (W = 1), I.morphAttributes.normal !== void 0 && (W = 2), I.morphAttributes.color !== void 0 && (W = 3);
    let J, U, Y, at;
    if (B) {
      const Be = zi[B];
      J = Be.vertexShader, U = Be.fragmentShader;
    } else
      J = T.vertexShader, U = T.fragmentShader, l.update(T), Y = l.getVertexShaderID(T), at = l.getFragmentShaderID(T);
    const st = r.getRenderTarget(), ut = E.isInstancedMesh === !0, lt = E.isBatchedMesh === !0, H = !!T.map, ct = !!T.matcap, ot = !!O, Gt = !!T.aoMap, yt = !!T.lightMap, Mt = !!T.bumpMap, Rt = !!T.normalMap, Kt = !!T.displacementMap, Ae = !!T.emissiveMap, z = !!T.metalnessMap, k = !!T.roughnessMap, nt = T.anisotropy > 0, ht = T.clearcoat > 0, mt = T.dispersion > 0, xt = T.iridescence > 0, Qt = T.sheen > 0, Ft = T.transmission > 0, kt = nt && !!T.anisotropyMap, _e = ht && !!T.clearcoatMap, Tt = ht && !!T.clearcoatNormalMap, Jt = ht && !!T.clearcoatRoughnessMap, De = xt && !!T.iridescenceMap, ie = xt && !!T.iridescenceThicknessMap, Ht = Qt && !!T.sheenColorMap, xe = Qt && !!T.sheenRoughnessMap, Ee = !!T.specularMap, ir = !!T.specularColorMap, Se = !!T.specularIntensityMap, Z = Ft && !!T.transmissionMap, vt = Ft && !!T.thicknessMap, ft = !!T.gradientMap, It = !!T.alphaMap, Ut = T.alphaTest > 0, Le = !!T.alphaHash, Ze = !!T.extensions;
    let Je = Io;
    T.toneMapped && (st === null || st.isXRRenderTarget === !0) && (Je = r.toneMapping);
    const Hr = {
      shaderID: B,
      shaderType: T.type,
      shaderName: T.name,
      vertexShader: J,
      fragmentShader: U,
      defines: T.defines,
      customVertexShaderID: Y,
      customFragmentShaderID: at,
      isRawShaderMaterial: T.isRawShaderMaterial === !0,
      glslVersion: T.glslVersion,
      precision: d,
      batching: lt,
      instancing: ut,
      instancingColor: ut && E.instanceColor !== null,
      instancingMorph: ut && E.morphTexture !== null,
      supportsVertexTextures: h,
      outputColorSpace: st === null ? r.outputColorSpace : st.isXRRenderTarget === !0 ? st.texture.colorSpace : qo,
      alphaToCoverage: !!T.alphaToCoverage,
      map: H,
      matcap: ct,
      envMap: ot,
      envMapMode: ot && O.mapping,
      envMapCubeUVHeight: N,
      aoMap: Gt,
      lightMap: yt,
      bumpMap: Mt,
      normalMap: Rt,
      displacementMap: h && Kt,
      emissiveMap: Ae,
      normalMapObjectSpace: Rt && T.normalMapType === yz,
      normalMapTangentSpace: Rt && T.normalMapType === mz,
      metalnessMap: z,
      roughnessMap: k,
      anisotropy: nt,
      anisotropyMap: kt,
      clearcoat: ht,
      clearcoatMap: _e,
      clearcoatNormalMap: Tt,
      clearcoatRoughnessMap: Jt,
      dispersion: mt,
      iridescence: xt,
      iridescenceMap: De,
      iridescenceThicknessMap: ie,
      sheen: Qt,
      sheenColorMap: Ht,
      sheenRoughnessMap: xe,
      specularMap: Ee,
      specularColorMap: ir,
      specularIntensityMap: Se,
      transmission: Ft,
      transmissionMap: Z,
      thicknessMap: vt,
      gradientMap: ft,
      opaque: T.transparent === !1 && T.blending === Uu && T.alphaToCoverage === !1,
      alphaMap: It,
      alphaTest: Ut,
      alphaHash: Le,
      combine: T.combine,
      //
      mapUv: H && g(T.map.channel),
      aoMapUv: Gt && g(T.aoMap.channel),
      lightMapUv: yt && g(T.lightMap.channel),
      bumpMapUv: Mt && g(T.bumpMap.channel),
      normalMapUv: Rt && g(T.normalMap.channel),
      displacementMapUv: Kt && g(T.displacementMap.channel),
      emissiveMapUv: Ae && g(T.emissiveMap.channel),
      metalnessMapUv: z && g(T.metalnessMap.channel),
      roughnessMapUv: k && g(T.roughnessMap.channel),
      anisotropyMapUv: kt && g(T.anisotropyMap.channel),
      clearcoatMapUv: _e && g(T.clearcoatMap.channel),
      clearcoatNormalMapUv: Tt && g(T.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Jt && g(T.clearcoatRoughnessMap.channel),
      iridescenceMapUv: De && g(T.iridescenceMap.channel),
      iridescenceThicknessMapUv: ie && g(T.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ht && g(T.sheenColorMap.channel),
      sheenRoughnessMapUv: xe && g(T.sheenRoughnessMap.channel),
      specularMapUv: Ee && g(T.specularMap.channel),
      specularColorMapUv: ir && g(T.specularColorMap.channel),
      specularIntensityMapUv: Se && g(T.specularIntensityMap.channel),
      transmissionMapUv: Z && g(T.transmissionMap.channel),
      thicknessMapUv: vt && g(T.thicknessMap.channel),
      alphaMapUv: It && g(T.alphaMap.channel),
      //
      vertexTangents: !!I.attributes.tangent && (Rt || nt),
      vertexColors: T.vertexColors,
      vertexAlphas: T.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4,
      pointsUvs: E.isPoints === !0 && !!I.attributes.uv && (H || It),
      fog: !!D,
      useFog: T.fog === !0,
      fogExp2: !!D && D.isFogExp2,
      flatShading: T.flatShading === !0,
      sizeAttenuation: T.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      skinning: E.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: G,
      morphTextureStride: W,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: T.dithering,
      shadowMapEnabled: r.shadowMap.enabled && C.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: Je,
      useLegacyLights: r._useLegacyLights,
      decodeVideoTexture: H && T.map.isVideoTexture === !0 && Fe.getTransfer(T.map.colorSpace) === qe,
      premultipliedAlpha: T.premultipliedAlpha,
      doubleSided: T.side === Aa,
      flipSided: T.side === bn,
      useDepthPacking: T.depthPacking >= 0,
      depthPacking: T.depthPacking || 0,
      index0AttributeName: T.index0AttributeName,
      extensionClipCullDistance: Ze && T.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: Ze && T.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: T.customProgramCacheKey()
    };
    return Hr.vertexUv1s = u.has(1), Hr.vertexUv2s = u.has(2), Hr.vertexUv3s = u.has(3), u.clear(), Hr;
  }
  function m(T) {
    const M = [];
    if (T.shaderID ? M.push(T.shaderID) : (M.push(T.customVertexShaderID), M.push(T.customFragmentShaderID)), T.defines !== void 0)
      for (const C in T.defines)
        M.push(C), M.push(T.defines[C]);
    return T.isRawShaderMaterial === !1 && (y(M, T), _(M, T), M.push(r.outputColorSpace)), M.push(T.customProgramCacheKey), M.join();
  }
  function y(T, M) {
    T.push(M.precision), T.push(M.outputColorSpace), T.push(M.envMapMode), T.push(M.envMapCubeUVHeight), T.push(M.mapUv), T.push(M.alphaMapUv), T.push(M.lightMapUv), T.push(M.aoMapUv), T.push(M.bumpMapUv), T.push(M.normalMapUv), T.push(M.displacementMapUv), T.push(M.emissiveMapUv), T.push(M.metalnessMapUv), T.push(M.roughnessMapUv), T.push(M.anisotropyMapUv), T.push(M.clearcoatMapUv), T.push(M.clearcoatNormalMapUv), T.push(M.clearcoatRoughnessMapUv), T.push(M.iridescenceMapUv), T.push(M.iridescenceThicknessMapUv), T.push(M.sheenColorMapUv), T.push(M.sheenRoughnessMapUv), T.push(M.specularMapUv), T.push(M.specularColorMapUv), T.push(M.specularIntensityMapUv), T.push(M.transmissionMapUv), T.push(M.thicknessMapUv), T.push(M.combine), T.push(M.fogExp2), T.push(M.sizeAttenuation), T.push(M.morphTargetsCount), T.push(M.morphAttributeCount), T.push(M.numDirLights), T.push(M.numPointLights), T.push(M.numSpotLights), T.push(M.numSpotLightMaps), T.push(M.numHemiLights), T.push(M.numRectAreaLights), T.push(M.numDirLightShadows), T.push(M.numPointLightShadows), T.push(M.numSpotLightShadows), T.push(M.numSpotLightShadowsWithMaps), T.push(M.numLightProbes), T.push(M.shadowMapType), T.push(M.toneMapping), T.push(M.numClippingPlanes), T.push(M.numClipIntersection), T.push(M.depthPacking);
  }
  function _(T, M) {
    s.disableAll(), M.supportsVertexTextures && s.enable(0), M.instancing && s.enable(1), M.instancingColor && s.enable(2), M.instancingMorph && s.enable(3), M.matcap && s.enable(4), M.envMap && s.enable(5), M.normalMapObjectSpace && s.enable(6), M.normalMapTangentSpace && s.enable(7), M.clearcoat && s.enable(8), M.iridescence && s.enable(9), M.alphaTest && s.enable(10), M.vertexColors && s.enable(11), M.vertexAlphas && s.enable(12), M.vertexUv1s && s.enable(13), M.vertexUv2s && s.enable(14), M.vertexUv3s && s.enable(15), M.vertexTangents && s.enable(16), M.anisotropy && s.enable(17), M.alphaHash && s.enable(18), M.batching && s.enable(19), M.dispersion && s.enable(20), T.push(s.mask), s.disableAll(), M.fog && s.enable(0), M.useFog && s.enable(1), M.flatShading && s.enable(2), M.logarithmicDepthBuffer && s.enable(3), M.skinning && s.enable(4), M.morphTargets && s.enable(5), M.morphNormals && s.enable(6), M.morphColors && s.enable(7), M.premultipliedAlpha && s.enable(8), M.shadowMapEnabled && s.enable(9), M.useLegacyLights && s.enable(10), M.doubleSided && s.enable(11), M.flipSided && s.enable(12), M.useDepthPacking && s.enable(13), M.dithering && s.enable(14), M.transmission && s.enable(15), M.sheen && s.enable(16), M.opaque && s.enable(17), M.pointsUvs && s.enable(18), M.decodeVideoTexture && s.enable(19), M.alphaToCoverage && s.enable(20), T.push(s.mask);
  }
  function x(T) {
    const M = p[T.type];
    let C;
    if (M) {
      const R = zi[M];
      C = Yz.clone(R.uniforms);
    } else
      C = T.uniforms;
    return C;
  }
  function b(T, M) {
    let C;
    for (let R = 0, E = c.length; R < E; R++) {
      const D = c[R];
      if (D.cacheKey === M) {
        C = D, ++C.usedTimes;
        break;
      }
    }
    return C === void 0 && (C = new i4(r, M, T, a), c.push(C)), C;
  }
  function S(T) {
    if (--T.usedTimes === 0) {
      const M = c.indexOf(T);
      c[M] = c[c.length - 1], c.pop(), T.destroy();
    }
  }
  function w(T) {
    l.remove(T);
  }
  function A() {
    l.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: m,
    getUniforms: x,
    acquireProgram: b,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: A
  };
}
function u4() {
  let r = /* @__PURE__ */ new WeakMap();
  function t(a) {
    let o = r.get(a);
    return o === void 0 && (o = {}, r.set(a, o)), o;
  }
  function e(a) {
    r.delete(a);
  }
  function n(a, o, s) {
    r.get(a)[o] = s;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: e,
    update: n,
    dispose: i
  };
}
function c4(r, t) {
  return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.material.id !== t.material.id ? r.material.id - t.material.id : r.z !== t.z ? r.z - t.z : r.id - t.id;
}
function lT(r, t) {
  return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.z !== t.z ? t.z - r.z : r.id - t.id;
}
function uT() {
  const r = [];
  let t = 0;
  const e = [], n = [], i = [];
  function a() {
    t = 0, e.length = 0, n.length = 0, i.length = 0;
  }
  function o(f, h, d, p, g, v) {
    let m = r[t];
    return m === void 0 ? (m = {
      id: f.id,
      object: f,
      geometry: h,
      material: d,
      groupOrder: p,
      renderOrder: f.renderOrder,
      z: g,
      group: v
    }, r[t] = m) : (m.id = f.id, m.object = f, m.geometry = h, m.material = d, m.groupOrder = p, m.renderOrder = f.renderOrder, m.z = g, m.group = v), t++, m;
  }
  function s(f, h, d, p, g, v) {
    const m = o(f, h, d, p, g, v);
    d.transmission > 0 ? n.push(m) : d.transparent === !0 ? i.push(m) : e.push(m);
  }
  function l(f, h, d, p, g, v) {
    const m = o(f, h, d, p, g, v);
    d.transmission > 0 ? n.unshift(m) : d.transparent === !0 ? i.unshift(m) : e.unshift(m);
  }
  function u(f, h) {
    e.length > 1 && e.sort(f || c4), n.length > 1 && n.sort(h || lT), i.length > 1 && i.sort(h || lT);
  }
  function c() {
    for (let f = t, h = r.length; f < h; f++) {
      const d = r[f];
      if (d.id === null)
        break;
      d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null;
    }
  }
  return {
    opaque: e,
    transmissive: n,
    transparent: i,
    init: a,
    push: s,
    unshift: l,
    finish: c,
    sort: u
  };
}
function f4() {
  let r = /* @__PURE__ */ new WeakMap();
  function t(n, i) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new uT(), r.set(n, [o])) : i >= a.length ? (o = new uT(), a.push(o)) : o = a[i], o;
  }
  function e() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: e
  };
}
function h4() {
  const r = {};
  return {
    get: function(t) {
      if (r[t.id] !== void 0)
        return r[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            direction: new K(),
            color: new le()
          };
          break;
        case "SpotLight":
          e = {
            position: new K(),
            direction: new K(),
            color: new le(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          e = {
            position: new K(),
            color: new le(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          e = {
            direction: new K(),
            skyColor: new le(),
            groundColor: new le()
          };
          break;
        case "RectAreaLight":
          e = {
            color: new le(),
            position: new K(),
            halfWidth: new K(),
            halfHeight: new K()
          };
          break;
      }
      return r[t.id] = e, e;
    }
  };
}
function d4() {
  const r = {};
  return {
    get: function(t) {
      if (r[t.id] !== void 0)
        return r[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "SpotLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "PointLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[t.id] = e, e;
    }
  };
}
let p4 = 0;
function v4(r, t) {
  return (t.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (r.map ? 1 : 0);
}
function g4(r) {
  const t = new h4(), e = d4(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++)
    n.probe.push(new K());
  const i = new K(), a = new $e(), o = new $e();
  function s(u, c) {
    let f = 0, h = 0, d = 0;
    for (let C = 0; C < 9; C++)
      n.probe[C].set(0, 0, 0);
    let p = 0, g = 0, v = 0, m = 0, y = 0, _ = 0, x = 0, b = 0, S = 0, w = 0, A = 0;
    u.sort(v4);
    const T = c === !0 ? Math.PI : 1;
    for (let C = 0, R = u.length; C < R; C++) {
      const E = u[C], D = E.color, I = E.intensity, P = E.distance, O = E.shadow && E.shadow.map ? E.shadow.map.texture : null;
      if (E.isAmbientLight)
        f += D.r * I * T, h += D.g * I * T, d += D.b * I * T;
      else if (E.isLightProbe) {
        for (let N = 0; N < 9; N++)
          n.probe[N].addScaledVector(E.sh.coefficients[N], I);
        A++;
      } else if (E.isDirectionalLight) {
        const N = t.get(E);
        if (N.color.copy(E.color).multiplyScalar(E.intensity * T), E.castShadow) {
          const B = E.shadow, F = e.get(E);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, n.directionalShadow[p] = F, n.directionalShadowMap[p] = O, n.directionalShadowMatrix[p] = E.shadow.matrix, _++;
        }
        n.directional[p] = N, p++;
      } else if (E.isSpotLight) {
        const N = t.get(E);
        N.position.setFromMatrixPosition(E.matrixWorld), N.color.copy(D).multiplyScalar(I * T), N.distance = P, N.coneCos = Math.cos(E.angle), N.penumbraCos = Math.cos(E.angle * (1 - E.penumbra)), N.decay = E.decay, n.spot[v] = N;
        const B = E.shadow;
        if (E.map && (n.spotLightMap[S] = E.map, S++, B.updateMatrices(E), E.castShadow && w++), n.spotLightMatrix[v] = B.matrix, E.castShadow) {
          const F = e.get(E);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, n.spotShadow[v] = F, n.spotShadowMap[v] = O, b++;
        }
        v++;
      } else if (E.isRectAreaLight) {
        const N = t.get(E);
        N.color.copy(D).multiplyScalar(I), N.halfWidth.set(E.width * 0.5, 0, 0), N.halfHeight.set(0, E.height * 0.5, 0), n.rectArea[m] = N, m++;
      } else if (E.isPointLight) {
        const N = t.get(E);
        if (N.color.copy(E.color).multiplyScalar(E.intensity * T), N.distance = E.distance, N.decay = E.decay, E.castShadow) {
          const B = E.shadow, F = e.get(E);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, F.shadowCameraNear = B.camera.near, F.shadowCameraFar = B.camera.far, n.pointShadow[g] = F, n.pointShadowMap[g] = O, n.pointShadowMatrix[g] = E.shadow.matrix, x++;
        }
        n.point[g] = N, g++;
      } else if (E.isHemisphereLight) {
        const N = t.get(E);
        N.skyColor.copy(E.color).multiplyScalar(I * T), N.groundColor.copy(E.groundColor).multiplyScalar(I * T), n.hemi[y] = N, y++;
      }
    }
    m > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Et.LTC_FLOAT_1, n.rectAreaLTC2 = Et.LTC_FLOAT_2) : (n.rectAreaLTC1 = Et.LTC_HALF_1, n.rectAreaLTC2 = Et.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = h, n.ambient[2] = d;
    const M = n.hash;
    (M.directionalLength !== p || M.pointLength !== g || M.spotLength !== v || M.rectAreaLength !== m || M.hemiLength !== y || M.numDirectionalShadows !== _ || M.numPointShadows !== x || M.numSpotShadows !== b || M.numSpotMaps !== S || M.numLightProbes !== A) && (n.directional.length = p, n.spot.length = v, n.rectArea.length = m, n.point.length = g, n.hemi.length = y, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + S - w, n.spotLightMap.length = S, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = A, M.directionalLength = p, M.pointLength = g, M.spotLength = v, M.rectAreaLength = m, M.hemiLength = y, M.numDirectionalShadows = _, M.numPointShadows = x, M.numSpotShadows = b, M.numSpotMaps = S, M.numLightProbes = A, n.version = p4++);
  }
  function l(u, c) {
    let f = 0, h = 0, d = 0, p = 0, g = 0;
    const v = c.matrixWorldInverse;
    for (let m = 0, y = u.length; m < y; m++) {
      const _ = u[m];
      if (_.isDirectionalLight) {
        const x = n.directional[f];
        x.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(v), f++;
      } else if (_.isSpotLight) {
        const x = n.spot[d];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), x.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(v), d++;
      } else if (_.isRectAreaLight) {
        const x = n.rectArea[p];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), o.identity(), a.copy(_.matrixWorld), a.premultiply(v), o.extractRotation(a), x.halfWidth.set(_.width * 0.5, 0, 0), x.halfHeight.set(0, _.height * 0.5, 0), x.halfWidth.applyMatrix4(o), x.halfHeight.applyMatrix4(o), p++;
      } else if (_.isPointLight) {
        const x = n.point[h];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), h++;
      } else if (_.isHemisphereLight) {
        const x = n.hemi[g];
        x.direction.setFromMatrixPosition(_.matrixWorld), x.direction.transformDirection(v), g++;
      }
    }
  }
  return {
    setup: s,
    setupView: l,
    state: n
  };
}
function cT(r) {
  const t = new g4(r), e = [], n = [];
  function i(c) {
    u.camera = c, e.length = 0, n.length = 0;
  }
  function a(c) {
    e.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function s(c) {
    t.setup(e, c);
  }
  function l(c) {
    t.setupView(e, c);
  }
  const u = {
    lightsArray: e,
    shadowsArray: n,
    camera: null,
    lights: t,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: u,
    setupLights: s,
    setupLightsView: l,
    pushLight: a,
    pushShadow: o
  };
}
function m4(r) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(i, a = 0) {
    const o = t.get(i);
    let s;
    return o === void 0 ? (s = new cT(r), t.set(i, [s])) : a >= o.length ? (s = new cT(r), o.push(s)) : s = o[a], s;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
class y4 extends Ph {
  constructor(t) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = vz, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
}
class _4 extends Ph {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
}
const x4 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, S4 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function b4(r, t, e) {
  let n = new g1();
  const i = new Ce(), a = new Ce(), o = new Nr(), s = new y4({ depthPacking: gz }), l = new _4(), u = {}, c = e.maxTextureSize, f = { [Fo]: bn, [bn]: Fo, [Aa]: Aa }, h = new za({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ce() },
      radius: { value: 4 }
    },
    vertexShader: x4,
    fragmentShader: S4
  }), d = h.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const p = new ca();
  p.setAttribute(
    "position",
    new ni(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const g = new Pn(p, h), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = cI;
  let m = this.type;
  this.render = function(S, w, A) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || S.length === 0)
      return;
    const T = r.getRenderTarget(), M = r.getActiveCubeFace(), C = r.getActiveMipmapLevel(), R = r.state;
    R.setBlending(Ro), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
    const E = m !== wa && this.type === wa, D = m === wa && this.type !== wa;
    for (let I = 0, P = S.length; I < P; I++) {
      const O = S[I], N = O.shadow;
      if (N === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (N.autoUpdate === !1 && N.needsUpdate === !1)
        continue;
      i.copy(N.mapSize);
      const B = N.getFrameExtents();
      if (i.multiply(B), a.copy(N.mapSize), (i.x > c || i.y > c) && (i.x > c && (a.x = Math.floor(c / B.x), i.x = a.x * B.x, N.mapSize.x = a.x), i.y > c && (a.y = Math.floor(c / B.y), i.y = a.y * B.y, N.mapSize.y = a.y)), N.map === null || E === !0 || D === !0) {
        const G = this.type !== wa ? { minFilter: Sn, magFilter: Sn } : {};
        N.map !== null && N.map.dispose(), N.map = new fl(i.x, i.y, G), N.map.texture.name = O.name + ".shadowMap", N.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(N.map), r.clear();
      const F = N.getViewportCount();
      for (let G = 0; G < F; G++) {
        const W = N.getViewport(G);
        o.set(
          a.x * W.x,
          a.y * W.y,
          a.x * W.z,
          a.y * W.w
        ), R.viewport(o), N.updateMatrices(O, G), n = N.getFrustum(), x(w, A, N.camera, O, this.type);
      }
      N.isPointLightShadow !== !0 && this.type === wa && y(N, A), N.needsUpdate = !1;
    }
    m = this.type, v.needsUpdate = !1, r.setRenderTarget(T, M, C);
  };
  function y(S, w) {
    const A = t.update(g);
    h.defines.VSM_SAMPLES !== S.blurSamples && (h.defines.VSM_SAMPLES = S.blurSamples, d.defines.VSM_SAMPLES = S.blurSamples, h.needsUpdate = !0, d.needsUpdate = !0), S.mapPass === null && (S.mapPass = new fl(i.x, i.y)), h.uniforms.shadow_pass.value = S.map.texture, h.uniforms.resolution.value = S.mapSize, h.uniforms.radius.value = S.radius, r.setRenderTarget(S.mapPass), r.clear(), r.renderBufferDirect(w, null, A, h, g, null), d.uniforms.shadow_pass.value = S.mapPass.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, r.setRenderTarget(S.map), r.clear(), r.renderBufferDirect(w, null, A, d, g, null);
  }
  function _(S, w, A, T) {
    let M = null;
    const C = A.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (C !== void 0)
      M = C;
    else if (M = A.isPointLight === !0 ? l : s, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const R = M.uuid, E = w.uuid;
      let D = u[R];
      D === void 0 && (D = {}, u[R] = D);
      let I = D[E];
      I === void 0 && (I = M.clone(), D[E] = I, w.addEventListener("dispose", b)), M = I;
    }
    if (M.visible = w.visible, M.wireframe = w.wireframe, T === wa ? M.side = w.shadowSide !== null ? w.shadowSide : w.side : M.side = w.shadowSide !== null ? w.shadowSide : f[w.side], M.alphaMap = w.alphaMap, M.alphaTest = w.alphaTest, M.map = w.map, M.clipShadows = w.clipShadows, M.clippingPlanes = w.clippingPlanes, M.clipIntersection = w.clipIntersection, M.displacementMap = w.displacementMap, M.displacementScale = w.displacementScale, M.displacementBias = w.displacementBias, M.wireframeLinewidth = w.wireframeLinewidth, M.linewidth = w.linewidth, A.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
      const R = r.properties.get(M);
      R.light = A;
    }
    return M;
  }
  function x(S, w, A, T, M) {
    if (S.visible === !1)
      return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && M === wa) && (!S.frustumCulled || n.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, S.matrixWorld);
      const E = t.update(S), D = S.material;
      if (Array.isArray(D)) {
        const I = E.groups;
        for (let P = 0, O = I.length; P < O; P++) {
          const N = I[P], B = D[N.materialIndex];
          if (B && B.visible) {
            const F = _(S, B, T, M);
            S.onBeforeShadow(r, S, w, A, E, F, N), r.renderBufferDirect(A, null, E, F, S, N), S.onAfterShadow(r, S, w, A, E, F, N);
          }
        }
      } else if (D.visible) {
        const I = _(S, D, T, M);
        S.onBeforeShadow(r, S, w, A, E, I, null), r.renderBufferDirect(A, null, E, I, S, null), S.onAfterShadow(r, S, w, A, E, I, null);
      }
    }
    const R = S.children;
    for (let E = 0, D = R.length; E < D; E++)
      x(R[E], w, A, T, M);
  }
  function b(S) {
    S.target.removeEventListener("dispose", b);
    for (const A in u) {
      const T = u[A], M = S.target.uuid;
      M in T && (T[M].dispose(), delete T[M]);
    }
  }
}
function w4(r) {
  function t() {
    let Z = !1;
    const vt = new Nr();
    let ft = null;
    const It = new Nr(0, 0, 0, 0);
    return {
      setMask: function(Ut) {
        ft !== Ut && !Z && (r.colorMask(Ut, Ut, Ut, Ut), ft = Ut);
      },
      setLocked: function(Ut) {
        Z = Ut;
      },
      setClear: function(Ut, Le, Ze, Je, Hr) {
        Hr === !0 && (Ut *= Je, Le *= Je, Ze *= Je), vt.set(Ut, Le, Ze, Je), It.equals(vt) === !1 && (r.clearColor(Ut, Le, Ze, Je), It.copy(vt));
      },
      reset: function() {
        Z = !1, ft = null, It.set(-1, 0, 0, 0);
      }
    };
  }
  function e() {
    let Z = !1, vt = null, ft = null, It = null;
    return {
      setTest: function(Ut) {
        Ut ? at(r.DEPTH_TEST) : st(r.DEPTH_TEST);
      },
      setMask: function(Ut) {
        vt !== Ut && !Z && (r.depthMask(Ut), vt = Ut);
      },
      setFunc: function(Ut) {
        if (ft !== Ut) {
          switch (Ut) {
            case HF:
              r.depthFunc(r.NEVER);
              break;
            case WF:
              r.depthFunc(r.ALWAYS);
              break;
            case XF:
              r.depthFunc(r.LESS);
              break;
            case cv:
              r.depthFunc(r.LEQUAL);
              break;
            case YF:
              r.depthFunc(r.EQUAL);
              break;
            case $F:
              r.depthFunc(r.GEQUAL);
              break;
            case ZF:
              r.depthFunc(r.GREATER);
              break;
            case qF:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          ft = Ut;
        }
      },
      setLocked: function(Ut) {
        Z = Ut;
      },
      setClear: function(Ut) {
        It !== Ut && (r.clearDepth(Ut), It = Ut);
      },
      reset: function() {
        Z = !1, vt = null, ft = null, It = null;
      }
    };
  }
  function n() {
    let Z = !1, vt = null, ft = null, It = null, Ut = null, Le = null, Ze = null, Je = null, Hr = null;
    return {
      setTest: function(Be) {
        Z || (Be ? at(r.STENCIL_TEST) : st(r.STENCIL_TEST));
      },
      setMask: function(Be) {
        vt !== Be && !Z && (r.stencilMask(Be), vt = Be);
      },
      setFunc: function(Be, Ci, Qr) {
        (ft !== Be || It !== Ci || Ut !== Qr) && (r.stencilFunc(Be, Ci, Qr), ft = Be, It = Ci, Ut = Qr);
      },
      setOp: function(Be, Ci, Qr) {
        (Le !== Be || Ze !== Ci || Je !== Qr) && (r.stencilOp(Be, Ci, Qr), Le = Be, Ze = Ci, Je = Qr);
      },
      setLocked: function(Be) {
        Z = Be;
      },
      setClear: function(Be) {
        Hr !== Be && (r.clearStencil(Be), Hr = Be);
      },
      reset: function() {
        Z = !1, vt = null, ft = null, It = null, Ut = null, Le = null, Ze = null, Je = null, Hr = null;
      }
    };
  }
  const i = new t(), a = new e(), o = new n(), s = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let u = {}, c = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, p = !1, g = null, v = null, m = null, y = null, _ = null, x = null, b = null, S = new le(0, 0, 0), w = 0, A = !1, T = null, M = null, C = null, R = null, E = null;
  const D = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let I = !1, P = 0;
  const O = r.getParameter(r.VERSION);
  O.indexOf("WebGL") !== -1 ? (P = parseFloat(/^WebGL (\d)/.exec(O)[1]), I = P >= 1) : O.indexOf("OpenGL ES") !== -1 && (P = parseFloat(/^OpenGL ES (\d)/.exec(O)[1]), I = P >= 2);
  let N = null, B = {};
  const F = r.getParameter(r.SCISSOR_BOX), G = r.getParameter(r.VIEWPORT), W = new Nr().fromArray(F), J = new Nr().fromArray(G);
  function U(Z, vt, ft, It) {
    const Ut = new Uint8Array(4), Le = r.createTexture();
    r.bindTexture(Z, Le), r.texParameteri(Z, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(Z, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let Ze = 0; Ze < ft; Ze++)
      Z === r.TEXTURE_3D || Z === r.TEXTURE_2D_ARRAY ? r.texImage3D(vt, 0, r.RGBA, 1, 1, It, 0, r.RGBA, r.UNSIGNED_BYTE, Ut) : r.texImage2D(vt + Ze, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ut);
    return Le;
  }
  const Y = {};
  Y[r.TEXTURE_2D] = U(r.TEXTURE_2D, r.TEXTURE_2D, 1), Y[r.TEXTURE_CUBE_MAP] = U(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Y[r.TEXTURE_2D_ARRAY] = U(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), Y[r.TEXTURE_3D] = U(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), at(r.DEPTH_TEST), a.setFunc(cv), Mt(!1), Rt(Xw), at(r.CULL_FACE), Gt(Ro);
  function at(Z) {
    u[Z] !== !0 && (r.enable(Z), u[Z] = !0);
  }
  function st(Z) {
    u[Z] !== !1 && (r.disable(Z), u[Z] = !1);
  }
  function ut(Z, vt) {
    return c[Z] !== vt ? (r.bindFramebuffer(Z, vt), c[Z] = vt, Z === r.DRAW_FRAMEBUFFER && (c[r.FRAMEBUFFER] = vt), Z === r.FRAMEBUFFER && (c[r.DRAW_FRAMEBUFFER] = vt), !0) : !1;
  }
  function lt(Z, vt) {
    let ft = h, It = !1;
    if (Z) {
      ft = f.get(vt), ft === void 0 && (ft = [], f.set(vt, ft));
      const Ut = Z.textures;
      if (ft.length !== Ut.length || ft[0] !== r.COLOR_ATTACHMENT0) {
        for (let Le = 0, Ze = Ut.length; Le < Ze; Le++)
          ft[Le] = r.COLOR_ATTACHMENT0 + Le;
        ft.length = Ut.length, It = !0;
      }
    } else
      ft[0] !== r.BACK && (ft[0] = r.BACK, It = !0);
    It && r.drawBuffers(ft);
  }
  function H(Z) {
    return d !== Z ? (r.useProgram(Z), d = Z, !0) : !1;
  }
  const ct = {
    [Us]: r.FUNC_ADD,
    [AF]: r.FUNC_SUBTRACT,
    [EF]: r.FUNC_REVERSE_SUBTRACT
  };
  ct[CF] = r.MIN, ct[DF] = r.MAX;
  const ot = {
    [LF]: r.ZERO,
    [RF]: r.ONE,
    [IF]: r.SRC_COLOR,
    [z_]: r.SRC_ALPHA,
    [VF]: r.SRC_ALPHA_SATURATE,
    [kF]: r.DST_COLOR,
    [NF]: r.DST_ALPHA,
    [PF]: r.ONE_MINUS_SRC_COLOR,
    [U_]: r.ONE_MINUS_SRC_ALPHA,
    [BF]: r.ONE_MINUS_DST_COLOR,
    [OF]: r.ONE_MINUS_DST_ALPHA,
    [FF]: r.CONSTANT_COLOR,
    [zF]: r.ONE_MINUS_CONSTANT_COLOR,
    [UF]: r.CONSTANT_ALPHA,
    [GF]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Gt(Z, vt, ft, It, Ut, Le, Ze, Je, Hr, Be) {
    if (Z === Ro) {
      p === !0 && (st(r.BLEND), p = !1);
      return;
    }
    if (p === !1 && (at(r.BLEND), p = !0), Z !== TF) {
      if (Z !== g || Be !== A) {
        if ((v !== Us || _ !== Us) && (r.blendEquation(r.FUNC_ADD), v = Us, _ = Us), Be)
          switch (Z) {
            case Uu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Yw:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case $w:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Zw:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Z);
              break;
          }
        else
          switch (Z) {
            case Uu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Yw:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case $w:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Zw:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Z);
              break;
          }
        m = null, y = null, x = null, b = null, S.set(0, 0, 0), w = 0, g = Z, A = Be;
      }
      return;
    }
    Ut = Ut || vt, Le = Le || ft, Ze = Ze || It, (vt !== v || Ut !== _) && (r.blendEquationSeparate(ct[vt], ct[Ut]), v = vt, _ = Ut), (ft !== m || It !== y || Le !== x || Ze !== b) && (r.blendFuncSeparate(ot[ft], ot[It], ot[Le], ot[Ze]), m = ft, y = It, x = Le, b = Ze), (Je.equals(S) === !1 || Hr !== w) && (r.blendColor(Je.r, Je.g, Je.b, Hr), S.copy(Je), w = Hr), g = Z, A = !1;
  }
  function yt(Z, vt) {
    Z.side === Aa ? st(r.CULL_FACE) : at(r.CULL_FACE);
    let ft = Z.side === bn;
    vt && (ft = !ft), Mt(ft), Z.blending === Uu && Z.transparent === !1 ? Gt(Ro) : Gt(Z.blending, Z.blendEquation, Z.blendSrc, Z.blendDst, Z.blendEquationAlpha, Z.blendSrcAlpha, Z.blendDstAlpha, Z.blendColor, Z.blendAlpha, Z.premultipliedAlpha), a.setFunc(Z.depthFunc), a.setTest(Z.depthTest), a.setMask(Z.depthWrite), i.setMask(Z.colorWrite);
    const It = Z.stencilWrite;
    o.setTest(It), It && (o.setMask(Z.stencilWriteMask), o.setFunc(Z.stencilFunc, Z.stencilRef, Z.stencilFuncMask), o.setOp(Z.stencilFail, Z.stencilZFail, Z.stencilZPass)), Ae(Z.polygonOffset, Z.polygonOffsetFactor, Z.polygonOffsetUnits), Z.alphaToCoverage === !0 ? at(r.SAMPLE_ALPHA_TO_COVERAGE) : st(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Mt(Z) {
    T !== Z && (Z ? r.frontFace(r.CW) : r.frontFace(r.CCW), T = Z);
  }
  function Rt(Z) {
    Z !== bF ? (at(r.CULL_FACE), Z !== M && (Z === Xw ? r.cullFace(r.BACK) : Z === wF ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : st(r.CULL_FACE), M = Z;
  }
  function Kt(Z) {
    Z !== C && (I && r.lineWidth(Z), C = Z);
  }
  function Ae(Z, vt, ft) {
    Z ? (at(r.POLYGON_OFFSET_FILL), (R !== vt || E !== ft) && (r.polygonOffset(vt, ft), R = vt, E = ft)) : st(r.POLYGON_OFFSET_FILL);
  }
  function z(Z) {
    Z ? at(r.SCISSOR_TEST) : st(r.SCISSOR_TEST);
  }
  function k(Z) {
    Z === void 0 && (Z = r.TEXTURE0 + D - 1), N !== Z && (r.activeTexture(Z), N = Z);
  }
  function nt(Z, vt, ft) {
    ft === void 0 && (N === null ? ft = r.TEXTURE0 + D - 1 : ft = N);
    let It = B[ft];
    It === void 0 && (It = { type: void 0, texture: void 0 }, B[ft] = It), (It.type !== Z || It.texture !== vt) && (N !== ft && (r.activeTexture(ft), N = ft), r.bindTexture(Z, vt || Y[Z]), It.type = Z, It.texture = vt);
  }
  function ht() {
    const Z = B[N];
    Z !== void 0 && Z.type !== void 0 && (r.bindTexture(Z.type, null), Z.type = void 0, Z.texture = void 0);
  }
  function mt() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function xt() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Qt() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Ft() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function kt() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function _e() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Tt() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Jt() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function De() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function ie() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Ht(Z) {
    W.equals(Z) === !1 && (r.scissor(Z.x, Z.y, Z.z, Z.w), W.copy(Z));
  }
  function xe(Z) {
    J.equals(Z) === !1 && (r.viewport(Z.x, Z.y, Z.z, Z.w), J.copy(Z));
  }
  function Ee(Z, vt) {
    let ft = l.get(vt);
    ft === void 0 && (ft = /* @__PURE__ */ new WeakMap(), l.set(vt, ft));
    let It = ft.get(Z);
    It === void 0 && (It = r.getUniformBlockIndex(vt, Z.name), ft.set(Z, It));
  }
  function ir(Z, vt) {
    const It = l.get(vt).get(Z);
    s.get(vt) !== It && (r.uniformBlockBinding(vt, It, Z.__bindingPointIndex), s.set(vt, It));
  }
  function Se() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), u = {}, N = null, B = {}, c = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, p = !1, g = null, v = null, m = null, y = null, _ = null, x = null, b = null, S = new le(0, 0, 0), w = 0, A = !1, T = null, M = null, C = null, R = null, E = null, W.set(0, 0, r.canvas.width, r.canvas.height), J.set(0, 0, r.canvas.width, r.canvas.height), i.reset(), a.reset(), o.reset();
  }
  return {
    buffers: {
      color: i,
      depth: a,
      stencil: o
    },
    enable: at,
    disable: st,
    bindFramebuffer: ut,
    drawBuffers: lt,
    useProgram: H,
    setBlending: Gt,
    setMaterial: yt,
    setFlipSided: Mt,
    setCullFace: Rt,
    setLineWidth: Kt,
    setPolygonOffset: Ae,
    setScissorTest: z,
    activeTexture: k,
    bindTexture: nt,
    unbindTexture: ht,
    compressedTexImage2D: mt,
    compressedTexImage3D: xt,
    texImage2D: De,
    texImage3D: ie,
    updateUBOMapping: Ee,
    uniformBlockBinding: ir,
    texStorage2D: Tt,
    texStorage3D: Jt,
    texSubImage2D: Qt,
    texSubImage3D: Ft,
    compressedTexSubImage2D: kt,
    compressedTexSubImage3D: _e,
    scissor: Ht,
    viewport: xe,
    reset: Se
  };
}
function M4(r, t, e, n, i, a, o) {
  const s = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new Ce(), c = /* @__PURE__ */ new WeakMap();
  let f;
  const h = /* @__PURE__ */ new WeakMap();
  let d = !1;
  try {
    d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function p(z, k) {
    return d ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(z, k)
    ) : vv("canvas");
  }
  function g(z, k, nt) {
    let ht = 1;
    const mt = Ae(z);
    if ((mt.width > nt || mt.height > nt) && (ht = nt / Math.max(mt.width, mt.height)), ht < 1)
      if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap || typeof VideoFrame < "u" && z instanceof VideoFrame) {
        const xt = Math.floor(ht * mt.width), Qt = Math.floor(ht * mt.height);
        f === void 0 && (f = p(xt, Qt));
        const Ft = k ? p(xt, Qt) : f;
        return Ft.width = xt, Ft.height = Qt, Ft.getContext("2d").drawImage(z, 0, 0, xt, Qt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + mt.width + "x" + mt.height + ") to (" + xt + "x" + Qt + ")."), Ft;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + mt.width + "x" + mt.height + ")."), z;
    return z;
  }
  function v(z) {
    return z.generateMipmaps && z.minFilter !== Sn && z.minFilter !== vi;
  }
  function m(z) {
    r.generateMipmap(z);
  }
  function y(z, k, nt, ht, mt = !1) {
    if (z !== null) {
      if (r[z] !== void 0)
        return r[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let xt = k;
    if (k === r.RED && (nt === r.FLOAT && (xt = r.R32F), nt === r.HALF_FLOAT && (xt = r.R16F), nt === r.UNSIGNED_BYTE && (xt = r.R8)), k === r.RED_INTEGER && (nt === r.UNSIGNED_BYTE && (xt = r.R8UI), nt === r.UNSIGNED_SHORT && (xt = r.R16UI), nt === r.UNSIGNED_INT && (xt = r.R32UI), nt === r.BYTE && (xt = r.R8I), nt === r.SHORT && (xt = r.R16I), nt === r.INT && (xt = r.R32I)), k === r.RG && (nt === r.FLOAT && (xt = r.RG32F), nt === r.HALF_FLOAT && (xt = r.RG16F), nt === r.UNSIGNED_BYTE && (xt = r.RG8)), k === r.RG_INTEGER && (nt === r.UNSIGNED_BYTE && (xt = r.RG8UI), nt === r.UNSIGNED_SHORT && (xt = r.RG16UI), nt === r.UNSIGNED_INT && (xt = r.RG32UI), nt === r.BYTE && (xt = r.RG8I), nt === r.SHORT && (xt = r.RG16I), nt === r.INT && (xt = r.RG32I)), k === r.RGB && nt === r.UNSIGNED_INT_5_9_9_9_REV && (xt = r.RGB9_E5), k === r.RGBA) {
      const Qt = mt ? fv : Fe.getTransfer(ht);
      nt === r.FLOAT && (xt = r.RGBA32F), nt === r.HALF_FLOAT && (xt = r.RGBA16F), nt === r.UNSIGNED_BYTE && (xt = Qt === qe ? r.SRGB8_ALPHA8 : r.RGBA8), nt === r.UNSIGNED_SHORT_4_4_4_4 && (xt = r.RGBA4), nt === r.UNSIGNED_SHORT_5_5_5_1 && (xt = r.RGB5_A1);
    }
    return (xt === r.R16F || xt === r.R32F || xt === r.RG16F || xt === r.RG32F || xt === r.RGBA16F || xt === r.RGBA32F) && t.get("EXT_color_buffer_float"), xt;
  }
  function _(z, k) {
    return v(z) === !0 || z.isFramebufferTexture && z.minFilter !== Sn && z.minFilter !== vi ? Math.log2(Math.max(k.width, k.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? k.mipmaps.length : 1;
  }
  function x(z) {
    const k = z.target;
    k.removeEventListener("dispose", x), S(k), k.isVideoTexture && c.delete(k);
  }
  function b(z) {
    const k = z.target;
    k.removeEventListener("dispose", b), A(k);
  }
  function S(z) {
    const k = n.get(z);
    if (k.__webglInit === void 0)
      return;
    const nt = z.source, ht = h.get(nt);
    if (ht) {
      const mt = ht[k.__cacheKey];
      mt.usedTimes--, mt.usedTimes === 0 && w(z), Object.keys(ht).length === 0 && h.delete(nt);
    }
    n.remove(z);
  }
  function w(z) {
    const k = n.get(z);
    r.deleteTexture(k.__webglTexture);
    const nt = z.source, ht = h.get(nt);
    delete ht[k.__cacheKey], o.memory.textures--;
  }
  function A(z) {
    const k = n.get(z);
    if (z.depthTexture && z.depthTexture.dispose(), z.isWebGLCubeRenderTarget)
      for (let ht = 0; ht < 6; ht++) {
        if (Array.isArray(k.__webglFramebuffer[ht]))
          for (let mt = 0; mt < k.__webglFramebuffer[ht].length; mt++)
            r.deleteFramebuffer(k.__webglFramebuffer[ht][mt]);
        else
          r.deleteFramebuffer(k.__webglFramebuffer[ht]);
        k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer[ht]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let ht = 0; ht < k.__webglFramebuffer.length; ht++)
          r.deleteFramebuffer(k.__webglFramebuffer[ht]);
      else
        r.deleteFramebuffer(k.__webglFramebuffer);
      if (k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer), k.__webglMultisampledFramebuffer && r.deleteFramebuffer(k.__webglMultisampledFramebuffer), k.__webglColorRenderbuffer)
        for (let ht = 0; ht < k.__webglColorRenderbuffer.length; ht++)
          k.__webglColorRenderbuffer[ht] && r.deleteRenderbuffer(k.__webglColorRenderbuffer[ht]);
      k.__webglDepthRenderbuffer && r.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const nt = z.textures;
    for (let ht = 0, mt = nt.length; ht < mt; ht++) {
      const xt = n.get(nt[ht]);
      xt.__webglTexture && (r.deleteTexture(xt.__webglTexture), o.memory.textures--), n.remove(nt[ht]);
    }
    n.remove(z);
  }
  let T = 0;
  function M() {
    T = 0;
  }
  function C() {
    const z = T;
    return z >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + i.maxTextures), T += 1, z;
  }
  function R(z) {
    const k = [];
    return k.push(z.wrapS), k.push(z.wrapT), k.push(z.wrapR || 0), k.push(z.magFilter), k.push(z.minFilter), k.push(z.anisotropy), k.push(z.internalFormat), k.push(z.format), k.push(z.type), k.push(z.generateMipmaps), k.push(z.premultiplyAlpha), k.push(z.flipY), k.push(z.unpackAlignment), k.push(z.colorSpace), k.join();
  }
  function E(z, k) {
    const nt = n.get(z);
    if (z.isVideoTexture && Rt(z), z.isRenderTargetTexture === !1 && z.version > 0 && nt.__version !== z.version) {
      const ht = z.image;
      if (ht === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ht.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        W(nt, z, k);
        return;
      }
    }
    e.bindTexture(r.TEXTURE_2D, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function D(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      W(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_2D_ARRAY, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function I(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      W(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_3D, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function P(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      J(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_CUBE_MAP, nt.__webglTexture, r.TEXTURE0 + k);
  }
  const O = {
    [W_]: r.REPEAT,
    [$s]: r.CLAMP_TO_EDGE,
    [X_]: r.MIRRORED_REPEAT
  }, N = {
    [Sn]: r.NEAREST,
    [az]: r.NEAREST_MIPMAP_NEAREST,
    [Qh]: r.NEAREST_MIPMAP_LINEAR,
    [vi]: r.LINEAR,
    [Lm]: r.LINEAR_MIPMAP_NEAREST,
    [Zs]: r.LINEAR_MIPMAP_LINEAR
  }, B = {
    [_z]: r.NEVER,
    [Tz]: r.ALWAYS,
    [xz]: r.LESS,
    [SI]: r.LEQUAL,
    [Sz]: r.EQUAL,
    [Mz]: r.GEQUAL,
    [bz]: r.GREATER,
    [wz]: r.NOTEQUAL
  };
  function F(z, k) {
    if (k.type === Ca && t.has("OES_texture_float_linear") === !1 && (k.magFilter === vi || k.magFilter === Lm || k.magFilter === Qh || k.magFilter === Zs || k.minFilter === vi || k.minFilter === Lm || k.minFilter === Qh || k.minFilter === Zs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(z, r.TEXTURE_WRAP_S, O[k.wrapS]), r.texParameteri(z, r.TEXTURE_WRAP_T, O[k.wrapT]), (z === r.TEXTURE_3D || z === r.TEXTURE_2D_ARRAY) && r.texParameteri(z, r.TEXTURE_WRAP_R, O[k.wrapR]), r.texParameteri(z, r.TEXTURE_MAG_FILTER, N[k.magFilter]), r.texParameteri(z, r.TEXTURE_MIN_FILTER, N[k.minFilter]), k.compareFunction && (r.texParameteri(z, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(z, r.TEXTURE_COMPARE_FUNC, B[k.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
      if (k.magFilter === Sn || k.minFilter !== Qh && k.minFilter !== Zs || k.type === Ca && t.has("OES_texture_float_linear") === !1)
        return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const nt = t.get("EXT_texture_filter_anisotropic");
        r.texParameterf(z, nt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(k.anisotropy, i.getMaxAnisotropy())), n.get(k).__currentAnisotropy = k.anisotropy;
      }
    }
  }
  function G(z, k) {
    let nt = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, k.addEventListener("dispose", x));
    const ht = k.source;
    let mt = h.get(ht);
    mt === void 0 && (mt = {}, h.set(ht, mt));
    const xt = R(k);
    if (xt !== z.__cacheKey) {
      mt[xt] === void 0 && (mt[xt] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, nt = !0), mt[xt].usedTimes++;
      const Qt = mt[z.__cacheKey];
      Qt !== void 0 && (mt[z.__cacheKey].usedTimes--, Qt.usedTimes === 0 && w(k)), z.__cacheKey = xt, z.__webglTexture = mt[xt].texture;
    }
    return nt;
  }
  function W(z, k, nt) {
    let ht = r.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) && (ht = r.TEXTURE_2D_ARRAY), k.isData3DTexture && (ht = r.TEXTURE_3D);
    const mt = G(z, k), xt = k.source;
    e.bindTexture(ht, z.__webglTexture, r.TEXTURE0 + nt);
    const Qt = n.get(xt);
    if (xt.version !== Qt.__version || mt === !0) {
      e.activeTexture(r.TEXTURE0 + nt);
      const Ft = Fe.getPrimaries(Fe.workingColorSpace), kt = k.colorSpace === xo ? null : Fe.getPrimaries(k.colorSpace), _e = k.colorSpace === xo || Ft === kt ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, _e);
      let Tt = g(k.image, !1, i.maxTextureSize);
      Tt = Kt(k, Tt);
      const Jt = a.convert(k.format, k.colorSpace), De = a.convert(k.type);
      let ie = y(k.internalFormat, Jt, De, k.colorSpace, k.isVideoTexture);
      F(ht, k);
      let Ht;
      const xe = k.mipmaps, Ee = k.isVideoTexture !== !0, ir = Qt.__version === void 0 || mt === !0, Se = xt.dataReady, Z = _(k, Tt);
      if (k.isDepthTexture)
        ie = r.DEPTH_COMPONENT16, k.type === Ca ? ie = r.DEPTH_COMPONENT32F : k.type === Ju ? ie = r.DEPTH_COMPONENT24 : k.type === Lh && (ie = r.DEPTH24_STENCIL8), ir && (Ee ? e.texStorage2D(r.TEXTURE_2D, 1, ie, Tt.width, Tt.height) : e.texImage2D(r.TEXTURE_2D, 0, ie, Tt.width, Tt.height, 0, Jt, De, null));
      else if (k.isDataTexture)
        if (xe.length > 0) {
          Ee && ir && e.texStorage2D(r.TEXTURE_2D, Z, ie, xe[0].width, xe[0].height);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, De, Ht.data) : e.texImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Jt, De, Ht.data);
          k.generateMipmaps = !1;
        } else
          Ee ? (ir && e.texStorage2D(r.TEXTURE_2D, Z, ie, Tt.width, Tt.height), Se && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Tt.width, Tt.height, Jt, De, Tt.data)) : e.texImage2D(r.TEXTURE_2D, 0, ie, Tt.width, Tt.height, 0, Jt, De, Tt.data);
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          Ee && ir && e.texStorage3D(r.TEXTURE_2D_ARRAY, Z, ie, xe[0].width, xe[0].height, Tt.depth);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], k.format !== Xi ? Jt !== null ? Ee ? Se && e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, vt, 0, 0, 0, Ht.width, Ht.height, Tt.depth, Jt, Ht.data, 0, 0) : e.compressedTexImage3D(r.TEXTURE_2D_ARRAY, vt, ie, Ht.width, Ht.height, Tt.depth, 0, Ht.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ee ? Se && e.texSubImage3D(r.TEXTURE_2D_ARRAY, vt, 0, 0, 0, Ht.width, Ht.height, Tt.depth, Jt, De, Ht.data) : e.texImage3D(r.TEXTURE_2D_ARRAY, vt, ie, Ht.width, Ht.height, Tt.depth, 0, Jt, De, Ht.data);
        } else {
          Ee && ir && e.texStorage2D(r.TEXTURE_2D, Z, ie, xe[0].width, xe[0].height);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], k.format !== Xi ? Jt !== null ? Ee ? Se && e.compressedTexSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, Ht.data) : e.compressedTexImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Ht.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, De, Ht.data) : e.texImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Jt, De, Ht.data);
        }
      else if (k.isDataArrayTexture)
        Ee ? (ir && e.texStorage3D(r.TEXTURE_2D_ARRAY, Z, ie, Tt.width, Tt.height, Tt.depth), Se && e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Tt.width, Tt.height, Tt.depth, Jt, De, Tt.data)) : e.texImage3D(r.TEXTURE_2D_ARRAY, 0, ie, Tt.width, Tt.height, Tt.depth, 0, Jt, De, Tt.data);
      else if (k.isData3DTexture)
        Ee ? (ir && e.texStorage3D(r.TEXTURE_3D, Z, ie, Tt.width, Tt.height, Tt.depth), Se && e.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Tt.width, Tt.height, Tt.depth, Jt, De, Tt.data)) : e.texImage3D(r.TEXTURE_3D, 0, ie, Tt.width, Tt.height, Tt.depth, 0, Jt, De, Tt.data);
      else if (k.isFramebufferTexture) {
        if (ir)
          if (Ee)
            e.texStorage2D(r.TEXTURE_2D, Z, ie, Tt.width, Tt.height);
          else {
            let vt = Tt.width, ft = Tt.height;
            for (let It = 0; It < Z; It++)
              e.texImage2D(r.TEXTURE_2D, It, ie, vt, ft, 0, Jt, De, null), vt >>= 1, ft >>= 1;
          }
      } else if (xe.length > 0) {
        if (Ee && ir) {
          const vt = Ae(xe[0]);
          e.texStorage2D(r.TEXTURE_2D, Z, ie, vt.width, vt.height);
        }
        for (let vt = 0, ft = xe.length; vt < ft; vt++)
          Ht = xe[vt], Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Jt, De, Ht) : e.texImage2D(r.TEXTURE_2D, vt, ie, Jt, De, Ht);
        k.generateMipmaps = !1;
      } else if (Ee) {
        if (ir) {
          const vt = Ae(Tt);
          e.texStorage2D(r.TEXTURE_2D, Z, ie, vt.width, vt.height);
        }
        Se && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Jt, De, Tt);
      } else
        e.texImage2D(r.TEXTURE_2D, 0, ie, Jt, De, Tt);
      v(k) && m(ht), Qt.__version = xt.version, k.onUpdate && k.onUpdate(k);
    }
    z.__version = k.version;
  }
  function J(z, k, nt) {
    if (k.image.length !== 6)
      return;
    const ht = G(z, k), mt = k.source;
    e.bindTexture(r.TEXTURE_CUBE_MAP, z.__webglTexture, r.TEXTURE0 + nt);
    const xt = n.get(mt);
    if (mt.version !== xt.__version || ht === !0) {
      e.activeTexture(r.TEXTURE0 + nt);
      const Qt = Fe.getPrimaries(Fe.workingColorSpace), Ft = k.colorSpace === xo ? null : Fe.getPrimaries(k.colorSpace), kt = k.colorSpace === xo || Qt === Ft ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, kt);
      const _e = k.isCompressedTexture || k.image[0].isCompressedTexture, Tt = k.image[0] && k.image[0].isDataTexture, Jt = [];
      for (let ft = 0; ft < 6; ft++)
        !_e && !Tt ? Jt[ft] = g(k.image[ft], !0, i.maxCubemapSize) : Jt[ft] = Tt ? k.image[ft].image : k.image[ft], Jt[ft] = Kt(k, Jt[ft]);
      const De = Jt[0], ie = a.convert(k.format, k.colorSpace), Ht = a.convert(k.type), xe = y(k.internalFormat, ie, Ht, k.colorSpace), Ee = k.isVideoTexture !== !0, ir = xt.__version === void 0 || ht === !0, Se = mt.dataReady;
      let Z = _(k, De);
      F(r.TEXTURE_CUBE_MAP, k);
      let vt;
      if (_e) {
        Ee && ir && e.texStorage2D(r.TEXTURE_CUBE_MAP, Z, xe, De.width, De.height);
        for (let ft = 0; ft < 6; ft++) {
          vt = Jt[ft].mipmaps;
          for (let It = 0; It < vt.length; It++) {
            const Ut = vt[It];
            k.format !== Xi ? ie !== null ? Ee ? Se && e.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It, 0, 0, Ut.width, Ut.height, ie, Ut.data) : e.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It, xe, Ut.width, Ut.height, 0, Ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It, 0, 0, Ut.width, Ut.height, ie, Ht, Ut.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It, xe, Ut.width, Ut.height, 0, ie, Ht, Ut.data);
          }
        }
      } else {
        if (vt = k.mipmaps, Ee && ir) {
          vt.length > 0 && Z++;
          const ft = Ae(Jt[0]);
          e.texStorage2D(r.TEXTURE_CUBE_MAP, Z, xe, ft.width, ft.height);
        }
        for (let ft = 0; ft < 6; ft++)
          if (Tt) {
            Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, Jt[ft].width, Jt[ft].height, ie, Ht, Jt[ft].data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, xe, Jt[ft].width, Jt[ft].height, 0, ie, Ht, Jt[ft].data);
            for (let It = 0; It < vt.length; It++) {
              const Le = vt[It].image[ft].image;
              Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It + 1, 0, 0, Le.width, Le.height, ie, Ht, Le.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It + 1, xe, Le.width, Le.height, 0, ie, Ht, Le.data);
            }
          } else {
            Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, ie, Ht, Jt[ft]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, xe, ie, Ht, Jt[ft]);
            for (let It = 0; It < vt.length; It++) {
              const Ut = vt[It];
              Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It + 1, 0, 0, ie, Ht, Ut.image[ft]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, It + 1, xe, ie, Ht, Ut.image[ft]);
            }
          }
      }
      v(k) && m(r.TEXTURE_CUBE_MAP), xt.__version = mt.version, k.onUpdate && k.onUpdate(k);
    }
    z.__version = k.version;
  }
  function U(z, k, nt, ht, mt, xt) {
    const Qt = a.convert(nt.format, nt.colorSpace), Ft = a.convert(nt.type), kt = y(nt.internalFormat, Qt, Ft, nt.colorSpace);
    if (!n.get(k).__hasExternalTextures) {
      const Tt = Math.max(1, k.width >> xt), Jt = Math.max(1, k.height >> xt);
      mt === r.TEXTURE_3D || mt === r.TEXTURE_2D_ARRAY ? e.texImage3D(mt, xt, kt, Tt, Jt, k.depth, 0, Qt, Ft, null) : e.texImage2D(mt, xt, kt, Tt, Jt, 0, Qt, Ft, null);
    }
    e.bindFramebuffer(r.FRAMEBUFFER, z), Mt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ht, mt, n.get(nt).__webglTexture, 0, yt(k)) : (mt === r.TEXTURE_2D || mt >= r.TEXTURE_CUBE_MAP_POSITIVE_X && mt <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ht, mt, n.get(nt).__webglTexture, xt), e.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function Y(z, k, nt) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, z), k.depthBuffer && !k.stencilBuffer) {
      let ht = r.DEPTH_COMPONENT24;
      if (nt || Mt(k)) {
        const mt = k.depthTexture;
        mt && mt.isDepthTexture && (mt.type === Ca ? ht = r.DEPTH_COMPONENT32F : mt.type === Ju && (ht = r.DEPTH_COMPONENT24));
        const xt = yt(k);
        Mt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, xt, ht, k.width, k.height) : r.renderbufferStorageMultisample(r.RENDERBUFFER, xt, ht, k.width, k.height);
      } else
        r.renderbufferStorage(r.RENDERBUFFER, ht, k.width, k.height);
      r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, z);
    } else if (k.depthBuffer && k.stencilBuffer) {
      const ht = yt(k);
      nt && Mt(k) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ht, r.DEPTH24_STENCIL8, k.width, k.height) : Mt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ht, r.DEPTH24_STENCIL8, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, k.width, k.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, z);
    } else {
      const ht = k.textures;
      for (let mt = 0; mt < ht.length; mt++) {
        const xt = ht[mt], Qt = a.convert(xt.format, xt.colorSpace), Ft = a.convert(xt.type), kt = y(xt.internalFormat, Qt, Ft, xt.colorSpace), _e = yt(k);
        nt && Mt(k) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, _e, kt, k.width, k.height) : Mt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, _e, kt, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, kt, k.width, k.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function at(z, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(r.FRAMEBUFFER, z), !(k.depthTexture && k.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(k.depthTexture).__webglTexture || k.depthTexture.image.width !== k.width || k.depthTexture.image.height !== k.height) && (k.depthTexture.image.width = k.width, k.depthTexture.image.height = k.height, k.depthTexture.needsUpdate = !0), E(k.depthTexture, 0);
    const ht = n.get(k.depthTexture).__webglTexture, mt = yt(k);
    if (k.depthTexture.format === Gu)
      Mt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ht, 0, mt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ht, 0);
    else if (k.depthTexture.format === th)
      Mt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ht, 0, mt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ht, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function st(z) {
    const k = n.get(z), nt = z.isWebGLCubeRenderTarget === !0;
    if (z.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (nt)
        throw new Error("target.depthTexture not supported in Cube render targets");
      at(k.__webglFramebuffer, z);
    } else if (nt) {
      k.__webglDepthbuffer = [];
      for (let ht = 0; ht < 6; ht++)
        e.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer[ht]), k.__webglDepthbuffer[ht] = r.createRenderbuffer(), Y(k.__webglDepthbuffer[ht], z, !1);
    } else
      e.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer), k.__webglDepthbuffer = r.createRenderbuffer(), Y(k.__webglDepthbuffer, z, !1);
    e.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function ut(z, k, nt) {
    const ht = n.get(z);
    k !== void 0 && U(ht.__webglFramebuffer, z, z.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), nt !== void 0 && st(z);
  }
  function lt(z) {
    const k = z.texture, nt = n.get(z), ht = n.get(k);
    z.addEventListener("dispose", b);
    const mt = z.textures, xt = z.isWebGLCubeRenderTarget === !0, Qt = mt.length > 1;
    if (Qt || (ht.__webglTexture === void 0 && (ht.__webglTexture = r.createTexture()), ht.__version = k.version, o.memory.textures++), xt) {
      nt.__webglFramebuffer = [];
      for (let Ft = 0; Ft < 6; Ft++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          nt.__webglFramebuffer[Ft] = [];
          for (let kt = 0; kt < k.mipmaps.length; kt++)
            nt.__webglFramebuffer[Ft][kt] = r.createFramebuffer();
        } else
          nt.__webglFramebuffer[Ft] = r.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        nt.__webglFramebuffer = [];
        for (let Ft = 0; Ft < k.mipmaps.length; Ft++)
          nt.__webglFramebuffer[Ft] = r.createFramebuffer();
      } else
        nt.__webglFramebuffer = r.createFramebuffer();
      if (Qt)
        for (let Ft = 0, kt = mt.length; Ft < kt; Ft++) {
          const _e = n.get(mt[Ft]);
          _e.__webglTexture === void 0 && (_e.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (z.samples > 0 && Mt(z) === !1) {
        nt.__webglMultisampledFramebuffer = r.createFramebuffer(), nt.__webglColorRenderbuffer = [], e.bindFramebuffer(r.FRAMEBUFFER, nt.__webglMultisampledFramebuffer);
        for (let Ft = 0; Ft < mt.length; Ft++) {
          const kt = mt[Ft];
          nt.__webglColorRenderbuffer[Ft] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, nt.__webglColorRenderbuffer[Ft]);
          const _e = a.convert(kt.format, kt.colorSpace), Tt = a.convert(kt.type), Jt = y(kt.internalFormat, _e, Tt, kt.colorSpace, z.isXRRenderTarget === !0), De = yt(z);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, De, Jt, z.width, z.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ft, r.RENDERBUFFER, nt.__webglColorRenderbuffer[Ft]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), z.depthBuffer && (nt.__webglDepthRenderbuffer = r.createRenderbuffer(), Y(nt.__webglDepthRenderbuffer, z, !0)), e.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (xt) {
      e.bindTexture(r.TEXTURE_CUBE_MAP, ht.__webglTexture), F(r.TEXTURE_CUBE_MAP, k);
      for (let Ft = 0; Ft < 6; Ft++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let kt = 0; kt < k.mipmaps.length; kt++)
            U(nt.__webglFramebuffer[Ft][kt], z, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, kt);
        else
          U(nt.__webglFramebuffer[Ft], z, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, 0);
      v(k) && m(r.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Qt) {
      for (let Ft = 0, kt = mt.length; Ft < kt; Ft++) {
        const _e = mt[Ft], Tt = n.get(_e);
        e.bindTexture(r.TEXTURE_2D, Tt.__webglTexture), F(r.TEXTURE_2D, _e), U(nt.__webglFramebuffer, z, _e, r.COLOR_ATTACHMENT0 + Ft, r.TEXTURE_2D, 0), v(_e) && m(r.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let Ft = r.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Ft = z.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), e.bindTexture(Ft, ht.__webglTexture), F(Ft, k), k.mipmaps && k.mipmaps.length > 0)
        for (let kt = 0; kt < k.mipmaps.length; kt++)
          U(nt.__webglFramebuffer[kt], z, k, r.COLOR_ATTACHMENT0, Ft, kt);
      else
        U(nt.__webglFramebuffer, z, k, r.COLOR_ATTACHMENT0, Ft, 0);
      v(k) && m(Ft), e.unbindTexture();
    }
    z.depthBuffer && st(z);
  }
  function H(z) {
    const k = z.textures;
    for (let nt = 0, ht = k.length; nt < ht; nt++) {
      const mt = k[nt];
      if (v(mt)) {
        const xt = z.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D, Qt = n.get(mt).__webglTexture;
        e.bindTexture(xt, Qt), m(xt), e.unbindTexture();
      }
    }
  }
  const ct = [], ot = [];
  function Gt(z) {
    if (z.samples > 0) {
      if (Mt(z) === !1) {
        const k = z.textures, nt = z.width, ht = z.height;
        let mt = r.COLOR_BUFFER_BIT;
        const xt = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Qt = n.get(z), Ft = k.length > 1;
        if (Ft)
          for (let kt = 0; kt < k.length; kt++)
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + kt, r.RENDERBUFFER, null), e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + kt, r.TEXTURE_2D, null, 0);
        e.bindFramebuffer(r.READ_FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qt.__webglFramebuffer);
        for (let kt = 0; kt < k.length; kt++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (mt |= r.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (mt |= r.STENCIL_BUFFER_BIT)), Ft) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Qt.__webglColorRenderbuffer[kt]);
            const _e = n.get(k[kt]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, _e, 0);
          }
          r.blitFramebuffer(0, 0, nt, ht, 0, 0, nt, ht, mt, r.NEAREST), l === !0 && (ct.length = 0, ot.length = 0, ct.push(r.COLOR_ATTACHMENT0 + kt), z.depthBuffer && z.resolveDepthBuffer === !1 && (ct.push(xt), ot.push(xt), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, ot)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, ct));
        }
        if (e.bindFramebuffer(r.READ_FRAMEBUFFER, null), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), Ft)
          for (let kt = 0; kt < k.length; kt++) {
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + kt, r.RENDERBUFFER, Qt.__webglColorRenderbuffer[kt]);
            const _e = n.get(k[kt]).__webglTexture;
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + kt, r.TEXTURE_2D, _e, 0);
          }
        e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qt.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && l) {
        const k = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function yt(z) {
    return Math.min(i.maxSamples, z.samples);
  }
  function Mt(z) {
    const k = n.get(z);
    return z.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && k.__useRenderToTexture !== !1;
  }
  function Rt(z) {
    const k = o.render.frame;
    c.get(z) !== k && (c.set(z, k), z.update());
  }
  function Kt(z, k) {
    const nt = z.colorSpace, ht = z.format, mt = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || nt !== qo && nt !== xo && (Fe.getTransfer(nt) === qe ? (ht !== Xi || mt !== zo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", nt)), k;
  }
  function Ae(z) {
    return typeof HTMLImageElement < "u" && z instanceof HTMLImageElement ? (u.width = z.naturalWidth || z.width, u.height = z.naturalHeight || z.height) : typeof VideoFrame < "u" && z instanceof VideoFrame ? (u.width = z.displayWidth, u.height = z.displayHeight) : (u.width = z.width, u.height = z.height), u;
  }
  this.allocateTextureUnit = C, this.resetTextureUnits = M, this.setTexture2D = E, this.setTexture2DArray = D, this.setTexture3D = I, this.setTextureCube = P, this.rebindTextures = ut, this.setupRenderTarget = lt, this.updateRenderTargetMipmap = H, this.updateMultisampleRenderTarget = Gt, this.setupDepthRenderbuffer = st, this.setupFrameBufferTexture = U, this.useMultisampledRTT = Mt;
}
function T4(r, t) {
  function e(n, i = xo) {
    let a;
    const o = Fe.getTransfer(i);
    if (n === zo)
      return r.UNSIGNED_BYTE;
    if (n === vI)
      return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === gI)
      return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === lz)
      return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === oz)
      return r.BYTE;
    if (n === sz)
      return r.SHORT;
    if (n === dI)
      return r.UNSIGNED_SHORT;
    if (n === pI)
      return r.INT;
    if (n === Ju)
      return r.UNSIGNED_INT;
    if (n === Ca)
      return r.FLOAT;
    if (n === Ng)
      return r.HALF_FLOAT;
    if (n === uz)
      return r.ALPHA;
    if (n === cz)
      return r.RGB;
    if (n === Xi)
      return r.RGBA;
    if (n === fz)
      return r.LUMINANCE;
    if (n === hz)
      return r.LUMINANCE_ALPHA;
    if (n === Gu)
      return r.DEPTH_COMPONENT;
    if (n === th)
      return r.DEPTH_STENCIL;
    if (n === mI)
      return r.RED;
    if (n === yI)
      return r.RED_INTEGER;
    if (n === dz)
      return r.RG;
    if (n === _I)
      return r.RG_INTEGER;
    if (n === xI)
      return r.RGBA_INTEGER;
    if (n === Rm || n === Im || n === Pm || n === Nm)
      if (o === qe)
        if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Rm)
            return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Im)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Pm)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Nm)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = t.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Rm)
          return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Im)
          return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Pm)
          return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Nm)
          return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === qw || n === Kw || n === jw || n === Jw)
      if (a = t.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === qw)
          return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === Kw)
          return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === jw)
          return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === Jw)
          return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === Qw || n === tM || n === eM)
      if (a = t.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === Qw || n === tM)
          return o === qe ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === eM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === rM || n === nM || n === iM || n === aM || n === oM || n === sM || n === lM || n === uM || n === cM || n === fM || n === hM || n === dM || n === pM || n === vM)
      if (a = t.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === rM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === nM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === iM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === aM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === oM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === sM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === lM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === uM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === cM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === fM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === hM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === dM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === pM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === vM)
          return o === qe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Om || n === gM || n === mM)
      if (a = t.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Om)
          return o === qe ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === gM)
          return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === mM)
          return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === pz || n === yM || n === _M || n === xM)
      if (a = t.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Om)
          return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === yM)
          return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === _M)
          return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === xM)
          return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Lh ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: e };
}
class A4 extends Rn {
  constructor(t = []) {
    super(), this.isArrayCamera = !0, this.cameras = t;
  }
}
let Pu = class extends Or {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const E4 = { type: "move" };
class sy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Pu(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Pu(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new K(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new K()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Pu(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new K(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new K()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e)
        for (const n of t.hand.values())
          this._getHandJoint(e, n);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(t, e, n) {
    let i = null, a = null, o = null;
    const s = this._targetRay, l = this._grip, u = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (u && t.hand) {
        o = !0;
        for (const g of t.hand.values()) {
          const v = e.getJointPose(g, n), m = this._getHandJoint(u, g);
          v !== null && (m.matrix.fromArray(v.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = v.radius), m.visible = v !== null;
        }
        const c = u.joints["index-finger-tip"], f = u.joints["thumb-tip"], h = c.position.distanceTo(f.position), d = 0.02, p = 5e-3;
        u.inputState.pinching && h > d + p ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !u.inputState.pinching && h <= d - p && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }));
      } else
        l !== null && t.gripSpace && (a = e.getPose(t.gripSpace, n), a !== null && (l.matrix.fromArray(a.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(a.linearVelocity)) : l.hasLinearVelocity = !1, a.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(a.angularVelocity)) : l.hasAngularVelocity = !1));
      s !== null && (i = e.getPose(t.targetRaySpace, n), i === null && a !== null && (i = a), i !== null && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(E4)));
    }
    return s !== null && (s.visible = i !== null), l !== null && (l.visible = a !== null), u !== null && (u.visible = o !== null), this;
  }
  // private method
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const n = new Pu();
      n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n);
    }
    return t.joints[e.jointName];
  }
}
const C4 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, D4 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class L4 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(t, e, n) {
    if (this.texture === null) {
      const i = new ln(), a = t.properties.get(i);
      a.__webglTexture = e.texture, (e.depthNear != n.depthNear || e.depthFar != n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = i;
    }
  }
  render(t, e) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const n = e.cameras[0].viewport, i = new za({
          vertexShader: C4,
          fragmentShader: D4,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: n.z },
            depthHeight: { value: n.w }
          }
        });
        this.mesh = new Pn(new kg(20, 20), i);
      }
      t.render(this.mesh, e);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class R4 extends gc {
  constructor(t, e) {
    super();
    const n = this;
    let i = null, a = 1, o = null, s = "local-floor", l = 1, u = null, c = null, f = null, h = null, d = null, p = null;
    const g = new L4(), v = e.getContextAttributes();
    let m = null, y = null;
    const _ = [], x = [], b = new Ce();
    let S = null;
    const w = new Rn();
    w.layers.enable(1), w.viewport = new Nr();
    const A = new Rn();
    A.layers.enable(2), A.viewport = new Nr();
    const T = [w, A], M = new A4();
    M.layers.enable(1), M.layers.enable(2);
    let C = null, R = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(U) {
      let Y = _[U];
      return Y === void 0 && (Y = new sy(), _[U] = Y), Y.getTargetRaySpace();
    }, this.getControllerGrip = function(U) {
      let Y = _[U];
      return Y === void 0 && (Y = new sy(), _[U] = Y), Y.getGripSpace();
    }, this.getHand = function(U) {
      let Y = _[U];
      return Y === void 0 && (Y = new sy(), _[U] = Y), Y.getHandSpace();
    };
    function E(U) {
      const Y = x.indexOf(U.inputSource);
      if (Y === -1)
        return;
      const at = _[Y];
      at !== void 0 && (at.update(U.inputSource, U.frame, u || o), at.dispatchEvent({ type: U.type, data: U.inputSource }));
    }
    function D() {
      i.removeEventListener("select", E), i.removeEventListener("selectstart", E), i.removeEventListener("selectend", E), i.removeEventListener("squeeze", E), i.removeEventListener("squeezestart", E), i.removeEventListener("squeezeend", E), i.removeEventListener("end", D), i.removeEventListener("inputsourceschange", I);
      for (let U = 0; U < _.length; U++) {
        const Y = x[U];
        Y !== null && (x[U] = null, _[U].disconnect(Y));
      }
      C = null, R = null, g.reset(), t.setRenderTarget(m), d = null, h = null, f = null, i = null, y = null, J.stop(), n.isPresenting = !1, t.setPixelRatio(S), t.setSize(b.width, b.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(U) {
      a = U, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(U) {
      s = U, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || o;
    }, this.setReferenceSpace = function(U) {
      u = U;
    }, this.getBaseLayer = function() {
      return h !== null ? h : d;
    }, this.getBinding = function() {
      return f;
    }, this.getFrame = function() {
      return p;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(U) {
      if (i = U, i !== null) {
        if (m = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", D), i.addEventListener("inputsourceschange", I), v.xrCompatible !== !0 && await e.makeXRCompatible(), S = t.getPixelRatio(), t.getSize(b), i.renderState.layers === void 0) {
          const Y = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: a
          };
          d = new XRWebGLLayer(i, e, Y), i.updateRenderState({ baseLayer: d }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), y = new fl(
            d.framebufferWidth,
            d.framebufferHeight,
            {
              format: Xi,
              type: zo,
              colorSpace: t.outputColorSpace,
              stencilBuffer: v.stencil
            }
          );
        } else {
          let Y = null, at = null, st = null;
          v.depth && (st = v.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, Y = v.stencil ? th : Gu, at = v.stencil ? Lh : Ju);
          const ut = {
            colorFormat: e.RGBA8,
            depthFormat: st,
            scaleFactor: a
          };
          f = new XRWebGLBinding(i, e), h = f.createProjectionLayer(ut), i.updateRenderState({ layers: [h] }), t.setPixelRatio(1), t.setSize(h.textureWidth, h.textureHeight, !1), y = new fl(
            h.textureWidth,
            h.textureHeight,
            {
              format: Xi,
              type: zo,
              depthTexture: new PI(h.textureWidth, h.textureHeight, at, void 0, void 0, void 0, void 0, void 0, void 0, Y),
              stencilBuffer: v.stencil,
              colorSpace: t.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: h.ignoreDepthValues === !1
            }
          );
        }
        y.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await i.requestReferenceSpace(s), J.setContext(i), J.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function I(U) {
      for (let Y = 0; Y < U.removed.length; Y++) {
        const at = U.removed[Y], st = x.indexOf(at);
        st >= 0 && (x[st] = null, _[st].disconnect(at));
      }
      for (let Y = 0; Y < U.added.length; Y++) {
        const at = U.added[Y];
        let st = x.indexOf(at);
        if (st === -1) {
          for (let lt = 0; lt < _.length; lt++)
            if (lt >= x.length) {
              x.push(at), st = lt;
              break;
            } else if (x[lt] === null) {
              x[lt] = at, st = lt;
              break;
            }
          if (st === -1)
            break;
        }
        const ut = _[st];
        ut && ut.connect(at);
      }
    }
    const P = new K(), O = new K();
    function N(U, Y, at) {
      P.setFromMatrixPosition(Y.matrixWorld), O.setFromMatrixPosition(at.matrixWorld);
      const st = P.distanceTo(O), ut = Y.projectionMatrix.elements, lt = at.projectionMatrix.elements, H = ut[14] / (ut[10] - 1), ct = ut[14] / (ut[10] + 1), ot = (ut[9] + 1) / ut[5], Gt = (ut[9] - 1) / ut[5], yt = (ut[8] - 1) / ut[0], Mt = (lt[8] + 1) / lt[0], Rt = H * yt, Kt = H * Mt, Ae = st / (-yt + Mt), z = Ae * -yt;
      Y.matrixWorld.decompose(U.position, U.quaternion, U.scale), U.translateX(z), U.translateZ(Ae), U.matrixWorld.compose(U.position, U.quaternion, U.scale), U.matrixWorldInverse.copy(U.matrixWorld).invert();
      const k = H + Ae, nt = ct + Ae, ht = Rt - z, mt = Kt + (st - z), xt = ot * ct / nt * k, Qt = Gt * ct / nt * k;
      U.projectionMatrix.makePerspective(ht, mt, xt, Qt, k, nt), U.projectionMatrixInverse.copy(U.projectionMatrix).invert();
    }
    function B(U, Y) {
      Y === null ? U.matrixWorld.copy(U.matrix) : U.matrixWorld.multiplyMatrices(Y.matrixWorld, U.matrix), U.matrixWorldInverse.copy(U.matrixWorld).invert();
    }
    this.updateCamera = function(U) {
      if (i === null)
        return;
      g.texture !== null && (U.near = g.depthNear, U.far = g.depthFar), M.near = A.near = w.near = U.near, M.far = A.far = w.far = U.far, (C !== M.near || R !== M.far) && (i.updateRenderState({
        depthNear: M.near,
        depthFar: M.far
      }), C = M.near, R = M.far, w.near = C, w.far = R, A.near = C, A.far = R, w.updateProjectionMatrix(), A.updateProjectionMatrix(), U.updateProjectionMatrix());
      const Y = U.parent, at = M.cameras;
      B(M, Y);
      for (let st = 0; st < at.length; st++)
        B(at[st], Y);
      at.length === 2 ? N(M, w, A) : M.projectionMatrix.copy(w.projectionMatrix), F(U, M, Y);
    };
    function F(U, Y, at) {
      at === null ? U.matrix.copy(Y.matrixWorld) : (U.matrix.copy(at.matrixWorld), U.matrix.invert(), U.matrix.multiply(Y.matrixWorld)), U.matrix.decompose(U.position, U.quaternion, U.scale), U.updateMatrixWorld(!0), U.projectionMatrix.copy(Y.projectionMatrix), U.projectionMatrixInverse.copy(Y.projectionMatrixInverse), U.isPerspectiveCamera && (U.fov = Y_ * 2 * Math.atan(1 / U.projectionMatrix.elements[5]), U.zoom = 1);
    }
    this.getCamera = function() {
      return M;
    }, this.getFoveation = function() {
      if (!(h === null && d === null))
        return l;
    }, this.setFoveation = function(U) {
      l = U, h !== null && (h.fixedFoveation = U), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = U);
    }, this.hasDepthSensing = function() {
      return g.texture !== null;
    };
    let G = null;
    function W(U, Y) {
      if (c = Y.getViewerPose(u || o), p = Y, c !== null) {
        const at = c.views;
        d !== null && (t.setRenderTargetFramebuffer(y, d.framebuffer), t.setRenderTarget(y));
        let st = !1;
        at.length !== M.cameras.length && (M.cameras.length = 0, st = !0);
        for (let lt = 0; lt < at.length; lt++) {
          const H = at[lt];
          let ct = null;
          if (d !== null)
            ct = d.getViewport(H);
          else {
            const Gt = f.getViewSubImage(h, H);
            ct = Gt.viewport, lt === 0 && (t.setRenderTargetTextures(
              y,
              Gt.colorTexture,
              h.ignoreDepthValues ? void 0 : Gt.depthStencilTexture
            ), t.setRenderTarget(y));
          }
          let ot = T[lt];
          ot === void 0 && (ot = new Rn(), ot.layers.enable(lt), ot.viewport = new Nr(), T[lt] = ot), ot.matrix.fromArray(H.transform.matrix), ot.matrix.decompose(ot.position, ot.quaternion, ot.scale), ot.projectionMatrix.fromArray(H.projectionMatrix), ot.projectionMatrixInverse.copy(ot.projectionMatrix).invert(), ot.viewport.set(ct.x, ct.y, ct.width, ct.height), lt === 0 && (M.matrix.copy(ot.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), st === !0 && M.cameras.push(ot);
        }
        const ut = i.enabledFeatures;
        if (ut && ut.includes("depth-sensing")) {
          const lt = f.getDepthInformation(at[0]);
          lt && lt.isValid && lt.texture && g.init(t, lt, i.renderState);
        }
      }
      for (let at = 0; at < _.length; at++) {
        const st = x[at], ut = _[at];
        st !== null && ut !== void 0 && ut.update(st, Y, u || o);
      }
      g.render(t, M), G && G(U, Y), Y.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: Y }), p = null;
    }
    const J = new RI();
    J.setAnimationLoop(W), this.setAnimationLoop = function(U) {
      G = U;
    }, this.dispose = function() {
    };
  }
}
const os = /* @__PURE__ */ new Fa(), I4 = /* @__PURE__ */ new $e();
function P4(r, t) {
  function e(v, m) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), m.value.copy(v.matrix);
  }
  function n(v, m) {
    m.color.getRGB(v.fogColor.value, CI(r)), m.isFog ? (v.fogNear.value = m.near, v.fogFar.value = m.far) : m.isFogExp2 && (v.fogDensity.value = m.density);
  }
  function i(v, m, y, _, x) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial ? a(v, m) : m.isMeshToonMaterial ? (a(v, m), f(v, m)) : m.isMeshPhongMaterial ? (a(v, m), c(v, m)) : m.isMeshStandardMaterial ? (a(v, m), h(v, m), m.isMeshPhysicalMaterial && d(v, m, x)) : m.isMeshMatcapMaterial ? (a(v, m), p(v, m)) : m.isMeshDepthMaterial ? a(v, m) : m.isMeshDistanceMaterial ? (a(v, m), g(v, m)) : m.isMeshNormalMaterial ? a(v, m) : m.isLineBasicMaterial ? (o(v, m), m.isLineDashedMaterial && s(v, m)) : m.isPointsMaterial ? l(v, m, y, _) : m.isSpriteMaterial ? u(v, m) : m.isShadowMaterial ? (v.color.value.copy(m.color), v.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function a(v, m) {
    v.opacity.value = m.opacity, m.color && v.diffuse.value.copy(m.color), m.emissive && v.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (v.map.value = m.map, e(m.map, v.mapTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.bumpMap && (v.bumpMap.value = m.bumpMap, e(m.bumpMap, v.bumpMapTransform), v.bumpScale.value = m.bumpScale, m.side === bn && (v.bumpScale.value *= -1)), m.normalMap && (v.normalMap.value = m.normalMap, e(m.normalMap, v.normalMapTransform), v.normalScale.value.copy(m.normalScale), m.side === bn && v.normalScale.value.negate()), m.displacementMap && (v.displacementMap.value = m.displacementMap, e(m.displacementMap, v.displacementMapTransform), v.displacementScale.value = m.displacementScale, v.displacementBias.value = m.displacementBias), m.emissiveMap && (v.emissiveMap.value = m.emissiveMap, e(m.emissiveMap, v.emissiveMapTransform)), m.specularMap && (v.specularMap.value = m.specularMap, e(m.specularMap, v.specularMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
    const y = t.get(m), _ = y.envMap, x = y.envMapRotation;
    if (_ && (v.envMap.value = _, os.copy(x), os.x *= -1, os.y *= -1, os.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (os.y *= -1, os.z *= -1), v.envMapRotation.value.setFromMatrix4(I4.makeRotationFromEuler(os)), v.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = m.reflectivity, v.ior.value = m.ior, v.refractionRatio.value = m.refractionRatio), m.lightMap) {
      v.lightMap.value = m.lightMap;
      const b = r._useLegacyLights === !0 ? Math.PI : 1;
      v.lightMapIntensity.value = m.lightMapIntensity * b, e(m.lightMap, v.lightMapTransform);
    }
    m.aoMap && (v.aoMap.value = m.aoMap, v.aoMapIntensity.value = m.aoMapIntensity, e(m.aoMap, v.aoMapTransform));
  }
  function o(v, m) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, m.map && (v.map.value = m.map, e(m.map, v.mapTransform));
  }
  function s(v, m) {
    v.dashSize.value = m.dashSize, v.totalSize.value = m.dashSize + m.gapSize, v.scale.value = m.scale;
  }
  function l(v, m, y, _) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, v.size.value = m.size * y, v.scale.value = _ * 0.5, m.map && (v.map.value = m.map, e(m.map, v.uvTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
  }
  function u(v, m) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, v.rotation.value = m.rotation, m.map && (v.map.value = m.map, e(m.map, v.mapTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
  }
  function c(v, m) {
    v.specular.value.copy(m.specular), v.shininess.value = Math.max(m.shininess, 1e-4);
  }
  function f(v, m) {
    m.gradientMap && (v.gradientMap.value = m.gradientMap);
  }
  function h(v, m) {
    v.metalness.value = m.metalness, m.metalnessMap && (v.metalnessMap.value = m.metalnessMap, e(m.metalnessMap, v.metalnessMapTransform)), v.roughness.value = m.roughness, m.roughnessMap && (v.roughnessMap.value = m.roughnessMap, e(m.roughnessMap, v.roughnessMapTransform)), m.envMap && (v.envMapIntensity.value = m.envMapIntensity);
  }
  function d(v, m, y) {
    v.ior.value = m.ior, m.sheen > 0 && (v.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), v.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (v.sheenColorMap.value = m.sheenColorMap, e(m.sheenColorMap, v.sheenColorMapTransform)), m.sheenRoughnessMap && (v.sheenRoughnessMap.value = m.sheenRoughnessMap, e(m.sheenRoughnessMap, v.sheenRoughnessMapTransform))), m.clearcoat > 0 && (v.clearcoat.value = m.clearcoat, v.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (v.clearcoatMap.value = m.clearcoatMap, e(m.clearcoatMap, v.clearcoatMapTransform)), m.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, e(m.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (v.clearcoatNormalMap.value = m.clearcoatNormalMap, e(m.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === bn && v.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (v.dispersion.value = m.dispersion), m.iridescence > 0 && (v.iridescence.value = m.iridescence, v.iridescenceIOR.value = m.iridescenceIOR, v.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (v.iridescenceMap.value = m.iridescenceMap, e(m.iridescenceMap, v.iridescenceMapTransform)), m.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = m.iridescenceThicknessMap, e(m.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), m.transmission > 0 && (v.transmission.value = m.transmission, v.transmissionSamplerMap.value = y.texture, v.transmissionSamplerSize.value.set(y.width, y.height), m.transmissionMap && (v.transmissionMap.value = m.transmissionMap, e(m.transmissionMap, v.transmissionMapTransform)), v.thickness.value = m.thickness, m.thicknessMap && (v.thicknessMap.value = m.thicknessMap, e(m.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = m.attenuationDistance, v.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (v.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (v.anisotropyMap.value = m.anisotropyMap, e(m.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = m.specularIntensity, v.specularColor.value.copy(m.specularColor), m.specularColorMap && (v.specularColorMap.value = m.specularColorMap, e(m.specularColorMap, v.specularColorMapTransform)), m.specularIntensityMap && (v.specularIntensityMap.value = m.specularIntensityMap, e(m.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function p(v, m) {
    m.matcap && (v.matcap.value = m.matcap);
  }
  function g(v, m) {
    const y = t.get(m).light;
    v.referencePosition.value.setFromMatrixPosition(y.matrixWorld), v.nearDistance.value = y.shadow.camera.near, v.farDistance.value = y.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function N4(r, t, e, n) {
  let i = {}, a = {}, o = [];
  const s = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, _) {
    const x = _.program;
    n.uniformBlockBinding(y, x);
  }
  function u(y, _) {
    let x = i[y.id];
    x === void 0 && (p(y), x = c(y), i[y.id] = x, y.addEventListener("dispose", v));
    const b = _.program;
    n.updateUBOMapping(y, b);
    const S = t.render.frame;
    a[y.id] !== S && (h(y), a[y.id] = S);
  }
  function c(y) {
    const _ = f();
    y.__bindingPointIndex = _;
    const x = r.createBuffer(), b = y.__size, S = y.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, x), r.bufferData(r.UNIFORM_BUFFER, b, S), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, _, x), x;
  }
  function f() {
    for (let y = 0; y < s; y++)
      if (o.indexOf(y) === -1)
        return o.push(y), y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function h(y) {
    const _ = i[y.id], x = y.uniforms, b = y.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, _);
    for (let S = 0, w = x.length; S < w; S++) {
      const A = Array.isArray(x[S]) ? x[S] : [x[S]];
      for (let T = 0, M = A.length; T < M; T++) {
        const C = A[T];
        if (d(C, S, T, b) === !0) {
          const R = C.__offset, E = Array.isArray(C.value) ? C.value : [C.value];
          let D = 0;
          for (let I = 0; I < E.length; I++) {
            const P = E[I], O = g(P);
            typeof P == "number" || typeof P == "boolean" ? (C.__data[0] = P, r.bufferSubData(r.UNIFORM_BUFFER, R + D, C.__data)) : P.isMatrix3 ? (C.__data[0] = P.elements[0], C.__data[1] = P.elements[1], C.__data[2] = P.elements[2], C.__data[3] = 0, C.__data[4] = P.elements[3], C.__data[5] = P.elements[4], C.__data[6] = P.elements[5], C.__data[7] = 0, C.__data[8] = P.elements[6], C.__data[9] = P.elements[7], C.__data[10] = P.elements[8], C.__data[11] = 0) : (P.toArray(C.__data, D), D += O.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, R, C.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function d(y, _, x, b) {
    const S = y.value, w = _ + "_" + x;
    if (b[w] === void 0)
      return typeof S == "number" || typeof S == "boolean" ? b[w] = S : b[w] = S.clone(), !0;
    {
      const A = b[w];
      if (typeof S == "number" || typeof S == "boolean") {
        if (A !== S)
          return b[w] = S, !0;
      } else if (A.equals(S) === !1)
        return A.copy(S), !0;
    }
    return !1;
  }
  function p(y) {
    const _ = y.uniforms;
    let x = 0;
    const b = 16;
    for (let w = 0, A = _.length; w < A; w++) {
      const T = Array.isArray(_[w]) ? _[w] : [_[w]];
      for (let M = 0, C = T.length; M < C; M++) {
        const R = T[M], E = Array.isArray(R.value) ? R.value : [R.value];
        for (let D = 0, I = E.length; D < I; D++) {
          const P = E[D], O = g(P), N = x % b;
          N !== 0 && b - N < O.boundary && (x += b - N), R.__data = new Float32Array(O.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = x, x += O.storage;
        }
      }
    }
    const S = x % b;
    return S > 0 && (x += b - S), y.__size = x, y.__cache = {}, this;
  }
  function g(y) {
    const _ = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof y == "number" || typeof y == "boolean" ? (_.boundary = 4, _.storage = 4) : y.isVector2 ? (_.boundary = 8, _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16, _.storage = 12) : y.isVector4 ? (_.boundary = 16, _.storage = 16) : y.isMatrix3 ? (_.boundary = 48, _.storage = 48) : y.isMatrix4 ? (_.boundary = 64, _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), _;
  }
  function v(y) {
    const _ = y.target;
    _.removeEventListener("dispose", v);
    const x = o.indexOf(_.__bindingPointIndex);
    o.splice(x, 1), r.deleteBuffer(i[_.id]), delete i[_.id], delete a[_.id];
  }
  function m() {
    for (const y in i)
      r.deleteBuffer(i[y]);
    o = [], i = {}, a = {};
  }
  return {
    bind: l,
    update: u,
    dispose: m
  };
}
class FI {
  constructor(t = {}) {
    const {
      canvas: e = Ez(),
      context: n = null,
      depth: i = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: s = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: c = "default",
      failIfMajorPerformanceCaveat: f = !1
    } = t;
    this.isWebGLRenderer = !0;
    let h;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      h = n.getContextAttributes().alpha;
    } else
      h = o;
    const d = new Uint32Array(4), p = new Int32Array(4);
    let g = null, v = null;
    const m = [], y = [];
    this.domElement = e, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Vi, this._useLegacyLights = !1, this.toneMapping = Io, this.toneMappingExposure = 1;
    const _ = this;
    let x = !1, b = 0, S = 0, w = null, A = -1, T = null;
    const M = new Nr(), C = new Nr();
    let R = null;
    const E = new le(0);
    let D = 0, I = e.width, P = e.height, O = 1, N = null, B = null;
    const F = new Nr(0, 0, I, P), G = new Nr(0, 0, I, P);
    let W = !1;
    const J = new g1();
    let U = !1, Y = !1;
    const at = new $e(), st = new K(), ut = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function lt() {
      return w === null ? O : 1;
    }
    let H = n;
    function ct(V, q) {
      return e.getContext(V, q);
    }
    try {
      const V = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: s,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: c,
        failIfMajorPerformanceCaveat: f
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${f1}`), e.addEventListener("webglcontextlost", Z, !1), e.addEventListener("webglcontextrestored", vt, !1), e.addEventListener("webglcontextcreationerror", ft, !1), H === null) {
        const q = "webgl2";
        if (H = ct(q, V), H === null)
          throw ct(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (V) {
      throw console.error("THREE.WebGLRenderer: " + V.message), V;
    }
    let ot, Gt, yt, Mt, Rt, Kt, Ae, z, k, nt, ht, mt, xt, Qt, Ft, kt, _e, Tt, Jt, De, ie, Ht, xe, Ee;
    function ir() {
      ot = new H5(H), ot.init(), Ht = new T4(H, ot), Gt = new B5(H, ot, t, Ht), yt = new w4(H), Mt = new Y5(H), Rt = new u4(), Kt = new M4(H, ot, yt, Rt, Gt, Ht, Mt), Ae = new F5(_), z = new G5(_), k = new Qz(H), xe = new O5(H, k), nt = new W5(H, k, Mt, xe), ht = new Z5(H, nt, k, Mt), Jt = new $5(H, Gt, Kt), kt = new V5(Rt), mt = new l4(_, Ae, z, ot, Gt, xe, kt), xt = new P4(_, Rt), Qt = new f4(), Ft = new m4(ot), Tt = new N5(_, Ae, z, yt, ht, h, l), _e = new b4(_, ht, Gt), Ee = new N4(H, Mt, Gt, yt), De = new k5(H, ot, Mt), ie = new X5(H, ot, Mt), Mt.programs = mt.programs, _.capabilities = Gt, _.extensions = ot, _.properties = Rt, _.renderLists = Qt, _.shadowMap = _e, _.state = yt, _.info = Mt;
    }
    ir();
    const Se = new R4(_, H);
    this.xr = Se, this.getContext = function() {
      return H;
    }, this.getContextAttributes = function() {
      return H.getContextAttributes();
    }, this.forceContextLoss = function() {
      const V = ot.get("WEBGL_lose_context");
      V && V.loseContext();
    }, this.forceContextRestore = function() {
      const V = ot.get("WEBGL_lose_context");
      V && V.restoreContext();
    }, this.getPixelRatio = function() {
      return O;
    }, this.setPixelRatio = function(V) {
      V !== void 0 && (O = V, this.setSize(I, P, !1));
    }, this.getSize = function(V) {
      return V.set(I, P);
    }, this.setSize = function(V, q, it = !0) {
      if (Se.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      I = V, P = q, e.width = Math.floor(V * O), e.height = Math.floor(q * O), it === !0 && (e.style.width = V + "px", e.style.height = q + "px"), this.setViewport(0, 0, V, q);
    }, this.getDrawingBufferSize = function(V) {
      return V.set(I * O, P * O).floor();
    }, this.setDrawingBufferSize = function(V, q, it) {
      I = V, P = q, O = it, e.width = Math.floor(V * it), e.height = Math.floor(q * it), this.setViewport(0, 0, V, q);
    }, this.getCurrentViewport = function(V) {
      return V.copy(M);
    }, this.getViewport = function(V) {
      return V.copy(F);
    }, this.setViewport = function(V, q, it, Q) {
      V.isVector4 ? F.set(V.x, V.y, V.z, V.w) : F.set(V, q, it, Q), yt.viewport(M.copy(F).multiplyScalar(O).round());
    }, this.getScissor = function(V) {
      return V.copy(G);
    }, this.setScissor = function(V, q, it, Q) {
      V.isVector4 ? G.set(V.x, V.y, V.z, V.w) : G.set(V, q, it, Q), yt.scissor(C.copy(G).multiplyScalar(O).round());
    }, this.getScissorTest = function() {
      return W;
    }, this.setScissorTest = function(V) {
      yt.setScissorTest(W = V);
    }, this.setOpaqueSort = function(V) {
      N = V;
    }, this.setTransparentSort = function(V) {
      B = V;
    }, this.getClearColor = function(V) {
      return V.copy(Tt.getClearColor());
    }, this.setClearColor = function() {
      Tt.setClearColor.apply(Tt, arguments);
    }, this.getClearAlpha = function() {
      return Tt.getClearAlpha();
    }, this.setClearAlpha = function() {
      Tt.setClearAlpha.apply(Tt, arguments);
    }, this.clear = function(V = !0, q = !0, it = !0) {
      let Q = 0;
      if (V) {
        let tt = !1;
        if (w !== null) {
          const Pt = w.texture.format;
          tt = Pt === xI || Pt === _I || Pt === yI;
        }
        if (tt) {
          const Pt = w.texture.type, Xt = Pt === zo || Pt === Ju || Pt === dI || Pt === Lh || Pt === vI || Pt === gI, $t = Tt.getClearColor(), ae = Tt.getClearAlpha(), he = $t.r, ge = $t.g, be = $t.b;
          Xt ? (d[0] = he, d[1] = ge, d[2] = be, d[3] = ae, H.clearBufferuiv(H.COLOR, 0, d)) : (p[0] = he, p[1] = ge, p[2] = be, p[3] = ae, H.clearBufferiv(H.COLOR, 0, p));
        } else
          Q |= H.COLOR_BUFFER_BIT;
      }
      q && (Q |= H.DEPTH_BUFFER_BIT), it && (Q |= H.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), H.clear(Q);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Z, !1), e.removeEventListener("webglcontextrestored", vt, !1), e.removeEventListener("webglcontextcreationerror", ft, !1), Qt.dispose(), Ft.dispose(), Rt.dispose(), Ae.dispose(), z.dispose(), ht.dispose(), xe.dispose(), Ee.dispose(), mt.dispose(), Se.dispose(), Se.removeEventListener("sessionstart", Be), Se.removeEventListener("sessionend", Ci), Qr.stop();
    };
    function Z(V) {
      V.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0;
    }
    function vt() {
      console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
      const V = Mt.autoReset, q = _e.enabled, it = _e.autoUpdate, Q = _e.needsUpdate, tt = _e.type;
      ir(), Mt.autoReset = V, _e.enabled = q, _e.autoUpdate = it, _e.needsUpdate = Q, _e.type = tt;
    }
    function ft(V) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", V.statusMessage);
    }
    function It(V) {
      const q = V.target;
      q.removeEventListener("dispose", It), Ut(q);
    }
    function Ut(V) {
      Le(V), Rt.remove(V);
    }
    function Le(V) {
      const q = Rt.get(V).programs;
      q !== void 0 && (q.forEach(function(it) {
        mt.releaseProgram(it);
      }), V.isShaderMaterial && mt.releaseShaderCache(V));
    }
    this.renderBufferDirect = function(V, q, it, Q, tt, Pt) {
      q === null && (q = ut);
      const Xt = tt.isMesh && tt.matrixWorld.determinant() < 0, $t = iF(V, q, it, Q, tt);
      yt.setMaterial(Q, Xt);
      let ae = it.index, he = 1;
      if (Q.wireframe === !0) {
        if (ae = nt.getWireframeAttribute(it), ae === void 0)
          return;
        he = 2;
      }
      const ge = it.drawRange, be = it.attributes.position;
      let pr = ge.start * he, Wr = (ge.start + ge.count) * he;
      Pt !== null && (pr = Math.max(pr, Pt.start * he), Wr = Math.min(Wr, (Pt.start + Pt.count) * he)), ae !== null ? (pr = Math.max(pr, 0), Wr = Math.min(Wr, ae.count)) : be != null && (pr = Math.max(pr, 0), Wr = Math.min(Wr, be.count));
      const Mn = Wr - pr;
      if (Mn < 0 || Mn === 1 / 0)
        return;
      xe.setup(tt, Q, $t, it, ae);
      let ha, Pe = De;
      if (ae !== null && (ha = k.get(ae), Pe = ie, Pe.setIndex(ha)), tt.isMesh)
        Q.wireframe === !0 ? (yt.setLineWidth(Q.wireframeLinewidth * lt()), Pe.setMode(H.LINES)) : Pe.setMode(H.TRIANGLES);
      else if (tt.isLine) {
        let de = Q.linewidth;
        de === void 0 && (de = 1), yt.setLineWidth(de * lt()), tt.isLineSegments ? Pe.setMode(H.LINES) : tt.isLineLoop ? Pe.setMode(H.LINE_LOOP) : Pe.setMode(H.LINE_STRIP);
      } else
        tt.isPoints ? Pe.setMode(H.POINTS) : tt.isSprite && Pe.setMode(H.TRIANGLES);
      if (tt.isBatchedMesh)
        tt._multiDrawInstances !== null ? Pe.renderMultiDrawInstances(tt._multiDrawStarts, tt._multiDrawCounts, tt._multiDrawCount, tt._multiDrawInstances) : Pe.renderMultiDraw(tt._multiDrawStarts, tt._multiDrawCounts, tt._multiDrawCount);
      else if (tt.isInstancedMesh)
        Pe.renderInstances(pr, Mn, tt.count);
      else if (it.isInstancedBufferGeometry) {
        const de = it._maxInstanceCount !== void 0 ? it._maxInstanceCount : 1 / 0, kc = Math.min(it.instanceCount, de);
        Pe.renderInstances(pr, Mn, kc);
      } else
        Pe.render(pr, Mn);
    };
    function Ze(V, q, it) {
      V.transparent === !0 && V.side === Aa && V.forceSinglePass === !1 ? (V.side = bn, V.needsUpdate = !0, Jh(V, q, it), V.side = Fo, V.needsUpdate = !0, Jh(V, q, it), V.side = Aa) : Jh(V, q, it);
    }
    this.compile = function(V, q, it = null) {
      it === null && (it = V), v = Ft.get(it), v.init(q), y.push(v), it.traverseVisible(function(tt) {
        tt.isLight && tt.layers.test(q.layers) && (v.pushLight(tt), tt.castShadow && v.pushShadow(tt));
      }), V !== it && V.traverseVisible(function(tt) {
        tt.isLight && tt.layers.test(q.layers) && (v.pushLight(tt), tt.castShadow && v.pushShadow(tt));
      }), v.setupLights(_._useLegacyLights);
      const Q = /* @__PURE__ */ new Set();
      return V.traverse(function(tt) {
        const Pt = tt.material;
        if (Pt)
          if (Array.isArray(Pt))
            for (let Xt = 0; Xt < Pt.length; Xt++) {
              const $t = Pt[Xt];
              Ze($t, it, tt), Q.add($t);
            }
          else
            Ze(Pt, it, tt), Q.add(Pt);
      }), y.pop(), v = null, Q;
    }, this.compileAsync = function(V, q, it = null) {
      const Q = this.compile(V, q, it);
      return new Promise((tt) => {
        function Pt() {
          if (Q.forEach(function(Xt) {
            Rt.get(Xt).currentProgram.isReady() && Q.delete(Xt);
          }), Q.size === 0) {
            tt(V);
            return;
          }
          setTimeout(Pt, 10);
        }
        ot.get("KHR_parallel_shader_compile") !== null ? Pt() : setTimeout(Pt, 10);
      });
    };
    let Je = null;
    function Hr(V) {
      Je && Je(V);
    }
    function Be() {
      Qr.stop();
    }
    function Ci() {
      Qr.start();
    }
    const Qr = new RI();
    Qr.setAnimationLoop(Hr), typeof self < "u" && Qr.setContext(self), this.setAnimationLoop = function(V) {
      Je = V, Se.setAnimationLoop(V), V === null ? Qr.stop() : Qr.start();
    }, Se.addEventListener("sessionstart", Be), Se.addEventListener("sessionend", Ci), this.render = function(V, q) {
      if (q !== void 0 && q.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (x === !0)
        return;
      V.matrixWorldAutoUpdate === !0 && V.updateMatrixWorld(), q.parent === null && q.matrixWorldAutoUpdate === !0 && q.updateMatrixWorld(), Se.enabled === !0 && Se.isPresenting === !0 && (Se.cameraAutoUpdate === !0 && Se.updateCamera(q), q = Se.getCamera()), V.isScene === !0 && V.onBeforeRender(_, V, q, w), v = Ft.get(V, y.length), v.init(q), y.push(v), at.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), J.setFromProjectionMatrix(at), Y = this.localClippingEnabled, U = kt.init(this.clippingPlanes, Y), g = Qt.get(V, m.length), g.init(), m.push(g), Bw(V, q, 0, _.sortObjects), g.finish(), _.sortObjects === !0 && g.sort(N, B);
      const it = Se.enabled === !1 || Se.isPresenting === !1 || Se.hasDepthSensing() === !1;
      it && Tt.addToRenderList(g, V), this.info.render.frame++, U === !0 && kt.beginShadows();
      const Q = v.state.shadowsArray;
      _e.render(Q, V, q), U === !0 && kt.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const tt = g.opaque, Pt = g.transmissive;
      if (v.setupLights(_._useLegacyLights), q.isArrayCamera) {
        const Xt = q.cameras;
        if (Pt.length > 0)
          for (let $t = 0, ae = Xt.length; $t < ae; $t++) {
            const he = Xt[$t];
            Fw(tt, Pt, V, he);
          }
        it && Tt.render(V);
        for (let $t = 0, ae = Xt.length; $t < ae; $t++) {
          const he = Xt[$t];
          Vw(g, V, he, he.viewport);
        }
      } else
        Pt.length > 0 && Fw(tt, Pt, V, q), it && Tt.render(V), Vw(g, V, q);
      w !== null && (Kt.updateMultisampleRenderTarget(w), Kt.updateRenderTargetMipmap(w)), V.isScene === !0 && V.onAfterRender(_, V, q), xe.resetDefaultState(), A = -1, T = null, y.pop(), y.length > 0 ? (v = y[y.length - 1], U === !0 && kt.setGlobalState(_.clippingPlanes, v.state.camera)) : v = null, m.pop(), m.length > 0 ? g = m[m.length - 1] : g = null;
    };
    function Bw(V, q, it, Q) {
      if (V.visible === !1)
        return;
      if (V.layers.test(q.layers)) {
        if (V.isGroup)
          it = V.renderOrder;
        else if (V.isLOD)
          V.autoUpdate === !0 && V.update(q);
        else if (V.isLight)
          v.pushLight(V), V.castShadow && v.pushShadow(V);
        else if (V.isSprite) {
          if (!V.frustumCulled || J.intersectsSprite(V)) {
            Q && st.setFromMatrixPosition(V.matrixWorld).applyMatrix4(at);
            const Xt = ht.update(V), $t = V.material;
            $t.visible && g.push(V, Xt, $t, it, st.z, null);
          }
        } else if ((V.isMesh || V.isLine || V.isPoints) && (!V.frustumCulled || J.intersectsObject(V))) {
          const Xt = ht.update(V), $t = V.material;
          if (Q && (V.boundingSphere !== void 0 ? (V.boundingSphere === null && V.computeBoundingSphere(), st.copy(V.boundingSphere.center)) : (Xt.boundingSphere === null && Xt.computeBoundingSphere(), st.copy(Xt.boundingSphere.center)), st.applyMatrix4(V.matrixWorld).applyMatrix4(at)), Array.isArray($t)) {
            const ae = Xt.groups;
            for (let he = 0, ge = ae.length; he < ge; he++) {
              const be = ae[he], pr = $t[be.materialIndex];
              pr && pr.visible && g.push(V, Xt, pr, it, st.z, be);
            }
          } else
            $t.visible && g.push(V, Xt, $t, it, st.z, null);
        }
      }
      const Pt = V.children;
      for (let Xt = 0, $t = Pt.length; Xt < $t; Xt++)
        Bw(Pt[Xt], q, it, Q);
    }
    function Vw(V, q, it, Q) {
      const tt = V.opaque, Pt = V.transmissive, Xt = V.transparent;
      v.setupLightsView(it), U === !0 && kt.setGlobalState(_.clippingPlanes, it), Q && yt.viewport(M.copy(Q)), tt.length > 0 && jh(tt, q, it), Pt.length > 0 && jh(Pt, q, it), Xt.length > 0 && jh(Xt, q, it), yt.buffers.depth.setTest(!0), yt.buffers.depth.setMask(!0), yt.buffers.color.setMask(!0), yt.setPolygonOffset(!1);
    }
    function Fw(V, q, it, Q) {
      if ((it.isScene === !0 ? it.overrideMaterial : null) !== null)
        return;
      v.state.transmissionRenderTarget[Q.id] === void 0 && (v.state.transmissionRenderTarget[Q.id] = new fl(1, 1, {
        generateMipmaps: !0,
        type: ot.has("EXT_color_buffer_half_float") || ot.has("EXT_color_buffer_float") ? Ng : zo,
        minFilter: Zs,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }));
      const Pt = v.state.transmissionRenderTarget[Q.id], Xt = Q.viewport || M;
      Pt.setSize(Xt.z, Xt.w);
      const $t = _.getRenderTarget();
      _.setRenderTarget(Pt), _.getClearColor(E), D = _.getClearAlpha(), D < 1 && _.setClearColor(16777215, 0.5), _.clear();
      const ae = _.toneMapping;
      _.toneMapping = Io;
      const he = Q.viewport;
      if (Q.viewport !== void 0 && (Q.viewport = void 0), v.setupLightsView(Q), U === !0 && kt.setGlobalState(_.clippingPlanes, Q), jh(V, it, Q), Kt.updateMultisampleRenderTarget(Pt), Kt.updateRenderTargetMipmap(Pt), ot.has("WEBGL_multisampled_render_to_texture") === !1) {
        let ge = !1;
        for (let be = 0, pr = q.length; be < pr; be++) {
          const Wr = q[be], Mn = Wr.object, ha = Wr.geometry, Pe = Wr.material, de = Wr.group;
          if (Pe.side === Aa && Mn.layers.test(Q.layers)) {
            const kc = Pe.side;
            Pe.side = bn, Pe.needsUpdate = !0, zw(Mn, it, Q, ha, Pe, de), Pe.side = kc, Pe.needsUpdate = !0, ge = !0;
          }
        }
        ge === !0 && (Kt.updateMultisampleRenderTarget(Pt), Kt.updateRenderTargetMipmap(Pt));
      }
      _.setRenderTarget($t), _.setClearColor(E, D), he !== void 0 && (Q.viewport = he), _.toneMapping = ae;
    }
    function jh(V, q, it) {
      const Q = q.isScene === !0 ? q.overrideMaterial : null;
      for (let tt = 0, Pt = V.length; tt < Pt; tt++) {
        const Xt = V[tt], $t = Xt.object, ae = Xt.geometry, he = Q === null ? Xt.material : Q, ge = Xt.group;
        $t.layers.test(it.layers) && zw($t, q, it, ae, he, ge);
      }
    }
    function zw(V, q, it, Q, tt, Pt) {
      V.onBeforeRender(_, q, it, Q, tt, Pt), V.modelViewMatrix.multiplyMatrices(it.matrixWorldInverse, V.matrixWorld), V.normalMatrix.getNormalMatrix(V.modelViewMatrix), tt.onBeforeRender(_, q, it, Q, V, Pt), tt.transparent === !0 && tt.side === Aa && tt.forceSinglePass === !1 ? (tt.side = bn, tt.needsUpdate = !0, _.renderBufferDirect(it, q, Q, tt, V, Pt), tt.side = Fo, tt.needsUpdate = !0, _.renderBufferDirect(it, q, Q, tt, V, Pt), tt.side = Aa) : _.renderBufferDirect(it, q, Q, tt, V, Pt), V.onAfterRender(_, q, it, Q, tt, Pt);
    }
    function Jh(V, q, it) {
      q.isScene !== !0 && (q = ut);
      const Q = Rt.get(V), tt = v.state.lights, Pt = v.state.shadowsArray, Xt = tt.state.version, $t = mt.getParameters(V, tt.state, Pt, q, it), ae = mt.getProgramCacheKey($t);
      let he = Q.programs;
      Q.environment = V.isMeshStandardMaterial ? q.environment : null, Q.fog = q.fog, Q.envMap = (V.isMeshStandardMaterial ? z : Ae).get(V.envMap || Q.environment), Q.envMapRotation = Q.environment !== null && V.envMap === null ? q.environmentRotation : V.envMapRotation, he === void 0 && (V.addEventListener("dispose", It), he = /* @__PURE__ */ new Map(), Q.programs = he);
      let ge = he.get(ae);
      if (ge !== void 0) {
        if (Q.currentProgram === ge && Q.lightsStateVersion === Xt)
          return Gw(V, $t), ge;
      } else
        $t.uniforms = mt.getUniforms(V), V.onBuild(it, $t, _), V.onBeforeCompile($t, _), ge = mt.acquireProgram($t, ae), he.set(ae, ge), Q.uniforms = $t.uniforms;
      const be = Q.uniforms;
      return (!V.isShaderMaterial && !V.isRawShaderMaterial || V.clipping === !0) && (be.clippingPlanes = kt.uniform), Gw(V, $t), Q.needsLights = oF(V), Q.lightsStateVersion = Xt, Q.needsLights && (be.ambientLightColor.value = tt.state.ambient, be.lightProbe.value = tt.state.probe, be.directionalLights.value = tt.state.directional, be.directionalLightShadows.value = tt.state.directionalShadow, be.spotLights.value = tt.state.spot, be.spotLightShadows.value = tt.state.spotShadow, be.rectAreaLights.value = tt.state.rectArea, be.ltc_1.value = tt.state.rectAreaLTC1, be.ltc_2.value = tt.state.rectAreaLTC2, be.pointLights.value = tt.state.point, be.pointLightShadows.value = tt.state.pointShadow, be.hemisphereLights.value = tt.state.hemi, be.directionalShadowMap.value = tt.state.directionalShadowMap, be.directionalShadowMatrix.value = tt.state.directionalShadowMatrix, be.spotShadowMap.value = tt.state.spotShadowMap, be.spotLightMatrix.value = tt.state.spotLightMatrix, be.spotLightMap.value = tt.state.spotLightMap, be.pointShadowMap.value = tt.state.pointShadowMap, be.pointShadowMatrix.value = tt.state.pointShadowMatrix), Q.currentProgram = ge, Q.uniformsList = null, ge;
    }
    function Uw(V) {
      if (V.uniformsList === null) {
        const q = V.currentProgram.getUniforms();
        V.uniformsList = Up.seqWithValue(q.seq, V.uniforms);
      }
      return V.uniformsList;
    }
    function Gw(V, q) {
      const it = Rt.get(V);
      it.outputColorSpace = q.outputColorSpace, it.batching = q.batching, it.instancing = q.instancing, it.instancingColor = q.instancingColor, it.instancingMorph = q.instancingMorph, it.skinning = q.skinning, it.morphTargets = q.morphTargets, it.morphNormals = q.morphNormals, it.morphColors = q.morphColors, it.morphTargetsCount = q.morphTargetsCount, it.numClippingPlanes = q.numClippingPlanes, it.numIntersection = q.numClipIntersection, it.vertexAlphas = q.vertexAlphas, it.vertexTangents = q.vertexTangents, it.toneMapping = q.toneMapping;
    }
    function iF(V, q, it, Q, tt) {
      q.isScene !== !0 && (q = ut), Kt.resetTextureUnits();
      const Pt = q.fog, Xt = Q.isMeshStandardMaterial ? q.environment : null, $t = w === null ? _.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : qo, ae = (Q.isMeshStandardMaterial ? z : Ae).get(Q.envMap || Xt), he = Q.vertexColors === !0 && !!it.attributes.color && it.attributes.color.itemSize === 4, ge = !!it.attributes.tangent && (!!Q.normalMap || Q.anisotropy > 0), be = !!it.morphAttributes.position, pr = !!it.morphAttributes.normal, Wr = !!it.morphAttributes.color;
      let Mn = Io;
      Q.toneMapped && (w === null || w.isXRRenderTarget === !0) && (Mn = _.toneMapping);
      const ha = it.morphAttributes.position || it.morphAttributes.normal || it.morphAttributes.color, Pe = ha !== void 0 ? ha.length : 0, de = Rt.get(Q), kc = v.state.lights;
      if (U === !0 && (Y === !0 || V !== T)) {
        const zn = V === T && Q.id === A;
        kt.setState(Q, V, zn);
      }
      let Ke = !1;
      Q.version === de.__version ? (de.needsLights && de.lightsStateVersion !== kc.state.version || de.outputColorSpace !== $t || tt.isBatchedMesh && de.batching === !1 || !tt.isBatchedMesh && de.batching === !0 || tt.isInstancedMesh && de.instancing === !1 || !tt.isInstancedMesh && de.instancing === !0 || tt.isSkinnedMesh && de.skinning === !1 || !tt.isSkinnedMesh && de.skinning === !0 || tt.isInstancedMesh && de.instancingColor === !0 && tt.instanceColor === null || tt.isInstancedMesh && de.instancingColor === !1 && tt.instanceColor !== null || tt.isInstancedMesh && de.instancingMorph === !0 && tt.morphTexture === null || tt.isInstancedMesh && de.instancingMorph === !1 && tt.morphTexture !== null || de.envMap !== ae || Q.fog === !0 && de.fog !== Pt || de.numClippingPlanes !== void 0 && (de.numClippingPlanes !== kt.numPlanes || de.numIntersection !== kt.numIntersection) || de.vertexAlphas !== he || de.vertexTangents !== ge || de.morphTargets !== be || de.morphNormals !== pr || de.morphColors !== Wr || de.toneMapping !== Mn || de.morphTargetsCount !== Pe) && (Ke = !0) : (Ke = !0, de.__version = Q.version);
      let ts = de.currentProgram;
      Ke === !0 && (ts = Jh(Q, q, tt));
      let Hw = !1, Bc = !1, Em = !1;
      const Xr = ts.getUniforms(), Qa = de.uniforms;
      if (yt.useProgram(ts.program) && (Hw = !0, Bc = !0, Em = !0), Q.id !== A && (A = Q.id, Bc = !0), Hw || T !== V) {
        Xr.setValue(H, "projectionMatrix", V.projectionMatrix), Xr.setValue(H, "viewMatrix", V.matrixWorldInverse);
        const zn = Xr.map.cameraPosition;
        zn !== void 0 && zn.setValue(H, st.setFromMatrixPosition(V.matrixWorld)), Gt.logarithmicDepthBuffer && Xr.setValue(
          H,
          "logDepthBufFC",
          2 / (Math.log(V.far + 1) / Math.LN2)
        ), (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial) && Xr.setValue(H, "isOrthographic", V.isOrthographicCamera === !0), T !== V && (T = V, Bc = !0, Em = !0);
      }
      if (tt.isSkinnedMesh) {
        Xr.setOptional(H, tt, "bindMatrix"), Xr.setOptional(H, tt, "bindMatrixInverse");
        const zn = tt.skeleton;
        zn && (zn.boneTexture === null && zn.computeBoneTexture(), Xr.setValue(H, "boneTexture", zn.boneTexture, Kt));
      }
      tt.isBatchedMesh && (Xr.setOptional(H, tt, "batchingTexture"), Xr.setValue(H, "batchingTexture", tt._matricesTexture, Kt));
      const Cm = it.morphAttributes;
      if ((Cm.position !== void 0 || Cm.normal !== void 0 || Cm.color !== void 0) && Jt.update(tt, it, ts), (Bc || de.receiveShadow !== tt.receiveShadow) && (de.receiveShadow = tt.receiveShadow, Xr.setValue(H, "receiveShadow", tt.receiveShadow)), Q.isMeshGouraudMaterial && Q.envMap !== null && (Qa.envMap.value = ae, Qa.flipEnvMap.value = ae.isCubeTexture && ae.isRenderTargetTexture === !1 ? -1 : 1), Q.isMeshStandardMaterial && Q.envMap === null && q.environment !== null && (Qa.envMapIntensity.value = q.environmentIntensity), Bc && (Xr.setValue(H, "toneMappingExposure", _.toneMappingExposure), de.needsLights && aF(Qa, Em), Pt && Q.fog === !0 && xt.refreshFogUniforms(Qa, Pt), xt.refreshMaterialUniforms(Qa, Q, O, P, v.state.transmissionRenderTarget[V.id]), Up.upload(H, Uw(de), Qa, Kt)), Q.isShaderMaterial && Q.uniformsNeedUpdate === !0 && (Up.upload(H, Uw(de), Qa, Kt), Q.uniformsNeedUpdate = !1), Q.isSpriteMaterial && Xr.setValue(H, "center", tt.center), Xr.setValue(H, "modelViewMatrix", tt.modelViewMatrix), Xr.setValue(H, "normalMatrix", tt.normalMatrix), Xr.setValue(H, "modelMatrix", tt.matrixWorld), Q.isShaderMaterial || Q.isRawShaderMaterial) {
        const zn = Q.uniformsGroups;
        for (let Dm = 0, sF = zn.length; Dm < sF; Dm++) {
          const Ww = zn[Dm];
          Ee.update(Ww, ts), Ee.bind(Ww, ts);
        }
      }
      return ts;
    }
    function aF(V, q) {
      V.ambientLightColor.needsUpdate = q, V.lightProbe.needsUpdate = q, V.directionalLights.needsUpdate = q, V.directionalLightShadows.needsUpdate = q, V.pointLights.needsUpdate = q, V.pointLightShadows.needsUpdate = q, V.spotLights.needsUpdate = q, V.spotLightShadows.needsUpdate = q, V.rectAreaLights.needsUpdate = q, V.hemisphereLights.needsUpdate = q;
    }
    function oF(V) {
      return V.isMeshLambertMaterial || V.isMeshToonMaterial || V.isMeshPhongMaterial || V.isMeshStandardMaterial || V.isShadowMaterial || V.isShaderMaterial && V.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return b;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return w;
    }, this.setRenderTargetTextures = function(V, q, it) {
      Rt.get(V.texture).__webglTexture = q, Rt.get(V.depthTexture).__webglTexture = it;
      const Q = Rt.get(V);
      Q.__hasExternalTextures = !0, Q.__autoAllocateDepthBuffer = it === void 0, Q.__autoAllocateDepthBuffer || ot.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Q.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(V, q) {
      const it = Rt.get(V);
      it.__webglFramebuffer = q, it.__useDefaultFramebuffer = q === void 0;
    }, this.setRenderTarget = function(V, q = 0, it = 0) {
      w = V, b = q, S = it;
      let Q = !0, tt = null, Pt = !1, Xt = !1;
      if (V) {
        const ae = Rt.get(V);
        ae.__useDefaultFramebuffer !== void 0 ? (yt.bindFramebuffer(H.FRAMEBUFFER, null), Q = !1) : ae.__webglFramebuffer === void 0 ? Kt.setupRenderTarget(V) : ae.__hasExternalTextures && Kt.rebindTextures(V, Rt.get(V.texture).__webglTexture, Rt.get(V.depthTexture).__webglTexture);
        const he = V.texture;
        (he.isData3DTexture || he.isDataArrayTexture || he.isCompressedArrayTexture) && (Xt = !0);
        const ge = Rt.get(V).__webglFramebuffer;
        V.isWebGLCubeRenderTarget ? (Array.isArray(ge[q]) ? tt = ge[q][it] : tt = ge[q], Pt = !0) : V.samples > 0 && Kt.useMultisampledRTT(V) === !1 ? tt = Rt.get(V).__webglMultisampledFramebuffer : Array.isArray(ge) ? tt = ge[it] : tt = ge, M.copy(V.viewport), C.copy(V.scissor), R = V.scissorTest;
      } else
        M.copy(F).multiplyScalar(O).floor(), C.copy(G).multiplyScalar(O).floor(), R = W;
      if (yt.bindFramebuffer(H.FRAMEBUFFER, tt) && Q && yt.drawBuffers(V, tt), yt.viewport(M), yt.scissor(C), yt.setScissorTest(R), Pt) {
        const ae = Rt.get(V.texture);
        H.framebufferTexture2D(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, H.TEXTURE_CUBE_MAP_POSITIVE_X + q, ae.__webglTexture, it);
      } else if (Xt) {
        const ae = Rt.get(V.texture), he = q || 0;
        H.framebufferTextureLayer(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, ae.__webglTexture, it || 0, he);
      }
      A = -1;
    }, this.readRenderTargetPixels = function(V, q, it, Q, tt, Pt, Xt) {
      if (!(V && V.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let $t = Rt.get(V).__webglFramebuffer;
      if (V.isWebGLCubeRenderTarget && Xt !== void 0 && ($t = $t[Xt]), $t) {
        yt.bindFramebuffer(H.FRAMEBUFFER, $t);
        try {
          const ae = V.texture, he = ae.format, ge = ae.type;
          if (!Gt.textureFormatReadable(he)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Gt.textureTypeReadable(ge)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          q >= 0 && q <= V.width - Q && it >= 0 && it <= V.height - tt && H.readPixels(q, it, Q, tt, Ht.convert(he), Ht.convert(ge), Pt);
        } finally {
          const ae = w !== null ? Rt.get(w).__webglFramebuffer : null;
          yt.bindFramebuffer(H.FRAMEBUFFER, ae);
        }
      }
    }, this.copyFramebufferToTexture = function(V, q, it = 0) {
      const Q = Math.pow(2, -it), tt = Math.floor(q.image.width * Q), Pt = Math.floor(q.image.height * Q);
      Kt.setTexture2D(q, 0), H.copyTexSubImage2D(H.TEXTURE_2D, it, 0, 0, V.x, V.y, tt, Pt), yt.unbindTexture();
    }, this.copyTextureToTexture = function(V, q, it, Q = 0) {
      const tt = q.image.width, Pt = q.image.height, Xt = Ht.convert(it.format), $t = Ht.convert(it.type);
      Kt.setTexture2D(it, 0), H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, it.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, it.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, it.unpackAlignment), q.isDataTexture ? H.texSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, tt, Pt, Xt, $t, q.image.data) : q.isCompressedTexture ? H.compressedTexSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, q.mipmaps[0].width, q.mipmaps[0].height, Xt, q.mipmaps[0].data) : H.texSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, Xt, $t, q.image), Q === 0 && it.generateMipmaps && H.generateMipmap(H.TEXTURE_2D), yt.unbindTexture();
    }, this.copyTextureToTexture3D = function(V, q, it, Q, tt = 0) {
      const Pt = V.max.x - V.min.x, Xt = V.max.y - V.min.y, $t = V.max.z - V.min.z, ae = Ht.convert(Q.format), he = Ht.convert(Q.type);
      let ge;
      if (Q.isData3DTexture)
        Kt.setTexture3D(Q, 0), ge = H.TEXTURE_3D;
      else if (Q.isDataArrayTexture || Q.isCompressedArrayTexture)
        Kt.setTexture2DArray(Q, 0), ge = H.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, Q.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, Q.unpackAlignment);
      const be = H.getParameter(H.UNPACK_ROW_LENGTH), pr = H.getParameter(H.UNPACK_IMAGE_HEIGHT), Wr = H.getParameter(H.UNPACK_SKIP_PIXELS), Mn = H.getParameter(H.UNPACK_SKIP_ROWS), ha = H.getParameter(H.UNPACK_SKIP_IMAGES), Pe = it.isCompressedTexture ? it.mipmaps[tt] : it.image;
      H.pixelStorei(H.UNPACK_ROW_LENGTH, Pe.width), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Pe.height), H.pixelStorei(H.UNPACK_SKIP_PIXELS, V.min.x), H.pixelStorei(H.UNPACK_SKIP_ROWS, V.min.y), H.pixelStorei(H.UNPACK_SKIP_IMAGES, V.min.z), it.isDataTexture || it.isData3DTexture ? H.texSubImage3D(ge, tt, q.x, q.y, q.z, Pt, Xt, $t, ae, he, Pe.data) : Q.isCompressedArrayTexture ? H.compressedTexSubImage3D(ge, tt, q.x, q.y, q.z, Pt, Xt, $t, ae, Pe.data) : H.texSubImage3D(ge, tt, q.x, q.y, q.z, Pt, Xt, $t, ae, he, Pe), H.pixelStorei(H.UNPACK_ROW_LENGTH, be), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, pr), H.pixelStorei(H.UNPACK_SKIP_PIXELS, Wr), H.pixelStorei(H.UNPACK_SKIP_ROWS, Mn), H.pixelStorei(H.UNPACK_SKIP_IMAGES, ha), tt === 0 && Q.generateMipmaps && H.generateMipmap(ge), yt.unbindTexture();
    }, this.initTexture = function(V) {
      V.isCubeTexture ? Kt.setTextureCube(V, 0) : V.isData3DTexture ? Kt.setTexture3D(V, 0) : V.isDataArrayTexture || V.isCompressedArrayTexture ? Kt.setTexture2DArray(V, 0) : Kt.setTexture2D(V, 0), yt.unbindTexture();
    }, this.resetState = function() {
      b = 0, S = 0, w = null, yt.reset(), xe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Da;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    e.drawingBufferColorSpace = t === h1 ? "display-p3" : "srgb", e.unpackColorSpace = Fe.workingColorSpace === Og ? "display-p3" : "srgb";
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(t) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t;
  }
}
class zI extends Or {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Fa(), this.environmentIntensity = 1, this.environmentRotation = new Fa(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}
class O4 extends ln {
  constructor(t = null, e = 1, n = 1, i, a, o, s, l, u = Sn, c = Sn, f, h) {
    super(null, o, s, l, u, c, i, a, f, h), this.isDataTexture = !0, this.image = { data: t, width: e, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class zf extends ni {
  constructor(t, e, n, i = 1) {
    super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(t) {
    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
}
const Jl = /* @__PURE__ */ new $e(), fT = /* @__PURE__ */ new $e(), bd = [], hT = /* @__PURE__ */ new bl(), k4 = /* @__PURE__ */ new $e(), Hc = /* @__PURE__ */ new Pn(), Wc = /* @__PURE__ */ new mc();
class B4 extends Pn {
  constructor(t, e, n) {
    super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new zf(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, k4);
  }
  computeBoundingBox() {
    const t = this.geometry, e = this.count;
    this.boundingBox === null && (this.boundingBox = new bl()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Jl), hT.copy(t.boundingBox).applyMatrix4(Jl), this.boundingBox.union(hT);
  }
  computeBoundingSphere() {
    const t = this.geometry, e = this.count;
    this.boundingSphere === null && (this.boundingSphere = new mc()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Jl), Wc.copy(t.boundingSphere).applyMatrix4(Jl), this.boundingSphere.union(Wc);
  }
  copy(t, e) {
    return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  }
  getMorphAt(t, e) {
    const n = e.morphTargetInfluences, i = this.morphTexture.source.data.data, a = n.length + 1, o = t * a + 1;
    for (let s = 0; s < n.length; s++)
      n[s] = i[o + s];
  }
  raycast(t, e) {
    const n = this.matrixWorld, i = this.count;
    if (Hc.geometry = this.geometry, Hc.material = this.material, Hc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Wc.copy(this.boundingSphere), Wc.applyMatrix4(n), t.ray.intersectsSphere(Wc) !== !1))
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, Jl), fT.multiplyMatrices(n, Jl), Hc.matrixWorld = fT, Hc.raycast(t, bd);
        for (let o = 0, s = bd.length; o < s; o++) {
          const l = bd[o];
          l.instanceId = a, l.object = this, e.push(l);
        }
        bd.length = 0;
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null && (this.instanceColor = new zf(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  }
  setMorphAt(t, e) {
    const n = e.morphTargetInfluences, i = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new O4(new Float32Array(i * this.count), i, this.count, mI, Ca));
    const a = this.morphTexture.source.data.data;
    let o = 0;
    for (let u = 0; u < n.length; u++)
      o += n[u];
    const s = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = i * t;
    a[l] = s, a.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
class y1 extends Ph {
  constructor(t) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new le(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
  }
}
const gv = /* @__PURE__ */ new K(), mv = /* @__PURE__ */ new K(), dT = /* @__PURE__ */ new $e(), Xc = /* @__PURE__ */ new d1(), wd = /* @__PURE__ */ new mc(), ly = /* @__PURE__ */ new K(), pT = /* @__PURE__ */ new K();
let V4 = class extends Or {
  constructor(t = new ca(), e = new y1()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [0];
      for (let i = 1, a = e.count; i < a; i++)
        gv.fromBufferAttribute(e, i - 1), mv.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += gv.distanceTo(mv);
      t.setAttribute("lineDistance", new kn(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(t, e) {
    const n = this.geometry, i = this.matrixWorld, a = t.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), wd.copy(n.boundingSphere), wd.applyMatrix4(i), wd.radius += a, t.ray.intersectsSphere(wd) === !1)
      return;
    dT.copy(i).invert(), Xc.copy(t.ray).applyMatrix4(dT);
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = s * s, u = this.isLineSegments ? 2 : 1, c = n.index, h = n.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start), p = Math.min(c.count, o.start + o.count);
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = c.getX(g), y = c.getX(g + 1), _ = Md(this, t, Xc, l, m, y);
        _ && e.push(_);
      }
      if (this.isLineLoop) {
        const g = c.getX(p - 1), v = c.getX(d), m = Md(this, t, Xc, l, g, v);
        m && e.push(m);
      }
    } else {
      const d = Math.max(0, o.start), p = Math.min(h.count, o.start + o.count);
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = Md(this, t, Xc, l, g, g + 1);
        m && e.push(m);
      }
      if (this.isLineLoop) {
        const g = Md(this, t, Xc, l, p - 1, d);
        g && e.push(g);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const i = e[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
};
function Md(r, t, e, n, i, a) {
  const o = r.geometry.attributes.position;
  if (gv.fromBufferAttribute(o, i), mv.fromBufferAttribute(o, a), e.distanceSqToSegment(gv, mv, ly, pT) > n)
    return;
  ly.applyMatrix4(r.matrixWorld);
  const l = t.ray.origin.distanceTo(ly);
  if (!(l < t.near || l > t.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: pT.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: r
    };
}
const vT = /* @__PURE__ */ new K(), gT = /* @__PURE__ */ new K();
class UI extends V4 {
  constructor(t, e) {
    super(t, e), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [];
      for (let i = 0, a = e.count; i < a; i += 2)
        vT.fromBufferAttribute(e, i), gT.fromBufferAttribute(e, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + vT.distanceTo(gT);
      t.setAttribute("lineDistance", new kn(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class GI extends Or {
  constructor(t, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new le(t), this.intensity = e;
  }
  dispose() {
  }
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
}
const uy = /* @__PURE__ */ new $e(), mT = /* @__PURE__ */ new K(), yT = /* @__PURE__ */ new K();
class F4 {
  constructor(t) {
    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ce(512, 512), this.map = null, this.mapPass = null, this.matrix = new $e(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new g1(), this._frameExtents = new Ce(1, 1), this._viewportCount = 1, this._viewports = [
      new Nr(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera, n = this.matrix;
    mT.setFromMatrixPosition(t.matrixWorld), e.position.copy(mT), yT.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(yT), e.updateMatrixWorld(), uy.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(uy), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(uy);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
}
class z4 extends F4 {
  constructor() {
    super(new II(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class HI extends GI {
  constructor(t, e) {
    super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Or.DEFAULT_UP), this.updateMatrix(), this.target = new Or(), this.shadow = new z4();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}
class WI extends GI {
  constructor(t, e) {
    super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
const _T = /* @__PURE__ */ new $e();
class XI {
  constructor(t, e, n = 0, i = 1 / 0) {
    this.ray = new d1(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new p1(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  setFromXRController(t) {
    return _T.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_T), this;
  }
  intersectObject(t, e = !0, n = []) {
    return Z_(t, this, n, e), n.sort(xT), n;
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, a = t.length; i < a; i++)
      Z_(t[i], this, n, e);
    return n.sort(xT), n;
  }
}
function xT(r, t) {
  return r.distance - t.distance;
}
function Z_(r, t, e, n) {
  if (r.layers.test(t.layers) && r.raycast(t, e), n === !0) {
    const i = r.children;
    for (let a = 0, o = i.length; a < o; a++)
      Z_(i[a], t, e, !0);
  }
}
class tct {
  constructor(t = 1, e = 0, n = 0) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  set(t, e, n) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  copy(t) {
    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(on(e / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class YI extends UI {
  constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
    n = new le(n), i = new le(i);
    const a = e / 2, o = t / e, s = t / 2, l = [], u = [];
    for (let h = 0, d = 0, p = -s; h <= e; h++, p += o) {
      l.push(-s, 0, p, s, 0, p), l.push(p, 0, -s, p, 0, s);
      const g = h === a ? n : i;
      g.toArray(u, d), d += 3, g.toArray(u, d), d += 3, g.toArray(u, d), d += 3, g.toArray(u, d), d += 3;
    }
    const c = new ca();
    c.setAttribute("position", new kn(l, 3)), c.setAttribute("color", new kn(u, 3));
    const f = new y1({ vertexColors: !0, toneMapped: !1 });
    super(c, f), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class $I extends UI {
  constructor(t = 1) {
    const e = [
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      0,
      t
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new ca();
    i.setAttribute("position", new kn(e, 3)), i.setAttribute("color", new kn(n, 3));
    const a = new y1({ vertexColors: !0, toneMapped: !1 });
    super(i, a), this.type = "AxesHelper";
  }
  setColors(t, e, n) {
    const i = new le(), a = this.geometry.attributes.color.array;
    return i.set(t), i.toArray(a, 0), i.toArray(a, 3), i.set(e), i.toArray(a, 6), i.toArray(a, 9), i.set(n), i.toArray(a, 12), i.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: f1
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = f1);
const U4 = ["innerHTML"], G4 = /* @__PURE__ */ c1({
  name: "JBHeatMap3D",
  __name: "HeatMap",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    width: { type: Number, default: 600 },
    height: { type: Number, default: 500 },
    baseSize: { type: Number, default: 0.1 },
    maxHeight: { type: Number, default: 3 },
    enableOrbit: { type: Boolean, default: !0 },
    backgroundColor: { type: String, default: "#0d1b2a" },
    showGridHelper: { type: Boolean, default: !0 },
    showAxesHelper: { type: Boolean, default: !0 },
    isStandardColor: { type: Boolean, default: !0 },
    rotateAnimation: { type: Boolean, default: !1 },
    // 
    rotationSpeed: { type: Number, default: 0.01 },
    // 
    gradientColors: {
      type: Array,
      default: () => ["#9b30ff", "#00ffff", "#ffff00", "#ff0000"]
    },
    autoAnimate: { type: Boolean, default: !1 },
    cameraPosition: {
      type: Object,
      default: () => ({ x: 5, y: 5, z: 5 })
    }
  },
  setup(r, { expose: t }) {
    const e = Ir(0), n = r, i = Ir(null), a = Ir({ show: !1, x: 0, y: 0, content: "" }), o = Ir(n.autoAnimate);
    let s, l, u, c = null, f, h, d, p = null, g = [], v = 0, m = 0;
    Rg(async () => {
      const { OrbitControls: R } = await import("./OrbitControls-D3EIFnCR.js");
      y(), n.enableOrbit && (c = new R(l, u.domElement), c.enableDamping = !0, c.dampingFactor = 0.05), A(), window.addEventListener("mousemove", M), window.addEventListener("resize", C), i.value && i.value.addEventListener("mouseleave", () => {
        a.value.show = !1;
      });
    }), uI(() => {
      p && cancelAnimationFrame(p), window.removeEventListener("mousemove", M), window.removeEventListener("resize", C), u.dispose();
    });
    function y() {
      const { backgroundColor: R, showGridHelper: E, showAxesHelper: D, cameraPosition: I } = n;
      s = new zI(), s.background = new le(R), l = new Rn(75, n.width / n.height, 0.1, 1e3), l.position.set(I.x, I.y, I.z), u = new FI({ antialias: !0 }), u.setSize(n.width, n.height), u.shadowMap.enabled = !0, i.value && i.value.appendChild(u.domElement), n.enableOrbit && c && (c.enableDamping = !0, c.dampingFactor = 0.05), s.add(new WI(16777215, 0.6));
      const P = new HI(16777215, 0.8);
      if (P.position.set(10, 20, 5), s.add(P), f = new Pu(), s.add(f), E) {
        const O = Math.max(v, m) * n.baseSize * 1.2, N = new YI(O, Math.max(v, m), 4473924, 2236962);
        s.add(N);
      }
      if (D) {
        const O = new $I(Math.max(v, m) * n.baseSize * 0.6);
        s.add(O);
      }
      h = new XI(), d = new Ce(), w();
    }
    function _(R = 10, E = 10) {
      return Array.from({ length: R }, () => Array.from({ length: E }, () => Math.random() * 15 + 1));
    }
    function x(R, E, D, I, P, O) {
      const N = 0.1 + (D - I) / (P - I) * n.maxHeight, B = new wl(n.baseSize, N, n.baseSize, 1, 8, 1), F = B.attributes.position, G = B.attributes.normal, W = [], J = (D - I) / (P - I), U = [
        new le(536927),
        // 
        new le(4556987),
        // 
        new le(8765155),
        // 
        new le(12508404),
        // 
        new le(14997468),
        // 
        new le(16572378),
        // 
        new le(16365218),
        // 
        new le(16349280),
        // 
        new le(13112870),
        // 
        new le(11468815)
        // 
      ];
      let Y = [], at = 0;
      J >= 0.9 ? (at = 10, Y = U.slice(0, 10)) : J >= 0.8 ? (at = 9, Y = U.slice(0, 9)) : J >= 0.7 ? (at = 8, Y = U.slice(0, 8)) : J >= 0.6 ? (at = 7, Y = U.slice(0, 7)) : J >= 0.5 ? (at = 6, Y = U.slice(0, 6)) : J >= 0.4 ? (at = 5, Y = U.slice(0, 5)) : J >= 0.3 ? (at = 4, Y = U.slice(0, 4)) : J >= 0.2 ? (at = 3, Y = U.slice(0, 3)) : J >= 0.1 ? (at = 2, Y = U.slice(0, 2)) : (at = 1, Y = U.slice(0, 1));
      for (let lt = 0; lt < F.count; lt++) {
        const H = F.getY(lt), ct = G.getY(lt);
        let ot = new le();
        const Gt = Math.max(0, Math.min(1, (H + N / 2) / N));
        if (ct > 0.5)
          ot.copy(Y[Y.length - 1]);
        else if (at === 1)
          ot.copy(Y[0]);
        else {
          const yt = 1 / (at - 1);
          let Mt = Math.floor(Gt / yt);
          Mt = Math.min(Mt, at - 2), Mt = Math.max(0, Mt);
          const Rt = (Gt - Mt * yt) / yt;
          Mt >= 0 && Mt + 1 < Y.length ? ot.lerpColors(Y[Mt], Y[Mt + 1], Rt) : ot.copy(Y[Y.length - 1]);
        }
        W.push(ot.r, ot.g, ot.b);
      }
      B.setAttribute("color", new ni(new Float32Array(W), 3));
      const st = new v1({ vertexColors: !0 }), ut = new Pn(B, st);
      return ut.position.set((R - (v - 1) / 2) * n.baseSize, N / 2, (E - (m - 1) / 2) * n.baseSize), ut.userData = { value: D, x: R, z: E }, ut;
    }
    let b = null;
    new Or();
    function S() {
      if (b)
        b.geometry.dispose(), b.material.dispose(), f.remove(b), b = null;
      else {
        const { children: R } = f;
        R.forEach((E) => {
          E instanceof Pn && (E.geometry.dispose(), (Array.isArray(E.material) ? E.material : [E.material]).forEach((I) => I.dispose()));
        }), f.clear();
      }
    }
    function w() {
      var I;
      if (S(), Array.isArray(n.data) && n.data.length > 0 && n.data.every((P) => Array.isArray(P)) ? g = n.data.map((P) => [...P]) : (console.log(""), g = _()), f.clear(), v = g.length, m = ((I = g[0]) == null ? void 0 : I.length) || 0, v === 0 || m === 0) {
        console.warn("");
        return;
      }
      let E = 1 / 0, D = -1 / 0;
      for (let P = 0; P < v; P++) {
        const O = g[P];
        if (Array.isArray(O))
          for (let N = 0; N < m; N++) {
            const B = O[N];
            typeof B == "number" && (B < E && (E = B), B > D && (D = B));
          }
      }
      E === 1 / 0 && (E = 0), D === -1 / 0 && (D = 0);
      for (let P = 0; P < v; P++) {
        const O = g[P];
        if (Array.isArray(O))
          for (let N = 0; N < m; N++) {
            const B = O[N], F = typeof B == "number" ? B : 0;
            let G = null;
            n.isStandardColor, G = x(P, N, F, E, D), f.add(G);
          }
      }
    }
    function A() {
      p = requestAnimationFrame(A), n.rotateAnimation && (e.value += n.rotationSpeed, f.rotation.y = e.value), c && c.update(), u.render(s, l);
    }
    let T = null;
    function M(R) {
      if (!i.value)
        return;
      const E = i.value.getBoundingClientRect();
      if (R.clientX < E.left || R.clientX > E.right || R.clientY < E.top || R.clientY > E.bottom) {
        a.value.show = !1;
        return;
      }
      T && cancelAnimationFrame(T), T = requestAnimationFrame(() => {
        d.x = (R.clientX - E.left) / E.width * 2 - 1, d.y = -((R.clientY - E.top) / E.height) * 2 + 1, h.setFromCamera(d, l);
        const D = h.intersectObjects(f.children);
        if (D.length) {
          const I = D[0].object, { value: P, x: O, z: N } = I.userData;
          a.value = {
            show: !0,
            x: R.clientX - E.left + 10,
            y: R.clientY - E.top - 30,
            content: `: ${P.toFixed(2)}<br>: (${O}, ${N})`
          };
        } else
          a.value.show = !1;
      });
    }
    function C() {
      l.aspect = n.width / n.height, l.updateProjectionMatrix(), u.setSize(n.width, n.height);
    }
    return t({
      refresh: w,
      toggleAnimation: () => o.value = !o.value
    }), (R, E) => (Ia(), Lo("div", {
      class: "heatmap-wrapper",
      style: qu({ width: r.width + "px", height: r.height + "px" })
    }, [
      Wi(a).show ? (Ia(), Lo("div", {
        key: 0,
        class: "tooltip",
        style: qu({ left: Wi(a).x + "px", top: Wi(a).y + "px" }),
        innerHTML: Wi(a).content
      }, null, 12, U4)) : uv("", !0),
      br("div", {
        ref_key: "containerRef",
        ref: i,
        class: "three-container"
      }, null, 512)
    ], 4));
  }
}), H4 = /* @__PURE__ */ Ig(G4, [["__scopeId", "data-v-72c1b72e"]]), W4 = Dh(H4), X4 = ["innerHTML"], Y4 = /* @__PURE__ */ c1({
  name: "JBHeatMap3DUV",
  __name: "HeatMap2",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    width: { type: Number, default: 600 },
    height: { type: Number, default: 500 },
    baseSize: { type: Number, default: 0.1 },
    maxHeight: { type: Number, default: 3 },
    enableOrbit: { type: Boolean, default: !0 },
    backgroundColor: { type: String, default: "#0d1b2a" },
    showGridHelper: { type: Boolean, default: !0 },
    showAxesHelper: { type: Boolean, default: !0 },
    gradientColors: {
      type: Array,
      default: () => ["#00008b", "#00ffff", "#ffff00", "#ff0000"]
    },
    autoAnimate: { type: Boolean, default: !1 },
    cameraPosition: {
      type: Object,
      default: () => ({ x: 8, y: 8, z: 8 })
    }
  },
  setup(r, { expose: t }) {
    const e = r, n = Ir(null), i = Ir({ show: !1, x: 0, y: 0, content: "" }), a = Ir(e.autoAnimate);
    let o, s, l, u = null, c, f, h, d = null, p = null;
    const g = [];
    let v = 0, m = 0, y;
    Rg(async () => {
      x();
      const { OrbitControls: D } = await import("./OrbitControls-D3EIFnCR.js");
      e.enableOrbit && (u = new D(s, l.domElement), u.enableDamping = !0, u.dampingFactor = 0.05), M(), window.addEventListener("mousemove", R), window.addEventListener("resize", E), n.value && n.value.addEventListener("mouseleave", () => {
        i.value.show = !1;
      });
    }), uI(() => {
      d && cancelAnimationFrame(d), window.removeEventListener("mousemove", R), window.removeEventListener("resize", E), p && (p.geometry.dispose(), p.material.dispose()), y && y.dispose(), l == null || l.dispose();
    });
    function _() {
      console.log("...");
      const D = [
        new K(0.0314, 0.1922, 0.3725),
        // #08315f 
        new K(0.2706, 0.5333, 0.7333),
        // #4588bb 
        new K(0.5216, 0.7451, 0.8902),
        // #85bee3 
        new K(0.7451, 0.8627, 0.9569),
        // #bedcf4 
        new K(0.8941, 0.8431, 0.8627),
        // #e4d7dc 
        new K(0.9882, 0.8745, 0.8549),
        // #fcdfda 
        new K(0.9765, 0.7137, 0.6353),
        // #f9b6a2 
        new K(0.9765, 0.4706, 0.3765),
        // #f97860 
        new K(0.7843, 0.0863, 0.149),
        // #c81626 
        new K(0.6863, 0, 0.0588)
        // #af000f 
      ], I = new za({
        uniforms: {
          color0: { value: D[0] },
          color1: { value: D[1] },
          color2: { value: D[2] },
          color3: { value: D[3] },
          color4: { value: D[4] },
          color5: { value: D[5] },
          color6: { value: D[6] },
          color7: { value: D[7] },
          color8: { value: D[8] },
          color9: { value: D[9] },
          baseSize: { value: e.baseSize },
          maxHeight: { value: e.maxHeight }
        },
        vertexShader: `
            attribute float instanceValue;
            attribute vec3 instancePosition;
            attribute vec3 instanceScale;

            varying float vValue;
            varying float vHeight;
            varying vec3 vPosition;

            void main() {
                vValue = instanceValue;
                vPosition = position;

                //  (01)
                vHeight = (position.y + 0.5); // y-0.50.5

                // 
                vec3 transformed = position * instanceScale;
                transformed += instancePosition;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 color0;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            uniform vec3 color4;
            uniform vec3 color5;
            uniform vec3 color6;
            uniform vec3 color7;
            uniform vec3 color8;
            uniform vec3 color9;

            varying float vValue;
            varying float vHeight;
            varying vec3 vPosition;

            vec3 getGradientColor(float value, float height) {
                // 
                if (value < 0.1) {
                    // 
                    return color0;
                } else if (value < 0.2) {
                    // 2
                    return mix(color0, color1, height);
                } else if (value < 0.3) {
                    // 3
                    if (height < 0.5) {
                        return mix(color0, color1, height / 0.5);
                    } else {
                        return mix(color1, color2, (height - 0.5) / 0.5);
                    }
                } else if (value < 0.4) {
                    // 4
                    if (height < 0.33) {
                        return mix(color0, color1, height / 0.33);
                    } else if (height < 0.66) {
                        return mix(color1, color2, (height - 0.33) / 0.33);
                    } else {
                        return mix(color2, color3, (height - 0.66) / 0.34);
                    }
                } else if (value < 0.5) {
                    // 5
                    if (height < 0.25) {
                        return mix(color0, color1, height / 0.25);
                    } else if (height < 0.5) {
                        return mix(color1, color2, (height - 0.25) / 0.25);
                    } else if (height < 0.75) {
                        return mix(color2, color3, (height - 0.5) / 0.25);
                    } else {
                        return mix(color3, color4, (height - 0.75) / 0.25);
                    }
                } else if (value < 0.6) {
                    // 6
                    if (height < 0.2) {
                        return mix(color0, color1, height / 0.2);
                    } else if (height < 0.4) {
                        return mix(color1, color2, (height - 0.2) / 0.2);
                    } else if (height < 0.6) {
                        return mix(color2, color3, (height - 0.4) / 0.2);
                    } else if (height < 0.8) {
                        return mix(color3, color4, (height - 0.6) / 0.2);
                    } else {
                        return mix(color4, color5, (height - 0.8) / 0.2);
                    }
                } else if (value < 0.7) {
                    // 7
                    if (height < 0.1667) {
                        return mix(color0, color1, height / 0.1667);
                    } else if (height < 0.3333) {
                        return mix(color1, color2, (height - 0.1667) / 0.1667);
                    } else if (height < 0.5) {
                        return mix(color2, color3, (height - 0.3333) / 0.1667);
                    } else if (height < 0.6667) {
                        return mix(color3, color4, (height - 0.5) / 0.1667);
                    } else if (height < 0.8333) {
                        return mix(color4, color5, (height - 0.6667) / 0.1667);
                    } else {
                        return mix(color5, color6, (height - 0.8333) / 0.1667);
                    }
                } else if (value < 0.8) {
                    // 8
                    if (height < 0.1429) {
                        return mix(color0, color1, height / 0.1429);
                    } else if (height < 0.2857) {
                        return mix(color1, color2, (height - 0.1429) / 0.1429);
                    } else if (height < 0.4286) {
                        return mix(color2, color3, (height - 0.2857) / 0.1429);
                    } else if (height < 0.5714) {
                        return mix(color3, color4, (height - 0.4286) / 0.1429);
                    } else if (height < 0.7143) {
                        return mix(color4, color5, (height - 0.5714) / 0.1429);
                    } else if (height < 0.8571) {
                        return mix(color5, color6, (height - 0.7143) / 0.1429);
                    } else {
                        return mix(color6, color7, (height - 0.8571) / 0.1429);
                    }
                } else if (value < 0.9) {
                    // 9
                    if (height < 0.125) {
                        return mix(color0, color1, height / 0.125);
                    } else if (height < 0.25) {
                        return mix(color1, color2, (height - 0.125) / 0.125);
                    } else if (height < 0.375) {
                        return mix(color2, color3, (height - 0.25) / 0.125);
                    } else if (height < 0.5) {
                        return mix(color3, color4, (height - 0.375) / 0.125);
                    } else if (height < 0.625) {
                        return mix(color4, color5, (height - 0.5) / 0.125);
                    } else if (height < 0.75) {
                        return mix(color5, color6, (height - 0.625) / 0.125);
                    } else if (height < 0.875) {
                        return mix(color6, color7, (height - 0.75) / 0.125);
                    } else {
                        return mix(color7, color8, (height - 0.875) / 0.125);
                    }
                } else {
                    // 10
                    if (height < 0.1111) {
                        return mix(color0, color1, height / 0.1111);
                    } else if (height < 0.2222) {
                        return mix(color1, color2, (height - 0.1111) / 0.1111);
                    } else if (height < 0.3333) {
                        return mix(color2, color3, (height - 0.2222) / 0.1111);
                    } else if (height < 0.4444) {
                        return mix(color3, color4, (height - 0.3333) / 0.1111);
                    } else if (height < 0.5556) {
                        return mix(color4, color5, (height - 0.4444) / 0.1111);
                    } else if (height < 0.6667) {
                        return mix(color5, color6, (height - 0.5556) / 0.1111);
                    } else if (height < 0.7778) {
                        return mix(color6, color7, (height - 0.6667) / 0.1111);
                    } else if (height < 0.8889) {
                        return mix(color7, color8, (height - 0.7778) / 0.1111);
                    } else {
                        return mix(color8, color9, (height - 0.8889) / 0.1111);
                    }
                }
            }

            void main() {
                // 
                vec3 lightDir = normalize(vec3(1.0, 2.0, 0.5));
                vec3 normal;

                // 
                if (abs(vPosition.y) > 0.49) {
                    normal = vec3(0.0, sign(vPosition.y), 0.0);
                } else if (abs(vPosition.x) > 0.49) {
                    normal = vec3(sign(vPosition.x), 0.0, 0.0);
                } else {
                    normal = vec3(0.0, 0.0, sign(vPosition.z));
                }

                float diffuse = max(dot(normal, lightDir), 0.3);

                // 
                float topBrightness = vPosition.y > 0.4 ? 1.2 : 1.0;

                // 
                vec3 gradientColor = getGradientColor(vValue, vHeight);

                gl_FragColor = vec4(gradientColor * diffuse * topBrightness, 1.0);
            }
        `,
        transparent: !1
      });
      return console.log(""), I;
    }
    function x() {
      console.log(" Three.js...");
      const { backgroundColor: D, showGridHelper: I, showAxesHelper: P, cameraPosition: O, enableOrbit: N } = e;
      o = new zI(), o.background = new le(D), console.log(":", D), s = new Rn(75, e.width / e.height, 0.1, 1e3), s.position.set(O.x, O.y, O.z), console.log(":", O), l = new FI({
        antialias: !0,
        powerPreference: "high-performance"
      }), l.setSize(e.width, e.height), l.setPixelRatio(Math.min(window.devicePixelRatio, 2)), console.log(":", e.width, "x", e.height), n.value && (n.value.innerHTML = "", n.value.appendChild(l.domElement), console.log("DOM"));
      const B = new WI(16777215, 0.8);
      o.add(B);
      const F = new HI(16777215, 0.8);
      F.position.set(5, 10, 5), o.add(F), console.log(""), c = new Pu(), o.add(c), console.log(""), f = new XI(), h = new Ce(), S(), console.log("Three.js ");
    }
    function b() {
      return new wl(1, 1, 1, 1, 8, 1);
    }
    function S() {
      var U;
      console.log("..."), p && (c.remove(p), p.geometry.dispose(), p.material.dispose(), p = null, console.log("")), g.length = 0;
      let D = e.data;
      Array.isArray(D) && D.length > 0 && D.every((Y) => Array.isArray(Y) && Y.length > 0) || (console.log(""), D = [
        [1, 3, 5, 7, 9],
        [2, 4, 6, 8, 10],
        [3, 5, 7, 9, 11],
        [4, 6, 8, 10, 12],
        [5, 7, 9, 11, 13]
      ]), v = D.length, m = ((U = D[0]) == null ? void 0 : U.length) || 0, console.log(`: ${v} x ${m}`, ":", D);
      let P = 1 / 0, O = -1 / 0;
      for (let Y = 0; Y < v; Y++) {
        const at = D[Y];
        if (Array.isArray(at))
          for (let st = 0; st < m; st++) {
            const ut = at[st];
            typeof ut == "number" && (ut < P && (P = ut), ut > O && (O = ut));
          }
      }
      P === 1 / 0 && (P = 0), O === -1 / 0 && (O = 1), P === O && (O = P + 1), console.log(`: ${P} - ${O}`), y = _();
      const N = b(), B = v * m, F = new Float32Array(B), G = new Float32Array(B * 3), W = new Float32Array(B * 3);
      let J = 0;
      for (let Y = 0; Y < v; Y++) {
        const at = D[Y];
        if (Array.isArray(at))
          for (let st = 0; st < m; st++) {
            const ut = typeof at[st] == "number" ? at[st] : 0, lt = (ut - P) / (O - P), H = 0.1 + lt * e.maxHeight;
            F[J] = lt;
            const ct = (Y - (v - 1) / 2) * e.baseSize, ot = (st - (m - 1) / 2) * e.baseSize, Gt = H / 2;
            G[J * 3] = ct, G[J * 3 + 1] = Gt, G[J * 3 + 2] = ot, W[J * 3] = e.baseSize, W[J * 3 + 1] = H, W[J * 3 + 2] = e.baseSize, g[J] = {
              value: ut,
              x: Y,
              z: st,
              normalizedValue: lt
            }, J++;
          }
      }
      console.log(` ${B} `), N.setAttribute("instanceValue", new zf(F, 1)), N.setAttribute("instancePosition", new zf(G, 3)), N.setAttribute("instanceScale", new zf(W, 3)), p = new B4(N, y, B), c.add(p), T(), console.log("");
    }
    let w = null, A = null;
    function T() {
      w && (o.remove(w), w = null), A && (o.remove(A), A = null);
      const { showGridHelper: D, showAxesHelper: I } = e;
      if (D) {
        const P = Math.max(v, m) * e.baseSize * 1.5, O = Math.max(v, m);
        w = new YI(P, O, 16777215, 8947848), w.position.y = -0.01, o.add(w);
      }
      if (I) {
        const P = Math.max(v, m) * e.baseSize * 0.8;
        A = new $I(P), o.add(A);
      }
    }
    function M() {
      d = requestAnimationFrame(M), u && u.update(), l.render(o, s);
    }
    let C = null;
    function R(D) {
      if (!n.value || !p)
        return;
      const I = n.value.getBoundingClientRect();
      if (D.clientX < I.left || D.clientX > I.right || D.clientY < I.top || D.clientY < I.bottom) {
        i.value.show = !1;
        return;
      }
      C && cancelAnimationFrame(C), C = requestAnimationFrame(() => {
        h.x = (D.clientX - I.left) / I.width * 2 - 1, h.y = -((D.clientY - I.top) / I.height) * 2 + 1, f.setFromCamera(h, s);
        const P = f.intersectObject(p);
        if (P.length > 0) {
          const O = P[0].instanceId;
          if (O !== void 0 && g[O]) {
            const N = g[O];
            i.value = {
              show: !0,
              x: D.clientX - I.left + 10,
              y: D.clientY - I.top - 30,
              content: `: ${N.value.toFixed(2)}<br>: (${N.x}, ${N.z})<br>: ${(N.normalizedValue * 100).toFixed(1)}%`
            };
          }
        } else
          i.value.show = !1;
      });
    }
    function E() {
      !s || !l || (s.aspect = e.width / e.height, s.updateProjectionMatrix(), l.setSize(e.width, e.height));
    }
    return t({
      refresh: S,
      toggleAnimation: () => a.value = !a.value,
      updateData: (D) => {
        S();
      }
    }), (D, I) => (Ia(), Lo("div", {
      class: "heatmap-wrapper",
      style: qu({ width: r.width + "px", height: r.height + "px" })
    }, [
      Wi(i).show ? (Ia(), Lo("div", {
        key: 0,
        class: "tooltip",
        style: qu({ left: Wi(i).x + "px", top: Wi(i).y + "px" }),
        innerHTML: Wi(i).content
      }, null, 12, X4)) : uv("", !0),
      br("div", {
        ref_key: "containerRef",
        ref: n,
        class: "three-container"
      }, null, 512)
    ], 4));
  }
}), $4 = /* @__PURE__ */ Ig(Y4, [["__scopeId", "data-v-1db22db8"]]), Z4 = Dh($4), q4 = { class: "heatmap-container" }, K4 = { class: "coordinates" }, j4 = {
  key: 0,
  class: "controls"
}, J4 = { class: "data-info" }, Q4 = {
  key: 1,
  class: "legend"
}, tW = /* @__PURE__ */ Object.assign({ name: "HeatMap2D" }, {
  __name: "HeatMap2D",
  props: {
    width: { type: Number, default: 612 },
    height: { type: Number, default: 831 },
    blockWidth: { type: Number, default: 36 },
    blockHeight: { type: Number, default: 36 },
    refreshTrigger: { type: [Number, String, Boolean], default: null },
    // 
    showControls: { type: Boolean, default: !1 },
    showLegend: { type: Boolean, default: !1 },
    heatmapData: { type: Array, default: () => [] }
  },
  setup(r) {
    const t = r, e = Ir(t.width ? t.width : 0), n = Ir(t.height), i = Ir(t.blockWidth), a = Ir(t.blockHeight), o = Ir(null);
    let s = null;
    const l = Ir(0), u = Ir(0), c = Ir([]), f = Ir(0), h = Ir(0), d = pF({
      visible: !1,
      x: 0,
      y: 0,
      col: 0,
      row: 0,
      value: 0,
      rawX: 0,
      rawY: 0
    });
    let p = !1;
    const g = [
      { threshold: 0.1, color: "#08315f" },
      { threshold: 0.2, color: "#4588bb" },
      { threshold: 0.3, color: "#85bee3" },
      { threshold: 0.4, color: "#bedcf4" },
      { threshold: 0.5, color: "#e4d7dc" },
      { threshold: 0.6, color: "#fcdfda" },
      { threshold: 0.7, color: "#f9b6a2" },
      { threshold: 0.8, color: "#f97860" },
      { threshold: 0.9, color: "#c81626" },
      { threshold: 1, color: "#af000f" }
    ];
    Fp(
      () => t.heatmapData,
      (D) => {
        c.value = D, S();
      },
      { deep: !0 }
    );
    function v(D, I) {
      if (I === 0)
        return "transparent";
      const P = D / I;
      for (let O of g)
        if (P <= O.threshold)
          return O.color;
      return g[g.length - 1].color;
    }
    const m = Vp(() => {
      var I;
      let D = 0;
      for (let P = 0; P < u.value; P++)
        for (let O = 0; O < l.value; O++)
          ((I = c.value[P]) == null ? void 0 : I[O]) > 0 && D++;
      return D;
    }), y = Vp(() => {
      var I;
      let D = 0;
      for (let P = 0; P < u.value; P++)
        for (let O = 0; O < l.value; O++) {
          const N = ((I = c.value[P]) == null ? void 0 : I[O]) || 0;
          N > D && (D = N);
        }
      return D;
    }), _ = Vp(() => {
      var P;
      let D = 0, I = 0;
      for (let O = 0; O < u.value; O++)
        for (let N = 0; N < l.value; N++) {
          const B = ((P = c.value[O]) == null ? void 0 : P[N]) || 0;
          B > 0 && (D += B, I++);
        }
      return I > 0 ? D / I : 0;
    });
    function x() {
      l.value = Math.ceil(e.value / i.value), u.value = Math.ceil(n.value / a.value);
    }
    function b() {
      c.value = Array(u.value).fill().map(() => Array(l.value).fill(0));
    }
    function S() {
      var D;
      if (s) {
        s.clearRect(0, 0, e.value, n.value);
        for (let I = 0; I < u.value; I++)
          for (let P = 0; P < l.value; P++) {
            const O = ((D = c.value[I]) == null ? void 0 : D[P]) || 0;
            if (O > 0) {
              const N = P * i.value, B = I * a.value;
              s.fillStyle = v(O, y.value), s.fillRect(N, B, i.value, a.value);
            }
          }
      }
    }
    function w(D, I, P, O) {
      for (let N = 0; N < u.value; N++)
        for (let B = 0; B < l.value; B++) {
          const F = B * i.value + i.value / 2, G = N * a.value + a.value / 2, W = Math.sqrt((F - D) ** 2 + (G - I) ** 2);
          if (W < P) {
            const J = O * (1 - W / P);
            c.value[N][B] = Math.max(c.value[N][B], Math.floor(J));
          }
        }
    }
    function A(D, I, P, O) {
      const N = Math.floor(D / i.value), B = Math.floor(I / a.value), F = Math.ceil(P / Math.max(i.value, a.value)), G = Math.max(0, N - F), W = Math.min(l.value - 1, N + F), J = Math.max(0, B - F), U = Math.min(u.value - 1, B + F);
      for (let Y = J; Y <= U; Y++)
        for (let at = G; at <= W; at++) {
          const ut = Math.sqrt((at - N) ** 2 + (Y - B) ** 2) * Math.max(i.value, a.value);
          if (ut < P) {
            const lt = O * (1 - ut / P);
            c.value[Y][at] = Math.max(c.value[Y][at], Math.floor(lt));
          }
        }
      S();
    }
    function T() {
      for (let D = 0; D < u.value; D++)
        for (let I = 0; I < l.value; I++)
          c.value[D][I] = Math.random() < 0.1 ? Math.floor(Math.random() * 100) : 0;
      S();
    }
    function M() {
      C(), w(0.1 * e.value, 0.1 * n.value, 50, 90), w(0.3 * e.value, 0.2 * n.value, 40, 80), w(0.2 * e.value, 0.5 * n.value, 60, 95), S();
    }
    function C() {
      c.value.forEach((D) => D.fill(0)), S();
    }
    function R(D) {
      var F;
      const I = o.value.getBoundingClientRect(), P = D.clientX - I.left, O = D.clientY - I.top;
      f.value = Math.floor(P), h.value = Math.floor(O);
      const N = Math.floor(P / i.value), B = Math.floor(O / a.value);
      N >= 0 && N < l.value && B >= 0 && B < u.value ? (d.visible = !0, d.col = N, d.row = B, d.value = ((F = c.value[B]) == null ? void 0 : F[N]) || 0, d.rawX = P, d.rawY = O, d.x = D.clientX + 15, d.y = D.clientY - 30) : d.visible = !1, p && A(P, O, 15, 60);
    }
    function E() {
      p = !1, d.visible = !1;
    }
    return Rg(() => {
      const D = o.value;
      D.width = t.width, D.height = t.height, s = D.getContext("2d"), x(), t.heatmapData && t.heatmapData.length > 0 ? c.value = t.heatmapData : b(), S();
    }), Fp(
      () => [t.width, t.height, t.blockWidth, t.blockHeight],
      () => {
        e.value = t.width, n.value = t.height, i.value = t.blockWidth, a.value = t.blockHeight, vF(() => {
          const D = o.value;
          D && (D.width = e.value, D.height = n.value, s = D.getContext("2d"), x(), S());
        });
      }
      //  { immediate: true }
    ), Fp(
      () => t.refreshTrigger,
      () => {
        t.refreshTrigger !== null && S();
      }
    ), (D, I) => (Ia(), Lo("div", q4, [
      br("div", {
        class: "canvas-wrapper",
        style: qu({ width: `${e.value}px`, height: `${n.value}px` })
      }, [
        br("canvas", {
          ref_key: "heatmapCanvas",
          ref: o,
          onMousemove: R,
          onMouseleave: E,
          onContextmenu: I[0] || (I[0] = gF(() => {
          }, ["prevent"]))
        }, null, 544),
        br("div", K4, "X: " + Tn(f.value) + ", Y: " + Tn(h.value), 1),
        br("div", {
          class: mF(["tooltip", { show: d.visible }]),
          style: qu({ left: d.x + "px", top: d.y + "px" })
        }, [
          I[1] || (I[1] = br("h3", null, "", -1)),
          br("p", null, ": (" + Tn(d.col) + ", " + Tn(d.row) + ")", 1),
          br("p", null, ": " + Tn(d.value), 1),
          br("p", null, ": (" + Tn(Math.floor(d.rawX)) + ", " + Tn(Math.floor(d.rawY)) + ")", 1)
        ], 6)
      ], 4),
      t.showControls ? (Ia(), Lo("div", j4, [
        br("div", J4, " : " + Tn(l.value) + "  " + Tn(u.value) + " ( " + Tn(l.value * u.value) + " ) : " + Tn(m.value) + " : " + Tn(y.value) + " : " + Tn(_.value.toFixed(2)), 1),
        br("div", { class: "btn-group" }, [
          br("button", { onClick: T }, ""),
          br("button", { onClick: M }, ""),
          br("button", { onClick: C }, "")
        ])
      ])) : uv("", !0),
      t.showLegend ? (Ia(), Lo("div", Q4, [...I[2] || (I[2] = [
        br("div", { class: "color-scale" }, null, -1),
        br("div", { class: "color-labels" }, [
          br("span", null, ""),
          br("span", null, "")
        ], -1)
      ])])) : uv("", !0)
    ]));
  }
}), eW = /* @__PURE__ */ Ig(tW, [["__scopeId", "data-v-fa92eb4d"]]), rW = Dh(eW);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var q_ = function(r, t) {
  return q_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, n) {
    e.__proto__ = n;
  } || function(e, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
  }, q_(r, t);
};
function $(r, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  q_(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var nW = /* @__PURE__ */ function() {
  function r() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return r;
}(), iW = /* @__PURE__ */ function() {
  function r() {
    this.browser = new nW(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return r;
}(), oe = new iW();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (oe.wxa = !0, oe.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? oe.worker = !0 : !oe.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (oe.node = !0, oe.svgSupported = !0) : aW(navigator.userAgent, oe);
function aW(r, t) {
  var e = t.browser, n = r.match(/Firefox\/([\d.]+)/), i = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
  n && (e.firefox = !0, e.version = n[1]), i && (e.ie = !0, e.version = i[1]), a && (e.edge = !0, e.version = a[1], e.newEdge = +a[1].split(".")[0] > 18), o && (e.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !e.ie && !e.edge, t.pointerEventsSupported = "onpointerdown" in window && (e.edge || e.ie && +e.version >= 11);
  var s = t.domSupported = typeof document < "u";
  if (s) {
    var l = document.documentElement.style;
    t.transform3dSupported = (e.ie && "transition" in l || e.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || e.ie && +e.version >= 9;
  }
}
var _1 = 12, ZI = "sans-serif", Ua = _1 + "px " + ZI, oW = 20, sW = 100, lW = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function uW(r) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var e = 0; e < r.length; e++) {
    var n = String.fromCharCode(e + 32), i = (r.charCodeAt(e) - oW) / sW;
    t[n] = i;
  }
  return t;
}
var cW = uW(lW), Si = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var r, t;
    return function(e, n) {
      if (!r) {
        var i = Si.createCanvas();
        r = i && i.getContext("2d");
      }
      if (r)
        return t !== n && (t = r.font = n || Ua), r.measureText(e);
      e = e || "", n = n || Ua;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), o = a && +a[1] || _1, s = 0;
      if (n.indexOf("mono") >= 0)
        s = o * e.length;
      else
        for (var l = 0; l < e.length; l++) {
          var u = cW[e[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(r, t, e) {
    var n = new Image();
    return n.onload = t, n.onerror = e, n.src = r, n;
  }
}, qI = ra([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(r, t) {
  return r["[object " + t + "]"] = !0, r;
}, {}), KI = ra([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(r, t) {
  return r["[object " + t + "Array]"] = !0, r;
}, {}), _c = Object.prototype.toString, Vg = Array.prototype, fW = Vg.forEach, hW = Vg.filter, x1 = Vg.slice, dW = Vg.map, ST = (function() {
}).constructor, Td = ST ? ST.prototype : null, S1 = "__proto__", pW = 2311;
function jI() {
  return pW++;
}
function mi() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, r);
}
function Dt(r) {
  if (r == null || typeof r != "object")
    return r;
  var t = r, e = _c.call(r);
  if (e === "[object Array]") {
    if (!Uf(r)) {
      t = [];
      for (var n = 0, i = r.length; n < i; n++)
        t[n] = Dt(r[n]);
    }
  } else if (KI[e]) {
    if (!Uf(r)) {
      var a = r.constructor;
      if (a.from)
        t = a.from(r);
      else {
        t = new a(r.length);
        for (var n = 0, i = r.length; n < i; n++)
          t[n] = r[n];
      }
    }
  } else if (!qI[e] && !Uf(r) && !hl(r)) {
    t = {};
    for (var o in r)
      r.hasOwnProperty(o) && o !== S1 && (t[o] = Dt(r[o]));
  }
  return t;
}
function qt(r, t, e) {
  if (!Lt(t) || !Lt(r))
    return e ? Dt(t) : r;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== S1) {
      var i = r[n], a = t[n];
      Lt(a) && Lt(i) && !et(a) && !et(i) && !hl(a) && !hl(i) && !bT(a) && !bT(i) && !Uf(a) && !Uf(i) ? qt(i, a, e) : (e || !(n in r)) && (r[n] = Dt(t[n]));
    }
  return r;
}
function b1(r, t) {
  for (var e = r[0], n = 1, i = r.length; n < i; n++)
    e = qt(e, r[n], t);
  return e;
}
function j(r, t) {
  if (Object.assign)
    Object.assign(r, t);
  else
    for (var e in t)
      t.hasOwnProperty(e) && e !== S1 && (r[e] = t[e]);
  return r;
}
function Bt(r, t, e) {
  for (var n = se(t), i = 0, a = n.length; i < a; i++) {
    var o = n[i];
    (e ? t[o] != null : r[o] == null) && (r[o] = t[o]);
  }
  return r;
}
function Zt(r, t) {
  if (r) {
    if (r.indexOf)
      return r.indexOf(t);
    for (var e = 0, n = r.length; e < n; e++)
      if (r[e] === t)
        return e;
  }
  return -1;
}
function vW(r, t) {
  var e = r.prototype;
  function n() {
  }
  n.prototype = t.prototype, r.prototype = new n();
  for (var i in e)
    e.hasOwnProperty(i) && (r.prototype[i] = e[i]);
  r.prototype.constructor = r, r.superClass = t;
}
function dr(r, t, e) {
  if (r = "prototype" in r ? r.prototype : r, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), i = 0; i < n.length; i++) {
      var a = n[i];
      a !== "constructor" && (e ? t[a] != null : r[a] == null) && (r[a] = t[a]);
    }
  else
    Bt(r, t, e);
}
function Kr(r) {
  return !r || typeof r == "string" ? !1 : typeof r.length == "number";
}
function L(r, t, e) {
  if (r && t)
    if (r.forEach && r.forEach === fW)
      r.forEach(t, e);
    else if (r.length === +r.length)
      for (var n = 0, i = r.length; n < i; n++)
        t.call(e, r[n], n, r);
    else
      for (var a in r)
        r.hasOwnProperty(a) && t.call(e, r[a], a, r);
}
function rt(r, t, e) {
  if (!r)
    return [];
  if (!t)
    return w1(r);
  if (r.map && r.map === dW)
    return r.map(t, e);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    n.push(t.call(e, r[i], i, r));
  return n;
}
function ra(r, t, e, n) {
  if (r && t) {
    for (var i = 0, a = r.length; i < a; i++)
      e = t.call(n, e, r[i], i, r);
    return e;
  }
}
function Te(r, t, e) {
  if (!r)
    return [];
  if (!t)
    return w1(r);
  if (r.filter && r.filter === hW)
    return r.filter(t, e);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    t.call(e, r[i], i, r) && n.push(r[i]);
  return n;
}
function Ml(r, t, e) {
  if (r && t) {
    for (var n = 0, i = r.length; n < i; n++)
      if (t.call(e, r[n], n, r))
        return r[n];
  }
}
function se(r) {
  if (!r)
    return [];
  if (Object.keys)
    return Object.keys(r);
  var t = [];
  for (var e in r)
    r.hasOwnProperty(e) && t.push(e);
  return t;
}
function gW(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++)
    e[n - 2] = arguments[n];
  return function() {
    return r.apply(t, e.concat(x1.call(arguments)));
  };
}
var gt = Td && At(Td.bind) ? Td.call.bind(Td.bind) : gW;
function Yt(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return function() {
    return r.apply(this, t.concat(x1.call(arguments)));
  };
}
function et(r) {
  return Array.isArray ? Array.isArray(r) : _c.call(r) === "[object Array]";
}
function At(r) {
  return typeof r == "function";
}
function pt(r) {
  return typeof r == "string";
}
function yv(r) {
  return _c.call(r) === "[object String]";
}
function fe(r) {
  return typeof r == "number";
}
function Lt(r) {
  var t = typeof r;
  return t === "function" || !!r && t === "object";
}
function bT(r) {
  return !!qI[_c.call(r)];
}
function hn(r) {
  return !!KI[_c.call(r)];
}
function hl(r) {
  return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
}
function Fg(r) {
  return r.colorStops != null;
}
function mW(r) {
  return r.image != null;
}
function JI(r) {
  return _c.call(r) === "[object RegExp]";
}
function kr(r) {
  return r !== r;
}
function mr() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  for (var e = 0, n = r.length; e < n; e++)
    if (r[e] != null)
      return r[e];
}
function bt(r, t) {
  return r ?? t;
}
function un(r, t, e) {
  return r ?? t ?? e;
}
function w1(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return x1.apply(r, t);
}
function zg(r) {
  if (typeof r == "number")
    return [r, r, r, r];
  var t = r.length;
  return t === 2 ? [r[0], r[1], r[0], r[1]] : t === 3 ? [r[0], r[1], r[2], r[1]] : r;
}
function St(r, t) {
  if (!r)
    throw new Error(t);
}
function ei(r) {
  return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var QI = "__ec_primitive__";
function _v(r) {
  r[QI] = !0;
}
function Uf(r) {
  return r[QI];
}
var yW = function() {
  function r() {
    this.data = {};
  }
  return r.prototype.delete = function(t) {
    var e = this.has(t);
    return e && delete this.data[t], e;
  }, r.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, r.prototype.get = function(t) {
    return this.data[t];
  }, r.prototype.set = function(t, e) {
    return this.data[t] = e, this;
  }, r.prototype.keys = function() {
    return se(this.data);
  }, r.prototype.forEach = function(t) {
    var e = this.data;
    for (var n in e)
      e.hasOwnProperty(n) && t(e[n], n);
  }, r;
}(), tP = typeof Map == "function";
function _W() {
  return tP ? /* @__PURE__ */ new Map() : new yW();
}
var xW = function() {
  function r(t) {
    var e = et(t);
    this.data = _W();
    var n = this;
    t instanceof r ? t.each(i) : t && L(t, i);
    function i(a, o) {
      e ? n.set(a, o) : n.set(o, a);
    }
  }
  return r.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, r.prototype.get = function(t) {
    return this.data.get(t);
  }, r.prototype.set = function(t, e) {
    return this.data.set(t, e), e;
  }, r.prototype.each = function(t, e) {
    this.data.forEach(function(n, i) {
      t.call(e, n, i);
    });
  }, r.prototype.keys = function() {
    var t = this.data.keys();
    return tP ? Array.from(t) : t;
  }, r.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, r;
}();
function wt(r) {
  return new xW(r);
}
function eh(r, t) {
  for (var e = new r.constructor(r.length + t.length), n = 0; n < r.length; n++)
    e[n] = r[n];
  for (var i = r.length, n = 0; n < t.length; n++)
    e[n + i] = t[n];
  return e;
}
function Ug(r, t) {
  var e;
  if (Object.create)
    e = Object.create(r);
  else {
    var n = function() {
    };
    n.prototype = r, e = new n();
  }
  return t && j(e, t), e;
}
function eP(r) {
  var t = r.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function _t(r, t) {
  return r.hasOwnProperty(t);
}
function rr() {
}
var Gp = 180 / Math.PI;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var K_ = function(r, t) {
  return K_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, n) {
    e.__proto__ = n;
  } || function(e, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
  }, K_(r, t);
};
function Ue(r, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  K_(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function Tl(r, t) {
  return r == null && (r = 0), t == null && (t = 0), [r, t];
}
function rn(r, t) {
  return r[0] = t[0], r[1] = t[1], r;
}
function Pa(r) {
  return [r[0], r[1]];
}
function M1(r, t, e) {
  return r[0] = t, r[1] = e, r;
}
function wT(r, t, e) {
  return r[0] = t[0] + e[0], r[1] = t[1] + e[1], r;
}
function j_(r, t, e, n) {
  return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r;
}
function qs(r, t, e) {
  return r[0] = t[0] - e[0], r[1] = t[1] - e[1], r;
}
function J_(r) {
  return Math.sqrt(SW(r));
}
function SW(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function Hp(r, t, e) {
  return r[0] = t[0] * e, r[1] = t[1] * e, r;
}
function xc(r, t) {
  var e = J_(t);
  return e === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = t[0] / e, r[1] = t[1] / e), r;
}
function Q_(r, t) {
  return Math.sqrt((r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1]));
}
var So = Q_;
function bW(r, t) {
  return (r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1]);
}
var rl = bW;
function Wp(r, t, e, n) {
  return r[0] = t[0] + n * (e[0] - t[0]), r[1] = t[1] + n * (e[1] - t[1]), r;
}
function nr(r, t, e) {
  var n = t[0], i = t[1];
  return r[0] = e[0] * n + e[2] * i + e[4], r[1] = e[1] * n + e[3] * i + e[5], r;
}
function bo(r, t, e) {
  return r[0] = Math.min(t[0], e[0]), r[1] = Math.min(t[1], e[1]), r;
}
function wo(r, t, e) {
  return r[0] = Math.max(t[0], e[0]), r[1] = Math.max(t[1], e[1]), r;
}
var Ql = /* @__PURE__ */ function() {
  function r(t, e) {
    this.target = t, this.topTarget = e && e.topTarget;
  }
  return r;
}(), wW = function() {
  function r(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return r.prototype._dragStart = function(t) {
    for (var e = t.target; e && !e.draggable; )
      e = e.parent || e.__hostTarget;
    e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Ql(e, t), "dragstart", t.event));
  }, r.prototype._drag = function(t) {
    var e = this._draggingTarget;
    if (e) {
      var n = t.offsetX, i = t.offsetY, a = n - this._x, o = i - this._y;
      this._x = n, this._y = i, e.drift(a, o, t), this.handler.dispatchToElement(new Ql(e, t), "drag", t.event);
      var s = this.handler.findHover(n, i, e).target, l = this._dropTarget;
      this._dropTarget = s, e !== s && (l && s !== l && this.handler.dispatchToElement(new Ql(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new Ql(s, t), "dragenter", t.event));
    }
  }, r.prototype._dragEnd = function(t) {
    var e = this._draggingTarget;
    e && (e.dragging = !1), this.handler.dispatchToElement(new Ql(e, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Ql(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, r;
}(), si = function() {
  function r(t) {
    t && (this._$eventProcessor = t);
  }
  return r.prototype.on = function(t, e, n, i) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof e == "function" && (i = n, n = e, e = null), !n || !t)
      return this;
    var o = this._$eventProcessor;
    e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)), a[t] || (a[t] = []);
    for (var s = 0; s < a[t].length; s++)
      if (a[t][s].h === n)
        return this;
    var l = {
      h: n,
      query: e,
      ctx: i || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, r.prototype.isSilent = function(t) {
    var e = this._$handlers;
    return !e || !e[t] || !e[t].length;
  }, r.prototype.off = function(t, e) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (e) {
      if (n[t]) {
        for (var i = [], a = 0, o = n[t].length; a < o; a++)
          n[t][a].h !== e && i.push(n[t][a]);
        n[t] = i;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, r.prototype.trigger = function(t) {
    for (var e = [], n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], a = this._$eventProcessor;
    if (i)
      for (var o = e.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, e[0]);
              break;
            case 2:
              u.h.call(u.ctx, e[0], e[1]);
              break;
            default:
              u.h.apply(u.ctx, e);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, r.prototype.triggerWithContext = function(t) {
    for (var e = [], n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], a = this._$eventProcessor;
    if (i)
      for (var o = e.length, s = e[o - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, e[0]);
              break;
            case 2:
              c.h.call(s, e[0], e[1]);
              break;
            default:
              c.h.apply(s, e.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, r;
}(), MW = Math.log(2);
function tx(r, t, e, n, i, a) {
  var o = n + "-" + i, s = r.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / MW);
    return r[e][l];
  }
  for (var u = n | 1 << e, c = e + 1; n & 1 << c; )
    c++;
  for (var f = 0, h = 0, d = 0; h < s; h++) {
    var p = 1 << h;
    p & i || (f += (d % 2 ? -1 : 1) * r[e][h] * tx(r, t - 1, c, u, i | p, a), d++);
  }
  return a[o] = f, f;
}
function MT(r, t) {
  var e = [
    [r[0], r[1], 1, 0, 0, 0, -t[0] * r[0], -t[0] * r[1]],
    [0, 0, 0, r[0], r[1], 1, -t[1] * r[0], -t[1] * r[1]],
    [r[2], r[3], 1, 0, 0, 0, -t[2] * r[2], -t[2] * r[3]],
    [0, 0, 0, r[2], r[3], 1, -t[3] * r[2], -t[3] * r[3]],
    [r[4], r[5], 1, 0, 0, 0, -t[4] * r[4], -t[4] * r[5]],
    [0, 0, 0, r[4], r[5], 1, -t[5] * r[4], -t[5] * r[5]],
    [r[6], r[7], 1, 0, 0, 0, -t[6] * r[6], -t[6] * r[7]],
    [0, 0, 0, r[6], r[7], 1, -t[7] * r[6], -t[7] * r[7]]
  ], n = {}, i = tx(e, 8, 0, 0, 0, n);
  if (i !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * tx(e, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / i * t[o];
    return function(l, u, c) {
      var f = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / f, l[1] = (u * a[3] + c * a[4] + a[5]) / f;
    };
  }
}
var xv = "___zrEVENTSAVED", cy = [];
function TW(r, t, e, n, i) {
  return ex(cy, t, n, i, !0) && ex(r, e, cy[0], cy[1]);
}
function AW(r, t) {
  r && e(r), t && e(t);
  function e(n) {
    var i = n[xv];
    i && (i.clearMarkers && i.clearMarkers(), delete n[xv]);
  }
}
function ex(r, t, e, n, i) {
  if (t.getBoundingClientRect && oe.domSupported && !rP(t)) {
    var a = t[xv] || (t[xv] = {}), o = EW(t, a), s = CW(o, a, i);
    if (s)
      return s(r, e, n), !0;
  }
  return !1;
}
function EW(r, t) {
  var e = t.markers;
  if (e)
    return e;
  e = t.markers = [];
  for (var n = ["left", "right"], i = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      i[u] + ":0",
      n[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), r.appendChild(o), e.push(o);
  }
  return t.clearMarkers = function() {
    L(e, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, e;
}
function CW(r, t, e) {
  for (var n = e ? "invTrans" : "trans", i = t[n], a = t.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = r[u].getBoundingClientRect(), f = 2 * u, h = c.left, d = c.top;
    o.push(h, d), l = l && a && h === a[f] && d === a[f + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
  }
  return l && i ? i : (t.srcCoords = o, t[n] = e ? MT(s, o) : MT(o, s));
}
function rP(r) {
  return r.nodeName.toUpperCase() === "CANVAS";
}
var DW = /([&<>"'])/g, LW = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function sn(r) {
  return r == null ? "" : (r + "").replace(DW, function(t, e) {
    return LW[e];
  });
}
var RW = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, fy = [], IW = oe.browser.firefox && +oe.browser.version.split(".")[0] < 39;
function rx(r, t, e, n) {
  return e = e || {}, n ? TT(r, t, e) : IW && t.layerX != null && t.layerX !== t.offsetX ? (e.zrX = t.layerX, e.zrY = t.layerY) : t.offsetX != null ? (e.zrX = t.offsetX, e.zrY = t.offsetY) : TT(r, t, e), e;
}
function TT(r, t, e) {
  if (oe.domSupported && r.getBoundingClientRect) {
    var n = t.clientX, i = t.clientY;
    if (rP(r)) {
      var a = r.getBoundingClientRect();
      e.zrX = n - a.left, e.zrY = i - a.top;
      return;
    } else if (ex(fy, r, n, i)) {
      e.zrX = fy[0], e.zrY = fy[1];
      return;
    }
  }
  e.zrX = e.zrY = 0;
}
function T1(r) {
  return r || window.event;
}
function $n(r, t, e) {
  if (t = T1(t), t.zrX != null)
    return t;
  var n = t.type, i = n && n.indexOf("touch") >= 0;
  if (i) {
    var o = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    o && rx(r, o, t, e);
  } else {
    rx(r, t, t, e);
    var a = PW(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && RW.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function PW(r) {
  var t = r.wheelDelta;
  if (t)
    return t;
  var e = r.deltaX, n = r.deltaY;
  if (e == null || n == null)
    return t;
  var i = Math.abs(n !== 0 ? n : e), a = n > 0 ? -1 : n < 0 ? 1 : e > 0 ? -1 : 1;
  return 3 * i * a;
}
function nx(r, t, e, n) {
  r.addEventListener(t, e, n);
}
function NW(r, t, e, n) {
  r.removeEventListener(t, e, n);
}
var Ga = function(r) {
  r.preventDefault(), r.stopPropagation(), r.cancelBubble = !0;
};
function AT(r) {
  return r.which === 2 || r.which === 3;
}
var OW = function() {
  function r() {
    this._track = [];
  }
  return r.prototype.recognize = function(t, e, n) {
    return this._doTrack(t, e, n), this._recognize(t);
  }, r.prototype.clear = function() {
    return this._track.length = 0, this;
  }, r.prototype._doTrack = function(t, e, n) {
    var i = t.touches;
    if (i) {
      for (var a = {
        points: [],
        touches: [],
        target: e,
        event: t
      }, o = 0, s = i.length; o < s; o++) {
        var l = i[o], u = rx(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, r.prototype._recognize = function(t) {
    for (var e in hy)
      if (hy.hasOwnProperty(e)) {
        var n = hy[e](this._track, t);
        if (n)
          return n;
      }
  }, r;
}();
function ET(r) {
  var t = r[1][0] - r[0][0], e = r[1][1] - r[0][1];
  return Math.sqrt(t * t + e * e);
}
function kW(r) {
  return [
    (r[0][0] + r[1][0]) / 2,
    (r[0][1] + r[1][1]) / 2
  ];
}
var hy = {
  pinch: function(r, t) {
    var e = r.length;
    if (e) {
      var n = (r[e - 1] || {}).points, i = (r[e - 2] || {}).points || n;
      if (i && i.length > 1 && n && n.length > 1) {
        var a = ET(n) / ET(i);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var o = kW(n);
        return t.pinchX = o[0], t.pinchY = o[1], {
          type: "pinch",
          target: r[0].target,
          event: t
        };
      }
    }
  }
};
function Br() {
  return [1, 0, 0, 1, 0, 0];
}
function Gg(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function Hg(r, t) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r;
}
function Ji(r, t, e) {
  var n = t[0] * e[0] + t[2] * e[1], i = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
  return r[0] = n, r[1] = i, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
}
function na(r, t, e) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4] + e[0], r[5] = t[5] + e[1], r;
}
function Ko(r, t, e, n) {
  n === void 0 && (n = [0, 0]);
  var i = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(e), f = Math.cos(e);
  return r[0] = i * f + s * c, r[1] = -i * c + s * f, r[2] = a * f + l * c, r[3] = -a * c + f * l, r[4] = f * (o - n[0]) + c * (u - n[1]) + n[0], r[5] = f * (u - n[1]) - c * (o - n[0]) + n[1], r;
}
function A1(r, t, e) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n, r[1] = t[1] * i, r[2] = t[2] * n, r[3] = t[3] * i, r[4] = t[4] * n, r[5] = t[5] * i, r;
}
function bi(r, t) {
  var e = t[0], n = t[2], i = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * n;
  return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -n * l, r[3] = e * l, r[4] = (n * s - o * i) * l, r[5] = (a * i - e * s) * l, r) : null;
}
function BW(r) {
  var t = Br();
  return Hg(t, r), t;
}
var Ot = function() {
  function r(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  return r.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y);
  }, r.prototype.set = function(t, e) {
    return this.x = t, this.y = e, this;
  }, r.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, r.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, r.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, r.prototype.scaleAndAdd = function(t, e) {
    this.x += t.x * e, this.y += t.y * e;
  }, r.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, r.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, r.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, r.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, r.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, r.prototype.distance = function(t) {
    var e = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(e * e + n * n);
  }, r.prototype.distanceSquare = function(t) {
    var e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  }, r.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, r.prototype.transform = function(t) {
    if (t) {
      var e = this.x, n = this.y;
      return this.x = t[0] * e + t[2] * n + t[4], this.y = t[1] * e + t[3] * n + t[5], this;
    }
  }, r.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, r.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, r.set = function(t, e, n) {
    t.x = e, t.y = n;
  }, r.copy = function(t, e) {
    t.x = e.x, t.y = e.y;
  }, r.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, r.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, r.dot = function(t, e) {
    return t.x * e.x + t.y * e.y;
  }, r.add = function(t, e, n) {
    t.x = e.x + n.x, t.y = e.y + n.y;
  }, r.sub = function(t, e, n) {
    t.x = e.x - n.x, t.y = e.y - n.y;
  }, r.scale = function(t, e, n) {
    t.x = e.x * n, t.y = e.y * n;
  }, r.scaleAndAdd = function(t, e, n, i) {
    t.x = e.x + n.x * i, t.y = e.y + n.y * i;
  }, r.lerp = function(t, e, n, i) {
    var a = 1 - i;
    t.x = a * e.x + i * n.x, t.y = a * e.y + i * n.y;
  }, r;
}(), Ks = Math.min, Nu = Math.max, ix = Math.abs, CT = ["x", "y"], VW = ["width", "height"], ss = new Ot(), ls = new Ot(), us = new Ot(), cs = new Ot(), Ln = nP(), Af = Ln.minTv, ax = Ln.maxTv, Gf = [0, 0], Vt = function() {
  function r(t, e, n, i) {
    r.set(this, t, e, n, i);
  }
  return r.set = function(t, e, n, i, a) {
    return i < 0 && (e = e + i, i = -i), a < 0 && (n = n + a, a = -a), t.x = e, t.y = n, t.width = i, t.height = a, t;
  }, r.prototype.union = function(t) {
    var e = Ks(t.x, this.x), n = Ks(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Nu(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Nu(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = e, this.y = n;
  }, r.prototype.applyTransform = function(t) {
    r.applyTransform(this, this, t);
  }, r.prototype.calculateTransform = function(t) {
    var e = this, n = t.width / e.width, i = t.height / e.height, a = Br();
    return na(a, a, [-e.x, -e.y]), A1(a, a, [n, i]), na(a, a, [t.x, t.y]), a;
  }, r.prototype.intersect = function(t, e, n) {
    return r.intersect(this, t, e, n);
  }, r.intersect = function(t, e, n, i) {
    n && Ot.set(n, 0, 0);
    var a = i && i.outIntersectRect || null, o = i && i.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !e)
      return !1;
    t instanceof r || (t = r.set(FW, t.x, t.y, t.width, t.height)), e instanceof r || (e = r.set(zW, e.x, e.y, e.width, e.height));
    var s = !!n;
    Ln.reset(i, s);
    var l = Ln.touchThreshold, u = t.x + l, c = t.x + t.width - l, f = t.y + l, h = t.y + t.height - l, d = e.x + l, p = e.x + e.width - l, g = e.y + l, v = e.y + e.height - l;
    if (u > c || f > h || d > p || g > v)
      return !1;
    var m = !(c < d || p < u || h < g || v < f);
    return (s || a) && (Gf[0] = 1 / 0, Gf[1] = 0, DT(u, c, d, p, 0, s, a, o), DT(f, h, g, v, 1, s, a, o), s && Ot.copy(n, m ? Ln.useDir ? Ln.dirMinTv : Af : ax)), m;
  }, r.contain = function(t, e, n) {
    return e >= t.x && e <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, r.prototype.contain = function(t, e) {
    return r.contain(this, t, e);
  }, r.prototype.clone = function() {
    return new r(this.x, this.y, this.width, this.height);
  }, r.prototype.copy = function(t) {
    r.copy(this, t);
  }, r.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, r.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, r.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, r.create = function(t) {
    return new r(t.x, t.y, t.width, t.height);
  }, r.copy = function(t, e) {
    return t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t;
  }, r.applyTransform = function(t, e, n) {
    if (!n) {
      t !== e && r.copy(t, e);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var i = n[0], a = n[3], o = n[4], s = n[5];
      t.x = e.x * i + o, t.y = e.y * a + s, t.width = e.width * i, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    ss.x = us.x = e.x, ss.y = cs.y = e.y, ls.x = cs.x = e.x + e.width, ls.y = us.y = e.y + e.height, ss.transform(n), cs.transform(n), ls.transform(n), us.transform(n), t.x = Ks(ss.x, ls.x, us.x, cs.x), t.y = Ks(ss.y, ls.y, us.y, cs.y);
    var l = Nu(ss.x, ls.x, us.x, cs.x), u = Nu(ss.y, ls.y, us.y, cs.y);
    t.width = l - t.x, t.height = u - t.y;
  }, r;
}(), FW = new Vt(0, 0, 0, 0), zW = new Vt(0, 0, 0, 0);
function DT(r, t, e, n, i, a, o, s) {
  var l = ix(t - e), u = ix(n - r), c = Ks(l, u), f = CT[i], h = CT[1 - i], d = VW[i];
  t < e || n < r ? l < u ? (a && (ax[f] = -l), s && (o[f] = t, o[d] = 0)) : (a && (ax[f] = u), s && (o[f] = r, o[d] = 0)) : (o && (o[f] = Nu(r, e), o[d] = Ks(t, n) - o[f]), a && (c < Gf[0] || Ln.useDir) && (Gf[0] = Ks(c, Gf[0]), (l < u || !Ln.bidirectional) && (Af[f] = l, Af[h] = 0, Ln.useDir && Ln.calcDirMTV()), (l >= u || !Ln.bidirectional) && (Af[f] = -u, Af[h] = 0, Ln.useDir && Ln.calcDirMTV())));
}
function nP() {
  var r = 0, t = new Ot(), e = new Ot(), n = {
    minTv: new Ot(),
    maxTv: new Ot(),
    useDir: !1,
    dirMinTv: new Ot(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, o) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Nu(0, a.touchThreshold)), n.negativeSize = !1, o && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), e.copy(n.minTv), r = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(r), Math.sin(r))));
    },
    calcDirMTV: function() {
      var a = n.minTv, o = n.dirMinTv, s = a.y * a.y + a.x * a.x, l = Math.sin(r), u = Math.cos(r), c = l * a.y + u * a.x;
      if (i(c)) {
        i(a.x) && i(a.y) && o.set(0, 0);
        return;
      }
      if (e.x = s * u / c, e.y = s * l / c, i(e.x) && i(e.y)) {
        o.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(e) > 0) && e.len() < o.len() && o.copy(e);
    }
  };
  function i(a) {
    return ix(a) < 1e-10;
  }
  return n;
}
var iP = "silent";
function UW(r, t, e) {
  return {
    type: r,
    event: e,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: e.zrX,
    offsetY: e.zrY,
    gestureEvent: e.gestureEvent,
    pinchX: e.pinchX,
    pinchY: e.pinchY,
    pinchScale: e.pinchScale,
    wheelDelta: e.zrDelta,
    zrByTouch: e.zrByTouch,
    which: e.which,
    stop: GW
  };
}
function GW() {
  Ga(this.event);
}
var HW = function(r) {
  Ue(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.handler = null, e;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
}(si), Yc = /* @__PURE__ */ function() {
  function r(t, e) {
    this.x = t, this.y = e;
  }
  return r;
}(), WW = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], dy = new Vt(0, 0, 0, 0), aP = function(r) {
  Ue(t, r);
  function t(e, n, i, a, o) {
    var s = r.call(this) || this;
    return s._hovered = new Yc(0, 0), s.storage = e, s.painter = n, s.painterRoot = a, s._pointerSize = o, i = i || new HW(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new wW(s), s;
  }
  return t.prototype.setHandlerProxy = function(e) {
    this.proxy && this.proxy.dispose(), e && (L(WW, function(n) {
      e.on && e.on(n, this[n], this);
    }, this), e.handler = this), this.proxy = e;
  }, t.prototype.mousemove = function(e) {
    var n = e.zrX, i = e.zrY, a = oP(this, n, i), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Yc(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", e), this.dispatchToElement(l, "mousemove", e), u && u !== s && this.dispatchToElement(l, "mouseover", e);
  }, t.prototype.mouseout = function(e) {
    var n = e.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", e), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: e });
  }, t.prototype.resize = function() {
    this._hovered = new Yc(0, 0);
  }, t.prototype.dispatch = function(e, n) {
    var i = this[e];
    i && i.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(e) {
    var n = this.proxy;
    n.setCursor && n.setCursor(e);
  }, t.prototype.dispatchToElement = function(e, n, i) {
    e = e || {};
    var a = e.target;
    if (!(a && a.silent)) {
      for (var o = "on" + n, s = UW(n, e, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, t.prototype.findHover = function(e, n, i) {
    var a = this.storage.getDisplayList(), o = new Yc(e, n);
    if (LT(a, o, e, n, i), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new Vt(e - u, n - u, l, l), f = a.length - 1; f >= 0; f--) {
        var h = a[f];
        h !== i && !h.ignore && !h.ignoreCoarsePointer && (!h.parent || !h.parent.ignoreCoarsePointer) && (dy.copy(h.getBoundingRect()), h.transform && dy.applyTransform(h.transform), dy.intersect(c) && s.push(h));
      }
      if (s.length)
        for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d)
          for (var m = 0; m < g; m += p) {
            var y = e + v * Math.cos(m), _ = n + v * Math.sin(m);
            if (LT(s, o, y, _, i), o.target)
              return o;
          }
    }
    return o;
  }, t.prototype.processGesture = function(e, n) {
    this._gestureMgr || (this._gestureMgr = new OW());
    var i = this._gestureMgr;
    n === "start" && i.clear();
    var a = i.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom);
    if (n === "end" && i.clear(), a) {
      var o = a.type;
      e.gestureEvent = o;
      var s = new Yc();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, t;
}(si);
L(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(r) {
  aP.prototype[r] = function(t) {
    var e = t.zrX, n = t.zrY, i = oP(this, e, n), a, o;
    if ((r !== "mouseup" || !i) && (a = this.findHover(e, n), o = a.target), r === "mousedown")
      this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
    else if (r === "mouseup")
      this._upEl = o;
    else if (r === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || So(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, r, t);
  };
});
function XW(r, t, e) {
  if (r[r.rectHover ? "rectContain" : "contain"](t, e)) {
    for (var n = r, i = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var o = n.getClipPath();
        if (o && !o.contain(t, e))
          return !1;
      }
      n.silent && (i = !0);
      var s = n.__hostTarget;
      n = s ? n.ignoreHostSilent ? null : s : n.parent;
    }
    return i ? iP : !0;
  }
  return !1;
}
function LT(r, t, e, n, i) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a], s = void 0;
    if (o !== i && !o.ignore && (s = XW(o, e, n)) && (!t.topTarget && (t.topTarget = o), s !== iP)) {
      t.target = o;
      break;
    }
  }
}
function oP(r, t, e) {
  var n = r.painter;
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight();
}
var sP = 32, $c = 7;
function YW(r) {
  for (var t = 0; r >= sP; )
    t |= r & 1, r >>= 1;
  return r + t;
}
function RT(r, t, e, n) {
  var i = t + 1;
  if (i === e)
    return 1;
  if (n(r[i++], r[t]) < 0) {
    for (; i < e && n(r[i], r[i - 1]) < 0; )
      i++;
    $W(r, t, i);
  } else
    for (; i < e && n(r[i], r[i - 1]) >= 0; )
      i++;
  return i - t;
}
function $W(r, t, e) {
  for (e--; t < e; ) {
    var n = r[t];
    r[t++] = r[e], r[e--] = n;
  }
}
function IT(r, t, e, n, i) {
  for (n === t && n++; n < e; n++) {
    for (var a = r[n], o = t, s = n, l; o < s; )
      l = o + s >>> 1, i(a, r[l]) < 0 ? s = l : o = l + 1;
    var u = n - o;
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2];
      case 2:
        r[o + 2] = r[o + 1];
      case 1:
        r[o + 1] = r[o];
        break;
      default:
        for (; u > 0; )
          r[o + u] = r[o + u - 1], u--;
    }
    r[o] = a;
  }
}
function py(r, t, e, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, t[e + i]) > 0) {
    for (s = n - i; l < s && a(r, t[e + i + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  } else {
    for (s = i + 1; l < s && a(r, t[e + i - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, t[e + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function vy(r, t, e, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, t[e + i]) < 0) {
    for (s = i + 1; l < s && a(r, t[e + i - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  } else {
    for (s = n - i; l < s && a(r, t[e + i + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, t[e + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function ZW(r, t) {
  var e = $c, n, i, a = 0, o = [];
  n = [], i = [];
  function s(d, p) {
    n[a] = d, i[a] = p, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2;
      if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1])
        i[d - 1] < i[d + 1] && d--;
      else if (i[d] > i[d + 1])
        break;
      c(d);
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2;
      d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
    }
  }
  function c(d) {
    var p = n[d], g = i[d], v = n[d + 1], m = i[d + 1];
    i[d] = g + m, d === a - 3 && (n[d + 1] = n[d + 2], i[d + 1] = i[d + 2]), a--;
    var y = vy(r[v], r, p, g, 0, t);
    p += y, g -= y, g !== 0 && (m = py(r[p + g - 1], r, v, m, m - 1, t), m !== 0 && (g <= m ? f(p, g, v, m) : h(p, g, v, m)));
  }
  function f(d, p, g, v) {
    var m = 0;
    for (m = 0; m < p; m++)
      o[m] = r[d + m];
    var y = 0, _ = g, x = d;
    if (r[x++] = r[_++], --v === 0) {
      for (m = 0; m < p; m++)
        r[x + m] = o[y + m];
      return;
    }
    if (p === 1) {
      for (m = 0; m < v; m++)
        r[x + m] = r[_ + m];
      r[x + v] = o[y];
      return;
    }
    for (var b = e, S, w, A; ; ) {
      S = 0, w = 0, A = !1;
      do
        if (t(r[_], o[y]) < 0) {
          if (r[x++] = r[_++], w++, S = 0, --v === 0) {
            A = !0;
            break;
          }
        } else if (r[x++] = o[y++], S++, w = 0, --p === 1) {
          A = !0;
          break;
        }
      while ((S | w) < b);
      if (A)
        break;
      do {
        if (S = vy(r[_], o, y, p, 0, t), S !== 0) {
          for (m = 0; m < S; m++)
            r[x + m] = o[y + m];
          if (x += S, y += S, p -= S, p <= 1) {
            A = !0;
            break;
          }
        }
        if (r[x++] = r[_++], --v === 0) {
          A = !0;
          break;
        }
        if (w = py(o[y], r, _, v, 0, t), w !== 0) {
          for (m = 0; m < w; m++)
            r[x + m] = r[_ + m];
          if (x += w, _ += w, v -= w, v === 0) {
            A = !0;
            break;
          }
        }
        if (r[x++] = o[y++], --p === 1) {
          A = !0;
          break;
        }
        b--;
      } while (S >= $c || w >= $c);
      if (A)
        break;
      b < 0 && (b = 0), b += 2;
    }
    if (e = b, e < 1 && (e = 1), p === 1) {
      for (m = 0; m < v; m++)
        r[x + m] = r[_ + m];
      r[x + v] = o[y];
    } else {
      if (p === 0)
        throw new Error();
      for (m = 0; m < p; m++)
        r[x + m] = o[y + m];
    }
  }
  function h(d, p, g, v) {
    var m = 0;
    for (m = 0; m < v; m++)
      o[m] = r[g + m];
    var y = d + p - 1, _ = v - 1, x = g + v - 1, b = 0, S = 0;
    if (r[x--] = r[y--], --p === 0) {
      for (b = x - (v - 1), m = 0; m < v; m++)
        r[b + m] = o[m];
      return;
    }
    if (v === 1) {
      for (x -= p, y -= p, S = x + 1, b = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[b + m];
      r[x] = o[_];
      return;
    }
    for (var w = e; ; ) {
      var A = 0, T = 0, M = !1;
      do
        if (t(o[_], r[y]) < 0) {
          if (r[x--] = r[y--], A++, T = 0, --p === 0) {
            M = !0;
            break;
          }
        } else if (r[x--] = o[_--], T++, A = 0, --v === 1) {
          M = !0;
          break;
        }
      while ((A | T) < w);
      if (M)
        break;
      do {
        if (A = p - vy(o[_], r, d, p, p - 1, t), A !== 0) {
          for (x -= A, y -= A, p -= A, S = x + 1, b = y + 1, m = A - 1; m >= 0; m--)
            r[S + m] = r[b + m];
          if (p === 0) {
            M = !0;
            break;
          }
        }
        if (r[x--] = o[_--], --v === 1) {
          M = !0;
          break;
        }
        if (T = v - py(r[y], o, 0, v, v - 1, t), T !== 0) {
          for (x -= T, _ -= T, v -= T, S = x + 1, b = _ + 1, m = 0; m < T; m++)
            r[S + m] = o[b + m];
          if (v <= 1) {
            M = !0;
            break;
          }
        }
        if (r[x--] = r[y--], --p === 0) {
          M = !0;
          break;
        }
        w--;
      } while (A >= $c || T >= $c);
      if (M)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (e = w, e < 1 && (e = 1), v === 1) {
      for (x -= p, y -= p, S = x + 1, b = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[b + m];
      r[x] = o[_];
    } else {
      if (v === 0)
        throw new Error();
      for (b = x - (v - 1), m = 0; m < v; m++)
        r[b + m] = o[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Xp(r, t, e, n) {
  e || (e = 0), n || (n = r.length);
  var i = n - e;
  if (!(i < 2)) {
    var a = 0;
    if (i < sP) {
      a = RT(r, e, n, t), IT(r, e, n, e + a, t);
      return;
    }
    var o = ZW(r, t), s = YW(i);
    do {
      if (a = RT(r, e, n, t), a < s) {
        var l = i;
        l > s && (l = s), IT(r, e, e + l, e + a, t), a = l;
      }
      o.pushRun(e, a), o.mergeRuns(), i -= a, e += a;
    } while (i !== 0);
    o.forceMergeRuns();
  }
}
var In = 1, Ef = 2, Cu = 4, PT = !1;
function gy() {
  PT || (PT = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function NT(r, t) {
  return r.zlevel === t.zlevel ? r.z === t.z ? r.z2 - t.z2 : r.z - t.z : r.zlevel - t.zlevel;
}
var qW = function() {
  function r() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = NT;
  }
  return r.prototype.traverse = function(t, e) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, e);
  }, r.prototype.getDisplayList = function(t, e) {
    e = e || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(e), n;
  }, r.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var e = this._roots, n = this._displayList, i = 0, a = e.length; i < a; i++)
      this._updateAndAddDisplayable(e[i], null, t);
    n.length = this._displayListLen, Xp(n, NT);
  }, r.prototype._updateAndAddDisplayable = function(t, e, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var i = t.getClipPath(), a = e && e.length, o = 0, s = t.__clipPaths;
      if (!t.ignoreClip && (a || i)) {
        if (s || (s = t.__clipPaths = []), a)
          for (var l = 0; l < e.length; l++)
            s[o++] = e[l];
        for (var u = i, c = t; u; )
          u.parent = c, u.updateTransform(), s[o++] = u, c = u, u = u.getClipPath();
      }
      if (s && (s.length = o), t.childrenRef) {
        for (var f = t.childrenRef(), h = 0; h < f.length; h++) {
          var d = f[h];
          t.__dirty && (d.__dirty |= In), this._updateAndAddDisplayable(d, s, n);
        }
        t.__dirty = 0;
      } else {
        var p = t;
        isNaN(p.z) && (gy(), p.z = 0), isNaN(p.z2) && (gy(), p.z2 = 0), isNaN(p.zlevel) && (gy(), p.zlevel = 0), this._displayList[this._displayListLen++] = p;
      }
      var g = t.getDecalElement && t.getDecalElement();
      g && this._updateAndAddDisplayable(g, s, n);
      var v = t.getTextGuideLine();
      v && this._updateAndAddDisplayable(v, s, n);
      var m = t.getTextContent();
      m && this._updateAndAddDisplayable(m, s, n);
    }
  }, r.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, r.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var e = 0, n = t.length; e < n; e++)
        this.delRoot(t[e]);
      return;
    }
    var i = Zt(this._roots, t);
    i >= 0 && this._roots.splice(i, 1);
  }, r.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, r.prototype.getRoots = function() {
    return this._roots;
  }, r.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, r;
}(), Sv;
Sv = oe.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
  return setTimeout(r, 16);
};
var Hf = {
  linear: function(r) {
    return r;
  },
  quadraticIn: function(r) {
    return r * r;
  },
  quadraticOut: function(r) {
    return r * (2 - r);
  },
  quadraticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
  },
  cubicIn: function(r) {
    return r * r * r;
  },
  cubicOut: function(r) {
    return --r * r * r + 1;
  },
  cubicInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
  },
  quarticIn: function(r) {
    return r * r * r * r;
  },
  quarticOut: function(r) {
    return 1 - --r * r * r * r;
  },
  quarticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
  },
  quinticIn: function(r) {
    return r * r * r * r * r;
  },
  quinticOut: function(r) {
    return --r * r * r * r * r + 1;
  },
  quinticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
  },
  sinusoidalIn: function(r) {
    return 1 - Math.cos(r * Math.PI / 2);
  },
  sinusoidalOut: function(r) {
    return Math.sin(r * Math.PI / 2);
  },
  sinusoidalInOut: function(r) {
    return 0.5 * (1 - Math.cos(Math.PI * r));
  },
  exponentialIn: function(r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1);
  },
  exponentialOut: function(r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
  },
  exponentialInOut: function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
  },
  circularIn: function(r) {
    return 1 - Math.sqrt(1 - r * r);
  },
  circularOut: function(r) {
    return Math.sqrt(1 - --r * r);
  },
  circularInOut: function(r) {
    return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
  },
  elasticIn: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * r) * Math.sin((r - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n)) : e * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(r) {
    var t = 1.70158;
    return r * r * ((t + 1) * r - t);
  },
  backOut: function(r) {
    var t = 1.70158;
    return --r * r * ((t + 1) * r + t) + 1;
  },
  backInOut: function(r) {
    var t = 2.5949095;
    return (r *= 2) < 1 ? 0.5 * (r * r * ((t + 1) * r - t)) : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2);
  },
  bounceIn: function(r) {
    return 1 - Hf.bounceOut(1 - r);
  },
  bounceOut: function(r) {
    return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
  },
  bounceInOut: function(r) {
    return r < 0.5 ? Hf.bounceIn(r * 2) * 0.5 : Hf.bounceOut(r * 2 - 1) * 0.5 + 0.5;
  }
}, Ad = Math.pow, Po = Math.sqrt, bv = 1e-8, lP = 1e-4, OT = Po(3), Ed = 1 / 3, Ui = Tl(), jn = Tl(), Wu = Tl();
function Mo(r) {
  return r > -bv && r < bv;
}
function uP(r) {
  return r > bv || r < -bv;
}
function wr(r, t, e, n, i) {
  var a = 1 - i;
  return a * a * (a * r + 3 * i * t) + i * i * (i * n + 3 * a * e);
}
function kT(r, t, e, n, i) {
  var a = 1 - i;
  return 3 * (((t - r) * a + 2 * (e - t) * i) * a + (n - e) * i * i);
}
function wv(r, t, e, n, i, a) {
  var o = n + 3 * (t - e) - r, s = 3 * (e - t * 2 + r), l = 3 * (t - r), u = r - i, c = s * s - 3 * o * l, f = s * l - 9 * o * u, h = l * l - 3 * s * u, d = 0;
  if (Mo(c) && Mo(f))
    if (Mo(s))
      a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
  else {
    var g = f * f - 4 * c * h;
    if (Mo(g)) {
      var v = f / c, p = -s / o + v, m = -v / 2;
      p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m);
    } else if (g > 0) {
      var y = Po(g), _ = c * s + 1.5 * o * (-f + y), x = c * s + 1.5 * o * (-f - y);
      _ < 0 ? _ = -Ad(-_, Ed) : _ = Ad(_, Ed), x < 0 ? x = -Ad(-x, Ed) : x = Ad(x, Ed);
      var p = (-s - (_ + x)) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p);
    } else {
      var b = (2 * c * s - 3 * o * f) / (2 * Po(c * c * c)), S = Math.acos(b) / 3, w = Po(c), A = Math.cos(S), p = (-s - 2 * w * A) / (3 * o), m = (-s + w * (A + OT * Math.sin(S))) / (3 * o), T = (-s + w * (A - OT * Math.sin(S))) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m), T >= 0 && T <= 1 && (a[d++] = T);
    }
  }
  return d;
}
function cP(r, t, e, n, i) {
  var a = 6 * e - 12 * t + 6 * r, o = 9 * t + 3 * n - 3 * r - 9 * e, s = 3 * t - 3 * r, l = 0;
  if (Mo(o)) {
    if (uP(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (Mo(c))
      i[0] = -a / (2 * o);
    else if (c > 0) {
      var f = Po(c), u = (-a + f) / (2 * o), h = (-a - f) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function Uo(r, t, e, n, i, a) {
  var o = (t - r) * i + r, s = (e - t) * i + t, l = (n - e) * i + e, u = (s - o) * i + o, c = (l - s) * i + s, f = (c - u) * i + u;
  a[0] = r, a[1] = o, a[2] = u, a[3] = f, a[4] = f, a[5] = c, a[6] = l, a[7] = n;
}
function fP(r, t, e, n, i, a, o, s, l, u, c) {
  var f, h = 5e-3, d = 1 / 0, p, g, v, m;
  Ui[0] = l, Ui[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    jn[0] = wr(r, e, i, o, y), jn[1] = wr(t, n, a, s, y), v = rl(Ui, jn), v < d && (f = y, d = v);
  d = 1 / 0;
  for (var _ = 0; _ < 32 && !(h < lP); _++)
    p = f - h, g = f + h, jn[0] = wr(r, e, i, o, p), jn[1] = wr(t, n, a, s, p), v = rl(jn, Ui), p >= 0 && v < d ? (f = p, d = v) : (Wu[0] = wr(r, e, i, o, g), Wu[1] = wr(t, n, a, s, g), m = rl(Wu, Ui), g <= 1 && m < d ? (f = g, d = m) : h *= 0.5);
  return c && (c[0] = wr(r, e, i, o, f), c[1] = wr(t, n, a, s, f)), Po(d);
}
function KW(r, t, e, n, i, a, o, s, l) {
  for (var u = r, c = t, f = 0, h = 1 / l, d = 1; d <= l; d++) {
    var p = d * h, g = wr(r, e, i, o, p), v = wr(t, n, a, s, p), m = g - u, y = v - c;
    f += Math.sqrt(m * m + y * y), u = g, c = v;
  }
  return f;
}
function Pr(r, t, e, n) {
  var i = 1 - n;
  return i * (i * r + 2 * n * t) + n * n * e;
}
function ox(r, t, e, n) {
  return 2 * ((1 - n) * (t - r) + n * (e - t));
}
function jW(r, t, e, n, i) {
  var a = r - 2 * t + e, o = 2 * (t - r), s = r - n, l = 0;
  if (Mo(a)) {
    if (uP(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (Mo(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var f = Po(c), u = (-o + f) / (2 * a), h = (-o - f) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function hP(r, t, e) {
  var n = r + e - 2 * t;
  return n === 0 ? 0.5 : (r - t) / n;
}
function rh(r, t, e, n, i) {
  var a = (t - r) * n + r, o = (e - t) * n + t, s = (o - a) * n + a;
  i[0] = r, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = e;
}
function dP(r, t, e, n, i, a, o, s, l) {
  var u, c = 5e-3, f = 1 / 0;
  Ui[0] = o, Ui[1] = s;
  for (var h = 0; h < 1; h += 0.05) {
    jn[0] = Pr(r, e, i, h), jn[1] = Pr(t, n, a, h);
    var d = rl(Ui, jn);
    d < f && (u = h, f = d);
  }
  f = 1 / 0;
  for (var p = 0; p < 32 && !(c < lP); p++) {
    var g = u - c, v = u + c;
    jn[0] = Pr(r, e, i, g), jn[1] = Pr(t, n, a, g);
    var d = rl(jn, Ui);
    if (g >= 0 && d < f)
      u = g, f = d;
    else {
      Wu[0] = Pr(r, e, i, v), Wu[1] = Pr(t, n, a, v);
      var m = rl(Wu, Ui);
      v <= 1 && m < f ? (u = v, f = m) : c *= 0.5;
    }
  }
  return l && (l[0] = Pr(r, e, i, u), l[1] = Pr(t, n, a, u)), Po(f);
}
function JW(r, t, e, n, i, a, o) {
  for (var s = r, l = t, u = 0, c = 1 / o, f = 1; f <= o; f++) {
    var h = f * c, d = Pr(r, e, i, h), p = Pr(t, n, a, h), g = d - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = d, l = p;
  }
  return u;
}
var QW = /cubic-bezier\(([0-9,\.e ]+)\)/;
function E1(r) {
  var t = r && QW.exec(r);
  if (t) {
    var e = t[1].split(","), n = +ei(e[0]), i = +ei(e[1]), a = +ei(e[2]), o = +ei(e[3]);
    if (isNaN(n + i + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : wv(0, n, a, 1, l, s) && wr(0, i, o, 1, s[0]);
    };
  }
}
var t8 = function() {
  function r(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || rr, this.ondestroy = t.ondestroy || rr, this.onrestart = t.onrestart || rr, t.easing && this.setEasing(t.easing);
  }
  return r.prototype.step = function(t, e) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += e;
      return;
    }
    var n = this._life, i = t - this._startTime - this._pausedTime, a = i / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = i % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, r.prototype.pause = function() {
    this._paused = !0;
  }, r.prototype.resume = function() {
    this._paused = !1;
  }, r.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = At(t) ? t : Hf[t] || E1(t);
  }, r;
}(), pP = /* @__PURE__ */ function() {
  function r(t) {
    this.value = t;
  }
  return r;
}(), e8 = function() {
  function r() {
    this._len = 0;
  }
  return r.prototype.insert = function(t) {
    var e = new pP(t);
    return this.insertEntry(e), e;
  }, r.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, r.prototype.remove = function(t) {
    var e = t.prev, n = t.next;
    e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, r;
}(), tc = function() {
  function r(t) {
    this._list = new e8(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return r.prototype.put = function(t, e) {
    var n = this._list, i = this._map, a = null;
    if (i[t] == null) {
      var o = n.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = n.head;
        n.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = e : s = new pP(e), s.key = t, n.insertEntry(s), i[t] = s;
    }
    return a;
  }, r.prototype.get = function(t) {
    var e = this._map[t], n = this._list;
    if (e != null)
      return e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value;
  }, r.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, r.prototype.len = function() {
    return this._list.len();
  }, r;
}(), BT = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function yi(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function r8(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
}
function nh(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function my(r) {
  var t = r;
  return t.length && t.charAt(t.length - 1) === "%" ? yi(parseFloat(t) / 100 * 255) : yi(parseInt(t, 10));
}
function No(r) {
  var t = r;
  return t.length && t.charAt(t.length - 1) === "%" ? nh(parseFloat(t) / 100) : nh(parseFloat(t));
}
function yy(r, t, e) {
  return e < 0 ? e += 1 : e > 1 && (e -= 1), e * 6 < 1 ? r + (t - r) * e * 6 : e * 2 < 1 ? t : e * 3 < 2 ? r + (t - r) * (2 / 3 - e) * 6 : r;
}
function To(r, t, e) {
  return r + (t - r) * e;
}
function Yn(r, t, e, n, i) {
  return r[0] = t, r[1] = e, r[2] = n, r[3] = i, r;
}
function sx(r, t) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r;
}
var vP = new tc(20), Cd = null;
function tu(r, t) {
  Cd && sx(Cd, t), Cd = vP.put(r, Cd || t.slice());
}
function wn(r, t) {
  if (r) {
    t = t || [];
    var e = vP.get(r);
    if (e)
      return sx(t, e);
    r = r + "";
    var n = r.replace(/ /g, "").toLowerCase();
    if (n in BT)
      return sx(t, BT[n]), tu(r, t), t;
    var i = n.length;
    if (n.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          Yn(t, 0, 0, 0, 1);
          return;
        }
        return Yn(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), tu(r, t), t;
      } else if (i === 7 || i === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          Yn(t, 0, 0, 0, 1);
          return;
        }
        return Yn(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), tu(r, t), t;
      }
      return;
    }
    var o = n.indexOf("("), s = n.indexOf(")");
    if (o !== -1 && s + 1 === i) {
      var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Yn(t, +u[0], +u[1], +u[2], 1) : Yn(t, 0, 0, 0, 1);
          c = No(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Yn(t, my(u[0]), my(u[1]), my(u[2]), u.length === 3 ? c : No(u[3])), tu(r, t), t;
          Yn(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Yn(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = No(u[3]), lx(u, t), tu(r, t), t;
        case "hsl":
          if (u.length !== 3) {
            Yn(t, 0, 0, 0, 1);
            return;
          }
          return lx(u, t), tu(r, t), t;
        default:
          return;
      }
    }
    Yn(t, 0, 0, 0, 1);
  }
}
function lx(r, t) {
  var e = (parseFloat(r[0]) % 360 + 360) % 360 / 360, n = No(r[1]), i = No(r[2]), a = i <= 0.5 ? i * (n + 1) : i + n - i * n, o = i * 2 - a;
  return t = t || [], Yn(t, yi(yy(o, a, e + 1 / 3) * 255), yi(yy(o, a, e) * 255), yi(yy(o, a, e - 1 / 3) * 255), 1), r.length === 4 && (t[3] = r[3]), t;
}
function n8(r) {
  if (r) {
    var t = r[0] / 255, e = r[1] / 255, n = r[2] / 255, i = Math.min(t, e, n), a = Math.max(t, e, n), o = a - i, s = (a + i) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
      var c = ((a - t) / 6 + o / 2) / o, f = ((a - e) / 6 + o / 2) / o, h = ((a - n) / 6 + o / 2) / o;
      t === a ? l = h - f : e === a ? l = 1 / 3 + c - h : n === a && (l = 2 / 3 + f - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, s];
    return r[3] != null && d.push(r[3]), d;
  }
}
function ux(r, t) {
  var e = wn(r);
  if (e) {
    for (var n = 0; n < 3; n++)
      t < 0 ? e[n] = e[n] * (1 - t) | 0 : e[n] = (255 - e[n]) * t + e[n] | 0, e[n] > 255 ? e[n] = 255 : e[n] < 0 && (e[n] = 0);
    return Qi(e, e.length === 4 ? "rgba" : "rgb");
  }
}
function _y(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    e = e || [];
    var n = r * (t.length - 1), i = Math.floor(n), a = Math.ceil(n), o = t[i], s = t[a], l = n - i;
    return e[0] = yi(To(o[0], s[0], l)), e[1] = yi(To(o[1], s[1], l)), e[2] = yi(To(o[2], s[2], l)), e[3] = nh(To(o[3], s[3], l)), e;
  }
}
function i8(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    var n = r * (t.length - 1), i = Math.floor(n), a = Math.ceil(n), o = wn(t[i]), s = wn(t[a]), l = n - i, u = Qi([
      yi(To(o[0], s[0], l)),
      yi(To(o[1], s[1], l)),
      yi(To(o[2], s[2], l)),
      nh(To(o[3], s[3], l))
    ], "rgba");
    return e ? {
      color: u,
      leftIndex: i,
      rightIndex: a,
      value: n
    } : u;
  }
}
function Oo(r, t, e, n) {
  var i = wn(r);
  if (r)
    return i = n8(i), t != null && (i[0] = r8(At(t) ? t(i[0]) : t)), e != null && (i[1] = No(At(e) ? e(i[1]) : e)), n != null && (i[2] = No(At(n) ? n(i[2]) : n)), Qi(lx(i), "rgba");
}
function Mv(r, t) {
  var e = wn(r);
  if (e && t != null)
    return e[3] = nh(t), Qi(e, "rgba");
}
function Qi(r, t) {
  if (!(!r || !r.length)) {
    var e = r[0] + "," + r[1] + "," + r[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (e += "," + r[3]), t + "(" + e + ")";
  }
}
function Tv(r, t) {
  var e = wn(r);
  return e ? (0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3] / 255 + (1 - e[3]) * t : 0;
}
var VT = new tc(100);
function cx(r) {
  if (pt(r)) {
    var t = VT.get(r);
    return t || (t = ux(r, -0.1), VT.put(r, t)), t;
  } else if (Fg(r)) {
    var e = j({}, r);
    return e.colorStops = rt(r.colorStops, function(n) {
      return {
        offset: n.offset,
        color: ux(n.color, -0.1)
      };
    }), e;
  }
  return r;
}
var Av = Math.round;
function ih(r) {
  var t;
  if (!r || r === "transparent")
    r = "none";
  else if (typeof r == "string" && r.indexOf("rgba") > -1) {
    var e = wn(r);
    e && (r = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", t = e[3]);
  }
  return {
    color: r,
    opacity: t ?? 1
  };
}
var FT = 1e-4;
function Ao(r) {
  return r < FT && r > -FT;
}
function Dd(r) {
  return Av(r * 1e3) / 1e3;
}
function fx(r) {
  return Av(r * 1e4) / 1e4;
}
function a8(r) {
  return "matrix(" + Dd(r[0]) + "," + Dd(r[1]) + "," + Dd(r[2]) + "," + Dd(r[3]) + "," + fx(r[4]) + "," + fx(r[5]) + ")";
}
var o8 = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function s8(r, t, e) {
  return e === "top" ? r += t / 2 : e === "bottom" && (r -= t / 2), r;
}
function l8(r) {
  return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY);
}
function u8(r) {
  var t = r.style, e = r.getGlobalScale();
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    e[0],
    e[1]
  ].join(",");
}
function gP(r) {
  return r && !!r.image;
}
function c8(r) {
  return r && !!r.svgElement;
}
function C1(r) {
  return gP(r) || c8(r);
}
function mP(r) {
  return r.type === "linear";
}
function yP(r) {
  return r.type === "radial";
}
function _P(r) {
  return r && (r.type === "linear" || r.type === "radial");
}
function Wg(r) {
  return "url(#" + r + ")";
}
function xP(r) {
  var t = r.getGlobalScale(), e = Math.max(t[0], t[1]);
  return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1);
}
function SP(r) {
  var t = r.x || 0, e = r.y || 0, n = (r.rotation || 0) * Gp, i = bt(r.scaleX, 1), a = bt(r.scaleY, 1), o = r.skewX || 0, s = r.skewY || 0, l = [];
  return (t || e) && l.push("translate(" + t + "px," + e + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + Av(o * Gp) + "deg, " + Av(s * Gp) + "deg)"), l.join(" ");
}
var f8 = function() {
  return oe.hasGlobalWindow && At(window.btoa) ? function(r) {
    return window.btoa(unescape(encodeURIComponent(r)));
  } : typeof Buffer < "u" ? function(r) {
    return Buffer.from(r).toString("base64");
  } : function(r) {
    return process.env.NODE_ENV !== "production" && mi("Base64 isn't natively supported in the current environment."), null;
  };
}(), hx = Array.prototype.slice;
function Ma(r, t, e) {
  return (t - r) * e + r;
}
function xy(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++)
    r[a] = Ma(t[a], e[a], n);
  return r;
}
function h8(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = Ma(t[o][s], e[o][s], n);
  }
  return r;
}
function Ld(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++)
    r[a] = t[a] + e[a] * n;
  return r;
}
function zT(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = t[o][s] + e[o][s] * n;
  }
  return r;
}
function d8(r, t) {
  for (var e = r.length, n = t.length, i = e > n ? t : r, a = Math.min(e, n), o = i[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(e, n); s++)
    i.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function p8(r, t, e) {
  var n = r, i = t;
  if (!(!n.push || !i.push)) {
    var a = n.length, o = i.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        n.length = o;
      else
        for (var l = a; l < o; l++)
          n.push(e === 1 ? i[l] : hx.call(i[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (e === 1)
        isNaN(n[l]) && (n[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = i[l][c]);
  }
}
function Wf(r) {
  if (Kr(r)) {
    var t = r.length;
    if (Kr(r[0])) {
      for (var e = [], n = 0; n < t; n++)
        e.push(hx.call(r[n]));
      return e;
    }
    return hx.call(r);
  }
  return r;
}
function Yp(r) {
  return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
}
function v8(r) {
  return Kr(r && r[0]) ? 2 : 1;
}
var Rd = 0, $p = 1, bP = 2, Cf = 3, dx = 4, px = 5, UT = 6;
function GT(r) {
  return r === dx || r === px;
}
function Id(r) {
  return r === $p || r === bP;
}
var Zc = [0, 0, 0, 0], g8 = function() {
  function r(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return r.prototype.isFinished = function() {
    return this._finished;
  }, r.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, r.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, r.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, r.prototype.addKeyframe = function(t, e, n) {
    this._needsSort = !0;
    var i = this.keyframes, a = i.length, o = !1, s = UT, l = e;
    if (Kr(e)) {
      var u = v8(e);
      s = u, (u === 1 && !fe(e[0]) || u === 2 && !fe(e[0][0])) && (o = !0);
    } else if (fe(e) && !kr(e))
      s = Rd;
    else if (pt(e))
      if (!isNaN(+e))
        s = Rd;
      else {
        var c = wn(e);
        c && (l = c, s = Cf);
      }
    else if (Fg(e)) {
      var f = j({}, l);
      f.colorStops = rt(e.colorStops, function(d) {
        return {
          offset: d.offset,
          color: wn(d.color)
        };
      }), mP(e) ? s = dx : yP(e) && (s = px), l = f;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === UT) && (o = !0), this.discrete = this.discrete || o;
    var h = {
      time: t,
      value: l,
      rawValue: e,
      percent: 0
    };
    return n && (h.easing = n, h.easingFunc = At(n) ? n : Hf[n] || E1(n)), i.push(h), h;
  }, r.prototype.prepare = function(t, e) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var i = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = Id(i), u = GT(i), c = 0; c < a; c++) {
      var f = n[c], h = f.value, d = o.value;
      f.percent = f.time / t, s || (l && c !== a - 1 ? p8(h, d, i) : u && d8(h.colorStops, d.colorStops));
    }
    if (!s && i !== px && e && this.needsAnimate() && e.needsAnimate() && i === e.valType && !e._finished) {
      this._additiveTrack = e;
      for (var p = n[0].value, c = 0; c < a; c++)
        i === Rd ? n[c].additiveValue = n[c].value - p : i === Cf ? n[c].additiveValue = Ld([], n[c].value, p, -1) : Id(i) && (n[c].additiveValue = i === $p ? Ld([], n[c].value, p, -1) : zT([], n[c].value, p, -1));
    }
  }, r.prototype.step = function(t, e) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Cf, c, f = this._lastFr, h = Math.min, d, p;
      if (s === 1)
        d = p = o[0];
      else {
        if (e < 0)
          c = 0;
        else if (e < this._lastFrP) {
          var g = h(f + 1, s - 1);
          for (c = g; c >= 0 && !(o[c].percent <= e); c--)
            ;
          c = h(c, s - 2);
        } else {
          for (c = f; c < s && !(o[c].percent > e); c++)
            ;
          c = h(c - 1, s - 2);
        }
        p = o[c + 1], d = o[c];
      }
      if (d && p) {
        this._lastFr = c, this._lastFrP = e;
        var v = p.percent - d.percent, m = v === 0 ? 1 : h((e - d.percent) / v, 1);
        p.easingFunc && (m = p.easingFunc(m));
        var y = n ? this._additiveValue : u ? Zc : t[l];
        if ((Id(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? d.rawValue : p.rawValue;
        else if (Id(a))
          a === $p ? xy(y, d[i], p[i], m) : h8(y, d[i], p[i], m);
        else if (GT(a)) {
          var _ = d[i], x = p[i], b = a === dx;
          t[l] = {
            type: b ? "linear" : "radial",
            x: Ma(_.x, x.x, m),
            y: Ma(_.y, x.y, m),
            colorStops: rt(_.colorStops, function(w, A) {
              var T = x.colorStops[A];
              return {
                offset: Ma(w.offset, T.offset, m),
                color: Yp(xy([], w.color, T.color, m))
              };
            }),
            global: x.global
          }, b ? (t[l].x2 = Ma(_.x2, x.x2, m), t[l].y2 = Ma(_.y2, x.y2, m)) : t[l].r = Ma(_.r, x.r, m);
        } else if (u)
          xy(y, d[i], p[i], m), n || (t[l] = Yp(y));
        else {
          var S = Ma(d[i], p[i], m);
          n ? this._additiveValue = S : t[l] = S;
        }
        n && this._addToTarget(t);
      }
    }
  }, r.prototype._addToTarget = function(t) {
    var e = this.valType, n = this.propName, i = this._additiveValue;
    e === Rd ? t[n] = t[n] + i : e === Cf ? (wn(t[n], Zc), Ld(Zc, Zc, i, 1), t[n] = Yp(Zc)) : e === $p ? Ld(t[n], t[n], i, 1) : e === bP && zT(t[n], t[n], i, 1);
  }, r;
}(), D1 = function() {
  function r(t, e, n, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && i) {
      mi("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = n;
  }
  return r.prototype.getMaxTime = function() {
    return this._maxTime;
  }, r.prototype.getDelay = function() {
    return this._delay;
  }, r.prototype.getLoop = function() {
    return this._loop;
  }, r.prototype.getTarget = function() {
    return this._target;
  }, r.prototype.changeTarget = function(t) {
    this._target = t;
  }, r.prototype.when = function(t, e, n) {
    return this.whenWithKeys(t, e, se(e), n);
  }, r.prototype.whenWithKeys = function(t, e, n, i) {
    for (var a = this._tracks, o = 0; o < n.length; o++) {
      var s = n[o], l = a[s];
      if (!l) {
        l = a[s] = new g8(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var f = c.keyframes, h = f[f.length - 1];
          u = h && h.value, c.valType === Cf && u && (u = Yp(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, Wf(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(t, Wf(e[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, r.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, r.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, r.prototype.isPaused = function() {
    return !!this._paused;
  }, r.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, r.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var e = t.length, n = 0; n < e; n++)
        t[n].call(this);
  }, r.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, e = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, e)
      for (var n = 0; n < e.length; n++)
        e[n].call(this);
  }, r.prototype._setTracksFinished = function() {
    for (var t = this._tracks, e = this._trackKeys, n = 0; n < e.length; n++)
      t[e[n]].setFinished();
  }, r.prototype._getAdditiveTrack = function(t) {
    var e, n = this._additiveAnimators;
    if (n)
      for (var i = 0; i < n.length; i++) {
        var a = n[i].getTrack(t);
        a && (e = a);
      }
    return e;
  }, r.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var e = this, n = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var f = u[c - 1];
            f && (e._target[s.propName] = f.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var h = new t8({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            e._started = 2;
            var p = e._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (e._additiveAnimators = null);
            }
            for (var v = 0; v < n.length; v++)
              n[v].step(e._target, d);
            var m = e._onframeCbs;
            if (m)
              for (var v = 0; v < m.length; v++)
                m[v](e._target, d);
          },
          ondestroy: function() {
            e._doneCallback();
          }
        });
        this._clip = h, this.animation && this.animation.addClip(h), t && h.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, r.prototype.stop = function(t) {
    if (this._clip) {
      var e = this._clip;
      t && e.onframe(1), this._abortedCallback();
    }
  }, r.prototype.delay = function(t) {
    return this._delay = t, this;
  }, r.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, r.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, r.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, r.prototype.getClip = function() {
    return this._clip;
  }, r.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, r.prototype.getTracks = function() {
    var t = this;
    return rt(this._trackKeys, function(e) {
      return t._tracks[e];
    });
  }, r.prototype.stopTracks = function(t, e) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, i = this._trackKeys, a = 0; a < t.length; a++) {
      var o = n[t[a]];
      o && !o.isFinished() && (e ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < i.length; a++)
      if (!n[i[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, r.prototype.saveTo = function(t, e, n) {
    if (t) {
      e = e || this._trackKeys;
      for (var i = 0; i < e.length; i++) {
        var a = e[i], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[n ? 0 : s.length - 1];
          l && (t[a] = Wf(l.rawValue));
        }
      }
    }
  }, r.prototype.__changeFinalValue = function(t, e) {
    e = e || se(t);
    for (var n = 0; n < e.length; n++) {
      var i = e[n], a = this._tracks[i];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, t[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, r;
}();
function Ou() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var m8 = function(r) {
  Ue(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, e = e || {}, n.stage = e.stage || {}, n;
  }
  return t.prototype.addClip = function(e) {
    e.animation && this.removeClip(e), this._head ? (this._tail.next = e, e.prev = this._tail, e.next = null, this._tail = e) : this._head = this._tail = e, e.animation = this;
  }, t.prototype.addAnimator = function(e) {
    e.animation = this;
    var n = e.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(e) {
    if (e.animation) {
      var n = e.prev, i = e.next;
      n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, e.next = e.prev = e.animation = null;
    }
  }, t.prototype.removeAnimator = function(e) {
    var n = e.getClip();
    n && this.removeClip(n), e.animation = null;
  }, t.prototype.update = function(e) {
    for (var n = Ou() - this._pausedTime, i = n - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(n, i);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = n, e || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var e = this;
    this._running = !0;
    function n() {
      e._running && (Sv(n), !e._paused && e.update());
    }
    Sv(n);
  }, t.prototype.start = function() {
    this._running || (this._time = Ou(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = Ou(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += Ou() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var e = this._head; e; ) {
      var n = e.next;
      e.prev = e.next = e.animation = null, e = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(e, n) {
    n = n || {}, this.start();
    var i = new D1(e, n.loop);
    return this.addAnimator(i), i;
  }, t;
}(si), y8 = 300, Sy = oe.domSupported, by = function() {
  var r = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], e = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = rt(r, function(i) {
    var a = i.replace("mouse", "pointer");
    return e.hasOwnProperty(a) ? a : i;
  });
  return {
    mouse: r,
    touch: t,
    pointer: n
  };
}(), HT = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, WT = !1;
function vx(r) {
  var t = r.pointerType;
  return t === "pen" || t === "touch";
}
function _8(r) {
  r.touching = !0, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
    r.touching = !1, r.touchTimer = null;
  }, 700);
}
function wy(r) {
  r && (r.zrByTouch = !0);
}
function x8(r, t) {
  return $n(r.dom, new S8(r, t), !0);
}
function wP(r, t) {
  for (var e = t, n = !1; e && e.nodeType !== 9 && !(n = e.domBelongToZr || e !== t && e === r.painterRoot); )
    e = e.parentNode;
  return n;
}
var S8 = /* @__PURE__ */ function() {
  function r(t, e) {
    this.stopPropagation = rr, this.stopImmediatePropagation = rr, this.preventDefault = rr, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
  }
  return r;
}(), hi = {
  mousedown: function(r) {
    r = $n(this.dom, r), this.__mayPointerCapture = [r.zrX, r.zrY], this.trigger("mousedown", r);
  },
  mousemove: function(r) {
    r = $n(this.dom, r);
    var t = this.__mayPointerCapture;
    t && (r.zrX !== t[0] || r.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    r = $n(this.dom, r), this.__togglePointerCapture(!1), this.trigger("mouseup", r);
  },
  mouseout: function(r) {
    r = $n(this.dom, r);
    var t = r.toElement || r.relatedTarget;
    wP(this, t) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
  },
  wheel: function(r) {
    WT = !0, r = $n(this.dom, r), this.trigger("mousewheel", r);
  },
  mousewheel: function(r) {
    WT || (r = $n(this.dom, r), this.trigger("mousewheel", r));
  },
  touchstart: function(r) {
    r = $n(this.dom, r), wy(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), hi.mousemove.call(this, r), hi.mousedown.call(this, r);
  },
  touchmove: function(r) {
    r = $n(this.dom, r), wy(r), this.handler.processGesture(r, "change"), hi.mousemove.call(this, r);
  },
  touchend: function(r) {
    r = $n(this.dom, r), wy(r), this.handler.processGesture(r, "end"), hi.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < y8 && hi.click.call(this, r);
  },
  pointerdown: function(r) {
    hi.mousedown.call(this, r);
  },
  pointermove: function(r) {
    vx(r) || hi.mousemove.call(this, r);
  },
  pointerup: function(r) {
    hi.mouseup.call(this, r);
  },
  pointerout: function(r) {
    vx(r) || hi.mouseout.call(this, r);
  }
};
L(["click", "dblclick", "contextmenu"], function(r) {
  hi[r] = function(t) {
    t = $n(this.dom, t), this.trigger(r, t);
  };
});
var gx = {
  pointermove: function(r) {
    vx(r) || gx.mousemove.call(this, r);
  },
  pointerup: function(r) {
    gx.mouseup.call(this, r);
  },
  mousemove: function(r) {
    this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", r), t && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
  }
};
function b8(r, t) {
  var e = t.domHandlers;
  oe.pointerEventsSupported ? L(by.pointer, function(n) {
    Zp(t, n, function(i) {
      e[n].call(r, i);
    });
  }) : (oe.touchEventsSupported && L(by.touch, function(n) {
    Zp(t, n, function(i) {
      e[n].call(r, i), _8(t);
    });
  }), L(by.mouse, function(n) {
    Zp(t, n, function(i) {
      i = T1(i), t.touching || e[n].call(r, i);
    });
  }));
}
function w8(r, t) {
  oe.pointerEventsSupported ? L(HT.pointer, e) : oe.touchEventsSupported || L(HT.mouse, e);
  function e(n) {
    function i(a) {
      a = T1(a), wP(r, a.target) || (a = x8(r, a), t.domHandlers[n].call(r, a));
    }
    Zp(t, n, i, { capture: !0 });
  }
}
function Zp(r, t, e, n) {
  r.mounted[t] = e, r.listenerOpts[t] = n, nx(r.domTarget, t, e, n);
}
function My(r) {
  var t = r.mounted;
  for (var e in t)
    t.hasOwnProperty(e) && NW(r.domTarget, e, t[e], r.listenerOpts[e]);
  r.mounted = {};
}
var XT = /* @__PURE__ */ function() {
  function r(t, e) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = e;
  }
  return r;
}(), M8 = function(r) {
  Ue(t, r);
  function t(e, n) {
    var i = r.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = e, i.painterRoot = n, i._localHandlerScope = new XT(e, hi), Sy && (i._globalHandlerScope = new XT(document, gx)), b8(i, i._localHandlerScope), i;
  }
  return t.prototype.dispose = function() {
    My(this._localHandlerScope), Sy && My(this._globalHandlerScope);
  }, t.prototype.setCursor = function(e) {
    this.dom.style && (this.dom.style.cursor = e || "default");
  }, t.prototype.__togglePointerCapture = function(e) {
    if (this.__mayPointerCapture = null, Sy && +this.__pointerCapturing ^ +e) {
      this.__pointerCapturing = e;
      var n = this._globalHandlerScope;
      e ? w8(this, n) : My(n);
    }
  }, t;
}(si), MP = 1;
oe.hasGlobalWindow && (MP = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Ev = MP, mx = 0.4, yx = "#333", _x = "#ccc", T8 = "#eee", YT = Gg, $T = 5e-5;
function fs(r) {
  return r > $T || r < -$T;
}
var hs = [], eu = [], Ty = Br(), Ay = Math.abs, La = function() {
  function r() {
  }
  return r.prototype.getLocalTransform = function(t) {
    return r.getLocalTransform(this, t);
  }, r.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, r.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, r.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, r.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, r.prototype.needLocalTransform = function() {
    return fs(this.rotation) || fs(this.x) || fs(this.y) || fs(this.scaleX - 1) || fs(this.scaleY - 1) || fs(this.skewX) || fs(this.skewY);
  }, r.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, e = this.needLocalTransform(), n = this.transform;
    if (!(e || t)) {
      n && (YT(n), this.invTransform = null);
      return;
    }
    n = n || Br(), e ? this.getLocalTransform(n) : YT(n), t && (e ? Ji(n, t, n) : Hg(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, r.prototype._resolveGlobalScaleRatio = function(t) {
    var e = this.globalScaleRatio;
    if (e != null && e !== 1) {
      this.getGlobalScale(hs);
      var n = hs[0] < 0 ? -1 : 1, i = hs[1] < 0 ? -1 : 1, a = ((hs[0] - n) * e + n) / hs[0] || 0, o = ((hs[1] - i) * e + i) / hs[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
    }
    this.invTransform = this.invTransform || Br(), bi(this.invTransform, t);
  }, r.prototype.getComputedTransform = function() {
    for (var t = this, e = []; t; )
      e.push(t), t = t.parent;
    for (; t = e.pop(); )
      t.updateTransform();
    return this.transform;
  }, r.prototype.setLocalTransform = function(t) {
    if (t) {
      var e = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], i = Math.atan2(t[1], t[0]), a = Math.PI / 2 + i - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, r.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, e = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || Br(), Ji(eu, t.invTransform, e), e = eu);
      var n = this.originX, i = this.originY;
      (n || i) && (Ty[4] = n, Ty[5] = i, Ji(eu, e, Ty), eu[4] -= n, eu[5] -= i, e = eu), this.setLocalTransform(e);
    }
  }, r.prototype.getGlobalScale = function(t) {
    var e = this.transform;
    return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, r.prototype.transformCoordToLocal = function(t, e) {
    var n = [t, e], i = this.invTransform;
    return i && nr(n, n, i), n;
  }, r.prototype.transformCoordToGlobal = function(t, e) {
    var n = [t, e], i = this.transform;
    return i && nr(n, n, i), n;
  }, r.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ay(t[0] - 1) > 1e-10 && Ay(t[3] - 1) > 1e-10 ? Math.sqrt(Ay(t[0] * t[3] - t[2] * t[1])) : 1;
  }, r.prototype.copyTransform = function(t) {
    Cv(this, t);
  }, r.getLocalTransform = function(t, e) {
    e = e || [];
    var n = t.originX || 0, i = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, f = t.y, h = t.skewX ? Math.tan(t.skewX) : 0, d = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || i || s || l) {
      var p = n + s, g = i + l;
      e[4] = -p * a - h * g * o, e[5] = -g * o - d * p * a;
    } else
      e[4] = e[5] = 0;
    return e[0] = a, e[3] = o, e[1] = d * a, e[2] = h * o, u && Ko(e, e, u), e[4] += n + c, e[5] += i + f, e;
  }, r.initDefaultProps = function() {
    var t = r.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  }(), r;
}(), ia = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function Cv(r, t) {
  for (var e = 0; e < ia.length; e++) {
    var n = ia[e];
    r[n] = t[n];
  }
}
function ta(r) {
  Pd || (Pd = new tc(100)), r = r || Ua;
  var t = Pd.get(r);
  return t || (t = {
    font: r,
    strWidthCache: new tc(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: Si.measureText("", r).width,
    asciiCharWidth: Si.measureText("a", r).width
  }, Pd.put(r, t)), t;
}
var Pd;
function A8(r) {
  if (!(Ey >= ZT)) {
    r = r || Ua;
    for (var t = [], e = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = Si.measureText(String.fromCharCode(n), r).width;
    var i = +/* @__PURE__ */ new Date() - e;
    return i > 16 ? Ey = ZT : i > 2 && Ey++, t;
  }
}
var Ey = 0, ZT = 5;
function TP(r, t) {
  return r.asciiWidthMapTried || (r.asciiWidthMap = A8(r.font), r.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? r.asciiWidthMap != null ? r.asciiWidthMap[t] : r.asciiCharWidth : r.stWideCharWidth;
}
function ea(r, t) {
  var e = r.strWidthCache, n = e.get(t);
  return n == null && (n = Si.measureText(t, r.font).width, e.put(t, n)), n;
}
function qT(r, t, e, n) {
  var i = ea(ta(t), r), a = Nh(t), o = ec(0, i, e), s = nl(0, a, n), l = new Vt(o, s, i, a);
  return l;
}
function Xg(r, t, e, n) {
  var i = ((r || "") + "").split(`
`), a = i.length;
  if (a === 1)
    return qT(i[0], t, e, n);
  for (var o = new Vt(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = qT(i[s], t, e, n);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function ec(r, t, e, n) {
  return e === "right" ? n ? r += t : r -= t : e === "center" && (n ? r += t / 2 : r -= t / 2), r;
}
function nl(r, t, e, n) {
  return e === "middle" ? n ? r += t / 2 : r -= t / 2 : e === "bottom" && (n ? r += t : r -= t), r;
}
function Nh(r) {
  return ta(r).stWideCharWidth;
}
function wi(r, t) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * t : parseFloat(r) : r;
}
function Dv(r, t, e) {
  var n = t.position || "inside", i = t.distance != null ? t.distance : 5, a = e.height, o = e.width, s = a / 2, l = e.x, u = e.y, c = "left", f = "top";
  if (n instanceof Array)
    l += wi(n[0], e.width), u += wi(n[1], e.height), c = null, f = null;
  else
    switch (n) {
      case "left":
        l -= i, u += s, c = "right", f = "middle";
        break;
      case "right":
        l += i + o, u += s, f = "middle";
        break;
      case "top":
        l += o / 2, u -= i, c = "center", f = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", f = "middle";
        break;
      case "insideLeft":
        l += i, u += s, f = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, c = "right", f = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, c = "center", f = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, f = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, c = "right", f = "bottom";
        break;
    }
  return r = r || {}, r.x = l, r.y = u, r.align = c, r.verticalAlign = f, r;
}
var Cy = "__zr_normal__", Dy = ia.concat(["ignore"]), E8 = ra(ia, function(r, t) {
  return r[t] = !0, r;
}, { ignore: !1 }), ru = {}, C8 = new Vt(0, 0, 0, 0), Nd = [], Yg = function() {
  function r(t) {
    this.id = jI(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return r.prototype._init = function(t) {
    this.attr(t);
  }, r.prototype.drift = function(t, e, n) {
    switch (this.draggable) {
      case "horizontal":
        e = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.markRedraw();
  }, r.prototype.beforeUpdate = function() {
  }, r.prototype.afterUpdate = function() {
  }, r.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, r.prototype.updateInnerText = function(t) {
    var e = this._textContent;
    if (e && (!e.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, i = n.local, a = e.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = i ? this : null;
      var u = !1;
      a.copyTransform(e);
      var c = n.position != null, f = n.autoOverflowArea, h = void 0;
      if ((f || c) && (h = C8, n.layoutRect ? h.copy(n.layoutRect) : h.copy(this.getBoundingRect()), i || h.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(ru, n, h) : Dv(ru, n, h), a.x = ru.x, a.y = ru.y, o = ru.align, s = ru.verticalAlign;
        var d = n.origin;
        if (d && n.rotation != null) {
          var p = void 0, g = void 0;
          d === "center" ? (p = h.width * 0.5, g = h.height * 0.5) : (p = wi(d[0], h.width), g = wi(d[1], h.height)), u = !0, a.originX = -a.x + p + (i ? 0 : h.x), a.originY = -a.y + g + (i ? 0 : h.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var v = n.offset;
      v && (a.x += v[0], a.y += v[1], u || (a.originX = -v[0], a.originY = -v[1]));
      var m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (f) {
        var y = m.overflowRect = m.overflowRect || new Vt(0, 0, 0, 0);
        a.getLocalTransform(Nd), bi(Nd, Nd), Vt.copy(y, h), y.applyTransform(Nd);
      } else
        m.overflowRect = null;
      var _ = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, x = void 0, b = void 0, S = void 0;
      _ && this.canBeInsideText() ? (x = n.insideFill, b = n.insideStroke, (x == null || x === "auto") && (x = this.getInsideTextFill()), (b == null || b === "auto") && (b = this.getInsideTextStroke(x), S = !0)) : (x = n.outsideFill, b = n.outsideStroke, (x == null || x === "auto") && (x = this.getOutsideFill()), (b == null || b === "auto") && (b = this.getOutsideStroke(x), S = !0)), x = x || "#000", (x !== m.fill || b !== m.stroke || S !== m.autoStroke || o !== m.align || s !== m.verticalAlign) && (l = !0, m.fill = x, m.stroke = b, m.autoStroke = S, m.align = o, m.verticalAlign = s, e.setDefaultTextStyle(m)), e.__dirty |= In, l && e.dirtyStyle(!0);
    }
  }, r.prototype.canBeInsideText = function() {
    return !0;
  }, r.prototype.getInsideTextFill = function() {
    return "#fff";
  }, r.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, r.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? _x : yx;
  }, r.prototype.getOutsideStroke = function(t) {
    var e = this.__zr && this.__zr.getBackgroundColor(), n = typeof e == "string" && wn(e);
    n || (n = [255, 255, 255, 1]);
    for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      n[o] = n[o] * i + (a ? 0 : 255) * (1 - i);
    return n[3] = 1, Qi(n, "rgba");
  }, r.prototype.traverse = function(t, e) {
  }, r.prototype.attrKV = function(t, e) {
    t === "textConfig" ? this.setTextConfig(e) : t === "textContent" ? this.setTextContent(e) : t === "clipPath" ? this.setClipPath(e) : t === "extra" ? (this.extra = this.extra || {}, j(this.extra, e)) : this[t] = e;
  }, r.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, r.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, r.prototype.attr = function(t, e) {
    if (typeof t == "string")
      this.attrKV(t, e);
    else if (Lt(t))
      for (var n = t, i = se(n), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, t[o]);
      }
    return this.markRedraw(), this;
  }, r.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var e = this._normalState, n = 0; n < this.animators.length; n++) {
      var i = this.animators[n], a = i.__fromStateTransition;
      if (!(i.getLoop() || a && a !== Cy)) {
        var o = i.targetName, s = o ? e[o] : e;
        i.saveTo(s);
      }
    }
  }, r.prototype._innerSaveToNormal = function(t) {
    var e = this._normalState;
    e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, Dy);
  }, r.prototype._savePrimaryToNormal = function(t, e, n) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      t[a] != null && !(a in e) && (e[a] = this[a]);
    }
  }, r.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, r.prototype.getState = function(t) {
    return this.states[t];
  }, r.prototype.ensureState = function(t) {
    var e = this.states;
    return e[t] || (e[t] = {}), e[t];
  }, r.prototype.clearStates = function(t) {
    this.useState(Cy, !1, t);
  }, r.prototype.useState = function(t, e, n, i) {
    var a = t === Cy, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Zt(s, t) >= 0 && (e || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          mi("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, e, !n && !this.__inHover && l && l.duration > 0, l);
        var f = this._textContent, h = this._textGuide;
        return f && f.useState(t, e, n, c), h && h.useState(t, e, n, c), a ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~In), u;
      }
    }
  }, r.prototype.useStates = function(t, e, n) {
    if (!t.length)
      this.clearStates();
    else {
      var i = [], a = this.currentStates, o = t.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (t[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && i.push(c);
      }
      var f = i[o - 1], h = !!(f && f.hoverLayer || n);
      h && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(i), p = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(t.join(","), d, this._normalState, !1, !e && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(t, e, h), v && v.useStates(t, e, h), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~In);
    }
  }, r.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var e = t.__hostTarget;
      t = e ? t.ignoreHostSilent ? null : e : t.parent;
    }
    return !1;
  }, r.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var e = this.animators[t];
      e.targetName && e.changeTarget(this[e.targetName]);
    }
  }, r.prototype.removeState = function(t) {
    var e = Zt(this.currentStates, t);
    if (e >= 0) {
      var n = this.currentStates.slice();
      n.splice(e, 1), this.useStates(n);
    }
  }, r.prototype.replaceState = function(t, e, n) {
    var i = this.currentStates.slice(), a = Zt(i, t), o = Zt(i, e) >= 0;
    a >= 0 ? o ? i.splice(a, 1) : i[a] = e : n && !o && i.push(e), this.useStates(i);
  }, r.prototype.toggleState = function(t, e) {
    e ? this.useState(t, !0) : this.removeState(t);
  }, r.prototype._mergeStates = function(t) {
    for (var e = {}, n, i = 0; i < t.length; i++) {
      var a = t[i];
      j(e, a), a.textConfig && (n = n || {}, j(n, a.textConfig));
    }
    return n && (e.textConfig = n), e;
  }, r.prototype._applyStateObj = function(t, e, n, i, a, o) {
    var s = !(e && i);
    e && e.textConfig ? (this.textConfig = j({}, i ? this.textConfig : n.textConfig), j(this.textConfig, e.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Dy.length; c++) {
      var f = Dy[c], h = a && E8[f];
      e && e[f] != null ? h ? (u = !0, l[f] = e[f]) : this[f] = e[f] : s && n[f] != null && (h ? (u = !0, l[f] = n[f]) : this[f] = n[f]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (e || n)[p] : e || n);
      }
    u && this._transitionState(t, l, o);
  }, r.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var e = this.__zr;
    e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this;
  }, r.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, r.prototype.getClipPath = function() {
    return this._clipPath;
  }, r.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, r.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, r.prototype.getTextContent = function() {
    return this._textContent;
  }, r.prototype.setTextContent = function(t) {
    var e = this._textContent;
    if (e !== t) {
      if (e && e !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new La(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, r.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), j(this.textConfig, t), this.markRedraw();
  }, r.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, r.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, r.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, r.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, r.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, r.prototype.markRedraw = function() {
    this.__dirty |= In;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, r.prototype.dirty = function() {
    this.markRedraw();
  }, r.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var e = this._textContent, n = this._textGuide;
    e && (e.__inHover = t), n && (n.__inHover = t);
  }, r.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var e = this.animators;
      if (e)
        for (var n = 0; n < e.length; n++)
          t.animation.addAnimator(e[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, r.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var e = this.animators;
      if (e)
        for (var n = 0; n < e.length; n++)
          t.animation.removeAnimator(e[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, r.prototype.animate = function(t, e, n) {
    var i = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      mi('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new D1(i, e, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, r.prototype.addAnimator = function(t, e) {
    var n = this.__zr, i = this;
    t.during(function() {
      i.updateDuringAnimation(e);
    }).done(function() {
      var a = i.animators, o = Zt(a, t);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, r.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, r.prototype.stopAnimation = function(t, e) {
    for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
      var s = n[o];
      !t || t === s.scope ? s.stop(e) : a.push(s);
    }
    return this.animators = a, this;
  }, r.prototype.animateTo = function(t, e, n) {
    Ly(this, t, e, n);
  }, r.prototype.animateFrom = function(t, e, n) {
    Ly(this, t, e, n, !0);
  }, r.prototype._transitionState = function(t, e, n, i) {
    for (var a = Ly(this, e, n, i), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = t;
  }, r.prototype.getBoundingRect = function() {
    return null;
  }, r.prototype.getPaintRect = function() {
    return null;
  }, r.initDefaultProps = function() {
    var t = r.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = In;
    var e = {};
    function n(a, o, s) {
      e[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), e[a + o + s] = !0);
    }
    function i(a, o, s, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, f) {
        Object.defineProperty(f, 0, {
          get: function() {
            return c[s];
          },
          set: function(h) {
            c[s] = h;
          }
        }), Object.defineProperty(f, 1, {
          get: function() {
            return c[l];
          },
          set: function(h) {
            c[l] = h;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), r;
}();
dr(Yg, si);
dr(Yg, La);
function Ly(r, t, e, n, i) {
  e = e || {};
  var a = [];
  AP(r, "", r, t, e, n, a, i);
  var o = a.length, s = !1, l = e.done, u = e.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, f = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && e.during && a[0].during(function(p, g) {
    e.during(g);
  });
  for (var h = 0; h < a.length; h++) {
    var d = a[h];
    c && d.done(c), f && d.aborted(f), e.force && d.duration(e.duration), d.start(e.easing);
  }
  return a;
}
function Ry(r, t, e) {
  for (var n = 0; n < e; n++)
    r[n] = t[n];
}
function D8(r) {
  return Kr(r[0]);
}
function L8(r, t, e) {
  if (Kr(t[e]))
    if (Kr(r[e]) || (r[e] = []), hn(t[e])) {
      var n = t[e].length;
      r[e].length !== n && (r[e] = new t[e].constructor(n), Ry(r[e], t[e], n));
    } else {
      var i = t[e], a = r[e], o = i.length;
      if (D8(i))
        for (var s = i[0].length, l = 0; l < o; l++)
          a[l] ? Ry(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else
        Ry(a, i, o);
      a.length = i.length;
    }
  else
    r[e] = t[e];
}
function R8(r, t) {
  return r === t || Kr(r) && Kr(t) && I8(r, t);
}
function I8(r, t) {
  var e = r.length;
  if (e !== t.length)
    return !1;
  for (var n = 0; n < e; n++)
    if (r[n] !== t[n])
      return !1;
  return !0;
}
function AP(r, t, e, n, i, a, o, s) {
  for (var l = se(n), u = i.duration, c = i.delay, f = i.additive, h = i.setToFinal, d = !Lt(a), p = r.animators, g = [], v = 0; v < l.length; v++) {
    var m = l[v], y = n[m];
    if (y != null && e[m] != null && (d || a[m]))
      if (Lt(y) && !Kr(y) && !Fg(y)) {
        if (t) {
          s || (e[m] = y, r.updateDuringAnimation(t));
          continue;
        }
        AP(r, m, e[m], y, i, a && a[m], o, s);
      } else
        g.push(m);
    else
      s || (e[m] = y, r.updateDuringAnimation(t), g.push(m));
  }
  var _ = g.length;
  if (!f && _)
    for (var x = 0; x < p.length; x++) {
      var b = p[x];
      if (b.targetName === t) {
        var S = b.stopTracks(g);
        if (S) {
          var w = Zt(p, b);
          p.splice(w, 1);
        }
      }
    }
  if (i.force || (g = Te(g, function(C) {
    return !R8(n[C], e[C]);
  }), _ = g.length), _ > 0 || i.force && !o.length) {
    var A = void 0, T = void 0, M = void 0;
    if (s) {
      T = {}, h && (A = {});
      for (var x = 0; x < _; x++) {
        var m = g[x];
        T[m] = e[m], h ? A[m] = n[m] : e[m] = n[m];
      }
    } else if (h) {
      M = {};
      for (var x = 0; x < _; x++) {
        var m = g[x];
        M[m] = Wf(e[m]), L8(e, n, m);
      }
    }
    var b = new D1(e, !1, !1, f ? Te(p, function(R) {
      return R.targetName === t;
    }) : null);
    b.targetName = t, i.scope && (b.scope = i.scope), h && A && b.whenWithKeys(0, A, g), M && b.whenWithKeys(0, M, g), b.whenWithKeys(u ?? 500, s ? T : n, g).delay(c || 0), r.addAnimator(b, t), o.push(b);
  }
}
var Ct = function(r) {
  Ue(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(e), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(e) {
    return this._children[e];
  }, t.prototype.childOfName = function(e) {
    for (var n = this._children, i = 0; i < n.length; i++)
      if (n[i].name === e)
        return n[i];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(e) {
    if (e && (e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)), process.env.NODE_ENV !== "production" && e.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(e, n) {
    if (e && e !== this && e.parent !== this && n && n.parent === this) {
      var i = this._children, a = i.indexOf(n);
      a >= 0 && (i.splice(a, 0, e), this._doAdd(e));
    }
    return this;
  }, t.prototype.replace = function(e, n) {
    var i = Zt(this._children, e);
    return i >= 0 && this.replaceAt(n, i), this;
  }, t.prototype.replaceAt = function(e, n) {
    var i = this._children, a = i[n];
    if (e && e !== this && e.parent !== this && e !== a) {
      i[n] = e, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(e);
    }
    return this;
  }, t.prototype._doAdd = function(e) {
    e.parent && e.parent.remove(e), e.parent = this;
    var n = this.__zr;
    n && n !== e.__zr && e.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(e) {
    var n = this.__zr, i = this._children, a = Zt(i, e);
    return a < 0 ? this : (i.splice(a, 1), e.parent = null, n && e.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var e = this._children, n = this.__zr, i = 0; i < e.length; i++) {
      var a = e[i];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return e.length = 0, this;
  }, t.prototype.eachChild = function(e, n) {
    for (var i = this._children, a = 0; a < i.length; a++) {
      var o = i[a];
      e.call(n, o, a);
    }
    return this;
  }, t.prototype.traverse = function(e, n) {
    for (var i = 0; i < this._children.length; i++) {
      var a = this._children[i], o = e.call(n, a);
      a.isGroup && !o && a.traverse(e, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(e) {
    r.prototype.addSelfToZr.call(this, e);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.addSelfToZr(e);
    }
  }, t.prototype.removeSelfFromZr = function(e) {
    r.prototype.removeSelfFromZr.call(this, e);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.removeSelfFromZr(e);
    }
  }, t.prototype.getBoundingRect = function(e) {
    for (var n = new Vt(0, 0, 0, 0), i = e || this._children, a = [], o = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (Vt.applyTransform(n, u, c), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || n;
  }, t;
}(Yg);
Ct.prototype.type = "group";
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Df = {}, EP = {};
function P8(r) {
  delete EP[r];
}
function N8(r) {
  if (!r)
    return !1;
  if (typeof r == "string")
    return Tv(r, 1) < mx;
  if (r.colorStops) {
    for (var t = r.colorStops, e = 0, n = t.length, i = 0; i < n; i++)
      e += Tv(t[i].color, 1);
    return e /= n, e < mx;
  }
  return !1;
}
var O8 = function() {
  function r(t, e, n) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = e, this.id = t;
    var a = new qW(), o = n.renderer || "canvas";
    if (Df[o] || (o = se(Df)[0]), process.env.NODE_ENV !== "production" && !Df[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new Df[o](e, a, n, t), l = n.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !oe.node && !oe.worker && !l ? new M8(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, f = c == null || c === "auto" ? oe.touchEventsSupported : !!c, h = 44, d;
    f && (d = bt(n.pointerSize, h)), this.handler = new aP(a, s, u, s.root, d), this.animation = new m8({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return r.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, r.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, r.prototype.configLayer = function(t, e) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, e), this.refresh());
  }, r.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = N8(t));
  }, r.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, r.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, r.prototype.isDarkMode = function() {
    return this._darkMode;
  }, r.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, r.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, r.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, r.prototype._flush = function(t) {
    var e, n = Ou();
    this._needsRefresh && (e = !0, this.refreshImmediately(t)), this._needsRefreshHover && (e = !0, this.refreshHoverImmediately());
    var i = Ou();
    e ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, r.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, r.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, r.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, r.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, r.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, r.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, r.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, r.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, r.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, r.prototype.findHover = function(t, e) {
    if (!this._disposed)
      return this.handler.findHover(t, e);
  }, r.prototype.on = function(t, e, n) {
    return this._disposed || this.handler.on(t, e, n), this;
  }, r.prototype.off = function(t, e) {
    this._disposed || this.handler.off(t, e);
  }, r.prototype.trigger = function(t, e) {
    this._disposed || this.handler.trigger(t, e);
  }, r.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), e = 0; e < t.length; e++)
        t[e] instanceof Ct && t[e].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, r.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, P8(this.id));
  }, r;
}();
function KT(r, t) {
  var e = new O8(jI(), r, t);
  return EP[e.id] = e, e;
}
function k8(r, t) {
  Df[r] = t;
}
var xx;
function B8(r) {
  if (typeof xx == "function")
    return xx(r);
}
function V8(r) {
  xx = r;
}
var jT = 1e-4, CP = 20;
function F8(r) {
  return r.replace(/^\s+|\s+$/g, "");
}
var Bn = Math.min, er = Math.max, Yi = Math.abs;
function Me(r, t, e, n) {
  var i = t[0], a = t[1], o = e[0], s = e[1], l = a - i, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (n)
    if (l > 0) {
      if (r <= i)
        return o;
      if (r >= a)
        return s;
    } else {
      if (r >= i)
        return o;
      if (r <= a)
        return s;
    }
  else {
    if (r === i)
      return o;
    if (r === a)
      return s;
  }
  return (r - i) / l * u + o;
}
var dt = z8;
function z8(r, t, e) {
  switch (r) {
    case "center":
    case "middle":
      r = "50%";
      break;
    case "left":
    case "top":
      r = "0%";
      break;
    case "right":
    case "bottom":
      r = "100%";
      break;
  }
  return Lv(r, t, e);
}
function Lv(r, t, e) {
  return pt(r) ? F8(r).match(/%$/) ? parseFloat(r) / 100 * t + (e || 0) : parseFloat(r) : r == null ? NaN : +r;
}
function sr(r, t, e) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), CP), r = (+r).toFixed(t), e ? r : +r;
}
function ri(r) {
  return r.sort(function(t, e) {
    return t - e;
  }), r;
}
function $i(r) {
  if (r = +r, isNaN(r))
    return 0;
  if (r > 1e-14) {
    for (var t = 1, e = 0; e < 15; e++, t *= 10)
      if (Math.round(r * t) / t === r)
        return e;
  }
  return Sx(r);
}
function Sx(r) {
  var t = r.toString().toLowerCase(), e = t.indexOf("e"), n = e > 0 ? +t.slice(e + 1) : 0, i = e > 0 ? e : t.length, a = t.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
  return Math.max(0, o - n);
}
function DP(r, t) {
  var e = Math.log, n = Math.LN10, i = Math.floor(e(r[1] - r[0]) / n), a = Math.round(e(Yi(t[1] - t[0])) / n), o = Math.min(Math.max(-i + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function U8(r, t) {
  var e = ra(r, function(d, p) {
    return d + (isNaN(p) ? 0 : p);
  }, 0);
  if (e === 0)
    return [];
  for (var n = Math.pow(10, t), i = rt(r, function(d) {
    return (isNaN(d) ? 0 : d) / e * n * 100;
  }), a = n * 100, o = rt(i, function(d) {
    return Math.floor(d);
  }), s = ra(o, function(d, p) {
    return d + p;
  }, 0), l = rt(i, function(d, p) {
    return d - o[p];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, f = 0, h = l.length; f < h; ++f)
      l[f] > u && (u = l[f], c = f);
    ++o[c], l[c] = 0, ++s;
  }
  return rt(o, function(d) {
    return d / n;
  });
}
function G8(r, t) {
  var e = Math.max($i(r), $i(t)), n = r + t;
  return e > CP ? n : sr(n, e);
}
var JT = 9007199254740991;
function LP(r) {
  var t = Math.PI * 2;
  return (r % t + t) % t;
}
function ah(r) {
  return r > -jT && r < jT;
}
var H8 = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Al(r) {
  if (r instanceof Date)
    return r;
  if (pt(r)) {
    var t = H8.exec(r);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var e = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (e -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, e, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (r == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(r));
}
function W8(r) {
  return Math.pow(10, $g(r));
}
function $g(r) {
  if (r === 0)
    return 0;
  var t = Math.floor(Math.log(r) / Math.LN10);
  return r / Math.pow(10, t) >= 10 && t++, t;
}
function RP(r, t) {
  var e = $g(r), n = Math.pow(10, e), i = r / n, a;
  return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, r = a * n, e >= -20 ? +r.toFixed(e < 0 ? -e : 0) : r;
}
function Iy(r, t) {
  var e = (r.length - 1) * t + 1, n = Math.floor(e), i = +r[n - 1], a = e - n;
  return a ? i + a * (r[n] - i) : i;
}
function QT(r) {
  r.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var t = -1 / 0, e = 1, n = 0; n < r.length; ) {
    for (var i = r[n].interval, a = r[n].close, o = 0; o < 2; o++)
      i[o] <= t && (i[o] = t, a[o] = o ? 1 : 1 - e), t = i[o], e = a[o];
    i[0] === i[1] && a[0] * a[1] !== 1 ? r.splice(n, 1) : n++;
  }
  return r;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function Ha(r) {
  var t = parseFloat(r);
  return t == r && (t !== 0 || !pt(r) || r.indexOf("x") <= 0) ? t : NaN;
}
function L1(r) {
  return !isNaN(Ha(r));
}
function IP() {
  return Math.round(Math.random() * 9);
}
function PP(r, t) {
  return t === 0 ? r : PP(t, r % t);
}
function tA(r, t) {
  return r == null ? t : t == null ? r : r * t / PP(r, t);
}
var X8 = "[ECharts] ", eA = {}, Y8 = typeof console < "u" && console.warn && console.log;
function Zg(r, t, e) {
  if (Y8) {
    if (e) {
      if (eA[t])
        return;
      eA[t] = !0;
    }
    console[r](X8 + t);
  }
}
function NP(r, t) {
  Zg("log", r, t);
}
function Ye(r, t) {
  Zg("warn", r, t);
}
function ce(r, t) {
  Zg("error", r, t);
}
function aa(r) {
  process.env.NODE_ENV !== "production" && Zg("warn", "DEPRECATED: " + r, !0);
}
function or(r, t, e) {
  process.env.NODE_ENV !== "production" && aa((e ? "[" + e + "]" : "") + (r + " is deprecated; use " + t + " instead."));
}
function dn() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  var e = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : kr(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : At(i) ? "function () { ... }" : JI(i) ? i + "" : null;
    };
    e = rt(r, function(i) {
      if (pt(i))
        return i;
      var a = n(i);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(o, s) {
            var l = n(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return e;
}
function we(r) {
  throw new Error(r);
}
function rA(r, t, e) {
  return (t - r) * e + r;
}
var OP = "series\0", kP = "\0_ec_\0";
function Ie(r) {
  return r instanceof Array ? r : r == null ? [] : [r];
}
function dl(r, t, e) {
  if (r) {
    r[t] = r[t] || {}, r.emphasis = r.emphasis || {}, r.emphasis[t] = r.emphasis[t] || {};
    for (var n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      !r.emphasis[t].hasOwnProperty(a) && r[t].hasOwnProperty(a) && (r.emphasis[t][a] = r[t][a]);
    }
  }
}
var nA = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Sc(r) {
  return Lt(r) && !et(r) && !(r instanceof Date) ? r.value : r;
}
function $8(r) {
  return Lt(r) && !(r instanceof Array);
}
function BP(r, t, e) {
  var n = e === "normalMerge", i = e === "replaceMerge", a = e === "replaceAll";
  r = r || [], t = (t || []).slice();
  var o = wt();
  L(t, function(l, u) {
    if (!Lt(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !aA(l.id) && iA(l.id), l.name != null && !aA(l.name) && iA(l.name));
  });
  var s = Z8(r, o, e);
  return (n || i) && q8(s, r, o, t), n && K8(s, t), n || i ? j8(s, t, i) : a && J8(s, t), Q8(s), s;
}
function Z8(r, t, e) {
  var n = [];
  if (e === "replaceAll")
    return n;
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    a && a.id != null && t.set(a.id, i), n.push({
      existing: e === "replaceMerge" || rc(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function q8(r, t, e, n) {
  L(n, function(i, a) {
    if (!(!i || i.id == null)) {
      var o = Xf(i.id), s = e.get(o);
      if (s != null) {
        var l = r[s];
        St(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = t[s], n[a] = null;
      }
    }
  });
}
function K8(r, t) {
  L(t, function(e, n) {
    if (!(!e || e.name == null))
      for (var i = 0; i < r.length; i++) {
        var a = r[i].existing;
        if (!r[i].newOption && a && (a.id == null || e.id == null) && !rc(e) && !rc(a) && VP("name", a, e)) {
          r[i].newOption = e, t[n] = null;
          return;
        }
      }
  });
}
function j8(r, t, e) {
  L(t, function(n) {
    if (n) {
      for (
        var i, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = r[a]) && (i.newOption || rc(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && n.id != null && !VP("id", n, i.existing));
      )
        a++;
      i ? (i.newOption = n, i.brandNew = e) : r.push({
        newOption: n,
        brandNew: e,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function J8(r, t) {
  L(t, function(e) {
    r.push({
      newOption: e,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function Q8(r) {
  var t = wt();
  L(r, function(e) {
    var n = e.existing;
    n && t.set(n.id, e);
  }), L(r, function(e) {
    var n = e.newOption;
    St(!n || n.id == null || !t.get(n.id) || t.get(n.id) === e, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, e), !e.keyInfo && (e.keyInfo = {});
  }), L(r, function(e, n) {
    var i = e.existing, a = e.newOption, o = e.keyInfo;
    if (Lt(a)) {
      if (o.name = a.name != null ? Xf(a.name) : i ? i.name : OP + n, i)
        o.id = Xf(i.id);
      else if (a.id != null)
        o.id = Xf(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (t.get(o.id));
      }
      t.set(o.id, e);
    }
  });
}
function VP(r, t, e) {
  var n = yr(t[r], null), i = yr(e[r], null);
  return n != null && i != null && n === i;
}
function Xf(r) {
  if (process.env.NODE_ENV !== "production" && r == null)
    throw new Error();
  return yr(r, "");
}
function yr(r, t) {
  return r == null ? t : pt(r) ? r : fe(r) || yv(r) ? r + "" : t;
}
function iA(r) {
  process.env.NODE_ENV !== "production" && Ye("`" + r + "` is invalid id or name. Must be a string or number.");
}
function aA(r) {
  return yv(r) || L1(r);
}
function R1(r) {
  var t = r.name;
  return !!(t && t.indexOf(OP));
}
function rc(r) {
  return r && r.id != null && Xf(r.id).indexOf(kP) === 0;
}
function t6(r) {
  return kP + r;
}
function e6(r, t, e) {
  L(r, function(n) {
    var i = n.newOption;
    Lt(i) && (n.keyInfo.mainType = t, n.keyInfo.subType = r6(t, i, n.existing, e));
  });
}
function r6(r, t, e, n) {
  var i = t.type ? t.type : e ? e.subType : n.determineSubType(r, t);
  return i;
}
function n6(r, t) {
  var e = {}, n = {};
  return i(r || [], e), i(t || [], n, e), [a(e), a(n)];
  function i(o, s, l) {
    for (var u = 0, c = o.length; u < c; u++) {
      var f = yr(o[u].seriesId, null);
      if (f == null)
        return;
      for (var h = Ie(o[u].dataIndex), d = l && l[f], p = 0, g = h.length; p < g; p++) {
        var v = h[p];
        d && d[v] ? d[v] = null : (s[f] || (s[f] = {}))[v] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = a(o[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function pl(r, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return et(t.dataIndex) ? rt(t.dataIndex, function(e) {
      return r.indexOfRawIndex(e);
    }) : r.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return et(t.name) ? rt(t.name, function(e) {
      return r.indexOfName(e);
    }) : r.indexOfName(t.name);
}
function ee() {
  var r = "__ec_inner_" + i6++;
  return function(t) {
    return t[r] || (t[r] = {});
  };
}
var i6 = IP();
function Xu(r, t, e) {
  var n = I1(t, e), i = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = e ? e.defaultMainType : null;
  return !i && l && a.set(l, {}), a.each(function(u, c) {
    var f = bc(r, c, u, {
      useDefault: l === c,
      enableAll: e && e.enableAll != null ? e.enableAll : !0,
      enableNone: e && e.enableNone != null ? e.enableNone : !0
    });
    s[c + "Models"] = f.models, s[c + "Model"] = f.models[0];
  }), s;
}
function I1(r, t) {
  var e;
  if (pt(r)) {
    var n = {};
    n[r + "Index"] = 0, e = n;
  } else
    e = r;
  var i = wt(), a = {}, o = !1;
  return L(e, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], f = (u[2] || "").toLowerCase();
    if (!(!c || !f || t && t.includeMainTypes && Zt(t.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var h = i.get(c) || i.set(c, {});
      h[f] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: i,
    others: a
  };
}
var je = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, a6 = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function bc(r, t, e, n) {
  n = n || je;
  var i = e.index, a = e.id, o = e.name, s = {
    models: null,
    specified: i != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = r.getComponent(t)) ? [l] : [], s;
  }
  if (i === "none" || i === !1) {
    if (n.enableNone)
      return s.models = [], s;
    process.env.NODE_ENV !== "production" && ce('`"none"` or `false` is not a valid value on index option.'), i = -1;
  }
  return i === "all" && (n.enableAll ? i = a = o = null : (process.env.NODE_ENV !== "production" && ce('`"all"` is not a valid value on index option.'), i = -1)), s.models = r.queryComponents({
    mainType: t,
    index: i,
    id: a,
    name: o
  }), s;
}
function FP(r, t, e) {
  r.setAttribute ? r.setAttribute(t, e) : r[t] = e;
}
function o6(r, t) {
  return r.getAttribute ? r.getAttribute(t) : r[t];
}
function s6(r) {
  return r === "auto" ? oe.domSupported ? "html" : "richText" : r || "html";
}
function bx(r, t) {
  var e = wt(), n = [];
  return L(r, function(i) {
    var a = t(i);
    (e.get(a) || (n.push(a), e.set(a, []))).push(i);
  }), {
    keys: n,
    buckets: e
  };
}
function zP(r, t, e, n, i) {
  var a = t == null || t === "auto";
  if (n == null)
    return n;
  if (fe(n)) {
    var o = rA(e || 0, n, i);
    return sr(o, a ? Math.max($i(e || 0), $i(n)) : t);
  } else {
    if (pt(n))
      return i < 1 ? e : n;
    for (var s = [], l = e, u = n, c = Math.max(l ? l.length : 0, u.length), f = 0; f < c; ++f) {
      var h = r.getDimensionInfo(f);
      if (h && h.type === "ordinal")
        s[f] = (i < 1 && l ? l : u)[f];
      else {
        var d = l && l[f] ? l[f] : 0, p = u[f], o = rA(d, p, i);
        s[f] = sr(o, a ? Math.max($i(d), $i(p)) : t);
      }
    }
    return s;
  }
}
var ko = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.reset = function(t, e, n, i) {
      return this._list = t, this._step = i = i || 1, this._idx = e, this._end = n ?? (i > 0 ? t.length : 0), this.item = null, this.key = NaN, this;
    }, r.prototype.next = function() {
      return (this._step > 0 ? this._idx < this._end : this._idx >= this._end) ? (this.item = this._list[this._idx], this.key = this._idx = this._idx + this._step, !0) : !1;
    }, r;
  }()
);
function Py(r) {
  r.option = r.parentModel = r.ecModel = null;
}
var l6 = ".", ds = "___EC__COMPONENT__CONTAINER___", UP = "___EC__EXTENDED_CLASS___";
function Zi(r) {
  var t = {
    main: "",
    sub: ""
  };
  if (r) {
    var e = r.split(l6);
    t.main = e[0] || "", t.sub = e[1] || "";
  }
  return t;
}
function u6(r) {
  St(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
}
function c6(r) {
  return !!(r && r[UP]);
}
function P1(r, t) {
  r.$constructor = r, r.extend = function(e) {
    process.env.NODE_ENV !== "production" && L(t, function(a) {
      e[a] || console.warn("Method `" + a + "` should be implemented" + (e.type ? " in " + e.type : "") + ".");
    });
    var n = this, i;
    return f6(n) ? i = /** @class */
    function(a) {
      $(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(n) : (i = function() {
      (e.$constructor || n).apply(this, arguments);
    }, vW(i, this)), j(i.prototype, e), i[UP] = !0, i.extend = this.extend, i.superCall = p6, i.superApply = v6, i.superClass = n, i;
  };
}
function f6(r) {
  return At(r) && /^class\s/.test(Function.prototype.toString.call(r));
}
function GP(r, t) {
  r.extend = t.extend;
}
var h6 = Math.round(Math.random() * 10);
function d6(r) {
  var t = ["__\0is_clz", h6++].join("_");
  r.prototype[t] = !0, process.env.NODE_ENV !== "production" && St(!r.isInstance, 'The method "is" can not be defined.'), r.isInstance = function(e) {
    return !!(e && e[t]);
  };
}
function p6(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++)
    e[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(r, e);
}
function v6(r, t, e) {
  return this.superClass.prototype[t].apply(r, e);
}
function qg(r) {
  var t = {};
  r.registerClass = function(n) {
    var i = n.type || n.prototype.type;
    if (i) {
      u6(i), n.prototype.type = i;
      var a = Zi(i);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== ds) {
        var o = e(a);
        o[a.sub] = n;
      }
    }
    return n;
  }, r.getClass = function(n, i, a) {
    var o = t[n];
    if (o && o[ds] && (o = i ? o[i] : null), a && !o)
      throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
    return o;
  }, r.getClassesByMainType = function(n) {
    var i = Zi(n), a = [], o = t[i.main];
    return o && o[ds] ? L(o, function(s, l) {
      l !== ds && a.push(s);
    }) : a.push(o), a;
  }, r.hasClass = function(n) {
    var i = Zi(n);
    return !!t[i.main];
  }, r.getAllClassMainTypes = function() {
    var n = [];
    return L(t, function(i, a) {
      n.push(a);
    }), n;
  }, r.hasSubTypes = function(n) {
    var i = Zi(n), a = t[i.main];
    return a && a[ds];
  };
  function e(n) {
    var i = t[n.main];
    return (!i || !i[ds]) && (i = t[n.main] = {}, i[ds] = !0), i;
  }
}
function vl(r, t) {
  for (var e = 0; e < r.length; e++)
    r[e][1] || (r[e][1] = r[e][0]);
  return t = t || !1, function(n, i, a) {
    for (var o = {}, s = 0; s < r.length; s++) {
      var l = r[s][1];
      if (!(i && Zt(i, l) >= 0 || a && Zt(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (o[r[s][0]] = u);
      }
    }
    return o;
  };
}
var g6 = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], m6 = vl(g6), y6 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(t, e) {
      return m6(this, t, e);
    }, r;
  }()
), Mx = new tc(50);
function _6(r) {
  if (typeof r == "string") {
    var t = Mx.get(r);
    return t && t.image;
  } else
    return r;
}
function N1(r, t, e, n, i) {
  if (r)
    if (typeof r == "string") {
      if (t && t.__zrImageSrc === r || !e)
        return t;
      var a = Mx.get(r), o = { hostEl: e, cb: n, cbPayload: i };
      return a ? (t = a.image, !Kg(t) && a.pending.push(o)) : (t = Si.loadImage(r, oA, oA), t.__zrImageSrc = r, Mx.put(r, t.__cachedImgObj = {
        image: t,
        pending: [o]
      })), t;
    } else
      return r;
  else
    return t;
}
function oA() {
  var r = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < r.pending.length; t++) {
    var e = r.pending[t], n = e.cb;
    n && n(this, e.cbPayload), e.hostEl.dirty();
  }
  r.pending.length = 0;
}
function Kg(r) {
  return r && r.width && r.height;
}
var Ny = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function x6(r, t, e, n, i, a) {
  if (!e) {
    r.text = "", r.isTruncated = !1;
    return;
  }
  var o = (t + "").split(`
`);
  a = HP(e, n, i, a);
  for (var s = !1, l = {}, u = 0, c = o.length; u < c; u++)
    WP(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
  r.text = o.join(`
`), r.isTruncated = s;
}
function HP(r, t, e, n) {
  n = n || {};
  var i = j({}, n);
  e = bt(e, "..."), i.maxIterations = bt(n.maxIterations, 2);
  var a = i.minChar = bt(n.minChar, 0), o = i.fontMeasureInfo = ta(t), s = o.asciiCharWidth;
  i.placeholder = bt(n.placeholder, "");
  for (var l = r = Math.max(0, r - 1), u = 0; u < a && l >= s; u++)
    l -= s;
  var c = ea(o, e);
  return c > l && (e = "", c = 0), l = r - c, i.ellipsis = e, i.ellipsisWidth = c, i.contentWidth = l, i.containerWidth = r, i;
}
function WP(r, t, e) {
  var n = e.containerWidth, i = e.contentWidth, a = e.fontMeasureInfo;
  if (!n) {
    r.textLine = "", r.isTruncated = !1;
    return;
  }
  var o = ea(a, t);
  if (o <= n) {
    r.textLine = t, r.isTruncated = !1;
    return;
  }
  for (var s = 0; ; s++) {
    if (o <= i || s >= e.maxIterations) {
      t += e.ellipsis;
      break;
    }
    var l = s === 0 ? S6(t, i, a) : o > 0 ? Math.floor(t.length * i / o) : 0;
    t = t.substr(0, l), o = ea(a, t);
  }
  t === "" && (t = e.placeholder), r.textLine = t, r.isTruncated = !0;
}
function S6(r, t, e) {
  for (var n = 0, i = 0, a = r.length; i < a && n < t; i++)
    n += TP(e, r.charCodeAt(i));
  return i;
}
function b6(r, t, e, n) {
  var i = O1(r), a = t.overflow, o = t.padding, s = o ? o[1] + o[3] : 0, l = o ? o[0] + o[2] : 0, u = t.font, c = a === "truncate", f = Nh(u), h = bt(t.lineHeight, f), d = t.lineOverflow === "truncate", p = !1, g = t.width;
  g == null && e != null && (g = e - s);
  var v = t.height;
  v == null && n != null && (v = n - l);
  var m;
  g != null && (a === "break" || a === "breakAll") ? m = i ? XP(i, t.font, g, a === "breakAll", 0).lines : [] : m = i ? i.split(`
`) : [];
  var y = m.length * h;
  if (v == null && (v = y), y > v && d) {
    var _ = Math.floor(v / h);
    p = p || m.length > _, m = m.slice(0, _), y = m.length * h;
  }
  if (i && c && g != null)
    for (var x = HP(g, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), b = {}, S = 0; S < m.length; S++)
      WP(b, m[S], x), m[S] = b.textLine, p = p || b.isTruncated;
  for (var w = v, A = 0, T = ta(u), S = 0; S < m.length; S++)
    A = Math.max(ea(T, m[S]), A);
  g == null && (g = A);
  var M = g;
  return w += l, M += s, {
    lines: m,
    height: v,
    outerWidth: M,
    outerHeight: w,
    lineHeight: h,
    calculatedLineHeight: f,
    contentWidth: A,
    contentHeight: y,
    width: g,
    isTruncated: p
  };
}
var w6 = /* @__PURE__ */ function() {
  function r() {
  }
  return r;
}(), sA = /* @__PURE__ */ function() {
  function r(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return r;
}(), M6 = /* @__PURE__ */ function() {
  function r() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return r;
}();
function T6(r, t, e, n, i) {
  var a = new M6(), o = O1(r);
  if (!o)
    return a;
  var s = t.padding, l = s ? s[1] + s[3] : 0, u = s ? s[0] + s[2] : 0, c = t.width;
  c == null && e != null && (c = e - l);
  var f = t.height;
  f == null && n != null && (f = n - u);
  for (var h = t.overflow, d = (h === "break" || h === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: h === "breakAll" } : null, p = Ny.lastIndex = 0, g; (g = Ny.exec(o)) != null; ) {
    var v = g.index;
    v > p && Oy(a, o.substring(p, v), t, d), Oy(a, g[2], t, d, g[1]), p = Ny.lastIndex;
  }
  p < o.length && Oy(a, o.substring(p, o.length), t, d);
  var m = [], y = 0, _ = 0, x = h === "truncate", b = t.lineOverflow === "truncate", S = {};
  function w(at, st, ut) {
    at.width = st, at.lineHeight = ut, y += ut, _ = Math.max(_, st);
  }
  t:
    for (var A = 0; A < a.lines.length; A++) {
      for (var T = a.lines[A], M = 0, C = 0, R = 0; R < T.tokens.length; R++) {
        var E = T.tokens[R], D = E.styleName && t.rich[E.styleName] || {}, I = E.textPadding = D.padding, P = I ? I[1] + I[3] : 0, O = E.font = D.font || t.font;
        E.contentHeight = Nh(O);
        var N = bt(D.height, E.contentHeight);
        if (E.innerHeight = N, I && (N += I[0] + I[2]), E.height = N, E.lineHeight = un(D.lineHeight, t.lineHeight, N), E.align = D && D.align || i, E.verticalAlign = D && D.verticalAlign || "middle", b && f != null && y + E.lineHeight > f) {
          var B = a.lines.length;
          R > 0 ? (T.tokens = T.tokens.slice(0, R), w(T, C, M), a.lines = a.lines.slice(0, A + 1)) : a.lines = a.lines.slice(0, A), a.isTruncated = a.isTruncated || a.lines.length < B;
          break t;
        }
        var F = D.width, G = F == null || F === "auto";
        if (typeof F == "string" && F.charAt(F.length - 1) === "%")
          E.percentWidth = F, m.push(E), E.contentWidth = ea(ta(O), E.text);
        else {
          if (G) {
            var W = D.backgroundColor, J = W && W.image;
            J && (J = _6(J), Kg(J) && (E.width = Math.max(E.width, J.width * N / J.height)));
          }
          var U = x && c != null ? c - C : null;
          U != null && U < E.width ? !G || U < P ? (E.text = "", E.width = E.contentWidth = 0) : (x6(S, E.text, U - P, O, t.ellipsis, { minChar: t.truncateMinChar }), E.text = S.text, a.isTruncated = a.isTruncated || S.isTruncated, E.width = E.contentWidth = ea(ta(O), E.text)) : E.contentWidth = ea(ta(O), E.text);
        }
        E.width += P, C += E.width, D && (M = Math.max(M, E.lineHeight));
      }
      w(T, C, M);
    }
  a.outerWidth = a.width = bt(c, _), a.outerHeight = a.height = bt(f, y), a.contentHeight = y, a.contentWidth = _, a.outerWidth += l, a.outerHeight += u;
  for (var A = 0; A < m.length; A++) {
    var E = m[A], Y = E.percentWidth;
    E.width = parseInt(Y, 10) / 100 * a.width;
  }
  return a;
}
function Oy(r, t, e, n, i) {
  var a = t === "", o = i && e.rich[i] || {}, s = r.lines, l = o.font || e.font, u = !1, c, f;
  if (n) {
    var h = o.padding, d = h ? h[1] + h[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var p = wi(o.width, n.width) + d;
      s.length > 0 && p + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = p;
    } else {
      var g = XP(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + d, f = g.linesWidths, c = g.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var v = ta(l), m = 0; m < c.length; m++) {
    var y = c[m], _ = new w6();
    if (_.styleName = i, _.text = y, _.isLineHolder = !y && !a, typeof o.width == "number" ? _.width = o.width : _.width = f ? f[m] : ea(v, y), !m && !u) {
      var x = (s[s.length - 1] || (s[0] = new sA())).tokens, b = x.length;
      b === 1 && x[0].isLineHolder ? x[0] = _ : (y || !b || a) && x.push(_);
    } else
      s.push(new sA([_]));
  }
}
function A6(r) {
  var t = r.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var E6 = ra(",&?/;] ".split(""), function(r, t) {
  return r[t] = !0, r;
}, {});
function C6(r) {
  return A6(r) ? !!E6[r] : !0;
}
function XP(r, t, e, n, i) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, f = ta(t), h = 0; h < r.length; h++) {
    var d = r.charAt(h);
    if (d === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var p = TP(f, d.charCodeAt(0)), g = n ? !1 : !C6(d);
    if (a.length ? c + p > e : i + c + p > e) {
      c ? (s || l) && (g ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += d, u += p, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = d, c = p)) : g ? (a.push(l), o.push(u), l = d, u = p) : (a.push(d), o.push(p));
      continue;
    }
    c += p, g ? (l += d, u += p) : (l && (s += l, l = "", u = 0), s += d);
  }
  return l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += i), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
function lA(r, t, e, n, i, a) {
  if (r.baseX = e, r.baseY = n, r.outerWidth = r.outerHeight = null, !!t) {
    var o = t.width * 2, s = t.height * 2;
    Vt.set(uA, ec(e, o, i), nl(n, s, a), o, s), Vt.intersect(t, uA, null, cA);
    var l = cA.outIntersectRect;
    r.outerWidth = l.width, r.outerHeight = l.height, r.baseX = ec(l.x, l.width, i, !0), r.baseY = nl(l.y, l.height, a, !0);
  }
}
var uA = new Vt(0, 0, 0, 0), cA = { outIntersectRect: {}, clamp: !0 };
function O1(r) {
  return r != null ? r += "" : r = "";
}
function D6(r) {
  var t = O1(r.text), e = r.font, n = ea(ta(e), t), i = Nh(e);
  return Tx(r, n, i, null);
}
function Tx(r, t, e, n) {
  var i = new Vt(ec(r.x || 0, t, r.textAlign), nl(r.y || 0, e, r.textBaseline), t, e), a = n ?? (YP(r) ? r.lineWidth : 0);
  return a > 0 && (i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a), i;
}
function YP(r) {
  var t = r.stroke;
  return t != null && t !== "none" && r.lineWidth > 0;
}
var Ax = "__zr_style_" + Math.round(Math.random() * 10), il = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, jg = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
il[Ax] = !0;
var fA = ["z", "z2", "invisible"], L6 = ["invisible"], ai = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype._init = function(e) {
    for (var n = se(e), i = 0; i < n.length; i++) {
      var a = n[i];
      a === "style" ? this.useStyle(e[a]) : r.prototype.attrKV.call(this, a, e[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(e, n, i, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && R6(this, e, n) || o && !o[0] && !o[3])
      return !1;
    if (i && this.__clipPaths && this.__clipPaths.length) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(e, n) {
    return this.rectContain(e, n);
  }, t.prototype.traverse = function(e, n) {
    e.call(n, this);
  }, t.prototype.rectContain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
    return a.contain(i[0], i[1]);
  }, t.prototype.getPaintRect = function() {
    var e = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      e = this._paintRect || (this._paintRect = new Vt(0, 0, 0, 0)), n ? Vt.applyTransform(e, i, n) : e.copy(i), (o || s || l) && (e.width += o * 2 + Math.abs(s), e.height += o * 2 + Math.abs(l), e.x = Math.min(e.x, e.x + s - o), e.y = Math.min(e.y, e.y + l - o));
      var u = this.dirtyRectTolerance;
      e.isZero() || (e.x = Math.floor(e.x - u), e.y = Math.floor(e.y - u), e.width = Math.ceil(e.width + 1 + u * 2), e.height = Math.ceil(e.height + 1 + u * 2));
    }
    return e;
  }, t.prototype.setPrevPaintRect = function(e) {
    e ? (this._prevPaintRect = this._prevPaintRect || new Vt(0, 0, 0, 0), this._prevPaintRect.copy(e)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(e) {
    return this.animate("style", e);
  }, t.prototype.updateDuringAnimation = function(e) {
    e === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(e, n) {
    e !== "style" ? r.prototype.attrKV.call(this, e, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(e, n) {
    return typeof e == "string" ? this.style[e] = n : j(this.style, e), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(e) {
    e || this.markRedraw(), this.__dirty |= Ef, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Ef);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Ef;
  }, t.prototype.createStyle = function(e) {
    return Ug(il, e);
  }, t.prototype.useStyle = function(e) {
    e[Ax] || (e = this.createStyle(e)), this.__inHover ? this.__hoverStyle = e : this.style = e, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(e) {
    return e[Ax];
  }, t.prototype._innerSaveToNormal = function(e) {
    r.prototype._innerSaveToNormal.call(this, e);
    var n = this._normalState;
    e.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, n, fA);
  }, t.prototype._applyStateObj = function(e, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, e, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var f = se(c), h = 0; h < f.length; h++) {
            var d = f[h];
            d in u && (u[d] = u[d], this.style[d] = c[d]);
          }
        for (var p = se(u), h = 0; h < p.length; h++) {
          var d = p[h];
          this.style[d] = this.style[d];
        }
        this._transitionState(e, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? L6 : fA, h = 0; h < g.length; h++) {
      var d = g[h];
      n && n[d] != null ? this[d] = n[d] : l && i[d] != null && (this[d] = i[d]);
    }
  }, t.prototype._mergeStates = function(e) {
    for (var n = r.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
      var o = e[a];
      o.style && (i = i || {}, this._mergeStyle(i, o.style));
    }
    return i && (n.style = i), n;
  }, t.prototype._mergeStyle = function(e, n) {
    return j(e, n), e;
  }, t.prototype.getAnimationStyleProps = function() {
    return jg;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.type = "displayable", e.invisible = !1, e.z = 0, e.z2 = 0, e.zlevel = 0, e.culling = !1, e.cursor = "pointer", e.rectHover = !1, e.incremental = !1, e._rect = null, e.dirtyRectTolerance = 0, e.__dirty = In | Ef;
  }(), t;
}(Yg), ky = new Vt(0, 0, 0, 0), By = new Vt(0, 0, 0, 0);
function R6(r, t, e) {
  return ky.copy(r.getBoundingRect()), r.transform && ky.applyTransform(r.transform), By.width = t, By.height = e, !ky.intersect(By);
}
var yn = Math.min, _n = Math.max, Vy = Math.sin, Fy = Math.cos, ps = Math.PI * 2, Od = Tl(), kd = Tl(), Bd = Tl();
function Jg(r, t, e) {
  if (r.length !== 0) {
    for (var n = r[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1; l < r.length; l++)
      n = r[l], i = yn(i, n[0]), a = _n(a, n[0]), o = yn(o, n[1]), s = _n(s, n[1]);
    t[0] = i, t[1] = o, e[0] = a, e[1] = s;
  }
}
function hA(r, t, e, n, i, a) {
  i[0] = yn(r, e), i[1] = yn(t, n), a[0] = _n(r, e), a[1] = _n(t, n);
}
var dA = [], pA = [];
function I6(r, t, e, n, i, a, o, s, l, u) {
  var c = cP, f = wr, h = c(r, e, i, o, dA);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < h; d++) {
    var p = f(r, e, i, o, dA[d]);
    l[0] = yn(p, l[0]), u[0] = _n(p, u[0]);
  }
  h = c(t, n, a, s, pA);
  for (var d = 0; d < h; d++) {
    var g = f(t, n, a, s, pA[d]);
    l[1] = yn(g, l[1]), u[1] = _n(g, u[1]);
  }
  l[0] = yn(r, l[0]), u[0] = _n(r, u[0]), l[0] = yn(o, l[0]), u[0] = _n(o, u[0]), l[1] = yn(t, l[1]), u[1] = _n(t, u[1]), l[1] = yn(s, l[1]), u[1] = _n(s, u[1]);
}
function P6(r, t, e, n, i, a, o, s) {
  var l = hP, u = Pr, c = _n(yn(l(r, e, i), 1), 0), f = _n(yn(l(t, n, a), 1), 0), h = u(r, e, i, c), d = u(t, n, a, f);
  o[0] = yn(r, i, h), o[1] = yn(t, a, d), s[0] = _n(r, i, h), s[1] = _n(t, a, d);
}
function N6(r, t, e, n, i, a, o, s, l) {
  var u = bo, c = wo, f = Math.abs(i - a);
  if (f % ps < 1e-4 && f > 1e-4) {
    s[0] = r - e, s[1] = t - n, l[0] = r + e, l[1] = t + n;
    return;
  }
  if (Od[0] = Fy(i) * e + r, Od[1] = Vy(i) * n + t, kd[0] = Fy(a) * e + r, kd[1] = Vy(a) * n + t, u(s, Od, kd), c(l, Od, kd), i = i % ps, i < 0 && (i = i + ps), a = a % ps, a < 0 && (a = a + ps), i > a && !o ? a += ps : i < a && o && (i += ps), o) {
    var h = a;
    a = i, i = h;
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > i && (Bd[0] = Fy(d) * e + r, Bd[1] = Vy(d) * n + t, u(s, Bd, s), c(l, Bd, l));
}
var Ne = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, vs = [], gs = [], Di = [], oo = [], Li = [], Ri = [], zy = Math.min, Uy = Math.max, ms = Math.cos, ys = Math.sin, ya = Math.abs, Ex = Math.PI, go = Ex * 2, Gy = typeof Float32Array < "u", qc = [];
function Hy(r) {
  var t = Math.round(r / Ex * 1e8) / 1e8;
  return t % 2 * Ex;
}
function Qg(r, t) {
  var e = Hy(r[0]);
  e < 0 && (e += go);
  var n = e - r[0], i = r[1];
  i += n, !t && i - e >= go ? i = e + go : t && e - i >= go ? i = e - go : !t && e > i ? i = e + (go - Hy(e - i)) : t && e < i && (i = e - (go - Hy(i - e))), r[0] = e, r[1] = i;
}
var oa = function() {
  function r(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return r.prototype.increaseVersion = function() {
    this._version++;
  }, r.prototype.getVersion = function() {
    return this._version;
  }, r.prototype.setScale = function(t, e, n) {
    n = n || 0, n > 0 && (this._ux = ya(n / Ev / t) || 0, this._uy = ya(n / Ev / e) || 0);
  }, r.prototype.setDPR = function(t) {
    this.dpr = t;
  }, r.prototype.setContext = function(t) {
    this._ctx = t;
  }, r.prototype.getContext = function() {
    return this._ctx;
  }, r.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, r.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, r.prototype.moveTo = function(t, e) {
    return this._drawPendingPt(), this.addData(Ne.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
  }, r.prototype.lineTo = function(t, e) {
    var n = ya(t - this._xi), i = ya(e - this._yi), a = n > this._ux || i > this._uy;
    if (this.addData(Ne.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a)
      this._xi = t, this._yi = e, this._pendingPtDist = 0;
    else {
      var o = n * n + i * i;
      o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = o);
    }
    return this;
  }, r.prototype.bezierCurveTo = function(t, e, n, i, a, o) {
    return this._drawPendingPt(), this.addData(Ne.C, t, e, n, i, a, o), this._ctx && this._ctx.bezierCurveTo(t, e, n, i, a, o), this._xi = a, this._yi = o, this;
  }, r.prototype.quadraticCurveTo = function(t, e, n, i) {
    return this._drawPendingPt(), this.addData(Ne.Q, t, e, n, i), this._ctx && this._ctx.quadraticCurveTo(t, e, n, i), this._xi = n, this._yi = i, this;
  }, r.prototype.arc = function(t, e, n, i, a, o) {
    this._drawPendingPt(), qc[0] = i, qc[1] = a, Qg(qc, o), i = qc[0], a = qc[1];
    var s = a - i;
    return this.addData(Ne.A, t, e, n, n, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, a, o), this._xi = ms(a) * n + t, this._yi = ys(a) * n + e, this;
  }, r.prototype.arcTo = function(t, e, n, i, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, n, i, a), this;
  }, r.prototype.rect = function(t, e, n, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, n, i), this.addData(Ne.R, t, e, n, i), this;
  }, r.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Ne.Z);
    var t = this._ctx, e = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = e, this._yi = n, this;
  }, r.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, r.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.setData = function(t) {
    if (this._saveData) {
      var e = t.length;
      !(this.data && this.data.length === e) && Gy && (this.data = new Float32Array(e));
      for (var n = 0; n < e; n++)
        this.data[n] = t[n];
      this._len = e;
    }
  }, r.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var e = t.length, n = 0, i = this._len, a = 0; a < e; a++)
        n += t[a].len();
      var o = this.data;
      if (Gy && (o instanceof Float32Array || !o) && (this.data = new Float32Array(i + n), i > 0 && o))
        for (var s = 0; s < i; s++)
          this.data[s] = o[s];
      for (var a = 0; a < e; a++)
        for (var l = t[a].data, s = 0; s < l.length; s++)
          this.data[i++] = l[s];
      this._len = i;
    }
  }, r.prototype.addData = function(t, e, n, i, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var f = 0; f < arguments.length; f++)
        c[this._len++] = arguments[f];
    }
  }, r.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, r.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], e = 0; e < this._len; e++)
        t[e] = this.data[e];
      this.data = t;
    }
  }, r.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Gy && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, r.prototype.getBoundingRect = function() {
    Di[0] = Di[1] = Li[0] = Li[1] = Number.MAX_VALUE, oo[0] = oo[1] = Ri[0] = Ri[1] = -Number.MAX_VALUE;
    var t = this.data, e = 0, n = 0, i = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = t[o++], l = o === 1;
      switch (l && (e = t[o], n = t[o + 1], i = e, a = n), s) {
        case Ne.M:
          e = i = t[o++], n = a = t[o++], Li[0] = i, Li[1] = a, Ri[0] = i, Ri[1] = a;
          break;
        case Ne.L:
          hA(e, n, t[o], t[o + 1], Li, Ri), e = t[o++], n = t[o++];
          break;
        case Ne.C:
          I6(e, n, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Li, Ri), e = t[o++], n = t[o++];
          break;
        case Ne.Q:
          P6(e, n, t[o++], t[o++], t[o], t[o + 1], Li, Ri), e = t[o++], n = t[o++];
          break;
        case Ne.A:
          var u = t[o++], c = t[o++], f = t[o++], h = t[o++], d = t[o++], p = t[o++] + d;
          o += 1;
          var g = !t[o++];
          l && (i = ms(d) * f + u, a = ys(d) * h + c), N6(u, c, f, h, d, p, g, Li, Ri), e = ms(p) * f + u, n = ys(p) * h + c;
          break;
        case Ne.R:
          i = e = t[o++], a = n = t[o++];
          var v = t[o++], m = t[o++];
          hA(i, a, i + v, a + m, Li, Ri);
          break;
        case Ne.Z:
          e = i, n = a;
          break;
      }
      bo(Di, Di, Li), wo(oo, oo, Ri);
    }
    return o === 0 && (Di[0] = Di[1] = oo[0] = oo[1] = 0), new Vt(Di[0], Di[1], oo[0] - Di[0], oo[1] - Di[1]);
  }, r.prototype._calculateLength = function() {
    var t = this.data, e = this._len, n = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, f = 0, h = 0; h < e; ) {
      var d = t[h++], p = h === 1;
      p && (a = t[h], o = t[h + 1], s = a, l = o);
      var g = -1;
      switch (d) {
        case Ne.M:
          a = s = t[h++], o = l = t[h++];
          break;
        case Ne.L: {
          var v = t[h++], m = t[h++], y = v - a, _ = m - o;
          (ya(y) > n || ya(_) > i || h === e - 1) && (g = Math.sqrt(y * y + _ * _), a = v, o = m);
          break;
        }
        case Ne.C: {
          var x = t[h++], b = t[h++], v = t[h++], m = t[h++], S = t[h++], w = t[h++];
          g = KW(a, o, x, b, v, m, S, w, 10), a = S, o = w;
          break;
        }
        case Ne.Q: {
          var x = t[h++], b = t[h++], v = t[h++], m = t[h++];
          g = JW(a, o, x, b, v, m, 10), a = v, o = m;
          break;
        }
        case Ne.A:
          var A = t[h++], T = t[h++], M = t[h++], C = t[h++], R = t[h++], E = t[h++], D = E + R;
          h += 1, p && (s = ms(R) * M + A, l = ys(R) * C + T), g = Uy(M, C) * zy(go, Math.abs(E)), a = ms(D) * M + A, o = ys(D) * C + T;
          break;
        case Ne.R: {
          s = a = t[h++], l = o = t[h++];
          var I = t[h++], P = t[h++];
          g = I * 2 + P * 2;
          break;
        }
        case Ne.Z: {
          var y = s - a, _ = l - o;
          g = Math.sqrt(y * y + _ * _), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[f++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, r.prototype.rebuildPath = function(t, e) {
    var n = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, c, f, h, d = e < 1, p, g, v = 0, m = 0, y, _ = 0, x, b;
    if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = e * g, !y)))
      t:
        for (var S = 0; S < o; ) {
          var w = n[S++], A = S === 1;
          switch (A && (u = n[S], c = n[S + 1], s = u, l = c), w !== Ne.L && _ > 0 && (t.lineTo(x, b), _ = 0), w) {
            case Ne.M:
              s = u = n[S++], l = c = n[S++], t.moveTo(u, c);
              break;
            case Ne.L: {
              f = n[S++], h = n[S++];
              var T = ya(f - u), M = ya(h - c);
              if (T > i || M > a) {
                if (d) {
                  var C = p[m++];
                  if (v + C > y) {
                    var R = (y - v) / C;
                    t.lineTo(u * (1 - R) + f * R, c * (1 - R) + h * R);
                    break t;
                  }
                  v += C;
                }
                t.lineTo(f, h), u = f, c = h, _ = 0;
              } else {
                var E = T * T + M * M;
                E > _ && (x = f, b = h, _ = E);
              }
              break;
            }
            case Ne.C: {
              var D = n[S++], I = n[S++], P = n[S++], O = n[S++], N = n[S++], B = n[S++];
              if (d) {
                var C = p[m++];
                if (v + C > y) {
                  var R = (y - v) / C;
                  Uo(u, D, P, N, R, vs), Uo(c, I, O, B, R, gs), t.bezierCurveTo(vs[1], gs[1], vs[2], gs[2], vs[3], gs[3]);
                  break t;
                }
                v += C;
              }
              t.bezierCurveTo(D, I, P, O, N, B), u = N, c = B;
              break;
            }
            case Ne.Q: {
              var D = n[S++], I = n[S++], P = n[S++], O = n[S++];
              if (d) {
                var C = p[m++];
                if (v + C > y) {
                  var R = (y - v) / C;
                  rh(u, D, P, R, vs), rh(c, I, O, R, gs), t.quadraticCurveTo(vs[1], gs[1], vs[2], gs[2]);
                  break t;
                }
                v += C;
              }
              t.quadraticCurveTo(D, I, P, O), u = P, c = O;
              break;
            }
            case Ne.A:
              var F = n[S++], G = n[S++], W = n[S++], J = n[S++], U = n[S++], Y = n[S++], at = n[S++], st = !n[S++], ut = W > J ? W : J, lt = ya(W - J) > 1e-3, H = U + Y, ct = !1;
              if (d) {
                var C = p[m++];
                v + C > y && (H = U + Y * (y - v) / C, ct = !0), v += C;
              }
              if (lt && t.ellipse ? t.ellipse(F, G, W, J, at, U, H, st) : t.arc(F, G, ut, U, H, st), ct)
                break t;
              A && (s = ms(U) * W + F, l = ys(U) * J + G), u = ms(H) * W + F, c = ys(H) * J + G;
              break;
            case Ne.R:
              s = u = n[S], l = c = n[S + 1], f = n[S++], h = n[S++];
              var ot = n[S++], Gt = n[S++];
              if (d) {
                var C = p[m++];
                if (v + C > y) {
                  var yt = y - v;
                  t.moveTo(f, h), t.lineTo(f + zy(yt, ot), h), yt -= ot, yt > 0 && t.lineTo(f + ot, h + zy(yt, Gt)), yt -= Gt, yt > 0 && t.lineTo(f + Uy(ot - yt, 0), h + Gt), yt -= ot, yt > 0 && t.lineTo(f, h + Uy(Gt - yt, 0));
                  break t;
                }
                v += C;
              }
              t.rect(f, h, ot, Gt);
              break;
            case Ne.Z:
              if (d) {
                var C = p[m++];
                if (v + C > y) {
                  var R = (y - v) / C;
                  t.lineTo(u * (1 - R) + s * R, c * (1 - R) + l * R);
                  break t;
                }
                v += C;
              }
              t.closePath(), u = s, c = l;
          }
        }
  }, r.prototype.clone = function() {
    var t = new r(), e = this.data;
    return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t;
  }, r.prototype.canSave = function() {
    return !!this._saveData;
  }, r.CMD = Ne, r.initDefaultProps = function() {
    var t = r.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  }(), r;
}();
function yo(r, t, e, n, i, a, o) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = r;
  if (o > t + s && o > n + s || o < t - s && o < n - s || a > r + s && a > e + s || a < r - s && a < e - s)
    return !1;
  if (r !== e)
    l = (t - n) / (r - e), u = (r * n - e * t) / (r - e);
  else
    return Math.abs(a - r) <= s / 2;
  var c = l * a - o + u, f = c * c / (l * l + 1);
  return f <= s / 2 * s / 2;
}
function O6(r, t, e, n, i, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var f = l;
  if (c > t + f && c > n + f && c > a + f && c > s + f || c < t - f && c < n - f && c < a - f && c < s - f || u > r + f && u > e + f && u > i + f && u > o + f || u < r - f && u < e - f && u < i - f && u < o - f)
    return !1;
  var h = fP(r, t, e, n, i, a, o, s, u, c, null);
  return h <= f / 2;
}
function $P(r, t, e, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || s > r + u && s > e + u && s > i + u || s < r - u && s < e - u && s < i - u)
    return !1;
  var c = dP(r, t, e, n, i, a, s, l, null);
  return c <= u / 2;
}
var vA = Math.PI * 2;
function Nn(r) {
  return r %= vA, r < 0 && (r += vA), r;
}
var Kc = Math.PI * 2;
function k6(r, t, e, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= r, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > e || c + u < e)
    return !1;
  if (Math.abs(n - i) % Kc < 1e-4)
    return !0;
  if (a) {
    var f = n;
    n = Nn(i), i = Nn(f);
  } else
    n = Nn(n), i = Nn(i);
  n > i && (i += Kc);
  var h = Math.atan2(l, s);
  return h < 0 && (h += Kc), h >= n && h <= i || h + Kc >= n && h + Kc <= i;
}
function Ta(r, t, e, n, i, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var o = (a - t) / (n - t), s = n < t ? 1 : -1;
  (o === 1 || o === 0) && (s = n < t ? 0.5 : -0.5);
  var l = o * (e - r) + r;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var so = oa.CMD, _s = Math.PI * 2, B6 = 1e-4;
function V6(r, t) {
  return Math.abs(r - t) < B6;
}
var nn = [-1, -1, -1], qn = [-1, -1];
function F6() {
  var r = qn[0];
  qn[0] = qn[1], qn[1] = r;
}
function z6(r, t, e, n, i, a, o, s, l, u) {
  if (u > t && u > n && u > a && u > s || u < t && u < n && u < a && u < s)
    return 0;
  var c = wv(t, n, a, s, u, nn);
  if (c === 0)
    return 0;
  for (var f = 0, h = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
    var v = nn[g], m = v === 0 || v === 1 ? 0.5 : 1, y = wr(r, e, i, o, v);
    y < l || (h < 0 && (h = cP(t, n, a, s, qn), qn[1] < qn[0] && h > 1 && F6(), d = wr(t, n, a, s, qn[0]), h > 1 && (p = wr(t, n, a, s, qn[1]))), h === 2 ? v < qn[0] ? f += d < t ? m : -m : v < qn[1] ? f += p < d ? m : -m : f += s < p ? m : -m : v < qn[0] ? f += d < t ? m : -m : f += s < d ? m : -m);
  }
  return f;
}
function U6(r, t, e, n, i, a, o, s) {
  if (s > t && s > n && s > a || s < t && s < n && s < a)
    return 0;
  var l = jW(t, n, a, s, nn);
  if (l === 0)
    return 0;
  var u = hP(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, f = Pr(t, n, a, u), h = 0; h < l; h++) {
      var d = nn[h] === 0 || nn[h] === 1 ? 0.5 : 1, p = Pr(r, e, i, nn[h]);
      p < o || (nn[h] < u ? c += f < t ? d : -d : c += a < f ? d : -d);
    }
    return c;
  } else {
    var d = nn[0] === 0 || nn[0] === 1 ? 0.5 : 1, p = Pr(r, e, i, nn[0]);
    return p < o ? 0 : a < t ? d : -d;
  }
}
function G6(r, t, e, n, i, a, o, s) {
  if (s -= t, s > e || s < -e)
    return 0;
  var l = Math.sqrt(e * e - s * s);
  nn[0] = -l, nn[1] = l;
  var u = Math.abs(n - i);
  if (u < 1e-4)
    return 0;
  if (u >= _s - 1e-4) {
    n = 0, i = _s;
    var c = a ? 1 : -1;
    return o >= nn[0] + r && o <= nn[1] + r ? c : 0;
  }
  if (n > i) {
    var f = n;
    n = i, i = f;
  }
  n < 0 && (n += _s, i += _s);
  for (var h = 0, d = 0; d < 2; d++) {
    var p = nn[d];
    if (p + r > o) {
      var g = Math.atan2(s, p), c = a ? 1 : -1;
      g < 0 && (g = _s + g), (g >= n && g <= i || g + _s >= n && g + _s <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), h += c);
    }
  }
  return h;
}
function ZP(r, t, e, n, i) {
  for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, c = 0, f = 0, h, d, p = 0; p < o; ) {
    var g = a[p++], v = p === 1;
    switch (g === so.M && p > 1 && (e || (s += Ta(l, u, c, f, n, i))), v && (l = a[p], u = a[p + 1], c = l, f = u), g) {
      case so.M:
        c = a[p++], f = a[p++], l = c, u = f;
        break;
      case so.L:
        if (e) {
          if (yo(l, u, a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += Ta(l, u, a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case so.C:
        if (e) {
          if (O6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += z6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case so.Q:
        if (e) {
          if ($P(l, u, a[p++], a[p++], a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += U6(l, u, a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case so.A:
        var m = a[p++], y = a[p++], _ = a[p++], x = a[p++], b = a[p++], S = a[p++];
        p += 1;
        var w = !!(1 - a[p++]);
        h = Math.cos(b) * _ + m, d = Math.sin(b) * x + y, v ? (c = h, f = d) : s += Ta(l, u, h, d, n, i);
        var A = (n - m) * x / _ + m;
        if (e) {
          if (k6(m, y, x, b, b + S, w, t, A, i))
            return !0;
        } else
          s += G6(m, y, x, b, b + S, w, A, i);
        l = Math.cos(b + S) * _ + m, u = Math.sin(b + S) * x + y;
        break;
      case so.R:
        c = l = a[p++], f = u = a[p++];
        var T = a[p++], M = a[p++];
        if (h = c + T, d = f + M, e) {
          if (yo(c, f, h, f, t, n, i) || yo(h, f, h, d, t, n, i) || yo(h, d, c, d, t, n, i) || yo(c, d, c, f, t, n, i))
            return !0;
        } else
          s += Ta(h, f, h, d, n, i), s += Ta(c, d, c, f, n, i);
        break;
      case so.Z:
        if (e) {
          if (yo(l, u, c, f, t, n, i))
            return !0;
        } else
          s += Ta(l, u, c, f, n, i);
        l = c, u = f;
        break;
    }
  }
  return !e && !V6(u, f) && (s += Ta(l, u, c, f, n, i) || 0), s !== 0;
}
function H6(r, t, e) {
  return ZP(r, 0, !1, t, e);
}
function W6(r, t, e, n) {
  return ZP(r, t, !0, e, n);
}
var Rv = Bt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, il), X6 = {
  style: Bt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, jg.style)
}, Wy = ia.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), ne = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.update = function() {
    var e = this;
    r.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var i = this._decalEl = this._decalEl || new t();
      i.buildPath === t.prototype.buildPath && (i.buildPath = function(l) {
        e.buildPath(l, e.shape);
      }), i.silent = !0;
      var a = i.style;
      for (var o in n)
        a[o] !== n[o] && (a[o] = n[o]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var s = 0; s < Wy.length; ++s)
        i[Wy[s]] = this[Wy[s]];
      i.__dirty |= In;
    } else
      this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(e) {
    var n = se(e);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = e[o];
      o === "style" ? this.style ? j(this.style, s) : this.useStyle(s) : o === "shape" ? j(this.shape, s) : r.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var e = this.style.fill;
    if (e !== "none") {
      if (pt(e)) {
        var n = Tv(e, 0);
        return n > 0.5 ? yx : n > 0.2 ? T8 : _x;
      } else if (e)
        return _x;
    }
    return yx;
  }, t.prototype.getInsideTextStroke = function(e) {
    var n = this.style.fill;
    if (pt(n)) {
      var i = this.__zr, a = !!(i && i.isDarkMode()), o = Tv(e, 0) < mx;
      if (a === o)
        return n;
    }
  }, t.prototype.buildPath = function(e, n, i) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Cu;
  }, t.prototype.getUpdatedPathProxy = function(e) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, e), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new oa(!1);
  }, t.prototype.hasStroke = function() {
    var e = this.style, n = e.stroke;
    return !(n == null || n === "none" || !(e.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var e = this.style, n = e.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var e = this._rect, n = this.style, i = !e;
    if (i) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & Cu) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), e = o.getBoundingRect();
    }
    if (this._rect = e, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = e.clone());
      if (this.__dirty || i) {
        s.copy(e);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return e;
  }, t.prototype.contain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect(), o = this.style;
    if (e = i[0], n = i[1], a.contain(e, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), W6(s, l / u, e, n)))
          return !0;
      }
      if (this.hasFill())
        return H6(s, e, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Cu, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(e) {
    return this.animate("shape", e);
  }, t.prototype.updateDuringAnimation = function(e) {
    e === "style" ? this.dirtyStyle() : e === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(e, n) {
    e === "shape" ? this.setShape(n) : r.prototype.attrKV.call(this, e, n);
  }, t.prototype.setShape = function(e, n) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof e == "string" ? i[e] = n : j(i, e), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Cu);
  }, t.prototype.createStyle = function(e) {
    return Ug(Rv, e);
  }, t.prototype._innerSaveToNormal = function(e) {
    r.prototype._innerSaveToNormal.call(this, e);
    var n = this._normalState;
    e.shape && !n.shape && (n.shape = j({}, this.shape));
  }, t.prototype._applyStateObj = function(e, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, e, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.shape ? o ? a ? u = n.shape : (u = j({}, i.shape), j(u, n.shape)) : (u = j({}, a ? this.shape : i.shape), j(u, n.shape)) : l && (u = i.shape), u)
      if (o) {
        this.shape = j({}, this.shape);
        for (var c = {}, f = se(u), h = 0; h < f.length; h++) {
          var d = f[h];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(e, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(e) {
    for (var n = r.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
      var o = e[a];
      o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
    }
    return i && (n.shape = i), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return X6;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(e) {
    var n = function(a) {
      Ue(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return e.init && e.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return Dt(e.style);
      }, o.prototype.getDefaultShape = function() {
        return Dt(e.shape);
      }, o;
    }(t);
    for (var i in e)
      typeof e[i] == "function" && (n.prototype[i] = e[i]);
    return n;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.type = "path", e.strokeContainThreshold = 5, e.segmentIgnoreThreshold = 0, e.subPixelOptimize = !1, e.autoBatch = !1, e.__dirty = In | Ef | Cu;
  }(), t;
}(ai), Y6 = Bt({
  strokeFirst: !0,
  font: Ua,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, Rv), nc = function(r) {
  Ue(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return YP(this.style);
  }, t.prototype.hasFill = function() {
    var e = this.style, n = e.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(e) {
    return Ug(Y6, e);
  }, t.prototype.setBoundingRect = function(e) {
    this._rect = e;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = D6(this.style)), this._rect;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.dirtyRectTolerance = 10;
  }(), t;
}(ai);
nc.prototype.type = "tspan";
var $6 = Bt({
  x: 0,
  y: 0
}, il), Z6 = {
  style: Bt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, jg.style)
};
function q6(r) {
  return !!(r && typeof r != "string" && r.width && r.height);
}
var Fr = function(r) {
  Ue(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(e) {
    return Ug($6, e);
  }, t.prototype._getSize = function(e) {
    var n = this.style, i = n[e];
    if (i != null)
      return i;
    var a = q6(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var o = e === "width" ? "height" : "width", s = n[o];
    return s == null ? a[e] : a[e] / a[o] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return Z6;
  }, t.prototype.getBoundingRect = function() {
    var e = this.style;
    return this._rect || (this._rect = new Vt(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
}(ai);
Fr.prototype.type = "image";
function K6(r, t) {
  var e = t.x, n = t.y, i = t.width, a = t.height, o = t.r, s, l, u, c;
  i < 0 && (e = e + i, i = -i), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var f;
  s + l > i && (f = s + l, s *= i / f, l *= i / f), u + c > i && (f = u + c, u *= i / f, c *= i / f), l + u > a && (f = l + u, l *= a / f, u *= a / f), s + c > a && (f = s + c, s *= a / f, c *= a / f), r.moveTo(e + s, n), r.lineTo(e + i - l, n), l !== 0 && r.arc(e + i - l, n + l, l, -Math.PI / 2, 0), r.lineTo(e + i, n + a - u), u !== 0 && r.arc(e + i - u, n + a - u, u, 0, Math.PI / 2), r.lineTo(e + c, n + a), c !== 0 && r.arc(e + c, n + a - c, c, Math.PI / 2, Math.PI), r.lineTo(e, n + s), s !== 0 && r.arc(e + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var ku = Math.round;
function tm(r, t, e) {
  if (t) {
    var n = t.x1, i = t.x2, a = t.y1, o = t.y2;
    r.x1 = n, r.x2 = i, r.y1 = a, r.y2 = o;
    var s = e && e.lineWidth;
    return s && (ku(n * 2) === ku(i * 2) && (r.x1 = r.x2 = On(n, s, !0)), ku(a * 2) === ku(o * 2) && (r.y1 = r.y2 = On(a, s, !0))), r;
  }
}
function qP(r, t, e) {
  if (t) {
    var n = t.x, i = t.y, a = t.width, o = t.height;
    r.x = n, r.y = i, r.width = a, r.height = o;
    var s = e && e.lineWidth;
    return s && (r.x = On(n, s, !0), r.y = On(i, s, !0), r.width = Math.max(On(n + a, s, !1) - r.x, a === 0 ? 0 : 1), r.height = Math.max(On(i + o, s, !1) - r.y, o === 0 ? 0 : 1)), r;
  }
}
function On(r, t, e) {
  if (!t)
    return r;
  var n = ku(r * 2);
  return (n + ku(t)) % 2 === 0 ? n / 2 : (n + (e ? 1 : -1)) / 2;
}
var j6 = /* @__PURE__ */ function() {
  function r() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return r;
}(), J6 = {}, te = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new j6();
  }, t.prototype.buildPath = function(e, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = qP(J6, n, this.style);
      i = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
    } else
      i = n.x, a = n.y, o = n.width, s = n.height;
    n.r ? K6(e, n) : e.rect(i, a, o, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
}(ne);
te.prototype.type = "rect";
var gA = {
  fill: "#000"
}, mA = 2, Ii = {}, Q6 = {
  style: Bt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, jg.style)
}, pe = function(r) {
  Ue(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = gA, n.attr(e), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var e = 0; e < this._children.length; e++) {
      var n = this._children[e];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var e = this.innerTransformable;
    e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : r.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(e) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(e) : r.prototype.getLocalTransform.call(this, e);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), r.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, r7(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(e) {
    r.prototype.addSelfToZr.call(this, e);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = e;
  }, t.prototype.removeSelfFromZr = function(e) {
    r.prototype.removeSelfFromZr.call(this, e);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var e = new Vt(0, 0, 0, 0), n = this._children, i = [], a = null, o = 0; o < n.length; o++) {
        var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (e.copy(l), e.applyTransform(u), a = a || e.clone(), a.union(e)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || e;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(e) {
    this._defaultStyle = e || gA;
  }, t.prototype.setTextContent = function(e) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(e, n) {
    if (!n)
      return e;
    var i = n.rich, a = e.rich || i && {};
    return j(e, n), i && a ? (this._mergeRich(a, i), e.rich = a) : a && (e.rich = a), e;
  }, t.prototype._mergeRich = function(e, n) {
    for (var i = se(n), a = 0; a < i.length; a++) {
      var o = i[a];
      e[o] = e[o] || {}, j(e[o], n[o]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return Q6;
  }, t.prototype._getOrCreateChild = function(e) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof e)) && (n = new e()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var e = this.style, n = e.font || Ua, i = e.padding, a = this._defaultStyle, o = e.x || 0, s = e.y || 0, l = e.align || a.align || "left", u = e.verticalAlign || a.verticalAlign || "top";
    lA(Ii, a.overflowRect, o, s, l, u), o = Ii.baseX, s = Ii.baseY;
    var c = MA(e), f = b6(c, e, Ii.outerWidth, Ii.outerHeight), h = Xy(e), d = !!e.backgroundColor, p = f.outerHeight, g = f.outerWidth, v = f.lines, m = f.lineHeight;
    this.isTruncated = !!f.isTruncated;
    var y = o, _ = nl(s, f.contentHeight, u);
    if (h || i) {
      var x = ec(o, g, l), b = nl(s, p, u);
      h && this._renderBackground(e, e, x, b, g, p);
    }
    _ += m / 2, i && (y = wA(o, l, i), u === "top" ? _ += i[0] : u === "bottom" && (_ -= i[2]));
    for (var S = 0, w = !1, A = !1, T = bA("fill" in e ? e.fill : (A = !0, a.fill)), M = SA("stroke" in e ? e.stroke : !d && (!a.autoStroke || A) ? (S = mA, w = !0, a.stroke) : null), C = e.textShadowBlur > 0, R = 0; R < v.length; R++) {
      var E = this._getOrCreateChild(nc), D = E.createStyle();
      E.useStyle(D), D.text = v[R], D.x = y, D.y = _, D.textAlign = l, D.textBaseline = "middle", D.opacity = e.opacity, D.strokeFirst = !0, C && (D.shadowBlur = e.textShadowBlur || 0, D.shadowColor = e.textShadowColor || "transparent", D.shadowOffsetX = e.textShadowOffsetX || 0, D.shadowOffsetY = e.textShadowOffsetY || 0), D.stroke = M, D.fill = T, M && (D.lineWidth = e.lineWidth || S, D.lineDash = e.lineDash, D.lineDashOffset = e.lineDashOffset || 0), D.font = n, _A(D, e), _ += m, E.setBoundingRect(Tx(D, f.contentWidth, f.calculatedLineHeight, w ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var e = this.style, n = this._defaultStyle, i = e.align || n.align, a = e.verticalAlign || n.verticalAlign, o = e.x || 0, s = e.y || 0;
    lA(Ii, n.overflowRect, o, s, i, a), o = Ii.baseX, s = Ii.baseY;
    var l = MA(e), u = T6(l, e, Ii.outerWidth, Ii.outerHeight, i), c = u.width, f = u.outerWidth, h = u.outerHeight, d = e.padding;
    this.isTruncated = !!u.isTruncated;
    var p = ec(o, f, i), g = nl(s, h, a), v = p, m = g;
    d && (v += d[3], m += d[0]);
    var y = v + c;
    Xy(e) && this._renderBackground(e, e, p, g, f, h);
    for (var _ = !!e.backgroundColor, x = 0; x < u.lines.length; x++) {
      for (var b = u.lines[x], S = b.tokens, w = S.length, A = b.lineHeight, T = b.width, M = 0, C = v, R = y, E = w - 1, D = void 0; M < w && (D = S[M], !D.align || D.align === "left"); )
        this._placeToken(D, e, A, m, C, "left", _), T -= D.width, C += D.width, M++;
      for (; E >= 0 && (D = S[E], D.align === "right"); )
        this._placeToken(D, e, A, m, R, "right", _), T -= D.width, R -= D.width, E--;
      for (C += (c - (C - v) - (y - R) - T) / 2; M <= E; )
        D = S[M], this._placeToken(D, e, A, m, C + D.width / 2, "center", _), C += D.width, M++;
      m += A;
    }
  }, t.prototype._placeToken = function(e, n, i, a, o, s, l) {
    var u = n.rich[e.styleName] || {};
    u.text = e.text;
    var c = e.verticalAlign, f = a + i / 2;
    c === "top" ? f = a + e.height / 2 : c === "bottom" && (f = a + i - e.height / 2);
    var h = !e.isLineHolder && Xy(u);
    h && this._renderBackground(u, n, s === "right" ? o - e.width : s === "center" ? o - e.width / 2 : o, f - e.height / 2, e.width, e.height);
    var d = !!u.backgroundColor, p = e.textPadding;
    p && (o = wA(o, s, p), f -= e.height / 2 - p[0] - e.innerHeight / 2);
    var g = this._getOrCreateChild(nc), v = g.createStyle();
    g.useStyle(v);
    var m = this._defaultStyle, y = !1, _ = 0, x = !1, b = bA("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), S = SA("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !d && !l && (!m.autoStroke || y) ? (_ = mA, x = !0, m.stroke) : null), w = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    v.text = e.text, v.x = o, v.y = f, w && (v.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, v.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = e.font || Ua, v.opacity = un(u.opacity, n.opacity, 1), _A(v, u), S && (v.lineWidth = un(u.lineWidth, n.lineWidth, _), v.lineDash = bt(u.lineDash, n.lineDash), v.lineDashOffset = n.lineDashOffset || 0, v.stroke = S), b && (v.fill = b), g.setBoundingRect(Tx(v, e.contentWidth, e.contentHeight, x ? 0 : null));
  }, t.prototype._renderBackground = function(e, n, i, a, o, s) {
    var l = e.backgroundColor, u = e.borderWidth, c = e.borderColor, f = l && l.image, h = l && !f, d = e.borderRadius, p = this, g, v;
    if (h || e.lineHeight || u && c) {
      g = this._getOrCreateChild(te), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = a, m.width = o, m.height = s, m.r = d, g.dirtyShape();
    }
    if (h) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = bt(e.fillOpacity, 1);
    } else if (f) {
      v = this._getOrCreateChild(Fr), v.onload = function() {
        p.dirtyStyle();
      };
      var _ = v.style;
      _.image = l.image, _.x = i, _.y = a, _.width = o, _.height = s;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = bt(e.strokeOpacity, 1), y.lineDash = e.borderDash, y.lineDashOffset = e.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var x = (g || v).style;
    x.shadowBlur = e.shadowBlur || 0, x.shadowColor = e.shadowColor || "transparent", x.shadowOffsetX = e.shadowOffsetX || 0, x.shadowOffsetY = e.shadowOffsetY || 0, x.opacity = un(e.opacity, n.opacity, 1);
  }, t.makeFont = function(e) {
    var n = "";
    return jP(e) && (n = [
      e.fontStyle,
      e.fontWeight,
      KP(e.fontSize),
      e.fontFamily || "sans-serif"
    ].join(" ")), n && ei(n) || e.textFont || e.font;
  }, t;
}(ai), t7 = { left: !0, right: 1, center: 1 }, e7 = { top: 1, bottom: 1, middle: 1 }, yA = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function KP(r) {
  return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? _1 + "px" : r + "px";
}
function _A(r, t) {
  for (var e = 0; e < yA.length; e++) {
    var n = yA[e], i = t[n];
    i != null && (r[n] = i);
  }
}
function jP(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight;
}
function r7(r) {
  return xA(r), L(r.rich, xA), r;
}
function xA(r) {
  if (r) {
    r.font = pe.makeFont(r);
    var t = r.align;
    t === "middle" && (t = "center"), r.align = t == null || t7[t] ? t : "left";
    var e = r.verticalAlign;
    e === "center" && (e = "middle"), r.verticalAlign = e == null || e7[e] ? e : "top";
    var n = r.padding;
    n && (r.padding = zg(r.padding));
  }
}
function SA(r, t) {
  return r == null || t <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function bA(r) {
  return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function wA(r, t, e) {
  return t === "right" ? r - e[1] : t === "center" ? r + e[3] / 2 - e[1] / 2 : r + e[3];
}
function MA(r) {
  var t = r.text;
  return t != null && (t += ""), t;
}
function Xy(r) {
  return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
}
var zt = ee(), Cx = function(r, t, e, n) {
  if (n) {
    var i = zt(n);
    i.dataIndex = e, i.dataType = t, i.seriesIndex = r, i.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var o = zt(a);
      o.seriesIndex = r, o.dataIndex = e, o.dataType = t, o.ssrType = "chart";
    });
  }
}, TA = 1, AA = {}, JP = ee(), k1 = ee(), B1 = 0, Oh = 1, em = 2, pn = ["emphasis", "blur", "select"], oh = ["normal", "emphasis", "blur", "select"], wc = 10, n7 = 9, al = "highlight", qp = "downplay", Iv = "select", Dx = "unselect", Pv = "toggleSelect", V1 = "selectchanged";
function nu(r) {
  return r != null && r !== "none";
}
function rm(r, t, e) {
  r.onHoverStateChange && (r.hoverState || 0) !== e && r.onHoverStateChange(t), r.hoverState = e;
}
function QP(r) {
  rm(r, "emphasis", em);
}
function tN(r) {
  r.hoverState === em && rm(r, "normal", B1);
}
function F1(r) {
  rm(r, "blur", Oh);
}
function eN(r) {
  r.hoverState === Oh && rm(r, "normal", B1);
}
function i7(r) {
  r.selected = !0;
}
function a7(r) {
  r.selected = !1;
}
function EA(r, t, e) {
  t(r, e);
}
function qa(r, t, e) {
  EA(r, t, e), r.isGroup && r.traverse(function(n) {
    EA(n, t, e);
  });
}
function Nv(r, t) {
  switch (t) {
    case "emphasis":
      r.hoverState = em;
      break;
    case "normal":
      r.hoverState = B1;
      break;
    case "blur":
      r.hoverState = Oh;
      break;
    case "select":
      r.selected = !0;
  }
}
function o7(r, t, e, n) {
  for (var i = r.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o], l = i[s];
    a[s] = l ?? (n && n[s]);
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(e) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function s7(r, t, e, n) {
  var i = e && Zt(e, "select") >= 0, a = !1;
  if (r instanceof ne) {
    var o = JP(r), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
    if (nu(s) || nu(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = j({}, n), u = j({}, u), u.fill = s) : !nu(u.fill) && nu(s) ? (a = !0, n = j({}, n), u = j({}, u), u.fill = cx(s)) : !nu(u.stroke) && nu(l) && (a || (n = j({}, n), u = j({}, u)), u.stroke = cx(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = j({}, n));
    var c = r.z2EmphasisLift;
    n.z2 = r.z2 + (c ?? wc);
  }
  return n;
}
function l7(r, t, e) {
  if (e && e.z2 == null) {
    e = j({}, e);
    var n = r.z2SelectLift;
    e.z2 = r.z2 + (n ?? n7);
  }
  return e;
}
function u7(r, t, e) {
  var n = Zt(r.currentStates, t) >= 0, i = r.style.opacity, a = n ? null : o7(r, ["opacity"], t, {
    opacity: 1
  });
  e = e || {};
  var o = e.style || {};
  return o.opacity == null && (e = j({}, e), o = j({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? i : a.opacity * 0.1
  }, o), e.style = o), e;
}
function Yy(r, t) {
  var e = this.states[r];
  if (this.style) {
    if (r === "emphasis")
      return s7(this, r, t, e);
    if (r === "blur")
      return u7(this, r, e);
    if (r === "select")
      return l7(this, r, e);
  }
  return e;
}
function gl(r) {
  r.stateProxy = Yy;
  var t = r.getTextContent(), e = r.getTextGuideLine();
  t && (t.stateProxy = Yy), e && (e.stateProxy = Yy);
}
function CA(r, t) {
  !aN(r, t) && !r.__highByOuter && qa(r, QP);
}
function DA(r, t) {
  !aN(r, t) && !r.__highByOuter && qa(r, tN);
}
function Wa(r, t) {
  r.__highByOuter |= 1 << (t || 0), qa(r, QP);
}
function Xa(r, t) {
  !(r.__highByOuter &= ~(1 << (t || 0))) && qa(r, tN);
}
function rN(r) {
  qa(r, F1);
}
function z1(r) {
  qa(r, eN);
}
function nN(r) {
  qa(r, i7);
}
function iN(r) {
  qa(r, a7);
}
function aN(r, t) {
  return r.__highDownSilentOnTouch && t.zrByTouch;
}
function oN(r) {
  var t = r.getModel(), e = [], n = [];
  t.eachComponent(function(i, a) {
    var o = k1(a), s = i === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
    !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
      eN(u);
    }), s && e.push(a)), o.isBlured = !1;
  }), L(n, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(e, !1, t);
  });
}
function Lx(r, t, e, n) {
  var i = n.getModel();
  e = e || "coordinateSystem";
  function a(u, c) {
    for (var f = 0; f < c.length; f++) {
      var h = u.getItemGraphicEl(c[f]);
      h && z1(h);
    }
  }
  if (r != null && !(!t || t === "none")) {
    var o = i.getSeriesByIndex(r), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = o === u, f = u.coordinateSystem;
      f && f.master && (f = f.master);
      var h = f && s ? f === s : c;
      if (!// Not blur other series if blurScope series
      (e === "series" && !c || e === "coordinateSystem" && !h || t === "series" && c)) {
        var d = n.getViewOfSeriesModel(u);
        if (d.group.traverse(function(v) {
          v.__highByOuter && c && t === "self" || F1(v);
        }), Kr(t))
          a(u.getData(), t);
        else if (Lt(t))
          for (var p = se(t), g = 0; g < p.length; g++)
            a(u.getData(p[g]), t[p[g]]);
        l.push(u), k1(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var f = n.getViewOfComponentModel(c);
        f && f.toggleBlurSeries && f.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function Rx(r, t, e) {
  if (!(r == null || t == null)) {
    var n = e.getModel().getComponent(r, t);
    if (n) {
      k1(n).isBlured = !0;
      var i = e.getViewOfComponentModel(n);
      !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
        F1(a);
      });
    }
  }
}
function c7(r, t, e) {
  var n = r.seriesIndex, i = r.getData(t.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && ce("Unknown dataType " + t.dataType);
    return;
  }
  var a = pl(i, t);
  a = (et(a) ? a[0] : a) || 0;
  var o = i.getItemGraphicEl(a);
  if (!o)
    for (var s = i.count(), l = 0; !o && l < s; )
      o = i.getItemGraphicEl(l++);
  if (o) {
    var u = zt(o);
    Lx(n, u.focus, u.blurScope, e);
  } else {
    var c = r.get(["emphasis", "focus"]), f = r.get(["emphasis", "blurScope"]);
    c != null && Lx(n, c, f, e);
  }
}
function U1(r, t, e, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (r == null || r === "series" || t == null || e == null)
    return i;
  var a = n.getModel().getComponent(r, t);
  if (!a)
    return i;
  var o = n.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return i;
  for (var s = o.findHighDownDispatchers(e), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !Go(s[u]) && ce("param should be highDownDispatcher"), zt(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function f7(r, t, e) {
  process.env.NODE_ENV !== "production" && !Go(r) && ce("param should be highDownDispatcher");
  var n = zt(r), i = U1(n.componentMainType, n.componentIndex, n.componentHighDownName, e), a = i.dispatchers, o = i.focusSelf;
  a ? (o && Rx(n.componentMainType, n.componentIndex, e), L(a, function(s) {
    return CA(s, t);
  })) : (Lx(n.seriesIndex, n.focus, n.blurScope, e), n.focus === "self" && Rx(n.componentMainType, n.componentIndex, e), CA(r, t));
}
function h7(r, t, e) {
  process.env.NODE_ENV !== "production" && !Go(r) && ce("param should be highDownDispatcher"), oN(e);
  var n = zt(r), i = U1(n.componentMainType, n.componentIndex, n.componentHighDownName, e).dispatchers;
  i ? L(i, function(a) {
    return DA(a, t);
  }) : DA(r, t);
}
function d7(r, t, e) {
  if (Px(t)) {
    var n = t.dataType, i = r.getData(n), a = pl(i, t);
    et(a) || (a = [a]), r[t.type === Pv ? "toggleSelect" : t.type === Iv ? "select" : "unselect"](a, n);
  }
}
function LA(r) {
  var t = r.getAllData();
  L(t, function(e) {
    var n = e.data, i = e.type;
    n.eachItemGraphicEl(function(a, o) {
      r.isSelected(o, i) ? nN(a) : iN(a);
    });
  });
}
function p7(r) {
  var t = [];
  return r.eachSeries(function(e) {
    var n = e.getAllData();
    L(n, function(i) {
      i.data;
      var a = i.type, o = e.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: e.seriesIndex
        };
        a != null && (s.dataType = a), t.push(s);
      }
    });
  }), t;
}
function ol(r, t, e) {
  js(r, !0), qa(r, gl), Ix(r, t, e);
}
function v7(r) {
  js(r, !1);
}
function He(r, t, e, n) {
  n ? v7(r) : ol(r, t, e);
}
function Ix(r, t, e) {
  var n = zt(r);
  t != null ? (n.focus = t, n.blurScope = e) : n.focus && (n.focus = null);
}
var RA = ["emphasis", "blur", "select"], g7 = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function _r(r, t, e, n) {
  e = e || "itemStyle";
  for (var i = 0; i < RA.length; i++) {
    var a = RA[i], o = t.getModel([a, e]), s = r.ensureState(a);
    s.style = n ? n(o) : o[g7[e]]();
  }
}
function js(r, t) {
  var e = t === !1, n = r;
  r.highDownSilentOnTouch && (n.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!e || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !e);
}
function Go(r) {
  return !!(r && r.__highDownDispatcher);
}
function m7(r, t, e) {
  var n = zt(r);
  n.componentMainType = t.mainType, n.componentIndex = t.componentIndex, n.componentHighDownName = e;
}
function y7(r) {
  var t = AA[r];
  return t == null && TA <= 32 && (t = AA[r] = TA++), t;
}
function Px(r) {
  var t = r.type;
  return t === Iv || t === Dx || t === Pv;
}
function IA(r) {
  var t = r.type;
  return t === al || t === qp;
}
function _7(r) {
  var t = JP(r);
  t.normalFill = r.style.fill, t.normalStroke = r.style.stroke;
  var e = r.states.select || {};
  t.selectFill = e.style && e.style.fill || null, t.selectStroke = e.style && e.style.stroke || null;
}
var iu = oa.CMD, x7 = [[], [], []], PA = Math.sqrt, S7 = Math.atan2;
function sN(r, t) {
  if (t) {
    var e = r.data, n = r.len(), i, a, o, s, l, u, c = iu.M, f = iu.C, h = iu.L, d = iu.R, p = iu.A, g = iu.Q;
    for (o = 0, s = 0; o < n; ) {
      switch (i = e[o++], s = o, a = 0, i) {
        case c:
          a = 1;
          break;
        case h:
          a = 1;
          break;
        case f:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case p:
          var v = t[4], m = t[5], y = PA(t[0] * t[0] + t[1] * t[1]), _ = PA(t[2] * t[2] + t[3] * t[3]), x = S7(-t[1] / _, t[0] / y);
          e[o] *= y, e[o++] += v, e[o] *= _, e[o++] += m, e[o++] *= y, e[o++] *= _, e[o++] += x, e[o++] += x, o += 2, s = o;
          break;
        case d:
          u[0] = e[o++], u[1] = e[o++], nr(u, u, t), e[s++] = u[0], e[s++] = u[1], u[0] += e[o++], u[1] += e[o++], nr(u, u, t), e[s++] = u[0], e[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var b = x7[l];
        b[0] = e[o++], b[1] = e[o++], nr(b, b, t), e[s++] = b[0], e[s++] = b[1];
      }
    }
    r.increaseVersion();
  }
}
var $y = Math.sqrt, Vd = Math.sin, Fd = Math.cos, jc = Math.PI;
function NA(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function Nx(r, t) {
  return (r[0] * t[0] + r[1] * t[1]) / (NA(r) * NA(t));
}
function OA(r, t) {
  return (r[0] * t[1] < r[1] * t[0] ? -1 : 1) * Math.acos(Nx(r, t));
}
function kA(r, t, e, n, i, a, o, s, l, u, c) {
  var f = l * (jc / 180), h = Fd(f) * (r - e) / 2 + Vd(f) * (t - n) / 2, d = -1 * Vd(f) * (r - e) / 2 + Fd(f) * (t - n) / 2, p = h * h / (o * o) + d * d / (s * s);
  p > 1 && (o *= $y(p), s *= $y(p));
  var g = (i === a ? -1 : 1) * $y((o * o * (s * s) - o * o * (d * d) - s * s * (h * h)) / (o * o * (d * d) + s * s * (h * h))) || 0, v = g * o * d / s, m = g * -s * h / o, y = (r + e) / 2 + Fd(f) * v - Vd(f) * m, _ = (t + n) / 2 + Vd(f) * v + Fd(f) * m, x = OA([1, 0], [(h - v) / o, (d - m) / s]), b = [(h - v) / o, (d - m) / s], S = [(-1 * h - v) / o, (-1 * d - m) / s], w = OA(b, S);
  if (Nx(b, S) <= -1 && (w = jc), Nx(b, S) >= 1 && (w = 0), w < 0) {
    var A = Math.round(w / jc * 1e6) / 1e6;
    w = jc * 2 + A % 2 * jc;
  }
  c.addData(u, y, _, o, s, x, w, f, a);
}
var b7 = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, w7 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function M7(r) {
  var t = new oa();
  if (!r)
    return t;
  var e = 0, n = 0, i = e, a = n, o, s = oa.CMD, l = r.match(b7);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], f = c.charAt(0), h = void 0, d = c.match(w7) || [], p = d.length, g = 0; g < p; g++)
      d[g] = parseFloat(d[g]);
    for (var v = 0; v < p; ) {
      var m = void 0, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0, w = void 0, A = e, T = n, M = void 0, C = void 0;
      switch (f) {
        case "l":
          e += d[v++], n += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "L":
          e = d[v++], n = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "m":
          e += d[v++], n += d[v++], h = s.M, t.addData(h, e, n), i = e, a = n, f = "l";
          break;
        case "M":
          e = d[v++], n = d[v++], h = s.M, t.addData(h, e, n), i = e, a = n, f = "L";
          break;
        case "h":
          e += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "H":
          e = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "v":
          n += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "V":
          n = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "C":
          h = s.C, t.addData(h, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), e = d[v - 2], n = d[v - 1];
          break;
        case "c":
          h = s.C, t.addData(h, d[v++] + e, d[v++] + n, d[v++] + e, d[v++] + n, d[v++] + e, d[v++] + n), e += d[v - 2], n += d[v - 1];
          break;
        case "S":
          m = e, y = n, M = t.len(), C = t.data, o === s.C && (m += e - C[M - 4], y += n - C[M - 3]), h = s.C, A = d[v++], T = d[v++], e = d[v++], n = d[v++], t.addData(h, m, y, A, T, e, n);
          break;
        case "s":
          m = e, y = n, M = t.len(), C = t.data, o === s.C && (m += e - C[M - 4], y += n - C[M - 3]), h = s.C, A = e + d[v++], T = n + d[v++], e += d[v++], n += d[v++], t.addData(h, m, y, A, T, e, n);
          break;
        case "Q":
          A = d[v++], T = d[v++], e = d[v++], n = d[v++], h = s.Q, t.addData(h, A, T, e, n);
          break;
        case "q":
          A = d[v++] + e, T = d[v++] + n, e += d[v++], n += d[v++], h = s.Q, t.addData(h, A, T, e, n);
          break;
        case "T":
          m = e, y = n, M = t.len(), C = t.data, o === s.Q && (m += e - C[M - 4], y += n - C[M - 3]), e = d[v++], n = d[v++], h = s.Q, t.addData(h, m, y, e, n);
          break;
        case "t":
          m = e, y = n, M = t.len(), C = t.data, o === s.Q && (m += e - C[M - 4], y += n - C[M - 3]), e += d[v++], n += d[v++], h = s.Q, t.addData(h, m, y, e, n);
          break;
        case "A":
          _ = d[v++], x = d[v++], b = d[v++], S = d[v++], w = d[v++], A = e, T = n, e = d[v++], n = d[v++], h = s.A, kA(A, T, e, n, S, w, _, x, b, h, t);
          break;
        case "a":
          _ = d[v++], x = d[v++], b = d[v++], S = d[v++], w = d[v++], A = e, T = n, e += d[v++], n += d[v++], h = s.A, kA(A, T, e, n, S, w, _, x, b, h, t);
          break;
      }
    }
    (f === "z" || f === "Z") && (h = s.Z, t.addData(h), e = i, n = a), o = h;
  }
  return t.toStatic(), t;
}
var lN = function(r) {
  Ue(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(e) {
  }, t;
}(ne);
function uN(r) {
  return r.setData != null;
}
function cN(r, t) {
  var e = M7(r), n = j({}, t);
  return n.buildPath = function(i) {
    var a = uN(i);
    if (a && i.canSave()) {
      i.appendPath(e);
      var o = i.getContext();
      o && i.rebuildPath(o, 1);
    } else {
      var o = a ? i.getContext() : i;
      o && e.rebuildPath(o, 1);
    }
  }, n.applyTransform = function(i) {
    sN(e, i), this.dirtyShape();
  }, n;
}
function fN(r, t) {
  return new lN(cN(r, t));
}
function T7(r, t) {
  var e = cN(r, t), n = function(i) {
    Ue(a, i);
    function a(o) {
      var s = i.call(this, o) || this;
      return s.applyTransform = e.applyTransform, s.buildPath = e.buildPath, s;
    }
    return a;
  }(lN);
  return n;
}
function A7(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++) {
    var a = r[i];
    e.push(a.getUpdatedPathProxy(!0));
  }
  var o = new ne(t);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (uN(s)) {
      s.appendPath(e);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function G1(r, t) {
  t = t || {};
  var e = new ne();
  return r.shape && e.setShape(r.shape), e.setStyle(r.style), t.bakeTransform ? sN(e.path, r.getComputedTransform()) : t.toLocal ? e.setLocalTransform(r.getComputedTransform()) : e.copyTransform(r), e.buildPath = r.buildPath, e.applyTransform = e.applyTransform, e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel, e;
}
var E7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return r;
}(), Ka = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new E7();
  }, t.prototype.buildPath = function(e, n) {
    e.moveTo(n.cx + n.r, n.cy), e.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
}(ne);
Ka.prototype.type = "circle";
var C7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return r;
}(), nm = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new C7();
  }, t.prototype.buildPath = function(e, n) {
    var i = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
    e.moveTo(a - s, o), e.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), e.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), e.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), e.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), e.closePath();
  }, t;
}(ne);
nm.prototype.type = "ellipse";
var hN = Math.PI, Zy = hN * 2, xs = Math.sin, au = Math.cos, D7 = Math.acos, Zr = Math.atan2, BA = Math.abs, Yf = Math.sqrt, Lf = Math.max, Pi = Math.min, fi = 1e-4;
function L7(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = f * l - c * u;
  if (!(h * h < fi))
    return h = (c * (t - a) - f * (r - i)) / h, [r + h * l, t + h * u];
}
function zd(r, t, e, n, i, a, o) {
  var s = r - e, l = t - n, u = (o ? a : -a) / Yf(s * s + l * l), c = u * l, f = -u * s, h = r + c, d = t + f, p = e + c, g = n + f, v = (h + p) / 2, m = (d + g) / 2, y = p - h, _ = g - d, x = y * y + _ * _, b = i - a, S = h * g - p * d, w = (_ < 0 ? -1 : 1) * Yf(Lf(0, b * b * x - S * S)), A = (S * _ - y * w) / x, T = (-S * y - _ * w) / x, M = (S * _ + y * w) / x, C = (-S * y + _ * w) / x, R = A - v, E = T - m, D = M - v, I = C - m;
  return R * R + E * E > D * D + I * I && (A = M, T = C), {
    cx: A,
    cy: T,
    x0: -c,
    y0: -f,
    x1: A * (i / b - 1),
    y1: T * (i / b - 1)
  };
}
function R7(r) {
  var t;
  if (et(r)) {
    var e = r.length;
    if (!e)
      return r;
    e === 1 ? t = [r[0], r[0], 0, 0] : e === 2 ? t = [r[0], r[0], r[1], r[1]] : e === 3 ? t = r.concat(r[2]) : t = r;
  } else
    t = [r, r, r, r];
  return t;
}
function I7(r, t) {
  var e, n = Lf(t.r, 0), i = Lf(t.r0 || 0, 0), a = n > 0, o = i > 0;
  if (!(!a && !o)) {
    if (a || (n = i, i = 0), i > n) {
      var s = n;
      n = i, i = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, f = t.cy, h = !!t.clockwise, d = BA(u - l), p = d > Zy && d % Zy;
      if (p > fi && (d = p), !(n > fi))
        r.moveTo(c, f);
      else if (d > Zy - fi)
        r.moveTo(c + n * au(l), f + n * xs(l)), r.arc(c, f, n, l, u, !h), i > fi && (r.moveTo(c + i * au(u), f + i * xs(u)), r.arc(c, f, i, u, l, h));
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0, w = void 0, A = void 0, T = void 0, M = void 0, C = void 0, R = void 0, E = void 0, D = void 0, I = n * au(l), P = n * xs(l), O = i * au(u), N = i * xs(u), B = d > fi;
        if (B) {
          var F = t.cornerRadius;
          F && (e = R7(F), g = e[0], v = e[1], m = e[2], y = e[3]);
          var G = BA(n - i) / 2;
          if (_ = Pi(G, m), x = Pi(G, y), b = Pi(G, g), S = Pi(G, v), T = w = Lf(_, x), M = A = Lf(b, S), (w > fi || A > fi) && (C = n * au(u), R = n * xs(u), E = i * au(l), D = i * xs(l), d < hN)) {
            var W = L7(I, P, E, D, C, R, O, N);
            if (W) {
              var J = I - W[0], U = P - W[1], Y = C - W[0], at = R - W[1], st = 1 / xs(D7((J * Y + U * at) / (Yf(J * J + U * U) * Yf(Y * Y + at * at))) / 2), ut = Yf(W[0] * W[0] + W[1] * W[1]);
              T = Pi(w, (n - ut) / (st + 1)), M = Pi(A, (i - ut) / (st - 1));
            }
          }
        }
        if (!B)
          r.moveTo(c + I, f + P);
        else if (T > fi) {
          var lt = Pi(m, T), H = Pi(y, T), ct = zd(E, D, I, P, n, lt, h), ot = zd(C, R, O, N, n, H, h);
          r.moveTo(c + ct.cx + ct.x0, f + ct.cy + ct.y0), T < w && lt === H ? r.arc(c + ct.cx, f + ct.cy, T, Zr(ct.y0, ct.x0), Zr(ot.y0, ot.x0), !h) : (lt > 0 && r.arc(c + ct.cx, f + ct.cy, lt, Zr(ct.y0, ct.x0), Zr(ct.y1, ct.x1), !h), r.arc(c, f, n, Zr(ct.cy + ct.y1, ct.cx + ct.x1), Zr(ot.cy + ot.y1, ot.cx + ot.x1), !h), H > 0 && r.arc(c + ot.cx, f + ot.cy, H, Zr(ot.y1, ot.x1), Zr(ot.y0, ot.x0), !h));
        } else
          r.moveTo(c + I, f + P), r.arc(c, f, n, l, u, !h);
        if (!(i > fi) || !B)
          r.lineTo(c + O, f + N);
        else if (M > fi) {
          var lt = Pi(g, M), H = Pi(v, M), ct = zd(O, N, C, R, i, -H, h), ot = zd(I, P, E, D, i, -lt, h);
          r.lineTo(c + ct.cx + ct.x0, f + ct.cy + ct.y0), M < A && lt === H ? r.arc(c + ct.cx, f + ct.cy, M, Zr(ct.y0, ct.x0), Zr(ot.y0, ot.x0), !h) : (H > 0 && r.arc(c + ct.cx, f + ct.cy, H, Zr(ct.y0, ct.x0), Zr(ct.y1, ct.x1), !h), r.arc(c, f, i, Zr(ct.cy + ct.y1, ct.cx + ct.x1), Zr(ot.cy + ot.y1, ot.cx + ot.x1), h), lt > 0 && r.arc(c + ot.cx, f + ot.cy, lt, Zr(ot.y1, ot.x1), Zr(ot.y0, ot.x0), !h));
        } else
          r.lineTo(c + O, f + N), r.arc(c, f, i, u, l, h);
      }
      r.closePath();
    }
  }
}
var P7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return r;
}(), jr = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new P7();
  }, t.prototype.buildPath = function(e, n) {
    I7(e, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
}(ne);
jr.prototype.type = "sector";
var N7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return r;
}(), kh = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new N7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.cx, a = n.cy, o = Math.PI * 2;
    e.moveTo(i + n.r, a), e.arc(i, a, n.r, 0, o, !1), e.moveTo(i + n.r0, a), e.arc(i, a, n.r0, 0, o, !0);
  }, t;
}(ne);
kh.prototype.type = "ring";
function O7(r, t, e, n) {
  var i = [], a = [], o = [], s = [], l, u, c, f;
  if (n) {
    c = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
    for (var h = 0, d = r.length; h < d; h++)
      bo(c, c, r[h]), wo(f, f, r[h]);
    bo(c, c, n[0]), wo(f, f, n[1]);
  }
  for (var h = 0, d = r.length; h < d; h++) {
    var p = r[h];
    if (e)
      l = r[h ? h - 1 : d - 1], u = r[(h + 1) % d];
    else if (h === 0 || h === d - 1) {
      i.push(Pa(r[h]));
      continue;
    } else
      l = r[h - 1], u = r[h + 1];
    qs(a, u, l), Hp(a, a, t);
    var g = Q_(p, l), v = Q_(p, u), m = g + v;
    m !== 0 && (g /= m, v /= m), Hp(o, a, -g), Hp(s, a, v);
    var y = wT([], p, o), _ = wT([], p, s);
    n && (wo(y, y, c), bo(y, y, f), wo(_, _, c), bo(_, _, f)), i.push(y), i.push(_);
  }
  return e && i.push(i.shift()), i;
}
function dN(r, t, e) {
  var n = t.smooth, i = t.points;
  if (i && i.length >= 2) {
    if (n) {
      var a = O7(i, n, e, t.smoothConstraint);
      r.moveTo(i[0][0], i[0][1]);
      for (var o = i.length, s = 0; s < (e ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = i[(s + 1) % o];
        r.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      r.moveTo(i[0][0], i[0][1]);
      for (var s = 1, f = i.length; s < f; s++)
        r.lineTo(i[s][0], i[s][1]);
    }
    e && r.closePath();
  }
}
var k7 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), Jr = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new k7();
  }, t.prototype.buildPath = function(e, n) {
    dN(e, n, !0);
  }, t;
}(ne);
Jr.prototype.type = "polygon";
var B7 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), Gr = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new B7();
  }, t.prototype.buildPath = function(e, n) {
    dN(e, n, !1);
  }, t;
}(ne);
Gr.prototype.type = "polyline";
var V7 = {}, F7 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return r;
}(), lr = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new F7();
  }, t.prototype.buildPath = function(e, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = tm(V7, n, this.style);
      i = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      i = n.x1, a = n.y1, o = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (e.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), e.lineTo(o, s));
  }, t.prototype.pointAt = function(e) {
    var n = this.shape;
    return [
      n.x1 * (1 - e) + n.x2 * e,
      n.y1 * (1 - e) + n.y2 * e
    ];
  }, t;
}(ne);
lr.prototype.type = "line";
var gn = [], z7 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return r;
}();
function VA(r, t, e) {
  var n = r.cpx2, i = r.cpy2;
  return n != null || i != null ? [
    (e ? kT : wr)(r.x1, r.cpx1, r.cpx2, r.x2, t),
    (e ? kT : wr)(r.y1, r.cpy1, r.cpy2, r.y2, t)
  ] : [
    (e ? ox : Pr)(r.x1, r.cpx1, r.x2, t),
    (e ? ox : Pr)(r.y1, r.cpy1, r.y2, t)
  ];
}
var Bh = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new z7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, f = n.cpy2, h = n.percent;
    h !== 0 && (e.moveTo(i, a), c == null || f == null ? (h < 1 && (rh(i, l, o, h, gn), l = gn[1], o = gn[2], rh(a, u, s, h, gn), u = gn[1], s = gn[2]), e.quadraticCurveTo(l, u, o, s)) : (h < 1 && (Uo(i, l, c, o, h, gn), l = gn[1], c = gn[2], o = gn[3], Uo(a, u, f, s, h, gn), u = gn[1], f = gn[2], s = gn[3]), e.bezierCurveTo(l, u, c, f, o, s)));
  }, t.prototype.pointAt = function(e) {
    return VA(this.shape, e, !1);
  }, t.prototype.tangentAt = function(e) {
    var n = VA(this.shape, e, !0);
    return xc(n, n);
  }, t;
}(ne);
Bh.prototype.type = "bezier-curve";
var U7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return r;
}(), im = function(r) {
  Ue(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new U7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), f = Math.sin(s);
    e.moveTo(c * o + i, f * o + a), e.arc(i, a, o, s, l, !u);
  }, t;
}(ne);
im.prototype.type = "arc";
var am = function(r) {
  Ue(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.type = "compound", e;
  }
  return t.prototype._updatePathDirty = function() {
    for (var e = this.shape.paths, n = this.shapeChanged(), i = 0; i < e.length; i++)
      n = n || e[i].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var e = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < e.length; i++)
      e[i].path || e[i].createPathProxy(), e[i].path.setScale(n[0], n[1], e[i].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(e, n) {
    for (var i = n.paths || [], a = 0; a < i.length; a++)
      i[a].buildPath(e, i[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var e = this.shape.paths || [], n = 0; n < e.length; n++)
      e[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), ne.prototype.getBoundingRect.call(this);
  }, t;
}(ne), pN = function() {
  function r(t) {
    this.colorStops = t || [];
  }
  return r.prototype.addColorStop = function(t, e) {
    this.colorStops.push({
      offset: t,
      color: e
    });
  }, r;
}(), Mc = function(r) {
  Ue(t, r);
  function t(e, n, i, a, o, s) {
    var l = r.call(this, o) || this;
    return l.x = e ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
}(pN), vN = function(r) {
  Ue(t, r);
  function t(e, n, i, a, o) {
    var s = r.call(this, a) || this;
    return s.x = e ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return t;
}(pN), qy = Math.min, G7 = Math.max, Ud = Math.abs, Ss = [0, 0], bs = [0, 0], Rr = nP(), Gd = Rr.minTv, Hd = Rr.maxTv, gN = function() {
  function r(t, e) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Ot();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Ot();
    t && this.fromBoundingRect(t, e);
  }
  return r.prototype.fromBoundingRect = function(t, e) {
    var n = this._corners, i = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
    if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), e)
      for (var u = 0; u < 4; u++)
        n[u].transform(e);
    Ot.sub(i[0], n[1], n[0]), Ot.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(n[0]);
  }, r.prototype.intersect = function(t, e, n) {
    var i = !0, a = !e;
    return e && Ot.set(e, 0, 0), Rr.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (i = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (i = !1, a) || !a && !Rr.negativeSize && Ot.copy(e, i ? Rr.useDir ? Rr.dirMinTv : Gd : Hd), i;
  }, r.prototype._intersectCheckOneSide = function(t, e, n, i) {
    for (var a = !0, o = 0; o < 2; o++) {
      var s = t._axes[o];
      if (t._getProjMinMaxOnAxis(o, t._corners, Ss), t._getProjMinMaxOnAxis(o, e._corners, bs), Rr.negativeSize || Ss[1] < bs[0] || Ss[0] > bs[1]) {
        if (a = !1, Rr.negativeSize || n)
          return a;
        var l = Ud(bs[0] - Ss[1]), u = Ud(Ss[0] - bs[1]);
        qy(l, u) > Hd.len() && (l < u ? Ot.scale(Hd, s, -l * i) : Ot.scale(Hd, s, u * i));
      } else if (!n) {
        var l = Ud(bs[0] - Ss[1]), u = Ud(Ss[0] - bs[1]);
        (Rr.useDir || qy(l, u) < Gd.len()) && ((l < u || !Rr.bidirectional) && (Ot.scale(Gd, s, l * i), Rr.useDir && Rr.calcDirMTV()), (l >= u || !Rr.bidirectional) && (Ot.scale(Gd, s, -u * i), Rr.useDir && Rr.calcDirMTV()));
      }
    }
    return a;
  }, r.prototype._getProjMinMaxOnAxis = function(t, e, n) {
    for (var i = this._axes[t], a = this._origin, o = e[0].dot(i) + a[t], s = o, l = o, u = 1; u < e.length; u++) {
      var c = e[u].dot(i) + a[t];
      s = qy(c, s), l = G7(c, l);
    }
    n[0] = s + Rr.touchThreshold, n[1] = l - Rr.touchThreshold, Rr.negativeSize = n[1] < n[0];
  }, r;
}(), H7 = [], W7 = function(r) {
  Ue(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.notClear = !0, e.incremental = !0, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e;
  }
  return t.prototype.traverse = function(e, n) {
    e.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(e, n) {
    n ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw();
  }, t.prototype.addDisplayables = function(e, n) {
    n = n || !1;
    for (var i = 0; i < e.length; i++)
      this.addDisplayable(e[i], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(e) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      e && e(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      e && e(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var e = this._cursor; e < this._displayables.length; e++) {
      var n = this._displayables[e];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var e = 0; e < this._temporaryDisplayables.length; e++) {
      var n = this._temporaryDisplayables[e];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var e = new Vt(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var i = this._displayables[n], a = i.getBoundingRect().clone();
        i.needLocalTransform() && a.applyTransform(i.getLocalTransform(H7)), e.union(a);
      }
      this._rect = e;
    }
    return this._rect;
  }, t.prototype.contain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
    if (a.contain(i[0], i[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(e, n))
          return !0;
      }
    return !1;
  }, t;
}(ai), mN = ee();
function Tc(r, t, e, n, i) {
  var a;
  if (t && t.ecModel) {
    var o = t.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = t && t.isAnimationEnabled(), l = r === "update";
  if (s) {
    var u = void 0, c = void 0, f = void 0;
    n ? (u = bt(n.duration, 200), c = bt(n.easing, "cubicOut"), f = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), f = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (f = a.delay)), At(f) && (f = f(e, i)), At(u) && (u = u(e));
    var h = {
      duration: u || 0,
      delay: f,
      easing: c
    };
    return h;
  } else
    return null;
}
function H1(r, t, e, n, i, a, o) {
  var s = !1, l;
  At(i) ? (o = a, a = i, i = null) : Lt(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = r === "leave";
  u || t.stopAnimation("leave");
  var c = Tc(r, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, i) : null);
  if (c && c.duration > 0) {
    var f = c.duration, h = c.delay, d = c.easing, p = {
      duration: f,
      delay: h || 0,
      easing: d,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: r,
      during: o
    };
    s ? t.animateFrom(e, p) : t.animateTo(e, p);
  } else
    t.stopAnimation(), !s && t.attr(e), o && o(1), a && a();
}
function ve(r, t, e, n, i, a) {
  H1("update", r, t, e, n, i, a);
}
function ze(r, t, e, n, i, a) {
  H1("enter", r, t, e, n, i, a);
}
function Yu(r) {
  if (!r.__zr)
    return !0;
  for (var t = 0; t < r.animators.length; t++) {
    var e = r.animators[t];
    if (e.scope === "leave")
      return !0;
  }
  return !1;
}
function Ho(r, t, e, n, i, a) {
  Yu(r) || H1("leave", r, t, e, n, i, a);
}
function FA(r, t, e, n) {
  r.removeTextContent(), r.removeTextGuideLine(), Ho(r, {
    style: {
      opacity: 0
    }
  }, t, e, n);
}
function Na(r, t, e) {
  function n() {
    r.parent && r.parent.remove(r);
  }
  r.isGroup ? r.traverse(function(i) {
    i.isGroup || FA(i, t, e, n);
  }) : FA(r, t, e, n);
}
function oi(r) {
  mN(r).oldStyle = r.style;
}
function X7(r) {
  return mN(r).oldStyle;
}
var Ox = {}, Wt = ["x", "y"], cr = ["width", "height"];
function Y7(r) {
  return ne.extend(r);
}
var $7 = T7;
function Z7(r, t) {
  return $7(r, t);
}
function Ti(r, t) {
  Ox[r] = t;
}
function Ov(r) {
  if (Ox.hasOwnProperty(r))
    return Ox[r];
}
function sh(r, t, e, n) {
  var i = fN(r, t);
  return e && (n === "center" && (e = _N(e, i.getBoundingRect())), xN(i, e)), i;
}
function yN(r, t, e) {
  var n = new Fr({
    style: {
      image: r,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(i) {
      if (e === "center") {
        var a = {
          width: i.width,
          height: i.height
        };
        n.setStyle(_N(t, a));
      }
    }
  });
  return n;
}
function _N(r, t) {
  var e = t.width / t.height, n = r.height * e, i;
  n <= r.width ? i = r.height : (n = r.width, i = n / e);
  var a = r.x + r.width / 2, o = r.y + r.height / 2;
  return {
    x: a - n / 2,
    y: o - i / 2,
    width: n,
    height: i
  };
}
var Qn = A7;
function xN(r, t) {
  if (r.applyTransform) {
    var e = r.getBoundingRect(), n = e.calculateTransform(t);
    r.applyTransform(n);
  }
}
function ic(r, t) {
  return tm(r, r, {
    lineWidth: t
  }), r;
}
function q7(r, t) {
  return qP(r, r, t), r;
}
var Kp = On;
function sl(r, t) {
  for (var e = Gg([]); r && r !== t; )
    Ji(e, r.getLocalTransform(), e), r = r.parent;
  return e;
}
function _i(r, t, e) {
  return t && !Kr(t) && (t = La.getLocalTransform(t)), e && (t = bi([], t)), nr([], r, t);
}
function om(r, t, e) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Yi(2 * t[4] / t[0]), i = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Yi(2 * t[4] / t[2]), a = [r === "left" ? -n : r === "right" ? n : 0, r === "top" ? -i : r === "bottom" ? i : 0];
  return a = _i(a, t, e), Yi(a[0]) > Yi(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function zA(r) {
  return !r.isGroup;
}
function K7(r) {
  return r.shape != null;
}
function Vh(r, t, e) {
  if (!r || !t)
    return;
  function n(o) {
    var s = {};
    return o.traverse(function(l) {
      zA(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return K7(o) && (s.shape = Dt(o.shape)), s;
  }
  var a = n(r);
  t.traverse(function(o) {
    if (zA(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = i(o);
        o.attr(i(s)), ve(o, l, e, zt(o).dataIndex);
      }
    }
  });
}
function SN(r, t) {
  return rt(r, function(e) {
    var n = e[0];
    n = er(n, t.x), n = Bn(n, t.x + t.width);
    var i = e[1];
    return i = er(i, t.y), i = Bn(i, t.y + t.height), [n, i];
  });
}
function j7(r, t) {
  var e = er(r.x, t.x), n = Bn(r.x + r.width, t.x + t.width), i = er(r.y, t.y), a = Bn(r.y + r.height, t.y + t.height);
  if (n >= e && a >= i)
    return {
      x: e,
      y: i,
      width: n - e,
      height: a - i
    };
}
function Fh(r, t, e) {
  var n = j({
    rectHover: !0
  }, t), i = n.style = {
    strokeNoScale: !0
  };
  if (e = e || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, r)
    return r.indexOf("image://") === 0 ? (i.image = r.slice(8), Bt(i, e), new Fr(n)) : sh(r.replace("path://", ""), n, e, "center");
}
function Rf(r, t, e, n, i) {
  for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
    var s = i[a];
    if (bN(r, t, e, n, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function bN(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = Ky(c, f, l, u);
  if (J7(h))
    return !1;
  var d = r - i, p = t - a, g = Ky(d, p, l, u) / h;
  if (g < 0 || g > 1)
    return !1;
  var v = Ky(d, p, c, f) / h;
  return !(v < 0 || v > 1);
}
function Ky(r, t, e, n) {
  return r * n - e * t;
}
function J7(r) {
  return r <= 1e-6 && r >= -1e-6;
}
function ml(r, t, e, n, i) {
  return t == null || (fe(t) ? Xe[0] = Xe[1] = Xe[2] = Xe[3] = t : (process.env.NODE_ENV !== "production" && St(t.length === 4), Xe[0] = t[0], Xe[1] = t[1], Xe[2] = t[2], Xe[3] = t[3]), n && (Xe[0] = er(0, Xe[0]), Xe[1] = er(0, Xe[1]), Xe[2] = er(0, Xe[2]), Xe[3] = er(0, Xe[3])), e && (Xe[0] = -Xe[0], Xe[1] = -Xe[1], Xe[2] = -Xe[2], Xe[3] = -Xe[3]), UA(r, Xe, "x", "width", 3, 1, i && i[0] || 0), UA(r, Xe, "y", "height", 0, 2, i && i[1] || 0)), r;
}
var Xe = [0, 0, 0, 0];
function UA(r, t, e, n, i, a, o) {
  var s = t[a] + t[i], l = r[n];
  r[n] += s, o = er(0, Bn(o, l)), r[n] < o ? (r[n] = o, r[e] += t[i] >= 0 ? -t[i] : t[a] >= 0 ? l + t[a] : Yi(s) > 1e-8 ? (l - o) * t[i] / s : 0) : r[e] -= t[i];
}
function ja(r) {
  var t = r.itemTooltipOption, e = r.componentModel, n = r.itemName, i = pt(t) ? {
    formatter: t
  } : t, a = e.mainType, o = e.componentIndex, s = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = r.formatterParamsExtra;
  l && L(se(l), function(c) {
    _t(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = zt(r.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: n,
    option: Bt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: s
    }, i)
  };
}
function kx(r, t) {
  var e;
  r.isGroup && (e = t(r)), e || r.traverse(t);
}
function jo(r, t) {
  if (r)
    if (et(r))
      for (var e = 0; e < r.length; e++)
        kx(r[e], t);
    else
      kx(r, t);
}
function W1(r) {
  return !r || Yi(r[1]) < Wd && Yi(r[2]) < Wd || Yi(r[0]) < Wd && Yi(r[3]) < Wd;
}
var Wd = 1e-5;
function lh(r, t) {
  return r ? Vt.copy(r, t) : t.clone();
}
function X1(r, t) {
  return t ? Hg(r || Br(), t) : void 0;
}
function yl(r) {
  return {
    z: r.get("z") || 0,
    zlevel: r.get("zlevel") || 0
  };
}
function wN(r) {
  var t = -1 / 0, e = 1 / 0;
  kx(r, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var o = a.currentStates;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          i(a.states[o[s]]);
      i(a);
    }
  }
  function i(a) {
    if (a) {
      var o = a.z2;
      o > t && (t = o), o < e && (e = o);
    }
  }
  return e > t && (e = t = 0), {
    min: e,
    max: t
  };
}
function sm(r, t, e) {
  MN(r, t, e, -1 / 0);
}
function MN(r, t, e, n) {
  if (r.ignoreModelZ)
    return n;
  var i = r.getTextContent(), a = r.getTextGuideLine(), o = r.isGroup;
  if (o)
    for (var s = r.childrenRef(), l = 0; l < s.length; l++)
      n = er(MN(s[l], t, e, n), n);
  else
    r.z = t, r.zlevel = e, n = er(r.z2 || 0, n);
  if (i && (i.z = t, i.zlevel = e, isFinite(n) && (i.z2 = n + 2)), a) {
    var u = r.textGuideLineConfig;
    a.z = t, a.zlevel = e, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
Ti("circle", Ka);
Ti("ellipse", nm);
Ti("sector", jr);
Ti("ring", kh);
Ti("polygon", Jr);
Ti("polyline", Gr);
Ti("rect", te);
Ti("line", lr);
Ti("bezierCurve", Bh);
Ti("arc", im);
const El = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: im,
  BezierCurve: Bh,
  BoundingRect: Vt,
  Circle: Ka,
  CompoundPath: am,
  Ellipse: nm,
  Group: Ct,
  Image: Fr,
  IncrementalDisplayable: W7,
  Line: lr,
  LinearGradient: Mc,
  OrientedBoundingRect: gN,
  Path: ne,
  Point: Ot,
  Polygon: Jr,
  Polyline: Gr,
  RadialGradient: vN,
  Rect: te,
  Ring: kh,
  Sector: jr,
  Text: pe,
  WH: cr,
  XY: Wt,
  applyTransform: _i,
  calcZ2Range: wN,
  clipPointsByRect: SN,
  clipRectByRect: j7,
  createIcon: Fh,
  ensureCopyRect: lh,
  ensureCopyTransform: X1,
  expandOrShrinkRect: ml,
  extendPath: Z7,
  extendShape: Y7,
  getShapeClass: Ov,
  getTransform: sl,
  groupTransition: Vh,
  initProps: ze,
  isBoundingRectAxisAligned: W1,
  isElementRemoved: Yu,
  lineLineIntersect: bN,
  linePolygonIntersect: Rf,
  makeImage: yN,
  makePath: sh,
  mergePath: Qn,
  registerShape: Ti,
  removeElement: Ho,
  removeElementWithFadeOut: Na,
  resizePath: xN,
  retrieveZInfo: yl,
  setTooltipConfig: ja,
  subPixelOptimize: Kp,
  subPixelOptimizeLine: ic,
  subPixelOptimizeRect: q7,
  transformDirection: om,
  traverseElements: jo,
  traverseUpdateZ: sm,
  updateProps: ve
}, Symbol.toStringTag, { value: "Module" }));
var lm = {};
function TN(r, t) {
  for (var e = 0; e < pn.length; e++) {
    var n = pn[e], i = t[n], a = r.ensureState(n);
    a.style = a.style || {}, a.style.text = i;
  }
  var o = r.currentStates.slice();
  r.clearStates(!0), r.setStyle({
    text: t.normal
  }), r.useStates(o, !0);
}
function Bx(r, t, e) {
  var n = r.labelFetcher, i = r.labelDataIndex, a = r.labelDimIndex, o = t.normal, s;
  n && (s = n.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), e != null ? {
    interpolatedValue: e
  } : null)), s == null && (s = At(r.defaultText) ? r.defaultText(i, r, e) : r.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < pn.length; u++) {
    var c = pn[u], f = t[c];
    l[c] = bt(n ? n.getFormattedLabel(i, c, null, a, f && f.get("formatter")) : null, s);
  }
  return l;
}
function Cr(r, t, e, n) {
  e = e || lm;
  for (var i = r instanceof pe, a = !1, o = 0; o < oh.length; o++) {
    var s = t[oh[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = i ? r : r.getTextContent();
  if (a) {
    i || (l || (l = new pe(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
    var u = Bx(e, t), c = t.normal, f = !!c.getShallow("show"), h = Oe(c, n && n.normal, e, !1, !i);
    h.text = u.normal, i || r.setTextConfig(kv(c, e, !1));
    for (var o = 0; o < pn.length; o++) {
      var d = pn[o], s = t[d];
      if (s) {
        var p = l.ensureState(d), g = !!bt(s.getShallow("show"), f);
        if (g !== f && (p.ignore = !g), p.style = Oe(s, n && n[d], e, !0, !i), p.style.text = u[d], !i) {
          var v = r.ensureState(d);
          v.textConfig = kv(s, e, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (h.x = l.style.x), l.style.y != null && (h.y = l.style.y), l.ignore = !f, l.useStyle(h), l.dirty(), e.enableTextSetter && (Ac(l).setLabelText = function(m) {
      var y = Bx(e, t, m);
      TN(l, y);
    });
  } else
    l && (l.ignore = !0);
  r.dirty();
}
function xr(r, t) {
  t = t || "label";
  for (var e = {
    normal: r.getModel(t)
  }, n = 0; n < pn.length; n++) {
    var i = pn[n];
    e[i] = r.getModel([i, t]);
  }
  return e;
}
function Oe(r, t, e, n, i) {
  var a = {};
  return Q7(a, r, e, n, i), t && j(a, t), a;
}
function kv(r, t, e) {
  t = t || {};
  var n = {}, i, a = r.getShallow("rotate"), o = bt(r.getShallow("distance"), e ? null : 5), s = r.getShallow("offset");
  return i = r.getShallow("position") || (e ? null : "inside"), i === "outside" && (i = t.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = r.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function Q7(r, t, e, n, i) {
  e = e || lm;
  var a = t.ecModel, o = a && a.option.textStyle, s = t9(t), l;
  if (s) {
    l = {};
    var u = "richInheritPlainLabel", c = bt(t.get(u), a ? a.get(u) : void 0);
    for (var f in s)
      if (s.hasOwnProperty(f)) {
        var h = t.getModel(["rich", f]);
        XA(l[f] = {}, h, o, t, c, e, n, i, !1, !0);
      }
  }
  l && (r.rich = l);
  var d = t.get("overflow");
  d && (r.overflow = d);
  var p = t.get("lineOverflow");
  p && (r.lineOverflow = p);
  var g = r, v = t.get("minMargin");
  if (v != null)
    v = fe(v) ? v / 2 : 0, g.margin = [v, v, v, v], g.__marginType = Bu.minMargin;
  else {
    var m = t.get("textMargin");
    m != null && (g.margin = zg(m), g.__marginType = Bu.textMargin);
  }
  XA(r, t, o, null, null, e, n, i, !0, !1);
}
function t9(r) {
  for (var t; r && r !== r.ecModel; ) {
    var e = (r.option || lm).rich;
    if (e) {
      t = t || {};
      for (var n = se(e), i = 0; i < n.length; i++) {
        var a = n[i];
        t[a] = 1;
      }
    }
    r = r.parentModel;
  }
  return t;
}
var GA = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], HA = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], WA = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function XA(r, t, e, n, i, a, o, s, l, u) {
  e = !o && e || lm;
  var c = a && a.inheritColor, f = t.getShallow("color"), h = t.getShallow("textBorderColor"), d = bt(t.getShallow("opacity"), e.opacity);
  (f === "inherit" || f === "auto") && (process.env.NODE_ENV !== "production" && f === "auto" && or("color: 'auto'", "color: 'inherit'"), c ? f = c : f = null), (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && or("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), s || (f = f || e.color, h = h || e.textBorderColor), f != null && (r.fill = f), h != null && (r.stroke = h);
  var p = bt(t.getShallow("textBorderWidth"), e.textBorderWidth);
  p != null && (r.lineWidth = p);
  var g = bt(t.getShallow("textBorderType"), e.textBorderType);
  g != null && (r.lineDash = g);
  var v = bt(t.getShallow("textBorderDashOffset"), e.textBorderDashOffset);
  v != null && (r.lineDashOffset = v), !o && d == null && !u && (d = a && a.defaultOpacity), d != null && (r.opacity = d), !o && !s && r.fill == null && a.inheritColor && (r.fill = a.inheritColor);
  for (var m = 0; m < GA.length; m++) {
    var y = GA[m], _ = i !== !1 && n ? un(t.getShallow(y), n.getShallow(y), e[y]) : bt(t.getShallow(y), e[y]);
    _ != null && (r[y] = _);
  }
  for (var m = 0; m < HA.length; m++) {
    var y = HA[m], _ = t.getShallow(y);
    _ != null && (r[y] = _);
  }
  if (r.verticalAlign == null) {
    var x = t.getShallow("baseline");
    x != null && (r.verticalAlign = x);
  }
  if (!l || !a.disableBox) {
    for (var m = 0; m < WA.length; m++) {
      var y = WA[m], _ = t.getShallow(y);
      _ != null && (r[y] = _);
    }
    var b = t.getShallow("borderType");
    b != null && (r.borderDash = b), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && r.backgroundColor === "auto" && or("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), r.backgroundColor = c), (r.borderColor === "auto" || r.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && r.borderColor === "auto" && or("borderColor: 'auto'", "borderColor: 'inherit'"), r.borderColor = c);
  }
}
function Y1(r, t) {
  var e = t && t.getModel("textStyle");
  return ei([
    // FIXME in node-canvas fontWeight is before fontStyle
    r.fontStyle || e && e.getShallow("fontStyle") || "",
    r.fontWeight || e && e.getShallow("fontWeight") || "",
    (r.fontSize || e && e.getShallow("fontSize") || 12) + "px",
    r.fontFamily || e && e.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Ac = ee();
function AN(r, t, e, n) {
  if (r) {
    var i = Ac(r);
    i.prevValue = i.value, i.value = e;
    var a = t.normal;
    i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = n, i.statesModels = t);
  }
}
function EN(r, t, e, n, i) {
  var a = Ac(r);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = bt(a.interpolatedValue, a.prevValue), l = a.value;
  function u(c) {
    var f = zP(e, a.precision, s, l, c);
    a.interpolatedValue = c === 1 ? null : f;
    var h = Bx({
      labelDataIndex: t,
      labelFetcher: i,
      defaultText: o ? o(f) : f + ""
    }, a.statesModels, f);
    TN(r, h);
  }
  r.percent = 0, (a.prevValue == null ? ze : ve)(r, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, n, t, null, u);
}
var Bu = {
  minMargin: 1,
  textMargin: 2
}, e9 = ["textStyle", "color"], jy = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Jy = new pe(), r9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getTextColor = function(t) {
      var e = this.ecModel;
      return this.getShallow("color") || (!t && e ? e.get(e9) : null);
    }, r.prototype.getFont = function() {
      return Y1({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(t) {
      for (var e = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < jy.length; n++)
        e[jy[n]] = this.getShallow(jy[n]);
      return Jy.useStyle(e), Jy.update(), Jy.getBoundingRect();
    }, r;
  }()
), CN = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], n9 = vl(CN), i9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(t) {
      return n9(this, t);
    }, r;
  }()
), DN = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], a9 = vl(DN), o9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(t, e) {
      return a9(this, t, e);
    }, r;
  }()
), ue = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.parentModel = e, this.ecModel = n, this.option = t;
    }
    return r.prototype.init = function(t, e, n) {
    }, r.prototype.mergeOption = function(t, e) {
      qt(this.option, t, !0);
    }, r.prototype.get = function(t, e) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel);
    }, r.prototype.getShallow = function(t, e) {
      var n = this.option, i = n == null ? n : n[t];
      if (i == null && !e) {
        var a = this.parentModel;
        a && (i = a.getShallow(t));
      }
      return i;
    }, r.prototype.getModel = function(t, e) {
      var n = t != null, i = n ? this.parsePath(t) : null, a = n ? this._doGet(i) : this.option;
      return e = e || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new r(a, e, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var t = this.constructor;
      return new t(Dt(this.option));
    }, r.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, r.prototype.resolveParentPath = function(t) {
      return t;
    }, r.prototype.isAnimationEnabled = function() {
      if (!oe.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(t, e) {
      var n = this.option;
      if (!t)
        return n;
      for (var i = 0; i < t.length && !(t[i] && (n = n && typeof n == "object" ? n[t[i]] : null, n == null)); i++)
        ;
      return n == null && e && (n = e._doGet(this.resolveParentPath(t), e.parentModel)), n;
    }, r;
  }()
);
P1(ue);
d6(ue);
dr(ue, i9);
dr(ue, o9);
dr(ue, y6);
dr(ue, r9);
var s9 = Math.round(Math.random() * 10);
function Ec(r) {
  return [r || "", s9++].join("_");
}
function l9(r) {
  var t = {};
  r.registerSubTypeDefaulter = function(e, n) {
    var i = Zi(e);
    t[i.main] = n;
  }, r.determineSubType = function(e, n) {
    var i = n.type;
    if (!i) {
      var a = Zi(e).main;
      r.hasSubTypes(e) && t[a] && (i = t[a](n));
    }
    return i;
  };
}
function u9(r, t) {
  r.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = e(o), c = u.graph, f = u.noEntryList, h = {};
    for (L(a, function(y) {
      h[y] = !0;
    }); f.length; ) {
      var d = f.pop(), p = c[d], g = !!h[d];
      g && (s.call(l, d, p.originalDeps.slice()), delete h[d]), L(p.successor, g ? m : v);
    }
    L(h, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = dn("Circular dependency may exists: ", h, a, o)), new Error(y);
    });
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && f.push(y);
    }
    function m(y) {
      h[y] = !0, v(y);
    }
  };
  function e(a) {
    var o = {}, s = [];
    return L(a, function(l) {
      var u = n(o, l), c = u.originalDeps = t(l), f = i(c, a);
      u.entryCount = f.length, u.entryCount === 0 && s.push(l), L(f, function(h) {
        Zt(u.predecessor, h) < 0 && u.predecessor.push(h);
        var d = n(o, h);
        Zt(d.successor, h) < 0 && d.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function n(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function i(a, o) {
    var s = [];
    return L(a, function(l) {
      Zt(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function Jo(r, t) {
  return qt(qt({}, r, !0), t, !0);
}
const c9 = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, f9 = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Bv = "ZH", $1 = "EN", $u = $1, jp = {}, Z1 = {}, LN = oe.domSupported ? function() {
  var r = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || $u).toUpperCase()
  );
  return r.indexOf(Bv) > -1 ? Bv : $u;
}() : $u;
function RN(r, t) {
  r = r.toUpperCase(), Z1[r] = new ue(t), jp[r] = t;
}
function h9(r) {
  if (pt(r)) {
    var t = jp[r.toUpperCase()] || {};
    return r === Bv || r === $1 ? Dt(t) : qt(Dt(t), Dt(jp[$u]), !1);
  } else
    return qt(Dt(r), Dt(jp[$u]), !1);
}
function Vx(r) {
  return Z1[r];
}
function d9() {
  return Z1[$u];
}
RN($1, c9);
RN(Bv, f9);
var Fx = null;
function p9(r) {
  Fx || (Fx = r);
}
function ur() {
  return Fx;
}
var q1 = 1e3, K1 = q1 * 60, $f = K1 * 60, ti = $f * 24, YA = ti * 365, v9 = {
  year: /({yyyy}|{yy})/,
  month: /({MMMM}|{MMM}|{MM}|{M})/,
  day: /({dd}|{d})/,
  hour: /({HH}|{H}|{hh}|{h})/,
  minute: /({mm}|{m})/,
  second: /({ss}|{s})/,
  millisecond: /({SSS}|{S})/
}, Jp = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}"
}, g9 = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}", Xd = "{yyyy}-{MM}-{dd}", $A = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: Xd,
  hour: Xd + " " + Jp.hour,
  minute: Xd + " " + Jp.minute,
  second: Xd + " " + Jp.second,
  millisecond: g9
}, Dn = ["year", "month", "day", "hour", "minute", "second", "millisecond"], m9 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function y9(r) {
  return !pt(r) && !At(r) ? _9(r) : r;
}
function _9(r) {
  r = r || {};
  var t = {}, e = !0;
  return L(Dn, function(n) {
    e && (e = r[n] == null);
  }), L(Dn, function(n, i) {
    var a = r[n];
    t[n] = {};
    for (var o = null, s = i; s >= 0; s--) {
      var l = Dn[s], u = Lt(a) && !et(a) ? a[l] : a, c = void 0;
      et(u) ? (c = u.slice(), o = c[0] || "") : pt(u) ? (o = u, c = [o]) : (o == null ? o = Jp[n] : v9[l].test(o) || (o = t[l][l][0] + " " + o), c = [o], e && (c[1] = "{primary|" + o + "}")), t[n][l] = c;
    }
  }), t;
}
function lo(r, t) {
  return r += "", "0000".substr(0, t - r.length) + r;
}
function Zf(r) {
  switch (r) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return r;
  }
}
function x9(r) {
  return r === Zf(r);
}
function S9(r) {
  switch (r) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function um(r, t, e, n) {
  var i = Al(r), a = i[IN(e)](), o = i[j1(e)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[J1(e)](), u = i["get" + (e ? "UTC" : "") + "Day"](), c = i[Q1(e)](), f = (c - 1) % 12 + 1, h = i[tb(e)](), d = i[eb(e)](), p = i[rb(e)](), g = c >= 12 ? "pm" : "am", v = g.toUpperCase(), m = n instanceof ue ? n : Vx(n || LN) || d9(), y = m.getModel("time"), _ = y.get("month"), x = y.get("monthAbbr"), b = y.get("dayOfWeek"), S = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, v + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, lo(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, _[o - 1]).replace(/{MMM}/g, x[o - 1]).replace(/{MM}/g, lo(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, lo(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, b[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, lo(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, lo(f + "", 2)).replace(/{h}/g, f + "").replace(/{mm}/g, lo(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, lo(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, lo(p, 3)).replace(/{S}/g, p + "");
}
function b9(r, t, e, n, i) {
  var a = null;
  if (pt(e))
    a = e;
  else if (At(e)) {
    var o = {
      time: r.time,
      level: r.time.level
    }, s = ur();
    s && s.makeAxisLabelFormatterParamBreak(o, r.break), a = e(r.value, t, o);
  } else {
    var l = r.time;
    if (l) {
      var u = e[l.lowerTimeUnit][l.upperTimeUnit];
      a = u[Math.min(l.level, u.length - 1)] || "";
    } else {
      var c = Vu(r.value, i);
      a = e[c][c][0];
    }
  }
  return um(new Date(r.value), a, i, n);
}
function Vu(r, t) {
  var e = Al(r), n = e[j1(t)]() + 1, i = e[J1(t)](), a = e[Q1(t)](), o = e[tb(t)](), s = e[eb(t)](), l = e[rb(t)](), u = l === 0, c = u && s === 0, f = c && o === 0, h = f && a === 0, d = h && i === 1, p = d && n === 1;
  return p ? "year" : d ? "month" : h ? "day" : f ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function zx(r, t, e) {
  switch (t) {
    case "year":
      r[PN(e)](0);
    case "month":
      r[NN(e)](1);
    case "day":
      r[ON(e)](0);
    case "hour":
      r[kN(e)](0);
    case "minute":
      r[BN(e)](0);
    case "second":
      r[VN(e)](0);
  }
  return r;
}
function IN(r) {
  return r ? "getUTCFullYear" : "getFullYear";
}
function j1(r) {
  return r ? "getUTCMonth" : "getMonth";
}
function J1(r) {
  return r ? "getUTCDate" : "getDate";
}
function Q1(r) {
  return r ? "getUTCHours" : "getHours";
}
function tb(r) {
  return r ? "getUTCMinutes" : "getMinutes";
}
function eb(r) {
  return r ? "getUTCSeconds" : "getSeconds";
}
function rb(r) {
  return r ? "getUTCMilliseconds" : "getMilliseconds";
}
function w9(r) {
  return r ? "setUTCFullYear" : "setFullYear";
}
function PN(r) {
  return r ? "setUTCMonth" : "setMonth";
}
function NN(r) {
  return r ? "setUTCDate" : "setDate";
}
function ON(r) {
  return r ? "setUTCHours" : "setHours";
}
function kN(r) {
  return r ? "setUTCMinutes" : "setMinutes";
}
function BN(r) {
  return r ? "setUTCSeconds" : "setSeconds";
}
function VN(r) {
  return r ? "setUTCMilliseconds" : "setMilliseconds";
}
function FN(r) {
  if (!L1(r))
    return pt(r) ? r : "-";
  var t = (r + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function zN(r, t) {
  return r = (r || "").toLowerCase().replace(/-(.)/g, function(e, n) {
    return n.toUpperCase();
  }), t && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
}
var zh = zg;
function Ux(r, t, e) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && ei(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = t === "time", s = r instanceof Date;
  if (o || s) {
    var l = o ? Al(r) : r;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return um(l, n, e);
  }
  if (t === "ordinal")
    return yv(r) ? i(r) : fe(r) && a(r) ? r + "" : "-";
  var u = Ha(r);
  return a(u) ? FN(u) : yv(r) ? i(r) : typeof r == "boolean" ? r + "" : "-";
}
var ZA = ["a", "b", "c", "d", "e", "f", "g"], Qy = function(r, t) {
  return "{" + r + (t ?? "") + "}";
};
function UN(r, t, e) {
  et(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var i = t[0].$vars || [], a = 0; a < i.length; a++) {
    var o = ZA[a];
    r = r.replace(Qy(o), Qy(o, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = t[s][i[l]];
      r = r.replace(Qy(ZA[l], s), e ? sn(u) : u);
    }
  return r;
}
function M9(r, t, e) {
  return L(t, function(n, i) {
    r = r.replace("{" + i + "}", n);
  }), r;
}
function T9(r, t) {
  var e = pt(r) ? {
    color: r,
    extraCssText: t
  } : r || {}, n = e.color, i = e.type;
  t = e.extraCssText;
  var a = e.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + sn(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + sn(n) + ";" + (t || "") + '"></span>';
  var o = e.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function _l(r, t) {
  return t = t || "transparent", pt(r) ? r : Lt(r) && r.colorStops && (r.colorStops[0] || {}).color || t;
}
function Vv(r, t) {
  if (t === "_blank" || t === "blank") {
    var e = window.open();
    e.opener = null, e.location.href = r;
  } else
    window.open(r, t);
}
var Qp = {}, t0 = {}, Cc = (
  /** @class */
  function() {
    function r() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return r.prototype.create = function(t, e) {
      this._nonSeriesBoxMasterList = n(Qp, !0), this._normalMasterList = n(t0, !1);
      function n(i, a) {
        var o = [];
        return L(i, function(s, l) {
          var u = s.create(t, e);
          o = o.concat(u || []), process.env.NODE_ENV !== "production" && a && L(u, function(c) {
            return St(!c.update);
          });
        }), o;
      }
    }, r.prototype.update = function(t, e) {
      L(this._normalMasterList, function(n) {
        n.update && n.update(t, e);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, r.register = function(t, e) {
      if (t === "matrix" || t === "calendar") {
        Qp[t] = e;
        return;
      }
      t0[t] = e;
    }, r.get = function(t) {
      return t0[t] || Qp[t];
    }, r;
  }()
);
function A9(r) {
  return !!Qp[r];
}
var Gx = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
};
function E9(r) {
  process.env.NODE_ENV !== "production" && St(!Hx.get(r.fullType)), Hx.set(r.fullType, {
    getCoord2: void 0
  }).getCoord2 = r.getCoord2;
}
var Hx = wt();
function C9(r) {
  var t = r.getShallow("coord", !0), e = Gx.coord;
  if (t == null) {
    var n = Hx.get(r.type);
    n && n.getCoord2 && (e = Gx.coord2, t = n.getCoord2(r));
  }
  return {
    coord: t,
    from: e
  };
}
var Gi = {
  none: 0,
  dataCoordSys: 1,
  boxCoordSys: 2
};
function GN(r, t) {
  var e = r.getShallow("coordinateSystem"), n = r.getShallow("coordinateSystemUsage", !0), i = n != null, a = Gi.none;
  if (e) {
    var o = r.mainType === "series";
    n == null && (n = o ? "data" : "box"), n === "data" ? (a = Gi.dataCoordSys, o || (process.env.NODE_ENV !== "production" && i && t && ce('coordinateSystemUsage "data" is not supported in non-series components.'), a = Gi.none)) : n === "box" && (a = Gi.boxCoordSys, !o && !A9(e) && (process.env.NODE_ENV !== "production" && i && t && ce('coordinateSystem "' + e + '" cannot be used' + (' as coordinateSystemUsage "box" for "' + r.type + '" yet.')), a = Gi.none));
  }
  return {
    coordSysType: e,
    kind: a
  };
}
function Uh(r) {
  var t = r.targetModel, e = r.coordSysType, n = r.coordSysProvider, i = r.isDefaultDataCoordSys, a = r.allowNotFound;
  process.env.NODE_ENV !== "production" && St(!!e);
  var o = GN(t, !0), s = o.kind, l = o.coordSysType;
  if (i && s !== Gi.dataCoordSys && (s = Gi.dataCoordSys, l = e), s === Gi.none || l !== e)
    return !1;
  var u = n(e, t);
  return u ? (s === Gi.dataCoordSys ? (process.env.NODE_ENV !== "production" && St(t.mainType === "series"), t.coordinateSystem = u) : t.boxCoordinateSystem = u, !0) : (process.env.NODE_ENV !== "production" && (a || ce(e + " cannot be found for" + (" " + t.type + " (index: " + t.componentIndex + ")."))), !1);
}
var HN = function(r, t) {
  var e = t.getReferringComponents(r, je).models[0];
  return e && e.coordinateSystem;
}, tv = L, WN = ["left", "right", "top", "bottom", "width", "height"], Js = [["width", "left", "right"], ["height", "top", "bottom"]];
function nb(r, t, e, n, i) {
  var a = 0, o = 0;
  n == null && (n = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), f = t.childAt(u + 1), h = f && f.getBoundingRect(), d, p;
    if (r === "horizontal") {
      var g = c.width + (h ? -h.x + c.x : 0);
      d = a + g, d > n || l.newline ? (a = 0, d = g, o += s + e, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (h ? -h.y + c.y : 0);
      p = o + v, p > i || l.newline ? (a += s + e, o = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = d + e : o = p + e);
  });
}
var ll = nb;
Yt(nb, "vertical");
Yt(nb, "horizontal");
function XN(r, t) {
  return {
    left: r.getShallow("left", t),
    top: r.getShallow("top", t),
    right: r.getShallow("right", t),
    bottom: r.getShallow("bottom", t),
    width: r.getShallow("width", t),
    height: r.getShallow("height", t)
  };
}
function D9(r, t) {
  var e = Sr(r, t, {
    enableLayoutOnlyByCenter: !0
  }), n = r.getBoxLayoutParams(), i, a;
  if (e.type === If.point)
    a = e.refPoint, i = We(n, {
      width: t.getWidth(),
      height: t.getHeight()
    });
  else {
    var o = r.get("center"), s = et(o) ? o : [o, o];
    i = We(n, e.refContainer), a = e.boxCoordFrom === Gx.coord2 ? e.refPoint : [dt(s[0], i.width) + i.x, dt(s[1], i.height) + i.y];
  }
  return {
    viewRect: i,
    center: a
  };
}
function YN(r, t) {
  var e = D9(r, t), n = e.viewRect, i = e.center, a = r.get("radius");
  et(a) || (a = [0, a]);
  var o = dt(n.width, t.getWidth()), s = dt(n.height, t.getHeight()), l = Math.min(o, s), u = dt(a[0], l / 2), c = dt(a[1], l / 2);
  return {
    cx: i[0],
    cy: i[1],
    r0: u,
    r: c,
    viewRect: n
  };
}
function We(r, t, e) {
  e = zh(e || 0);
  var n = t.width, i = t.height, a = dt(r.left, n), o = dt(r.top, i), s = dt(r.right, n), l = dt(r.bottom, i), u = dt(r.width, n), c = dt(r.height, i), f = e[2] + e[0], h = e[1] + e[3], d = r.aspect;
  switch (isNaN(u) && (u = n - s - h - a), isNaN(c) && (c = i - l - f - o), d != null && (isNaN(u) && isNaN(c) && (d > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = n - s - u - h), isNaN(o) && (o = i - l - c - f), r.left || r.right) {
    case "center":
      a = n / 2 - u / 2 - e[3];
      break;
    case "right":
      a = n - u - h;
      break;
  }
  switch (r.top || r.bottom) {
    case "middle":
    case "center":
      o = i / 2 - c / 2 - e[0];
      break;
    case "bottom":
      o = i - c - f;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = n - h - a - (s || 0)), isNaN(c) && (c = i - f - o - (l || 0));
  var p = new Vt((t.x || 0) + a + e[3], (t.y || 0) + o + e[0], u, c);
  return p.margin = e, p;
}
function $N(r, t, e) {
  var n = r.getShallow("preserveAspect", !0);
  if (!n)
    return t;
  var i = t.width / t.height;
  if (Math.abs(Math.atan(e) - Math.atan(i)) < 1e-9)
    return t;
  var a = r.getShallow("preserveAspectAlign", !0), o = r.getShallow("preserveAspectVerticalAlign", !0), s = {
    width: t.width,
    height: t.height
  }, l = n === "cover";
  return i > e && !l || i < e && l ? (s.width = t.height * e, a === "left" ? s.left = 0 : a === "right" ? s.right = 0 : s.left = "center") : (s.height = t.width / e, o === "top" ? s.top = 0 : o === "bottom" ? s.bottom = 0 : s.top = "middle"), We(s, t);
}
var If = {
  rect: 1,
  point: 2
};
function Sr(r, t, e) {
  var n, i, a, o = r.boxCoordinateSystem, s;
  if (o) {
    var l = C9(r), u = l.coord, c = l.from;
    if (o.dataToLayout) {
      a = If.rect, s = c;
      var f = o.dataToLayout(u);
      n = f.contentRect || f.rect;
    } else
      e && e.enableLayoutOnlyByCenter && o.dataToPoint ? (a = If.point, s = c, i = o.dataToPoint(u)) : process.env.NODE_ENV !== "production" && ce(r.type + "[" + r.componentIndex + "]" + (" layout based on " + o.type + " is not supported."));
  }
  return a == null && (a = If.rect), a === If.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), i = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: i,
    boxCoordFrom: s
  };
}
function cm(r, t, e, n, i, a) {
  var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (a = a || r, a.x = r.x, a.y = r.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = r.type === "group" ? new Vt(0, 0, +t.width || 0, +t.height || 0) : r.getBoundingRect();
  else if (u = r.getBoundingRect(), r.needLocalTransform()) {
    var c = r.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var f = We(Bt({
    width: u.width,
    height: u.height
  }, t), e, n), h = o ? f.x - u.x : 0, d = s ? f.y - u.y : 0;
  return l === "raw" ? (a.x = h, a.y = d) : (a.x += h, a.y += d), a === r && r.markRedraw(), !0;
}
function L9(r, t) {
  return r[Js[t][0]] != null || r[Js[t][1]] != null && r[Js[t][2]] != null;
}
function uh(r) {
  var t = r.layoutMode || r.constructor.layoutMode;
  return Lt(t) ? t : t ? {
    type: t
  } : null;
}
function sa(r, t, e) {
  var n = e && e.ignoreSize;
  !et(n) && (n = [n, n]);
  var i = o(Js[0], 0), a = o(Js[1], 1);
  l(Js[0], r, i), l(Js[1], r, a);
  function o(u, c) {
    var f = {}, h = 0, d = {}, p = 0, g = 2;
    if (tv(u, function(y) {
      d[y] = r[y];
    }), tv(u, function(y) {
      _t(t, y) && (f[y] = d[y] = t[y]), s(f, y) && h++, s(d, y) && p++;
    }), n[c])
      return s(t, u[1]) ? d[u[2]] = null : s(t, u[2]) && (d[u[1]] = null), d;
    if (p === g || !h)
      return d;
    if (h >= g)
      return f;
    for (var v = 0; v < u.length; v++) {
      var m = u[v];
      if (!_t(f, m) && _t(r, m)) {
        f[m] = r[m];
        break;
      }
    }
    return f;
  }
  function s(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, f) {
    tv(u, function(h) {
      c[h] = f[h];
    });
  }
}
function Cl(r) {
  return ZN({}, r);
}
function ZN(r, t) {
  return t && r && tv(WN, function(e) {
    _t(t, e) && (r[e] = t[e]);
  }), r;
}
var R9 = ee(), re = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, n, i) || this;
      return a.uid = Ec("ec_cpt_model"), a;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = uh(this), a = i ? Cl(e) : {}, o = n.getTheme();
      qt(e, o.get(this.mainType)), qt(e, this.getDefaultOption()), i && sa(e, a, i);
    }, t.prototype.mergeOption = function(e, n) {
      qt(this.option, e, !0);
      var i = uh(this);
      i && sa(this.option, e, i);
    }, t.prototype.optionUpdated = function(e, n) {
    }, t.prototype.getDefaultOption = function() {
      var e = this.constructor;
      if (!c6(e))
        return e.defaultOption;
      var n = R9(this);
      if (!n.defaultOption) {
        for (var i = [], a = e; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = qt(s, i[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(e, n) {
      var i = e + "Index", a = e + "Id";
      return bc(this.ecModel, e, {
        index: this.get(i, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return XN(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(e) {
      this.option.zlevel = e;
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "component", e.id = "", e.name = "", e.mainType = "", e.subType = "", e.componentIndex = 0;
    }(), t;
  }(ue)
);
GP(re, ue);
qg(re);
l9(re);
u9(re, I9);
function I9(r) {
  var t = [];
  return L(re.getClassesByMainType(r), function(e) {
    t = t.concat(e.dependencies || e.prototype.dependencies || []);
  }), t = rt(t, function(e) {
    return Zi(e).main;
  }), r !== "dataset" && Zt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var X = {
  color: {},
  darkColor: {},
  size: {}
}, Qe = X.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
j(Qe, {
  primary: Qe.neutral80,
  secondary: Qe.neutral70,
  tertiary: Qe.neutral60,
  quaternary: Qe.neutral50,
  disabled: Qe.neutral20,
  border: Qe.neutral30,
  borderTint: Qe.neutral20,
  borderShade: Qe.neutral40,
  background: Qe.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Qe.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Qe.neutral70,
  axisLineTint: Qe.neutral40,
  axisTick: Qe.neutral70,
  axisTickMinor: Qe.neutral60,
  axisLabel: Qe.neutral70,
  axisSplitLine: Qe.neutral15,
  axisMinorSplitLine: Qe.neutral05
});
for (var ws in Qe)
  if (Qe.hasOwnProperty(ws)) {
    var qA = Qe[ws];
    ws === "theme" ? X.darkColor.theme = Qe.theme.slice() : ws === "highlight" ? X.darkColor.highlight = "rgba(255,231,130,0.4)" : ws.indexOf("accent") === 0 ? X.darkColor[ws] = Oo(qA, null, function(r) {
      return r * 0.5;
    }, function(r) {
      return Math.min(1, 1.3 - r);
    }) : X.darkColor[ws] = Oo(qA, null, function(r) {
      return r * 0.9;
    }, function(r) {
      return 1 - Math.pow(r, 1.5);
    });
  }
X.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var qN = "";
typeof navigator < "u" && (qN = navigator.platform || "");
var ou = "rgba(0, 0, 0, 0.2)", KN = X.color.theme[0], P9 = Oo(KN, null, null, 0.9);
const N9 = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: X.color.theme,
  gradientColor: [P9, KN],
  aria: {
    decal: {
      decals: [{
        color: ou,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: ou,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: ou,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: ou,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: ou,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: ou,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: qN.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Wx = wt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Vn = "original", Vr = "arrayRows", Fn = "objectRows", Ai = "keyedColumns", Oa = "typedArray", jN = "unknown", xi = "column", Dl = "row", zr = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, JN = ee();
function O9(r) {
  JN(r).datasetMap = wt();
}
function QN(r, t, e) {
  var n = {}, i = ab(t);
  if (!i || !r)
    return n;
  var a = [], o = [], s = t.ecModel, l = JN(s).datasetMap, u = i.uid + "_" + e.seriesLayoutBy, c, f;
  r = r.slice(), L(r, function(g, v) {
    var m = Lt(g) ? g : r[v] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = v, f = p(m)), n[m.name] = [];
  });
  var h = l.get(u) || l.set(u, {
    categoryWayDim: f,
    valueWayDim: 0
  });
  L(r, function(g, v) {
    var m = g.name, y = p(g);
    if (c == null) {
      var _ = h.valueWayDim;
      d(n[m], _, y), d(o, _, y), h.valueWayDim += y;
    } else if (c === v)
      d(n[m], 0, y), d(a, 0, y);
    else {
      var _ = h.categoryWayDim;
      d(n[m], _, y), d(o, _, y), h.categoryWayDim += y;
    }
  });
  function d(g, v, m) {
    for (var y = 0; y < m; y++)
      g.push(v + y);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
}
function ib(r, t, e) {
  var n = {}, i = ab(r);
  if (!i)
    return n;
  var a = t.sourceFormat, o = t.dimensionsDefine, s;
  (a === Fn || a === Ai) && L(o, function(c, f) {
    (Lt(c) ? c.name : c) === "name" && (s = f);
  });
  var l = function() {
    for (var c = {}, f = {}, h = [], d = 0, p = Math.min(5, e); d < p; d++) {
      var g = eO(t.data, a, t.seriesLayoutBy, o, t.startIndex, d);
      h.push(g);
      var v = g === zr.Not;
      if (v && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !v && h[c.n] === zr.Not) && (c.n = d), m(c) && h[c.n] !== zr.Not)
        return c;
      v || (g === zr.Might && f.v == null && d !== s && (f.v = d), (f.n == null || f.n === f.v) && (f.n = d));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(c) ? c : m(f) ? f : null;
  }();
  if (l) {
    n.value = [l.v];
    var u = s ?? l.n;
    n.itemName = [u], n.seriesName = [u];
  }
  return n;
}
function ab(r) {
  var t = r.get("data", !0);
  if (!t)
    return bc(r.ecModel, "dataset", {
      index: r.get("datasetIndex", !0),
      id: r.get("datasetId", !0)
    }, je).models[0];
}
function k9(r) {
  return !r.get("transform", !0) && !r.get("fromTransformResult", !0) ? [] : bc(r.ecModel, "dataset", {
    index: r.get("fromDatasetIndex", !0),
    id: r.get("fromDatasetId", !0)
  }, je).models;
}
function tO(r, t) {
  return eO(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, t);
}
function eO(r, t, e, n, i, a) {
  var o, s = 5;
  if (hn(r))
    return zr.Not;
  var l, u;
  if (n) {
    var c = n[a];
    Lt(c) ? (l = c.name, u = c.type) : pt(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? zr.Must : zr.Not;
  if (t === Vr) {
    var f = r;
    if (e === Dl) {
      for (var h = f[a], d = 0; d < (h || []).length && d < s; d++)
        if ((o = x(h[i + d])) != null)
          return o;
    } else
      for (var d = 0; d < f.length && d < s; d++) {
        var p = f[i + d];
        if (p && (o = x(p[a])) != null)
          return o;
      }
  } else if (t === Fn) {
    var g = r;
    if (!l)
      return zr.Not;
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d];
      if (v && (o = x(v[l])) != null)
        return o;
    }
  } else if (t === Ai) {
    var m = r;
    if (!l)
      return zr.Not;
    var h = m[l];
    if (!h || hn(h))
      return zr.Not;
    for (var d = 0; d < h.length && d < s; d++)
      if ((o = x(h[d])) != null)
        return o;
  } else if (t === Vn)
    for (var y = r, d = 0; d < y.length && d < s; d++) {
      var v = y[d], _ = Sc(v);
      if (!et(_))
        return zr.Not;
      if ((o = x(_[a])) != null)
        return o;
    }
  function x(b) {
    var S = pt(b);
    if (b != null && Number.isFinite(Number(b)) && b !== "")
      return S ? zr.Might : zr.Not;
    if (S && b !== "-")
      return zr.Must;
  }
  return zr.Not;
}
var Xx = wt();
function B9(r, t) {
  St(Xx.get(r) == null && t), Xx.set(r, t);
}
function V9(r, t, e) {
  var n = Xx.get(t);
  if (!n)
    return e;
  var i = n(r);
  if (!i)
    return e;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < i.length; a++)
      St(rc(i[a]));
  return e.concat(i);
}
var KA = ee(), F9 = ee(), ob = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(t, e, n) {
      var i = Ie(this.get("color", !0)), a = this.get("colorLayer", !0);
      return rO(this, KA, i, a, t, e, n);
    }, r.prototype.clearColorPalette = function() {
      U9(this, KA);
    }, r;
  }()
);
function Yx(r, t, e, n) {
  var i = Ie(r.get(["aria", "decal", "decals"]));
  return rO(r, F9, i, null, t, e, n);
}
function z9(r, t) {
  for (var e = r.length, n = 0; n < e; n++)
    if (r[n].length > t)
      return r[n];
  return r[e - 1];
}
function rO(r, t, e, n, i, a, o) {
  a = a || r;
  var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = o == null || !n ? e : z9(n, o);
  if (c = c || e, !(!c || !c.length)) {
    var f = c[l];
    return i && (u[i] = f), s.paletteIdx = (l + 1) % c.length, f;
  }
}
function U9(r, t) {
  t(r).paletteIdx = 0, t(r).paletteNameMap = {};
}
var Yd, Jc, jA, e0 = "\0_ec_inner", JA = 1, G9 = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, H9 = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Fv = {};
function W9(r) {
  L(r, function(t, e) {
    if (!re.hasClass(e)) {
      var n = G9[e];
      n && !Fv[n] && (ce("Component " + e + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Fv[n] = !0);
    }
  });
}
var sb = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e, n, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new ue(a), this._locale = new ue(o), this._optionManager = s;
    }, t.prototype.setOption = function(e, n, i) {
      process.env.NODE_ENV !== "production" && (St(e != null, "option is null/undefined"), St(e[e0] !== JA, "please use chart.getOption()"));
      var a = eE(n);
      this._optionManager.setOption(e, i, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(e, n) {
      return this._resetOption(e, eE(n));
    }, t.prototype._resetOption = function(e, n) {
      var i = !1, a = this._optionManager;
      if (!e || e === "recreate") {
        var o = a.mountOption(e === "recreate");
        process.env.NODE_ENV !== "production" && W9(o), !this.option || e === "recreate" ? jA(this, o) : (this.restoreData(), this._mergeOption(o, n)), i = !0;
      }
      if ((e === "timeline" || e === "media") && this.restoreData(), !e || e === "recreate" || e === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, n));
      }
      if (!e || e === "recreate" || e === "media") {
        var l = a.getMediaOption(this);
        l.length && L(l, function(u) {
          i = !0, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, t.prototype.mergeOption = function(e) {
      this._mergeOption(e, null);
    }, t.prototype._mergeOption = function(e, n) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = wt(), u = n && n.replaceMergeMainTypeMap;
      O9(this), L(e, function(f, h) {
        f != null && (re.hasClass(h) ? h && (s.push(h), l.set(h, !0)) : i[h] = i[h] == null ? Dt(f) : qt(i[h], f, !0));
      }), u && u.each(function(f, h) {
        re.hasClass(h) && !l.get(h) && (s.push(h), l.set(h, !0));
      }), re.topologicalTravel(s, re.getAllClassMainTypes(), c, this);
      function c(f) {
        var h = V9(this, f, Ie(e[f])), d = a.get(f), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(f) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = BP(d, h, p);
        e6(g, f, re), i[f] = null, a.set(f, null), o.set(f, 0);
        var v = [], m = [], y = 0, _, x;
        L(g, function(b, S) {
          var w = b.existing, A = b.newOption;
          if (!A)
            w && (w.mergeOption({}, this), w.optionUpdated({}, !1));
          else {
            var T = f === "series", M = re.getClass(
              f,
              b.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!M) {
              if (process.env.NODE_ENV !== "production") {
                var C = b.keyInfo.subType, R = H9[C];
                Fv[C] || (Fv[C] = !0, ce(R ? "Series " + C + ` is used but not imported.
import { ` + R + ` } from 'echarts/charts';
echarts.use([` + R + "]);" : "Unknown series " + C));
              }
              return;
            }
            if (f === "tooltip") {
              if (_) {
                process.env.NODE_ENV !== "production" && (x || (Ye("Currently only one tooltip component is allowed."), x = !0));
                return;
              }
              _ = !0;
            }
            if (w && w.constructor === M)
              w.name = b.keyInfo.name, w.mergeOption(A, this), w.optionUpdated(A, !1);
            else {
              var E = j({
                componentIndex: S
              }, b.keyInfo);
              w = new M(A, this, this, E), j(w, E), b.brandNew && (w.__requireNewView = !0), w.init(A, this, this), w.optionUpdated(null, !0);
            }
          }
          w ? (v.push(w.option), m.push(w), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[f] = v, a.set(f, m), o.set(f, y), f === "series" && Yd(this);
      }
      this._seriesIndices || Yd(this);
    }, t.prototype.getOption = function() {
      var e = Dt(this.option);
      return L(e, function(n, i) {
        if (re.hasClass(i)) {
          for (var a = Ie(n), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !rc(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, e[i] = a;
        }
      }), delete e[e0], e;
    }, t.prototype.setTheme = function(e) {
      this._theme = new ue(e), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(e) {
      this._payload = e;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(e, n) {
      var i = this._componentsMap.get(e);
      if (i) {
        var a = i[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var o = 0; o < i.length; o++)
            if (i[o])
              return i[o];
        }
      }
    }, t.prototype.queryComponents = function(e) {
      var n = e.mainType;
      if (!n)
        return [];
      var i = e.index, a = e.id, o = e.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], L(Ie(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = QA("id", a, s) : o != null ? l = QA("name", o, s) : l = Te(s, function(u) {
        return !!u;
      }), tE(l, e);
    }, t.prototype.findComponents = function(e) {
      var n = e.query, i = e.mainType, a = s(n), o = a ? this.queryComponents(a) : Te(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(tE(o, e));
      function s(u) {
        var c = i + "Index", f = i + "Id", h = i + "Name";
        return u && (u[c] != null || u[f] != null || u[h] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[f],
          name: u[h]
        } : null;
      }
      function l(u) {
        return e.filter ? Te(u, e.filter) : u;
      }
    }, t.prototype.eachComponent = function(e, n, i) {
      var a = this._componentsMap;
      if (At(e)) {
        var o = n, s = e;
        a.each(function(f, h) {
          for (var d = 0; f && d < f.length; d++) {
            var p = f[d];
            p && s.call(o, h, p, p.componentIndex);
          }
        });
      } else
        for (var l = pt(e) ? a.get(e) : Lt(e) ? this.findComponents(e) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(i, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(e) {
      var n = yr(e, null);
      return Te(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(e) {
      return this._componentsMap.get("series")[e];
    }, t.prototype.getSeriesByType = function(e) {
      return Te(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === e;
      });
    }, t.prototype.getSeries = function() {
      return Te(this._componentsMap.get("series"), function(e) {
        return !!e;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(e, n) {
      Jc(this), L(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        e.call(n, a, i);
      }, this);
    }, t.prototype.eachRawSeries = function(e, n) {
      L(this._componentsMap.get("series"), function(i) {
        i && e.call(n, i, i.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(e, n, i) {
      Jc(this), L(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === e && n.call(i, o, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(e, n, i) {
      return L(this.getSeriesByType(e), n, i);
    }, t.prototype.isSeriesFiltered = function(e) {
      return Jc(this), this._seriesIndicesMap.get(e.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(e, n) {
      Jc(this);
      var i = [];
      L(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        e.call(n, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = wt(i);
    }, t.prototype.restoreData = function(e) {
      Yd(this);
      var n = this._componentsMap, i = [];
      n.each(function(a, o) {
        re.hasClass(o) && i.push(o);
      }), re.topologicalTravel(i, re.getAllClassMainTypes(), function(a) {
        L(n.get(a), function(o) {
          o && (a !== "series" || !X9(o, e)) && o.restoreData();
        });
      });
    }, t.internalField = function() {
      Yd = function(e) {
        var n = e._seriesIndices = [];
        L(e._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), e._seriesIndicesMap = wt(n);
      }, Jc = function(e) {
        if (process.env.NODE_ENV !== "production" && !e._seriesIndices)
          throw new Error("Option should contains series.");
      }, jA = function(e, n) {
        e.option = {}, e.option[e0] = JA, e._componentsMap = wt({
          series: []
        }), e._componentsCount = wt();
        var i = n.aria;
        Lt(i) && i.enabled == null && (i.enabled = !0), Y9(n, e._theme.option), qt(n, N9, !1), e._mergeOption(n, null);
      };
    }(), t;
  }(ue)
);
function X9(r, t) {
  if (t) {
    var e = t.seriesIndex, n = t.seriesId, i = t.seriesName;
    return e != null && r.componentIndex !== e || n != null && r.id !== n || i != null && r.name !== i;
  }
}
function Y9(r, t) {
  var e = r.color && !r.colorLayer;
  L(t, function(n, i) {
    i === "colorLayer" && e || i === "color" && r.color || re.hasClass(i) || (typeof n == "object" ? r[i] = r[i] ? qt(r[i], n, !1) : Dt(n) : r[i] == null && (r[i] = n));
  });
}
function QA(r, t, e) {
  if (et(t)) {
    var n = wt();
    return L(t, function(a) {
      if (a != null) {
        var o = yr(a, null);
        o != null && n.set(a, !0);
      }
    }), Te(e, function(a) {
      return a && n.get(a[r]);
    });
  } else {
    var i = yr(t, null);
    return Te(e, function(a) {
      return a && i != null && a[r] === i;
    });
  }
}
function tE(r, t) {
  return t.hasOwnProperty("subType") ? Te(r, function(e) {
    return e && e.subType === t.subType;
  }) : r;
}
function eE(r) {
  var t = wt();
  return r && L(Ie(r.replaceMerge), function(e) {
    process.env.NODE_ENV !== "production" && St(re.hasClass(e), '"' + e + '" is not valid component main type in "replaceMerge"'), t.set(e, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
dr(sb, ob);
var $9 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], nO = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      L($9, function(e) {
        this[e] = gt(t[e], t);
      }, this);
    }
    return r;
  }()
), Z9 = /^(min|max)?(.+)$/, q9 = (
  /** @class */
  function() {
    function r(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return r.prototype.setOption = function(t, e, n) {
      t && (L(Ie(t.series), function(o) {
        o && o.data && hn(o.data) && _v(o.data);
      }), L(Ie(t.dataset), function(o) {
        o && o.source && hn(o.source) && _v(o.source);
      })), t = Dt(t);
      var i = this._optionBackup, a = K9(t, e, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(t) {
      var e = this._optionBackup;
      return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], Dt(t ? e.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(t) {
      var e, n = this._timelineOptions;
      if (n.length) {
        var i = t.getComponent("timeline");
        i && (e = Dt(
          // FIXME:TS as TimelineModel or quivlant interface
          n[i.getCurrentIndex()]
        ));
      }
      return e;
    }, r.prototype.getMediaOption = function(t) {
      var e = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        j9(i[l].query, e, n) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !Q9(o, this._currentMediaIndices) && (s = rt(o, function(c) {
        return Dt(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }()
);
function K9(r, t, e) {
  var n = [], i, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, c = !!r.media, f = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((f || c) && (r.options = r.media = null), a = r), c && (et(u) ? L(u, function(d) {
    process.env.NODE_ENV !== "production" && d && !d.option && Lt(d.query) && Lt(d.query.option) && ce("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), d && d.option && (d.query ? n.push(d) : i || (i = d));
  }) : process.env.NODE_ENV !== "production" && ce("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), h(a), L(l, function(d) {
    return h(d);
  }), L(n, function(d) {
    return h(d.option);
  });
  function h(d) {
    L(t, function(p) {
      p(d, e);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n
  };
}
function j9(r, t, e) {
  var n = {
    width: t,
    height: e,
    aspectratio: t / e
    // lower case for convenience.
  }, i = !0;
  return L(r, function(a, o) {
    var s = o.match(Z9);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      J9(n[u], a, l) || (i = !1);
    }
  }), i;
}
function J9(r, t, e) {
  return e === "min" ? r >= t : e === "max" ? r <= t : r === t;
}
function Q9(r, t) {
  return r.join(",") === t.join(",");
}
var Gn = L, ch = Lt, rE = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function r0(r) {
  var t = r && r.itemStyle;
  if (t)
    for (var e = 0, n = rE.length; e < n; e++) {
      var i = rE[e], a = t.normal, o = t.emphasis;
      a && a[i] && (process.env.NODE_ENV !== "production" && or("itemStyle.normal." + i, i), r[i] = r[i] || {}, r[i].normal ? qt(r[i].normal, a[i]) : r[i].normal = a[i], a[i] = null), o && o[i] && (process.env.NODE_ENV !== "production" && or("itemStyle.emphasis." + i, "emphasis." + i), r[i] = r[i] || {}, r[i].emphasis ? qt(r[i].emphasis, o[i]) : r[i].emphasis = o[i], o[i] = null);
    }
}
function qr(r, t, e) {
  if (r && r[t] && (r[t].normal || r[t].emphasis)) {
    var n = r[t].normal, i = r[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && aa("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), e ? (r[t].normal = r[t].emphasis = null, Bt(r[t], n)) : r[t] = n), i && (process.env.NODE_ENV !== "production" && aa(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), r.emphasis = r.emphasis || {}, r.emphasis[t] = i, i.focus && (r.emphasis.focus = i.focus), i.blurScope && (r.emphasis.blurScope = i.blurScope));
  }
}
function Pf(r) {
  qr(r, "itemStyle"), qr(r, "lineStyle"), qr(r, "areaStyle"), qr(r, "label"), qr(r, "labelLine"), qr(r, "upperLabel"), qr(r, "edgeLabel");
}
function ar(r, t) {
  var e = ch(r) && r[t], n = ch(e) && e.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && aa("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var i = 0, a = nA.length; i < a; i++) {
      var o = nA[i];
      n.hasOwnProperty(o) && (e[o] = n[o]);
    }
  }
}
function Zn(r) {
  r && (Pf(r), ar(r, "label"), r.emphasis && ar(r.emphasis, "label"));
}
function tX(r) {
  if (ch(r)) {
    r0(r), Pf(r), ar(r, "label"), ar(r, "upperLabel"), ar(r, "edgeLabel"), r.emphasis && (ar(r.emphasis, "label"), ar(r.emphasis, "upperLabel"), ar(r.emphasis, "edgeLabel"));
    var t = r.markPoint;
    t && (r0(t), Zn(t));
    var e = r.markLine;
    e && (r0(e), Zn(e));
    var n = r.markArea;
    n && Zn(n);
    var i = r.data;
    if (r.type === "graph") {
      i = i || r.nodes;
      var a = r.links || r.edges;
      if (a && !hn(a))
        for (var o = 0; o < a.length; o++)
          Zn(a[o]);
      L(r.categories, function(u) {
        Pf(u);
      });
    }
    if (i && !hn(i))
      for (var o = 0; o < i.length; o++)
        Zn(i[o]);
    if (t = r.markPoint, t && t.data)
      for (var s = t.data, o = 0; o < s.length; o++)
        Zn(s[o]);
    if (e = r.markLine, e && e.data)
      for (var l = e.data, o = 0; o < l.length; o++)
        et(l[o]) ? (Zn(l[o][0]), Zn(l[o][1])) : Zn(l[o]);
    r.type === "gauge" ? (ar(r, "axisLabel"), ar(r, "title"), ar(r, "detail")) : r.type === "treemap" ? (qr(r.breadcrumb, "itemStyle"), L(r.levels, function(u) {
      Pf(u);
    })) : r.type === "tree" && Pf(r.leaves);
  }
}
function _a(r) {
  return et(r) ? r : r ? [r] : [];
}
function nE(r) {
  return (et(r) ? r[0] : r) || {};
}
function eX(r, t) {
  Gn(_a(r.series), function(n) {
    ch(n) && tX(n);
  });
  var e = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && e.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Gn(e, function(n) {
    Gn(_a(r[n]), function(i) {
      i && (ar(i, "axisLabel"), ar(i.axisPointer, "label"));
    });
  }), Gn(_a(r.parallel), function(n) {
    var i = n && n.parallelAxisDefault;
    ar(i, "axisLabel"), ar(i && i.axisPointer, "label");
  }), Gn(_a(r.calendar), function(n) {
    qr(n, "itemStyle"), ar(n, "dayLabel"), ar(n, "monthLabel"), ar(n, "yearLabel");
  }), Gn(_a(r.radar), function(n) {
    ar(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && aa("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && aa("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && Gn(n.indicator, function(i) {
      i.text && or("text", "name", "radar.indicator");
    });
  }), Gn(_a(r.geo), function(n) {
    ch(n) && (Zn(n), Gn(_a(n.regions), function(i) {
      Zn(i);
    }));
  }), Gn(_a(r.timeline), function(n) {
    Zn(n), qr(n, "label"), qr(n, "itemStyle"), qr(n, "controlStyle", !0);
    var i = n.data;
    et(i) && L(i, function(a) {
      Lt(a) && (qr(a, "label"), qr(a, "itemStyle"));
    });
  }), Gn(_a(r.toolbox), function(n) {
    qr(n, "iconStyle"), Gn(n.feature, function(i) {
      qr(i, "iconStyle");
    });
  }), ar(nE(r.axisPointer), "label"), ar(nE(r.tooltip).axisPointer, "label");
}
function rX(r, t) {
  for (var e = t.split(","), n = r, i = 0; i < e.length && (n = n && n[e[i]], n != null); i++)
    ;
  return n;
}
function nX(r, t, e, n) {
  for (var i = t.split(","), a = r, o, s = 0; s < i.length - 1; s++)
    o = i[s], a[o] == null && (a[o] = {}), a = a[o];
  a[i[s]] == null && (a[i[s]] = e);
}
function iE(r) {
  r && L(iX, function(t) {
    t[0] in r && !(t[1] in r) && (r[t[1]] = r[t[0]]);
  });
}
var iX = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], aX = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], n0 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Qc(r) {
  var t = r && r.itemStyle;
  if (t)
    for (var e = 0; e < n0.length; e++) {
      var n = n0[e][1], i = n0[e][0];
      t[n] != null && (t[i] = t[n], process.env.NODE_ENV !== "production" && or(n, i));
    }
}
function aE(r) {
  r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && (process.env.NODE_ENV !== "production" && or("label.margin", "label.edgeDistance", "pie"), r.edgeDistance = r.margin);
}
function oE(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay, process.env.NODE_ENV !== "production" && or("downplay", "blur", "sunburst"));
}
function oX(r) {
  r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && (process.env.NODE_ENV !== "production" && or("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), r.emphasis.focus = "adjacency"));
}
function iO(r, t) {
  if (r)
    for (var e = 0; e < r.length; e++)
      t(r[e]), r[e] && iO(r[e].children, t);
}
function aO(r, t) {
  eX(r, t), r.series = Ie(r.series), L(r.series, function(e) {
    if (Lt(e)) {
      var n = e.type;
      if (n === "line")
        e.clipOverflow != null && (e.clip = e.clipOverflow, process.env.NODE_ENV !== "production" && or("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        e.clockWise != null && (e.clockwise = e.clockWise, process.env.NODE_ENV !== "production" && or("clockWise", "clockwise")), aE(e.label);
        var i = e.data;
        if (i && !hn(i))
          for (var a = 0; a < i.length; a++)
            aE(i[a]);
        e.hoverOffset != null && (e.emphasis = e.emphasis || {}, (e.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && or("hoverOffset", "emphasis.scaleSize"), e.emphasis.scaleSize = e.hoverOffset));
      } else if (n === "gauge") {
        var o = rX(e, "pointer.color");
        o != null && nX(e, "itemStyle.color", o);
      } else if (n === "bar") {
        Qc(e), Qc(e.backgroundStyle), Qc(e.emphasis);
        var i = e.data;
        if (i && !hn(i))
          for (var a = 0; a < i.length; a++)
            typeof i[a] == "object" && (Qc(i[a]), Qc(i[a] && i[a].emphasis));
      } else if (n === "sunburst") {
        var s = e.highlightPolicy;
        s && (e.emphasis = e.emphasis || {}, e.emphasis.focus || (e.emphasis.focus = s, process.env.NODE_ENV !== "production" && or("highlightPolicy", "emphasis.focus", "sunburst"))), oE(e), iO(e.data, oE);
      } else
        n === "graph" || n === "sankey" ? oX(e) : n === "map" && (e.mapType && !e.map && (process.env.NODE_ENV !== "production" && or("mapType", "map", "map"), e.map = e.mapType), e.mapLocation && (process.env.NODE_ENV !== "production" && aa("`mapLocation` is not used anymore."), Bt(e, e.mapLocation)));
      e.hoverAnimation != null && (e.emphasis = e.emphasis || {}, e.emphasis && e.emphasis.scale == null && (process.env.NODE_ENV !== "production" && or("hoverAnimation", "emphasis.scale"), e.emphasis.scale = e.hoverAnimation)), iE(e);
    }
  }), r.dataRange && (r.visualMap = r.dataRange), L(aX, function(e) {
    var n = r[e];
    n && (et(n) || (n = [n]), L(n, function(i) {
      iE(i);
    }));
  });
}
function sX(r) {
  var t = wt();
  r.eachSeries(function(e) {
    var n = e.get("stack");
    if (n) {
      var i = t.get(n) || t.set(n, []), a = e.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: e
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      i.push(o);
    }
  }), t.each(function(e) {
    if (e.length !== 0) {
      var n = e[0].seriesModel, i = n.get("stackOrder") || "seriesAsc";
      i === "seriesDesc" && e.reverse(), L(e, function(a, o) {
        a.data.setCalculationInfo("stackedOnSeries", o > 0 ? e[o - 1].seriesModel : null);
      }), lX(e);
    }
  });
}
function lX(r) {
  L(r, function(t, e) {
    var n = [], i = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, f) {
      var h = o.get(t.stackedDimension, f);
      if (isNaN(h))
        return i;
      var d, p;
      s ? p = o.getRawIndex(f) : d = o.get(t.stackedByDimension, f);
      for (var g = NaN, v = e - 1; v >= 0; v--) {
        var m = r[v];
        if (s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && h >= 0 && y > 0 || l === "samesign" && h <= 0 && y < 0) {
            h = G8(h, y), g = y;
            break;
          }
        }
      }
      return n[0] = h, n[1] = g, n;
    });
  });
}
var fm = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.data = t.data || (t.sourceFormat === Ai ? {} : []), this.sourceFormat = t.sourceFormat || jN, this.seriesLayoutBy = t.seriesLayoutBy || xi, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var e = this.dimensionsDefine = t.dimensionsDefine;
      if (e)
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.type == null && tO(this, n) === zr.Must && (i.type = "ordinal");
        }
    }
    return r;
  }()
);
function lb(r) {
  return r instanceof fm;
}
function $x(r, t, e) {
  e = e || oO(r);
  var n = t.seriesLayoutBy, i = cX(r, e, n, t.sourceHeader, t.dimensions), a = new fm({
    data: r,
    sourceFormat: e,
    seriesLayoutBy: n,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: Dt(t)
  });
  return a;
}
function ub(r) {
  return new fm({
    data: r,
    sourceFormat: hn(r) ? Oa : Vn
  });
}
function uX(r) {
  return new fm({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: Dt(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount
  });
}
function oO(r) {
  var t = jN;
  if (hn(r))
    t = Oa;
  else if (et(r)) {
    r.length === 0 && (t = Vr);
    for (var e = 0, n = r.length; e < n; e++) {
      var i = r[e];
      if (i != null) {
        if (et(i) || hn(i)) {
          t = Vr;
          break;
        } else if (Lt(i)) {
          t = Fn;
          break;
        }
      }
    }
  } else if (Lt(r)) {
    for (var a in r)
      if (_t(r, a) && Kr(r[a])) {
        t = Ai;
        break;
      }
  }
  return t;
}
function cX(r, t, e, n, i) {
  var a, o;
  if (!r)
    return {
      dimensionsDefine: sE(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (t === Vr) {
    var s = r;
    n === "auto" || n == null ? lE(function(u) {
      u != null && u !== "-" && (pt(u) ? o == null && (o = 1) : o = 0);
    }, e, s, 10) : o = fe(n) ? n : n ? 1 : 0, !i && o === 1 && (i = [], lE(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, e, s, 1 / 0)), a = i ? i.length : e === Dl ? s.length : s[0] ? s[0].length : null;
  } else if (t === Fn)
    i || (i = fX(r));
  else if (t === Ai)
    i || (i = [], L(r, function(u, c) {
      i.push(c);
    }));
  else if (t === Vn) {
    var l = Sc(r[0]);
    a = et(l) && l.length || 1;
  } else
    t === Oa && process.env.NODE_ENV !== "production" && St(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: sE(i),
    dimensionsDetectedCount: a
  };
}
function fX(r) {
  for (var t = 0, e; t < r.length && !(e = r[t++]); )
    ;
  if (e)
    return se(e);
}
function sE(r) {
  if (r) {
    var t = wt();
    return rt(r, function(e, n) {
      e = Lt(e) ? e : {
        name: e
      };
      var i = {
        name: e.name,
        displayName: e.displayName,
        type: e.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var a = t.get(i.name);
      return a ? i.name += "-" + a.count++ : t.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function lE(r, t, e, n) {
  if (t === Dl)
    for (var i = 0; i < e.length && i < n; i++)
      r(e[i] ? e[i][0] : null, i);
  else
    for (var a = e[0] || [], i = 0; i < a.length && i < n; i++)
      r(a[i], i);
}
function sO(r) {
  var t = r.sourceFormat;
  return t === Fn || t === Ai;
}
var Ms, Ts, As, Es, uE, cE, lO = (
  /** @class */
  function() {
    function r(t, e) {
      var n = lb(t) ? t : ub(t);
      this._source = n;
      var i = this._data = n.data, a = n.sourceFormat, o = n.seriesLayoutBy;
      if (a === Oa) {
        if (process.env.NODE_ENV !== "production" && e == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = e, this._data = i;
      }
      if (process.env.NODE_ENV !== "production") {
        var s = hX[zv(a, o)];
        s && s(i, n.dimensionsDefine);
      }
      cE(this, i, n);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(t, e) {
    }, r.prototype.appendData = function(t) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var t = r.prototype;
      t.pure = !1, t.persistent = !0;
    }(), r.internalField = function() {
      var t;
      cE = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, f = l.startIndex, h = l.dimensionsDefine, d = uE[zv(u, c)];
        if (process.env.NODE_ENV !== "production" && St(d, "Invalide sourceFormat: " + u), j(o, d), u === Oa)
          o.getItem = e, o.count = i, o.fillStorage = n;
        else {
          var p = uO(u, c);
          o.getItem = gt(p, null, s, f, h);
          var g = cO(u, c);
          o.count = gt(g, null, s, f, h);
        }
      };
      var e = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, f = 0; f < u; f++)
          s[f] = l[c + f];
        return s;
      }, n = function(o, s, l, u) {
        for (var c = this._data, f = this._dimSize, h = 0; h < f; h++) {
          for (var d = u[h], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = s - o, m = l[h], y = 0; y < v; y++) {
            var _ = c[y * f + h];
            m[o + y] = _, _ < p && (p = _), _ > g && (g = _);
          }
          d[0] = p, d[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      uE = (t = {}, t[Vr + "_" + xi] = {
        pure: !0,
        appendData: a
      }, t[Vr + "_" + Dl] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Fn] = {
        pure: !0,
        appendData: a
      }, t[Ai] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          L(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), f = 0; f < (l || []).length; f++)
              c.push(l[f]);
          });
        }
      }, t[Vn] = {
        appendData: a
      }, t[Oa] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          process.env.NODE_ENV !== "production" && St(hn(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), r;
  }()
), $d = function(r) {
  et(r) || ce("series.data or dataset.source must be an array.");
}, hX = (Ms = {}, Ms[Vr + "_" + xi] = $d, Ms[Vr + "_" + Dl] = $d, Ms[Fn] = $d, Ms[Ai] = function(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e].name;
    n == null && ce("dimension name must not be null/undefined.");
  }
}, Ms[Vn] = $d, Ms), fE = function(r, t, e, n) {
  return r[n];
}, dX = (Ts = {}, Ts[Vr + "_" + xi] = function(r, t, e, n) {
  return r[n + t];
}, Ts[Vr + "_" + Dl] = function(r, t, e, n, i) {
  n += t;
  for (var a = i || [], o = r, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[n] : null;
  }
  return a;
}, Ts[Fn] = fE, Ts[Ai] = function(r, t, e, n, i) {
  for (var a = i || [], o = 0; o < e.length; o++) {
    var s = e[o].name, l = s != null ? r[s] : null;
    a[o] = l ? l[n] : null;
  }
  return a;
}, Ts[Vn] = fE, Ts);
function uO(r, t) {
  var e = dX[zv(r, t)];
  return process.env.NODE_ENV !== "production" && St(e, 'Do not support get item on "' + r + '", "' + t + '".'), e;
}
var hE = function(r, t, e) {
  return r.length;
}, pX = (As = {}, As[Vr + "_" + xi] = function(r, t, e) {
  return Math.max(0, r.length - t);
}, As[Vr + "_" + Dl] = function(r, t, e) {
  var n = r[0];
  return n ? Math.max(0, n.length - t) : 0;
}, As[Fn] = hE, As[Ai] = function(r, t, e) {
  var n = e[0].name, i = n != null ? r[n] : null;
  return i ? i.length : 0;
}, As[Vn] = hE, As);
function cO(r, t) {
  var e = pX[zv(r, t)];
  return process.env.NODE_ENV !== "production" && St(e, 'Do not support count on "' + r + '", "' + t + '".'), e;
}
var i0 = function(r, t, e) {
  return r[t];
}, vX = (Es = {}, Es[Vr] = i0, Es[Fn] = function(r, t, e) {
  return r[e];
}, Es[Ai] = i0, Es[Vn] = function(r, t, e) {
  var n = Sc(r);
  return n instanceof Array ? n[t] : n;
}, Es[Oa] = i0, Es);
function fO(r) {
  var t = vX[r];
  return process.env.NODE_ENV !== "production" && St(t, 'Do not support get value on "' + r + '".'), t;
}
function zv(r, t) {
  return r === Vr ? r + "_" + t : r;
}
function ac(r, t, e) {
  if (r) {
    var n = r.getRawDataItem(t);
    if (n != null) {
      var i = r.getStore(), a = i.getSource().sourceFormat;
      if (e != null) {
        var o = r.getDimensionIndex(e), s = i.getDimensionProperty(o);
        return fO(a)(n, o, s);
      } else {
        var l = n;
        return a === Vn && (l = Sc(n)), l;
      }
    }
  }
}
var gX = /\{@(.+?)\}/g, hm = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getDataParams = function(t, e) {
      var n = this.getData(e), i = this.getRawValue(t, e), a = n.getRawIndex(t), o = n.getName(t), s = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, f = this.mainType, h = f === "series", d = n.userOutput && n.userOutput.get();
      return {
        componentType: f,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: h ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: h ? this.id : null,
        seriesName: h ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: e,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, r.prototype.getFormattedLabel = function(t, e, n, i, a, o) {
      e = e || "normal";
      var s = this.getData(n), l = this.getDataParams(t, n);
      if (o && (l.value = o.interpolatedValue), i != null && et(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(t);
        a = u.get(e === "normal" ? ["label", "formatter"] : [e, "label", "formatter"]);
      }
      if (At(a))
        return l.status = e, l.dimensionIndex = i, a(l);
      if (pt(a)) {
        var c = UN(a, l);
        return c.replace(gX, function(f, h) {
          var d = h.length, p = h;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1), process.env.NODE_ENV !== "production" && isNaN(p) && ce("Invalide label formatter: @" + h + ", only support @[0], @[1], @[2], ..."));
          var g = ac(s, t, p);
          if (o && et(o.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = o.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(t, e) {
      return ac(this.getData(e), t);
    }, r.prototype.formatTooltip = function(t, e, n) {
    }, r;
  }()
);
function dE(r) {
  var t, e;
  return Lt(r) ? r.type ? e = r : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + dn(r)) : t = r, {
    text: t,
    // markers: markers || markersExisting,
    frag: e
  };
}
function qf(r) {
  return new mX(r);
}
var mX = (
  /** @class */
  function() {
    function r(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return r.prototype.perform = function(t) {
      var e = this._upstream, n = t && t.skip;
      if (this._dirty && e) {
        var i = this.context;
        i.data = i.outputData = e.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var f;
      (this._dirty || a === "reset") && (this._dirty = !1, f = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var h = t && t.step;
      if (e ? (process.env.NODE_ENV !== "production" && St(e._outputDueEnd != null), this._dueEnd = e._outputDueEnd) : (process.env.NODE_ENV !== "production" && St(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var d = this._dueIndex, p = Math.min(h != null ? this._dueIndex + h : 1 / 0, this._dueEnd);
        if (!n && (f || d < p)) {
          var g = this._progress;
          if (et(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], d, p, l, u);
          else
            this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        process.env.NODE_ENV !== "production" && St(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(t, e, n, i, a) {
      pE.reset(e, n, i, a), this._callingProgress = t, this._callingProgress({
        start: e,
        end: n,
        count: n - e,
        next: pE.next
      }, this.context);
    }, r.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var e, n;
      !t && this._reset && (e = this._reset(this.context), e && e.progress && (n = e.forceFirstProgress, e = e.progress), et(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && St(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, r;
  }()
), pE = /* @__PURE__ */ function() {
  var r, t, e, n, i, a = {
    reset: function(l, u, c, f) {
      t = l, r = u, e = c, n = f, i = Math.ceil(n / e), a.next = e > 1 && n > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return t < r ? t++ : null;
  }
  function s() {
    var l = t % i * e + Math.ceil(t / i), u = t >= r ? null : l < n ? l : t;
    return t++, u;
  }
}();
function Bo(r, t) {
  var e = t && t.type;
  return e === "ordinal" ? r : (e === "time" && !fe(r) && r != null && r !== "-" && (r = +Al(r)), r == null || r === "" ? NaN : Number(r));
}
var yX = wt({
  number: function(r) {
    return parseFloat(r);
  },
  time: function(r) {
    return +Al(r);
  },
  trim: function(r) {
    return pt(r) ? ei(r) : r;
  }
});
function hO(r) {
  return yX.get(r);
}
var dO = {
  lt: function(r, t) {
    return r < t;
  },
  lte: function(r, t) {
    return r <= t;
  },
  gt: function(r, t) {
    return r > t;
  },
  gte: function(r, t) {
    return r >= t;
  }
}, _X = (
  /** @class */
  function() {
    function r(t, e) {
      if (!fe(e)) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), we(n);
      }
      this._opFn = dO[t], this._rvalFloat = Ha(e);
    }
    return r.prototype.evaluate = function(t) {
      return fe(t) ? this._opFn(t, this._rvalFloat) : this._opFn(Ha(t), this._rvalFloat);
    }, r;
  }()
), pO = (
  /** @class */
  function() {
    function r(t, e) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, e == null && (e = n ? "min" : "max"), this._incomparable = e === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(t, e) {
      var n = fe(t) ? t : Ha(t), i = fe(e) ? e : Ha(e), a = isNaN(n), o = isNaN(i);
      if (a && (n = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = pt(t), l = pt(e);
        s && (n = l ? t : 0), l && (i = s ? e : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, r;
  }()
), xX = (
  /** @class */
  function() {
    function r(t, e) {
      this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = Ha(e);
    }
    return r.prototype.evaluate = function(t) {
      var e = t === this._rval;
      if (!e) {
        var n = typeof t;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (e = Ha(t) === this._rvalFloat);
      }
      return this._isEQ ? e : !e;
    }, r;
  }()
);
function SX(r, t) {
  return r === "eq" || r === "ne" ? new xX(r === "eq", t) : _t(dO, r) ? new _X(r, t) : null;
}
var bX = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(t) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(t, e) {
    }, r.prototype.retrieveValueFromItem = function(t, e) {
    }, r.prototype.convertValue = function(t, e) {
      return Bo(t, e);
    }, r;
  }()
);
function wX(r, t) {
  var e = new bX(), n = r.data, i = e.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
  r.seriesLayoutBy !== xi && (process.env.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), we(o));
  var s = [], l = {}, u = r.dimensionsDefine;
  if (u)
    L(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var _ = "";
        _t(l, m) && (process.env.NODE_ENV !== "production" && (_ = 'dimension name "' + m + '" duplicated.'), we(_)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < r.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var f = uO(i, xi);
  t.__isBuiltIn && (e.getRawDataItem = function(g) {
    return f(n, a, s, g);
  }, e.getRawData = gt(MX, null, r)), e.cloneRawData = gt(TX, null, r);
  var h = cO(i, xi);
  e.count = gt(h, null, n, a, s);
  var d = fO(i);
  e.retrieveValue = function(g, v) {
    var m = f(n, a, s, g);
    return p(m, v);
  };
  var p = e.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var m = s[v];
      if (m)
        return d(g, v, m.name);
    }
  };
  return e.getDimensionInfo = gt(AX, null, s, l), e.cloneAllDimensionInfo = gt(EX, null, s), e;
}
function MX(r) {
  var t = r.sourceFormat;
  if (!cb(t)) {
    var e = "";
    process.env.NODE_ENV !== "production" && (e = "`getRawData` is not supported in source format " + t), we(e);
  }
  return r.data;
}
function TX(r) {
  var t = r.sourceFormat, e = r.data;
  if (!cb(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), we(n);
  }
  if (t === Vr) {
    for (var i = [], a = 0, o = e.length; a < o; a++)
      i.push(e[a].slice());
    return i;
  } else if (t === Fn) {
    for (var i = [], a = 0, o = e.length; a < o; a++)
      i.push(j({}, e[a]));
    return i;
  }
}
function AX(r, t, e) {
  if (e != null) {
    if (fe(e) || !isNaN(e) && !_t(t, e))
      return r[e];
    if (_t(t, e))
      return t[e];
  }
}
function EX(r) {
  return Dt(r);
}
var vO = wt();
function CX(r) {
  r = Dt(r);
  var t = r.type, e = "";
  t || (process.env.NODE_ENV !== "production" && (e = "Must have a `type` when `registerTransform`."), we(e));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (e = 'Name must include namespace like "ns:regression".'), we(e));
  var i = !1;
  n[0] === "echarts" && (t = n[1], i = !0), r.__isBuiltIn = i, vO.set(t, r);
}
function DX(r, t, e) {
  var n = Ie(r), i = n.length, a = "";
  i || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), we(a));
  for (var o = 0, s = i; o < s; o++) {
    var l = n[o];
    t = LX(l, t, e, i === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function LX(r, t, e, n) {
  var i = "";
  t.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), we(i)), Lt(r) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof r + "."), we(i));
  var a = r.type, o = vO.get(a);
  o || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + a + '".'), we(i));
  var s = rt(t, function(c) {
    return wX(c, o);
  }), l = Ie(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: Dt(r.config)
  }));
  if (process.env.NODE_ENV !== "production" && r.print) {
    var u = rt(l, function(c) {
      var f = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + e.datasetIndex + f + " ===", "- transform result data:", dn(c.data), "- transform result dimensions:", dn(c.dimensions)].join(`
`);
    }).join(`
`);
    NP(u);
  }
  return rt(l, function(c, f) {
    var h = "";
    Lt(c) || (process.env.NODE_ENV !== "production" && (h = "A transform should not return some empty results."), we(h)), c.data || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be not be null or undefined"), we(h));
    var d = oO(c.data);
    cb(d) || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be array rows or object rows."), we(h));
    var p, g = t[0];
    if (g && f === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: xi,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: xi,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return $x(c.data, p, null);
  });
}
function cb(r) {
  return r === Vr || r === Fn;
}
var dm = "undefined", RX = typeof Uint32Array === dm ? Array : Uint32Array, IX = typeof Uint16Array === dm ? Array : Uint16Array, gO = typeof Int32Array === dm ? Array : Int32Array, vE = typeof Float64Array === dm ? Array : Float64Array, mO = {
  float: vE,
  int: gO,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: vE
}, a0;
function su(r) {
  return r > 65535 ? RX : IX;
}
function lu() {
  return [1 / 0, -1 / 0];
}
function PX(r) {
  var t = r.constructor;
  return t === Array ? r.slice() : new t(r);
}
function gE(r, t, e, n, i) {
  var a = mO[e || "float"];
  if (i) {
    var o = r[t], s = o && o.length;
    if (s !== n) {
      for (var l = new a(n), u = 0; u < s; u++)
        l[u] = o[u];
      r[t] = l;
    }
  } else
    r[t] = new a(n);
}
var Zx = (
  /** @class */
  function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = wt();
    }
    return r.prototype.initData = function(t, e, n) {
      process.env.NODE_ENV !== "production" && St(At(t.getItem) && At(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = t.getSource(), a = this.defaultDimValueGetter = a0[i.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var o = sO(i);
      this._dimensions = rt(e, function(s) {
        return process.env.NODE_ENV !== "production" && o && St(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(t, e) {
      var n = this._calcDimNameToIdx, i = this._dimensions, a = n.get(t);
      if (a != null) {
        if (i[a].type === e)
          return a;
      } else
        a = i.length;
      return i[a] = {
        type: e
      }, n.set(t, a), this._chunks[a] = new mO[e || "float"](this._rawCount), this._rawExtent[a] = lu(), a;
    }, r.prototype.collectOrdinalMeta = function(t, e) {
      var n = this._chunks[t], i = this._dimensions[t], a = this._rawExtent, o = i.ordinalOffset || 0, s = n.length;
      o === 0 && (a[t] = lu());
      for (var l = a[t], u = o; u < s; u++) {
        var c = n[u] = e.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = e, i.ordinalOffset = s, i.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(t) {
      var e = this._dimensions[t], n = e.ordinalMeta;
      return n;
    }, r.prototype.getDimensionProperty = function(t) {
      var e = this._dimensions[t];
      return e && e.property;
    }, r.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && St(!this._indices, "appendData can only be called on raw data.");
      var e = this._provider, n = this.count();
      e.appendData(t);
      var i = e.count();
      return e.persistent || (i += n), n < i && this._initDataFromProvider(n, i, !0), [n, i];
    }, r.prototype.appendValues = function(t, e) {
      for (var n = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e || 0), u = 0; u < a; u++) {
        var c = i[u];
        gE(n, u, c.type, l, !0);
      }
      for (var f = [], h = s; h < l; h++)
        for (var d = h - s, p = 0; p < a; p++) {
          var c = i[p], g = a0.arrayRows.call(this, t[d] || f, c.property, d, p);
          n[p][h] = g;
          var v = o[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(t, e, n) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = rt(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var f = o[c];
        l[c] || (l[c] = lu()), gE(a, c, f.type, e, n);
      }
      if (i.fillStorage)
        i.fillStorage(t, e, a, l);
      else
        for (var h = [], d = t; d < e; d++) {
          h = i.getItem(d, h);
          for (var p = 0; p < s; p++) {
            var g = a[p], v = this._dimValueGetter(h, u[p], d, p);
            g[d] = v;
            var m = l[p];
            v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = e, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(t, e) {
      if (!(e >= 0 && e < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(e)] : NaN;
    }, r.prototype.getValues = function(t, e) {
      var n = [], i = [];
      if (e == null) {
        e = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          i.push(a);
      } else
        i = t;
      for (var a = 0, o = i.length; a < o; a++)
        n.push(this.get(i[a], e));
      return n;
    }, r.prototype.getByRawIndex = function(t, e) {
      if (!(e >= 0 && e < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[e] : NaN;
    }, r.prototype.getSum = function(t) {
      var e = this._chunks[t], n = 0;
      if (e)
        for (var i = 0, a = this.count(); i < a; i++) {
          var o = this.get(t, i);
          isNaN(o) || (n += o);
        }
      return n;
    }, r.prototype.getMedian = function(t) {
      var e = [];
      this.each([t], function(a) {
        isNaN(a) || e.push(a);
      });
      var n = e.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var e = this._indices, n = e[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (e[o] < t)
          i = o + 1;
        else if (e[o] > t)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, r.prototype.getIndices = function() {
      var t, e = this._indices;
      if (e) {
        var n = e.constructor, i = this._count;
        if (n === Array) {
          t = new n(i);
          for (var a = 0; a < i; a++)
            t[a] = e[a];
        } else
          t = new n(e.buffer, 0, i);
      } else {
        var n = su(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, r.prototype.filter = function(t, e) {
      if (!this._count)
        return this;
      for (var n = this.clone(), i = n.count(), a = su(n._rawCount), o = new a(i), s = [], l = t.length, u = 0, c = t[0], f = n._chunks, h = 0; h < i; h++) {
        var d = void 0, p = n.getRawIndex(h);
        if (l === 0)
          d = e(h);
        else if (l === 1) {
          var g = f[c][p];
          d = e(g, h);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = f[t[v]][p];
          s[v] = h, d = e.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < i && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, r.prototype.selectRange = function(t) {
      var e = this.clone(), n = e._count;
      if (!n)
        return this;
      var i = se(t), a = i.length;
      if (!a)
        return this;
      var o = e.count(), s = su(e._rawCount), l = new s(o), u = 0, c = i[0], f = t[c][0], h = t[c][1], d = e._chunks, p = !1;
      if (!e._indices) {
        var g = 0;
        if (a === 1) {
          for (var v = d[i[0]], m = 0; m < n; m++) {
            var y = v[m];
            (y >= f && y <= h || isNaN(y)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (a === 2) {
          for (var v = d[i[0]], _ = d[i[1]], x = t[i[1]][0], b = t[i[1]][1], m = 0; m < n; m++) {
            var y = v[m], S = _[m];
            (y >= f && y <= h || isNaN(y)) && (S >= x && S <= b || isNaN(S)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (a === 1)
          for (var m = 0; m < o; m++) {
            var w = e.getRawIndex(m), y = d[i[0]][w];
            (y >= f && y <= h || isNaN(y)) && (l[u++] = w);
          }
        else
          for (var m = 0; m < o; m++) {
            for (var A = !0, w = e.getRawIndex(m), T = 0; T < a; T++) {
              var M = i[T], y = d[M][w];
              (y < t[M][0] || y > t[M][1]) && (A = !1);
            }
            A && (l[u++] = e.getRawIndex(m));
          }
      return u < o && (e._indices = l), e._count = u, e._extent = [], e._updateGetRawIdx(), e;
    }, r.prototype.map = function(t, e) {
      var n = this.clone(t);
      return this._updateDims(n, t, e), n;
    }, r.prototype.modify = function(t, e) {
      this._updateDims(this, t, e);
    }, r.prototype._updateDims = function(t, e, n) {
      for (var i = t._chunks, a = [], o = e.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < e.length; c++)
        u[e[c]] = lu();
      for (var f = 0; f < s; f++) {
        for (var h = t.getRawIndex(f), d = 0; d < o; d++)
          l[d] = i[e[d]][h];
        l[o] = f;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var g = e[c], v = p[c], m = u[g], y = i[g];
            y && (y[h] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(t, e) {
      var n = this.clone([t], !0), i = n._chunks, a = i[t], o = this.count(), s = 0, l = Math.floor(1 / e), u = this.getRawIndex(0), c, f, h, d = new (su(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var g = Math.min(p + l, o - 1), v = Math.min(p + l * 2, o), m = (v + g) / 2, y = 0, _ = g; _ < v; _++) {
          var x = this.getRawIndex(_), b = a[x];
          isNaN(b) || (y += b);
        }
        y /= v - g;
        var S = p, w = Math.min(p + l, o), A = p - 1, T = a[u];
        c = -1, h = S;
        for (var M = -1, C = 0, _ = S; _ < w; _++) {
          var x = this.getRawIndex(_), b = a[x];
          if (isNaN(b)) {
            C++, M < 0 && (M = x);
            continue;
          }
          f = Math.abs((A - m) * (b - T) - (A - _) * (y - T)), f > c && (c = f, h = x);
        }
        C > 0 && C < w - S && (d[s++] = Math.min(M, h), h = Math.max(M, h)), d[s++] = h, u = h;
      }
      return d[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = d, n.getRawIndex = this._getRawIdx, n;
    }, r.prototype.minmaxDownSample = function(t, e) {
      for (var n = this.clone([t], !0), i = n._chunks, a = Math.floor(1 / e), o = i[t], s = this.count(), l = new (su(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var f = c, h = o[this.getRawIndex(f)], d = c, p = o[this.getRawIndex(d)], g = a;
        c + a > s && (g = s - c);
        for (var v = 0; v < g; v++) {
          var m = this.getRawIndex(c + v), y = o[m];
          y < h && (h = y, f = c + v), y > p && (p = y, d = c + v);
        }
        var _ = this.getRawIndex(f), x = this.getRawIndex(d);
        f < d ? (l[u++] = _, l[u++] = x) : (l[u++] = x, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, r.prototype.downSample = function(t, e, n, i) {
      for (var a = this.clone([t], !0), o = a._chunks, s = [], l = Math.floor(1 / e), u = o[t], c = this.count(), f = a._rawExtent[t] = lu(), h = new (su(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < f[0] && (f[0] = m), m > f[1] && (f[1] = m), h[d++] = y;
      }
      return a._count = d, a._indices = h, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(t, e) {
      if (this._count)
        for (var n = t.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (n) {
            case 0:
              e(a);
              break;
            case 1:
              e(i[t[0]][s], a);
              break;
            case 2:
              e(i[t[0]][s], i[t[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = i[t[l]][s];
              u[l] = a, e.apply(null, u);
          }
        }
    }, r.prototype.getDataExtent = function(t) {
      var e = this._chunks[t], n = lu();
      if (!e)
        return n;
      var i = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[t].slice();
      if (o = this._extent[t], o)
        return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), f = e[c];
        f < s && (s = f), f > l && (l = f);
      }
      return o = [s, l], this._extent[t] = o, o;
    }, r.prototype.getRawDataItem = function(t) {
      var e = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(e);
      for (var n = [], i = this._chunks, a = 0; a < i.length; a++)
        n.push(i[a][e]);
      return n;
    }, r.prototype.clone = function(t, e) {
      var n = new r(), i = this._chunks, a = t && ra(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < i.length; o++)
          n._chunks[o] = a[o] ? PX(i[o]) : i[o];
      else
        n._chunks = i;
      return this._copyCommonProps(n), e || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, r.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = Dt(this._extent), t._rawExtent = Dt(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, e = void 0;
        if (t === Array) {
          var n = this._indices.length;
          e = new t(n);
          for (var i = 0; i < n; i++)
            e[i] = this._indices[i];
        } else
          e = new t(this._indices);
        return e;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, r.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function t(e, n, i, a) {
        return Bo(e[a], this._dimensions[a]);
      }
      a0 = {
        arrayRows: t,
        objectRows: function(e, n, i, a) {
          return Bo(e[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(e, n, i, a) {
          var o = e && (e.value == null ? e : e.value);
          return Bo(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(e, n, i, a) {
          return e[a];
        }
      };
    }(), r;
  }()
), yO = (
  /** @class */
  function() {
    function r(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, r.prototype._setLocalSource = function(t, e) {
      this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, e = this._getUpstreamSourceManagers(), n = !!e.length, i, a;
      if (tf(t)) {
        var o = t, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = e[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = hn(s) ? Oa : Vn, a = [];
        var f = this._getSourceMetaRawOption() || {}, h = u && u.metaRawOption || {}, d = bt(f.seriesLayoutBy, h.seriesLayoutBy) || null, p = bt(f.sourceHeader, h.sourceHeader), g = bt(f.dimensions, h.dimensions), v = d !== h.seriesLayoutBy || !!p != !!h.sourceHeader || g;
        i = v ? [$x(s, {
          seriesLayoutBy: d,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var y = this._applyTransform(e);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = m.get("source", !0);
          i = [$x(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && St(i && a), this._setLocalSource(i, a);
    }, r.prototype._applyTransform = function(t) {
      var e = this._sourceHost, n = e.get("transform", !0), i = e.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && St(i != null || n != null), i != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), yE(a));
      }
      var o, s = [], l = [];
      return L(t, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), f = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (f = "Can not retrieve result by `fromTransformResult`: " + i), yE(f)), s.push(c), l.push(u._getVersionSign());
      }), n ? o = DX(n, s, {
        datasetIndex: e.componentIndex
      }) : i != null && (o = [uX(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
        var n = t[e];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[e] !== n._getVersionSign()
        )
          return !0;
      }
    }, r.prototype.getSource = function(t) {
      t = t || 0;
      var e = this._sourceList[t];
      if (!e) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return e;
    }, r.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && St(tf(this._sourceHost), "Can only call getDataStore on series source manager.");
      var e = t.makeStoreSchema();
      return this._innerGetDataStore(e.dimensions, t.source, e.hash);
    }, r.prototype._innerGetDataStore = function(t, e, n) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        tf(this._sourceHost) && l ? s = l._innerGetDataStore(t, e, n) : (s = new Zx(), s.initData(new lO(e, t.length), t)), o[n] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (tf(t)) {
        var e = ab(t);
        return e ? [e.getSourceManager()] : [];
      } else
        return rt(k9(t), function(n) {
          return n.getSourceManager();
        });
    }, r.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, e, n, i;
      if (tf(t))
        e = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), i = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        e = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), i = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: e,
        sourceHeader: n,
        dimensions: i
      };
    }, r;
  }()
);
function mE(r) {
  var t = r.option.transform;
  t && _v(r.option.transform);
}
function tf(r) {
  return r.mainType === "series";
}
function yE(r) {
  throw new Error(r);
}
var NX = "line-height:1";
function _O(r) {
  var t = r.lineHeight;
  return t == null ? NX : "line-height:" + sn(t + "") + "px";
}
function xO(r, t) {
  var e = r.color || X.color.tertiary, n = r.fontSize || 12, i = r.fontWeight || "400", a = r.color || X.color.secondary, o = r.fontSize || 14, s = r.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + sn(n + "") + "px;color:" + sn(e) + ";font-weight:" + sn(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + sn(o + "") + "px;color:" + sn(a) + ";font-weight:" + sn(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: e,
      fontWeight: i
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var OX = [0, 10, 20, 30], kX = ["", `
`, `

`, `


`];
function fr(r, t) {
  return t.type = r, t;
}
function qx(r) {
  return r.type === "section";
}
function SO(r) {
  return qx(r) ? BX : VX;
}
function bO(r) {
  if (qx(r)) {
    var t = 0, e = r.blocks.length, n = e > 1 || e > 0 && !r.noHeader;
    return L(r.blocks, function(i) {
      var a = bO(i);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || qx(i) && !i.noHeader)));
    }), t;
  }
  return 0;
}
function BX(r, t, e, n) {
  var i = t.noHeader, a = FX(bO(t)), o = [], s = t.blocks || [];
  St(!s || et(s)), s = s || [];
  var l = r.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (_t(u, l)) {
      var c = new pO(u[l], null);
      s.sort(function(g, v) {
        return c.evaluate(g.sortParam, v.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  L(s, function(g, v) {
    var m = t.valueFormatter, y = SO(g)(
      // Inherit valueFormatter
      m ? j(j({}, r), {
        valueFormatter: m
      }) : r,
      g,
      v > 0 ? a.html : 0,
      n
    );
    y != null && o.push(y);
  });
  var f = r.renderMode === "richText" ? o.join(a.richText) : Kx(n, o.join(""), i ? e : a.html);
  if (i)
    return f;
  var h = Ux(t.header, "ordinal", r.useUTC), d = xO(n, r.renderMode).nameStyle, p = _O(n);
  return r.renderMode === "richText" ? wO(r, h, d) + a.richText + f : Kx(n, '<div style="' + d + ";" + p + ';">' + sn(h) + "</div>" + f, e);
}
function VX(r, t, e, n) {
  var i = r.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = r.useUTC, c = t.valueFormatter || r.valueFormatter || function(x) {
    return x = et(x) ? x : [x], rt(x, function(b, S) {
      return Ux(b, et(d) ? d[S] : d, u);
    });
  };
  if (!(a && o)) {
    var f = s ? "" : r.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || X.color.secondary, i), h = a ? "" : Ux(l, "ordinal", u), d = t.valueType, p = o ? [] : c(t.value, t.dataIndex), g = !s || !a, v = !s && a, m = xO(n, i), y = m.nameStyle, _ = m.valueStyle;
    return i === "richText" ? (s ? "" : f) + (a ? "" : wO(r, h, y)) + (o ? "" : GX(r, p, g, v, _)) : Kx(n, (s ? "" : f) + (a ? "" : zX(h, !s, y)) + (o ? "" : UX(p, g, v, _)), e);
  }
}
function _E(r, t, e, n, i, a) {
  if (r) {
    var o = SO(r), s = {
      useUTC: i,
      renderMode: e,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: r.valueFormatter
    };
    return o(s, r, 0, a);
  }
}
function FX(r) {
  return {
    html: OX[r],
    richText: kX[r]
  };
}
function Kx(r, t, e) {
  var n = '<div style="clear:both"></div>', i = "margin: " + e + "px 0 0", a = _O(r);
  return '<div style="' + i + ";" + a + ';">' + t + n + "</div>";
}
function zX(r, t, e) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + e + ";" + n + '">' + sn(r) + "</span>";
}
function UX(r, t, e, n) {
  var i = e ? "10px" : "20px", a = t ? "float:right;margin-left:" + i : "";
  return r = et(r) ? r : [r], '<span style="' + a + ";" + n + '">' + rt(r, function(o) {
    return sn(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wO(r, t, e) {
  return r.markupStyleCreator.wrapRichTextStyle(t, e);
}
function GX(r, t, e, n, i) {
  var a = [i], o = n ? 10 : 20;
  return e && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), r.markupStyleCreator.wrapRichTextStyle(et(t) ? t.join("  ") : t, a);
}
function MO(r, t) {
  var e = r.getData().getItemVisual(t, "style"), n = e[r.visualDrawType];
  return _l(n);
}
function TO(r, t) {
  var e = r.get("padding");
  return e ?? (t === "richText" ? [8, 10] : 10);
}
var o0 = (
  /** @class */
  function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = IP();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(t, e, n) {
      var i = n === "richText" ? this._generateStyleName() : null, a = T9({
        color: e,
        type: t,
        renderMode: n,
        markerId: i
      });
      return pt(a) ? a : (process.env.NODE_ENV !== "production" && St(i), this.richTextStyles[i] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(t, e) {
      var n = {};
      et(e) ? L(e, function(a) {
        return j(n, a);
      }) : j(n, e);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + t + "}";
    }, r;
  }()
);
function AO(r) {
  var t = r.series, e = r.dataIndex, n = r.multipleSeries, i = t.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(e), l = et(s), u = MO(t, e), c, f, h, d;
  if (o > 1 || l && !o) {
    var p = HX(s, t, e, a, u);
    c = p.inlineValues, f = p.inlineValueTypes, h = p.blocks, d = p.inlineValues[0];
  } else if (o) {
    var g = i.getDimensionInfo(a[0]);
    d = c = ac(i, e, a[0]), f = g.type;
  } else
    d = c = l ? s[0] : s;
  var v = R1(t), m = v && t.name || "", y = i.getName(e), _ = n ? m : y;
  return fr("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !v,
    sortParam: d,
    blocks: [fr("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !ei(_),
      value: c,
      valueType: f,
      dataIndex: e
    })].concat(h || [])
  });
}
function HX(r, t, e, n, i) {
  var a = t.getData(), o = ra(r, function(f, h, d) {
    var p = a.getDimensionInfo(d);
    return f = f || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? L(n, function(f) {
    c(ac(a, e, f), f);
  }) : L(r, c);
  function c(f, h) {
    var d = a.getDimensionInfo(h);
    !d || d.otherDims.tooltip === !1 || (o ? u.push(fr("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: d.displayName,
      value: f,
      valueType: d.type
    })) : (s.push(f), l.push(d.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var uo = ee();
function Zd(r, t) {
  return r.getName(t) || r.getId(t);
}
var ev = "__universalTransitionEnabled", ke = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e._selectedDataIndicesMap = {}, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = qf({
        count: XX,
        reset: YX
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(e, i);
      var a = uo(this).sourceManager = new yO(this);
      a.prepareSource();
      var o = this.getInitialData(e, i);
      SE(o, this), this.dataTask.context.data = o, process.env.NODE_ENV !== "production" && St(o, "getInitialData returned invalid data."), uo(this).dataBeforeProcessed = o, xE(this), this._initSelectedMapFromData(o);
    }, t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = uh(this), a = i ? Cl(e) : {}, o = this.subType;
      re.hasClass(o) && (o += "Series"), qt(e, n.getTheme().get(this.subType)), qt(e, this.getDefaultOption()), dl(e, "label", ["show"]), this.fillDataTextStyle(e.data), i && sa(e, a, i);
    }, t.prototype.mergeOption = function(e, n) {
      e = qt(this.option, e, !0), this.fillDataTextStyle(e.data);
      var i = uh(this);
      i && sa(this.option, e, i);
      var a = uo(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(e, n);
      SE(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, uo(this).dataBeforeProcessed = o, xE(this), this._initSelectedMapFromData(o);
    }, t.prototype.fillDataTextStyle = function(e) {
      if (e && !hn(e))
        for (var n = ["show"], i = 0; i < e.length; i++)
          e[i] && e[i].label && dl(e[i], "label", n);
    }, t.prototype.getInitialData = function(e, n) {
    }, t.prototype.appendData = function(e) {
      var n = this.getRawData();
      n.appendData(e.data);
    }, t.prototype.getData = function(e) {
      var n = jx(this);
      if (n) {
        var i = n.context.data;
        return e == null || !i.getLinkedData ? i : i.getLinkedData(e);
      } else
        return uo(this).data;
    }, t.prototype.getAllData = function() {
      var e = this.getData();
      return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [{
        data: e
      }];
    }, t.prototype.setData = function(e) {
      var n = jx(this);
      if (n) {
        var i = n.context;
        i.outputData = e, n !== this.dataTask && (i.data = e);
      }
      uo(this).data = e;
    }, t.prototype.getEncode = function() {
      var e = this.get("encode", !0);
      if (e)
        return wt(e);
    }, t.prototype.getSourceManager = function() {
      return uo(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return uo(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var e = this.get("colorBy");
      return e || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var e = this.coordinateSystem;
      return e && e.getBaseAxis && e.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(e, n, i, a) {
      var o = this.getData(), s = this.coordinateSystem, l = s && s.getAxis(e);
      if (!s || !l)
        return [];
      var u = l.dataToCoord(i);
      a == null && (a = 1 / 0);
      var c = [], f = 1 / 0, h = -1, d = 0;
      return o.each(n, function(p, g) {
        var v = l.dataToCoord(p), m = u - v, y = Math.abs(m);
        y <= a && ((y < f || y === f && m >= 0 && h < 0) && (f = y, h = m, d = 0), m === h && (c[d++] = g));
      }), c.length = d, c;
    }, t.prototype.formatTooltip = function(e, n, i) {
      return AO({
        series: this,
        dataIndex: e,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var e = this.ecModel;
      if (oe.node && !(e && e.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(e, n, i) {
      var a = this.ecModel, o = ob.prototype.getColorFromPalette.call(this, e, n, i);
      return o || (o = a.getColorFromPalette(e, n, i)), o;
    }, t.prototype.coordDimToDataDim = function(e) {
      return this.getRawData().mapDimensionsAll(e);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(e, n) {
      this._innerSelect(this.getData(n), e);
    }, t.prototype.unselect = function(e, n) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < e.length; s++) {
          var l = e[s], u = Zd(o, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(e, n) {
      for (var i = [], a = 0; a < e.length; a++)
        i[0] = e[a], this.isSelected(e[a], n) ? this.unselect(i, n) : this.select(i, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var e = this._selectedDataIndicesMap, n = se(e), i = [], a = 0; a < n.length; a++) {
        var o = e[n[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, t.prototype.isSelected = function(e, n) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var a = this.getData(n);
      return (i === "all" || i[Zd(a, e)]) && !a.getItemModel(e).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[ev])
        return !0;
      var e = this.option.universalTransition;
      return e ? e === !0 ? !0 : e && e.enabled : !1;
    }, t.prototype._innerSelect = function(e, n) {
      var i, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          Lt(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var f = n[c], h = Zd(e, f);
            u[h] = !0, this._selectedDataIndicesMap[h] = e.getRawIndex(f);
          }
        } else if (s === "single" || s === !0) {
          var d = n[l - 1], h = Zd(e, d);
          o.selectedMap = (i = {}, i[h] = !0, i), this._selectedDataIndicesMap = (a = {}, a[h] = e.getRawIndex(d), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(e) {
      if (!this.option.selectedMap) {
        var n = [];
        e.hasItemOption && e.each(function(i) {
          var a = e.getRawDataItem(i);
          a && a.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(e, n);
      }
    }, t.registerClass = function(e) {
      return re.registerClass(e);
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "series.__base__", e.seriesIndex = 0, e.ignoreStyleOnData = !1, e.hasSymbolVisual = !1, e.defaultSymbol = "circle", e.visualStyleAccessPath = "itemStyle", e.visualDrawType = "fill";
    }(), t;
  }(re)
);
dr(ke, hm);
dr(ke, ob);
GP(ke, re);
function xE(r) {
  var t = r.name;
  R1(r) || (r.name = WX(r) || t);
}
function WX(r) {
  var t = r.getRawData(), e = t.mapDimensionsAll("seriesName"), n = [];
  return L(e, function(i) {
    var a = t.getDimensionInfo(i);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function XX(r) {
  return r.model.getRawData().count();
}
function YX(r) {
  var t = r.model;
  return t.setData(t.getRawData().cloneShallow()), $X;
}
function $X(r, t) {
  t.outputData && r.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function SE(r, t) {
  L(eh(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(e) {
    r.wrapMethod(e, Yt(ZX, t));
  });
}
function ZX(r, t) {
  var e = jx(r);
  return e && e.setOutputEnd((t || this).count()), t;
}
function jx(r) {
  var t = (r.ecModel || {}).scheduler, e = t && t.getPipeline(r.uid);
  if (e) {
    var n = e.currentTask;
    if (n) {
      var i = n.agentStubMap;
      i && (n = i.get(r.uid));
    }
    return n;
  }
}
var Ge = (
  /** @class */
  function() {
    function r() {
      this.group = new Ct(), this.uid = Ec("viewComponent");
    }
    return r.prototype.init = function(t, e) {
    }, r.prototype.render = function(t, e, n, i) {
    }, r.prototype.dispose = function(t, e) {
    }, r.prototype.updateView = function(t, e, n, i) {
    }, r.prototype.updateLayout = function(t, e, n, i) {
    }, r.prototype.updateVisual = function(t, e, n, i) {
    }, r.prototype.toggleBlurSeries = function(t, e, n) {
    }, r.prototype.eachRendered = function(t) {
      var e = this.group;
      e && e.traverse(t);
    }, r;
  }()
);
P1(Ge);
qg(Ge);
function Dc() {
  var r = ee();
  return function(t) {
    var e = r(t), n = t.pipelineContext, i = !!e.large, a = !!e.progressiveRender, o = e.large = !!(n && n.large), s = e.progressiveRender = !!(n && n.progressiveRender);
    return (i !== o || a !== s) && "reset";
  };
}
var EO = ee(), qX = Dc(), Re = (
  /** @class */
  function() {
    function r() {
      this.group = new Ct(), this.uid = Ec("viewChart"), this.renderTask = qf({
        plan: KX,
        reset: jX
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(t, e) {
    }, r.prototype.render = function(t, e, n, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, r.prototype.highlight = function(t, e, n, i) {
      var a = t.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && ce("Unknown dataType " + i.dataType);
        return;
      }
      wE(a, i, "emphasis");
    }, r.prototype.downplay = function(t, e, n, i) {
      var a = t.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && ce("Unknown dataType " + i.dataType);
        return;
      }
      wE(a, i, "normal");
    }, r.prototype.remove = function(t, e) {
      this.group.removeAll();
    }, r.prototype.dispose = function(t, e) {
    }, r.prototype.updateView = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.updateLayout = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.updateVisual = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.eachRendered = function(t) {
      jo(this.group, t);
    }, r.markUpdateMethod = function(t, e) {
      EO(t).updateMethod = e;
    }, r.protoInitialize = function() {
      var t = r.prototype;
      t.type = "chart";
    }(), r;
  }()
);
function bE(r, t, e) {
  r && Go(r) && (t === "emphasis" ? Wa : Xa)(r, e);
}
function wE(r, t, e) {
  var n = pl(r, t), i = t && t.highlightKey != null ? y7(t.highlightKey) : null;
  n != null ? L(Ie(n), function(a) {
    bE(r.getItemGraphicEl(a), e, i);
  }) : r.eachItemGraphicEl(function(a) {
    bE(a, e, i);
  });
}
P1(Re, ["dispose"]);
qg(Re);
function KX(r) {
  return qX(r.model);
}
function jX(r) {
  var t = r.model, e = r.ecModel, n = r.api, i = r.payload, a = t.pipelineContext.progressiveRender, o = r.view, s = i && EO(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](t, e, n, i), JX[l];
}
var JX = {
  incrementalPrepareRender: {
    progress: function(r, t) {
      t.view.incrementalRender(r, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(r, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, Uv = "\0__throttleOriginMethod", ME = "\0__throttleRate", TE = "\0__throttleType";
function fb(r, t, e) {
  var n, i = 0, a = 0, o = null, s, l, u, c;
  t = t || 0;
  function f() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
  }
  var h = function() {
    for (var d = [], p = 0; p < arguments.length; p++)
      d[p] = arguments[p];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = c || t, v = c || e;
    c = null, s = n - (v ? i : a) - g, clearTimeout(o), v ? o = setTimeout(f, g) : s >= 0 ? f() : o = setTimeout(f, -s), i = n;
  };
  return h.clear = function() {
    o && (clearTimeout(o), o = null);
  }, h.debounceNextCall = function(d) {
    c = d;
  }, h;
}
function Lc(r, t, e, n) {
  var i = r[t];
  if (i) {
    var a = i[Uv] || i, o = i[TE], s = i[ME];
    if (s !== e || o !== n) {
      if (e == null || !n)
        return r[t] = a;
      i = r[t] = fb(a, e, n === "debounce"), i[Uv] = a, i[TE] = n, i[ME] = e;
    }
    return i;
  }
}
function fh(r, t) {
  var e = r[t];
  e && e[Uv] && (e.clear && e.clear(), r[t] = e[Uv]);
}
var AE = ee(), EE = {
  itemStyle: vl(DN, !0),
  lineStyle: vl(CN, !0)
}, QX = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function CO(r, t) {
  var e = r.visualStyleMapper || EE[t];
  return e || (console.warn("Unknown style type '" + t + "'."), EE.itemStyle);
}
function DO(r, t) {
  var e = r.visualDrawType || QX[t];
  return e || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var tY = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, t) {
    var e = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = r.getModel(n), a = CO(r, n), o = a(i), s = i.getShallow("decal");
    s && (e.setVisual("decal", s), s.dirty = !0);
    var l = DO(r, n), u = o[l], c = At(u) ? u : null, f = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || f) {
      var h = r.getColorFromPalette(
        // TODO series count changed.
        r.name,
        null,
        t.getSeriesCount()
      );
      o[l] || (o[l] = h, e.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || At(o.fill) ? h : o.fill, o.stroke = o.stroke === "auto" || At(o.stroke) ? h : o.stroke;
    }
    if (e.setVisual("style", o), e.setVisual("drawType", l), !t.isSeriesFiltered(r) && c)
      return e.setVisual("colorFromPalette", !1), {
        dataEach: function(d, p) {
          var g = r.getDataParams(p), v = j({}, o);
          v[l] = c(g), d.setItemVisual(p, "style", v);
        }
      };
  }
}, ef = new ue(), eY = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, t) {
    if (!(r.ignoreStyleOnData || t.isSeriesFiltered(r))) {
      var e = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = CO(r, n), a = e.getVisual("drawType");
      return {
        dataEach: e.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[n]) {
            ef.option = l[n];
            var u = i(ef), c = o.ensureUniqueItemVisual(s, "style");
            j(c, u), ef.option.decal && (o.setItemVisual(s, "decal", ef.option.decal), ef.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, rY = {
  performRawSeries: !0,
  overallReset: function(r) {
    var t = wt();
    r.eachSeries(function(e) {
      var n = e.getColorBy();
      if (!e.isColorBySeries()) {
        var i = e.type + "-" + n, a = t.get(i);
        a || (a = {}, t.set(i, a)), AE(e).scope = a;
      }
    }), r.eachSeries(function(e) {
      if (!(e.isColorBySeries() || r.isSeriesFiltered(e))) {
        var n = e.getRawData(), i = {}, a = e.getData(), o = AE(e).scope, s = e.visualStyleAccessPath || "itemStyle", l = DO(e, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          i[c] = u;
        }), n.each(function(u) {
          var c = i[u], f = a.getItemVisual(c, "colorFromPalette");
          if (f) {
            var h = a.ensureUniqueItemVisual(c, "style"), d = n.getName(u) || u + "", p = n.count();
            h[l] = e.getColorFromPalette(d, o, p);
          }
        });
      }
    });
  }
}, qd = Math.PI;
function nY(r, t) {
  t = t || {}, Bt(t, {
    text: "loading",
    textColor: X.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: X.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var e = new Ct(), n = new te({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  e.add(n);
  var i = new pe({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new te({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  e.add(a);
  var o;
  return t.showSpinner && (o = new im({
    shape: {
      startAngle: -qd / 2,
      endAngle: -qd / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: qd * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: qd * 3 / 2
  }).delay(300).start("circularInOut"), e.add(o)), e.resize = function() {
    var s = i.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = r.getHeight() / 2;
    t.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: r.getWidth(),
      height: r.getHeight()
    });
  }, e.resize(), e;
}
var LO = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this._stageTaskMap = wt(), this.ecInstance = t, this.api = e, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return r.prototype.restoreData = function(t, e) {
      t.restoreData(e), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, r.prototype.getPerformArgs = function(t, e) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), i = n.context, a = !e && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, r.prototype.updateStreamModes = function(t, e) {
      var n = this._pipelineMap.get(t.uid), i = t.getData(), a = i.count(), o = n.progressiveEnabled && e.incrementalPrepareRender && a >= n.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(t) {
      var e = this, n = e._pipelineMap = wt();
      t.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), e._pipe(i, i.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, e = this.api.getModel(), n = this.api;
      L(this._allHandlers, function(i) {
        var a = t.get(i.uid) || t.set(i.uid, {}), o = "";
        process.env.NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), St(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, e, n), i.overallReset && this._createOverallStageTask(i, a, e, n);
      }, this);
    }, r.prototype.prepareView = function(t, e, n, i) {
      var a = t.renderTask, o = a.context;
      o.model = e, o.ecModel = n, o.api = i, a.__block = !t.incrementalPrepareRender, this._pipe(e, a);
    }, r.prototype.performDataProcessorTasks = function(t, e) {
      this._performStageTasks(this._dataProcessorHandlers, t, e, {
        block: !0
      });
    }, r.prototype.performVisualTasks = function(t, e, n) {
      this._performStageTasks(this._visualHandlers, t, e, n);
    }, r.prototype._performStageTasks = function(t, e, n, i) {
      i = i || {};
      var a = !1, o = this;
      L(t, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), f = c.seriesTaskMap, h = c.overallTask;
          if (h) {
            var d, p = h.agentStubMap;
            p.each(function(v) {
              s(i, v) && (v.dirty(), d = !0);
            }), d && h.dirty(), o.updatePayload(h, n);
            var g = o.getPerformArgs(h, i.block);
            p.each(function(v) {
              v.perform(g);
            }), h.perform(g) && (a = !0);
          } else
            f && f.each(function(v, m) {
              s(i, v) && v.dirty();
              var y = o.getPerformArgs(v, i.block);
              y.skip = !l.performRawSeries && e.isSeriesFiltered(v.context.model), o.updatePayload(v, n), v.perform(y) && (a = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(t) {
      var e;
      t.eachSeries(function(n) {
        e = n.dataTask.perform() || e;
      }), this.unfinished = e || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var e = t.tail;
        do {
          if (e.__block) {
            t.blockIndex = e.__idxInPipeline;
            break;
          }
          e = e.getUpstream();
        } while (e);
      });
    }, r.prototype.updatePayload = function(t, e) {
      e !== "remain" && (t.context.payload = e);
    }, r.prototype._createSeriesStageTask = function(t, e, n, i) {
      var a = this, o = e.seriesTaskMap, s = e.seriesTaskMap = wt(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(f) {
        var h = f.uid, d = s.set(h, o && o.get(h) || qf({
          plan: lY,
          reset: uY,
          count: fY
        }));
        d.context = {
          model: f,
          ecModel: n,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(f, d);
      }
    }, r.prototype._createOverallStageTask = function(t, e, n, i) {
      var a = this, o = e.overallTask = e.overallTask || qf({
        reset: iY
      });
      o.context = {
        ecModel: n,
        api: i,
        overallReset: t.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = wt(), u = t.seriesType, c = t.getTargetSeries, f = !0, h = !1, d = "";
      process.env.NODE_ENV !== "production" && (d = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), St(!t.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (f = !1, L(n.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (h = !0, qf({
          reset: aY,
          onDirty: sY
        })));
        m.context = {
          model: g,
          overallProgress: f
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = o, m.__block = f, a._pipe(g, m);
      }
      h && o.dirty();
    }, r.prototype._pipe = function(t, e) {
      var n = t.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = e), i.tail && i.tail.pipe(e), i.tail = e, e.__idxInPipeline = i.count++, e.__pipeline = i;
    }, r.wrapStageHandler = function(t, e) {
      return At(t) && (t = {
        overallReset: t,
        seriesType: hY(t)
      }), t.uid = Ec("stageHandler"), e && (t.visualType = e), t;
    }, r;
  }()
);
function iY(r) {
  r.overallReset(r.ecModel, r.api, r.payload);
}
function aY(r) {
  return r.overallProgress && oY;
}
function oY() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function sY() {
  this.agent && this.agent.dirty();
}
function lY(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
}
function uY(r) {
  r.useClearVisual && r.data.clearAllVisual();
  var t = r.resetDefines = Ie(r.reset(r.model, r.ecModel, r.api, r.payload));
  return t.length > 1 ? rt(t, function(e, n) {
    return RO(n);
  }) : cY;
}
var cY = RO(0);
function RO(r) {
  return function(t, e) {
    var n = e.data, i = e.resetDefines[r];
    if (i && i.dataEach)
      for (var a = t.start; a < t.end; a++)
        i.dataEach(n, a);
    else
      i && i.progress && i.progress(t, n);
  };
}
function fY(r) {
  return r.data.count();
}
function hY(r) {
  Gv = null;
  try {
    r(hh, IO);
  } catch {
  }
  return Gv;
}
var hh = {}, IO = {}, Gv;
PO(hh, sb);
PO(IO, nO);
hh.eachSeriesByType = hh.eachRawSeriesByType = function(r) {
  Gv = r;
};
hh.eachComponent = function(r) {
  r.mainType === "series" && r.subType && (Gv = r.subType);
};
function PO(r, t) {
  for (var e in t.prototype)
    r[e] = rr;
}
var Nt = X.darkColor, dY = Nt.background, rf = function() {
  return {
    axisLine: {
      lineStyle: {
        color: Nt.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: Nt.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [Nt.backgroundTint, Nt.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: Nt.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: Nt.axisLabel
    },
    axisName: {}
  };
}, CE = {
  label: {
    color: Nt.secondary
  },
  itemStyle: {
    borderColor: Nt.borderTint
  },
  dividerLineStyle: {
    color: Nt.border
  }
}, NO = {
  darkMode: !0,
  color: Nt.theme,
  backgroundColor: dY,
  axisPointer: {
    lineStyle: {
      color: Nt.border
    },
    crossStyle: {
      color: Nt.borderShade
    },
    label: {
      color: Nt.tertiary
    }
  },
  legend: {
    textStyle: {
      color: Nt.secondary
    },
    pageTextStyle: {
      color: Nt.tertiary
    }
  },
  textStyle: {
    color: Nt.secondary
  },
  title: {
    textStyle: {
      color: Nt.primary
    },
    subtextStyle: {
      color: Nt.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: Nt.accent50
    }
  },
  tooltip: {
    backgroundColor: Nt.neutral20,
    defaultBorderColor: Nt.border,
    textStyle: {
      color: Nt.tertiary
    }
  },
  dataZoom: {
    borderColor: Nt.accent10,
    textStyle: {
      color: Nt.tertiary
    },
    brushStyle: {
      color: Nt.backgroundTint
    },
    handleStyle: {
      color: Nt.neutral00,
      borderColor: Nt.accent20
    },
    moveHandleStyle: {
      color: Nt.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: Nt.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: Nt.accent30
      },
      areaStyle: {
        color: Nt.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: Nt.accent50
      },
      areaStyle: {
        color: Nt.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: Nt.secondary
    },
    handleStyle: {
      borderColor: Nt.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: Nt.accent10
    },
    label: {
      color: Nt.tertiary
    },
    controlStyle: {
      color: Nt.accent30,
      borderColor: Nt.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: Nt.neutral00,
      borderColor: Nt.neutral20
    },
    dayLabel: {
      color: Nt.tertiary
    },
    monthLabel: {
      color: Nt.secondary
    },
    yearLabel: {
      color: Nt.secondary
    }
  },
  matrix: {
    x: CE,
    y: CE,
    backgroundColor: {
      borderColor: Nt.axisLine
    },
    body: {
      itemStyle: {
        borderColor: Nt.borderTint
      }
    }
  },
  timeAxis: rf(),
  logAxis: rf(),
  valueAxis: rf(),
  categoryAxis: rf(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: Nt.theme
  },
  gauge: {
    title: {
      color: Nt.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, Nt.neutral05]]
      }
    },
    axisLabel: {
      color: Nt.axisLabel
    },
    detail: {
      color: Nt.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: Nt.background
    }
  },
  radar: function() {
    var r = rf();
    return r.axisName = {
      color: Nt.axisLabel
    }, r.axisLine.lineStyle.color = Nt.neutral20, r;
  }(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: Nt.neutral20,
        textStyle: {
          color: Nt.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: Nt.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: Nt.background
    }
  },
  map: {
    itemStyle: {
      borderColor: Nt.border,
      areaColor: Nt.neutral10
    },
    label: {
      color: Nt.tertiary
    },
    emphasis: {
      label: {
        color: Nt.primary
      },
      itemStyle: {
        areaColor: Nt.highlight
      }
    },
    select: {
      label: {
        color: Nt.primary
      },
      itemStyle: {
        areaColor: Nt.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: Nt.border,
      areaColor: Nt.neutral10
    },
    emphasis: {
      label: {
        color: Nt.primary
      },
      itemStyle: {
        areaColor: Nt.highlight
      }
    },
    select: {
      label: {
        color: Nt.primary
      },
      itemStyle: {
        color: Nt.highlight
      }
    }
  }
};
NO.categoryAxis.splitLine.show = !1;
var pY = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(t) {
      var e = {}, n = {}, i = {};
      if (pt(t)) {
        var a = Zi(t);
        e.mainType = a.main || null, e.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        L(t, function(l, u) {
          for (var c = !1, f = 0; f < o.length; f++) {
            var h = o[f], d = u.lastIndexOf(h);
            if (d > 0 && d === u.length - h.length) {
              var p = u.slice(0, d);
              p !== "data" && (e.mainType = p, e[h.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: e,
        dataQuery: n,
        otherQuery: i
      };
    }, r.prototype.filter = function(t, e) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var i = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s)
        return !0;
      var l = e.cptQuery, u = e.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, i, a));
      function c(f, h, d, p) {
        return f[d] == null || h[p || d] === f[d];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }()
), Jx = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], DE = Jx.concat(["symbolKeepAspect"]), vY = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    var e = r.getData();
    if (r.legendIcon && e.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual)
      return;
    for (var n = {}, i = {}, a = !1, o = 0; o < Jx.length; o++) {
      var s = Jx[o], l = r.get(s);
      At(l) ? (a = !0, i[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || r.defaultSymbol, e.setVisual(j({
      legendIcon: r.legendIcon || n.symbol,
      symbolKeepAspect: r.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(r))
      return;
    var u = se(i);
    function c(f, h) {
      for (var d = r.getRawValue(h), p = r.getDataParams(h), g = 0; g < u.length; g++) {
        var v = u[g];
        f.setItemVisual(h, v, i[v](d, p));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, gY = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    if (!r.hasSymbolVisual || t.isSeriesFiltered(r))
      return;
    var e = r.getData();
    function n(i, a) {
      for (var o = i.getItemModel(a), s = 0; s < DE.length; s++) {
        var l = DE[s], u = o.getShallow(l, !0);
        u != null && i.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: e.hasItemOption ? n : null
    };
  }
};
function hb(r, t, e) {
  switch (e) {
    case "color":
      var n = r.getItemVisual(t, "style");
      return n[r.getVisual("drawType")];
    case "opacity":
      return r.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getItemVisual(t, e);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function Gh(r, t) {
  switch (t) {
    case "color":
      var e = r.getVisual("style");
      return e[r.getVisual("drawType")];
    case "opacity":
      return r.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function OO(r, t, e, n) {
  switch (e) {
    case "color":
      var i = r.ensureUniqueItemVisual(t, "style");
      i[r.getVisual("drawType")] = n, r.setItemVisual(t, "colorFromPalette", !1);
      break;
    case "opacity":
      r.ensureUniqueItemVisual(t, "style").opacity = n;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      r.setItemVisual(t, e, n);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function kO(r, t) {
  function e(n, i) {
    var a = [];
    return n.eachComponent({
      mainType: "series",
      subType: r,
      query: i
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  L([[r + "ToggleSelect", "toggleSelect"], [r + "Select", "select"], [r + "UnSelect", "unselect"]], function(n) {
    t(n[0], function(i, a, o) {
      i = j({}, i), process.env.NODE_ENV !== "production" && or(i.type, n[1]), o.dispatchAction(j(i, {
        type: n[1],
        seriesIndex: e(a, i)
      }));
    });
  });
}
function uu(r, t, e, n, i) {
  var a = r + t;
  e.isSilent(a) || (process.env.NODE_ENV !== "production" && aa("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var f = o.getData(), h = pl(f, i.fromActionPayload);
        e.trigger(a, {
          type: a,
          seriesId: o.id,
          name: et(h) ? f.getName(h[0]) : f.getName(h),
          selected: pt(l) ? l : j({}, l)
        });
      }
  }));
}
function mY(r, t, e) {
  r.on("selectchanged", function(n) {
    var i = e.getModel();
    n.isFromClick ? (uu("map", "selectchanged", t, i, n), uu("pie", "selectchanged", t, i, n)) : n.fromAction === "select" ? (uu("map", "selected", t, i, n), uu("pie", "selected", t, i, n)) : n.fromAction === "unselect" && (uu("map", "unselected", t, i, n), uu("pie", "unselected", t, i, n));
  });
}
function Qs(r, t, e) {
  for (var n; r && !(t(r) && (n = r, e)); )
    r = r.__hostTarget || r.parent;
  return n;
}
var yY = Math.round(Math.random() * 9), _Y = typeof Object.defineProperty == "function", xY = function() {
  function r() {
    this._id = "__ec_inner_" + yY++;
  }
  return r.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, r.prototype.set = function(t, e) {
    var n = this._guard(t);
    return _Y ? Object.defineProperty(n, this._id, {
      value: e,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = e, this;
  }, r.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, r.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, r.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, r;
}(), SY = ne.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.cx, n = t.cy, i = t.width / 2, a = t.height / 2;
    r.moveTo(e, n - a), r.lineTo(e + i, n + a), r.lineTo(e - i, n + a), r.closePath();
  }
}), bY = ne.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.cx, n = t.cy, i = t.width / 2, a = t.height / 2;
    r.moveTo(e, n - a), r.lineTo(e + i, n), r.lineTo(e, n + a), r.lineTo(e - i, n), r.closePath();
  }
}), wY = ne.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.x, n = t.y, i = t.width / 5 * 3, a = Math.max(i, t.height), o = i / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, f = Math.sin(u), h = Math.cos(u), d = o * 0.6, p = o * 0.7;
    r.moveTo(e - c, l + s), r.arc(e, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(e + c - f * d, l + s + h * d, e, n - p, e, n), r.bezierCurveTo(e, n - p, e - c + f * d, l + s + h * d, e - c, l + s), r.closePath();
  }
}), MY = ne.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.height, n = t.width, i = t.x, a = t.y, o = n / 3 * 2;
    r.moveTo(i, a), r.lineTo(i + o, a + e), r.lineTo(i, a + e / 4 * 3), r.lineTo(i - o, a + e), r.lineTo(i, a), r.closePath();
  }
}), TY = {
  line: lr,
  rect: te,
  roundRect: te,
  square: te,
  circle: Ka,
  diamond: bY,
  pin: wY,
  arrow: MY,
  triangle: SY
}, AY = {
  line: function(r, t, e, n, i) {
    i.x1 = r, i.y1 = t + n / 2, i.x2 = r + e, i.y2 = t + n / 2;
  },
  rect: function(r, t, e, n, i) {
    i.x = r, i.y = t, i.width = e, i.height = n;
  },
  roundRect: function(r, t, e, n, i) {
    i.x = r, i.y = t, i.width = e, i.height = n, i.r = Math.min(e, n) / 4;
  },
  square: function(r, t, e, n, i) {
    var a = Math.min(e, n);
    i.x = r, i.y = t, i.width = a, i.height = a;
  },
  circle: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.r = Math.min(e, n) / 2;
  },
  diamond: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.width = e, i.height = n;
  },
  pin: function(r, t, e, n, i) {
    i.x = r + e / 2, i.y = t + n / 2, i.width = e, i.height = n;
  },
  arrow: function(r, t, e, n, i) {
    i.x = r + e / 2, i.y = t + n / 2, i.width = e, i.height = n;
  },
  triangle: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.width = e, i.height = n;
  }
}, Hv = {};
L(TY, function(r, t) {
  Hv[t] = new r();
});
var EY = ne.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(r, t, e) {
    var n = Dv(r, t, e), i = this.shape;
    return i && i.symbolType === "pin" && t.position === "inside" && (n.y = e.y + e.height * 0.4), n;
  },
  buildPath: function(r, t, e) {
    var n = t.symbolType;
    if (n !== "none") {
      var i = Hv[n];
      i || (n = "rect", i = Hv[n]), AY[n](t.x, t.y, t.width, t.height, i.shape), i.buildPath(r, i.shape, e);
    }
  }
});
function CY(r, t) {
  if (this.type !== "image") {
    var e = this.style;
    this.__isEmptyBrush ? (e.stroke = r, e.fill = t || X.color.neutral00, e.lineWidth = 2) : this.shape.symbolType === "line" ? e.stroke = r : e.fill = r, this.markRedraw();
  }
}
function hr(r, t, e, n, i, a, o) {
  var s = r.indexOf("empty") === 0;
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
  var l;
  return r.indexOf("image://") === 0 ? l = yN(r.slice(8), new Vt(t, e, n, i), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = sh(r.slice(7), {}, new Vt(t, e, n, i), o ? "center" : "cover") : l = new EY({
    shape: {
      symbolType: r,
      x: t,
      y: e,
      width: n,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = CY, a && l.setColor(a), l;
}
function Rc(r) {
  return et(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0];
}
function Ll(r, t) {
  if (r != null)
    return et(r) || (r = [r, r]), [dt(r[0], t[0]) || 0, dt(bt(r[1], r[0]), t[1]) || 0];
}
function tl(r) {
  return isFinite(r);
}
function DY(r, t, e) {
  var n = t.x == null ? 0 : t.x, i = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * e.width + e.x, i = i * e.width + e.x, a = a * e.height + e.y, o = o * e.height + e.y), n = tl(n) ? n : 0, i = tl(i) ? i : 1, a = tl(a) ? a : 0, o = tl(o) ? o : 0;
  var s = r.createLinearGradient(n, a, i, o);
  return s;
}
function LY(r, t, e) {
  var n = e.width, i = e.height, a = Math.min(n, i), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (o = o * n + e.x, s = s * i + e.y, l = l * a), o = tl(o) ? o : 0.5, s = tl(s) ? s : 0.5, l = l >= 0 && tl(l) ? l : 0.5;
  var u = r.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function Qx(r, t, e) {
  for (var n = t.type === "radial" ? LY(r, t, e) : DY(r, t, e), i = t.colorStops, a = 0; a < i.length; a++)
    n.addColorStop(i[a].offset, i[a].color);
  return n;
}
function RY(r, t) {
  if (r === t || !r && !t)
    return !1;
  if (!r || !t || r.length !== t.length)
    return !0;
  for (var e = 0; e < r.length; e++)
    if (r[e] !== t[e])
      return !0;
  return !1;
}
function Kd(r) {
  return parseInt(r, 10);
}
function Fu(r, t, e) {
  var n = ["width", "height"][t], i = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
  if (e[n] != null && e[n] !== "auto")
    return parseFloat(e[n]);
  var s = document.defaultView.getComputedStyle(r);
  return (r[i] || Kd(s[n]) || Kd(r.style[n])) - (Kd(s[a]) || 0) - (Kd(s[o]) || 0) | 0;
}
function IY(r, t) {
  return !r || r === "solid" || !(t > 0) ? null : r === "dashed" ? [4 * t, 2 * t] : r === "dotted" ? [t] : fe(r) ? [r] : et(r) ? r : null;
}
function db(r) {
  var t = r.style, e = t.lineDash && t.lineWidth > 0 && IY(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (e) {
    var i = t.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
    i && i !== 1 && (e = rt(e, function(a) {
      return a / i;
    }), n /= i);
  }
  return [e, n];
}
var PY = new oa(!0);
function Wv(r) {
  var t = r.stroke;
  return !(t == null || t === "none" || !(r.lineWidth > 0));
}
function LE(r) {
  return typeof r == "string" && r !== "none";
}
function Xv(r) {
  var t = r.fill;
  return t != null && t !== "none";
}
function RE(r, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var e = r.globalAlpha;
    r.globalAlpha = t.fillOpacity * t.opacity, r.fill(), r.globalAlpha = e;
  } else
    r.fill();
}
function IE(r, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var e = r.globalAlpha;
    r.globalAlpha = t.strokeOpacity * t.opacity, r.stroke(), r.globalAlpha = e;
  } else
    r.stroke();
}
function tS(r, t, e) {
  var n = N1(t.image, t.__image, e);
  if (Kg(n)) {
    var i = r.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * Gp), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), i.setTransform(a);
    }
    return i;
  }
}
function NY(r, t, e, n) {
  var i, a = Wv(e), o = Xv(e), s = e.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || PY, f = t.__dirty;
  if (!n) {
    var h = e.fill, d = e.stroke, p = o && !!h.colorStops, g = a && !!d.colorStops, v = o && !!h.image, m = a && !!d.image, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0;
    (p || g) && (S = t.getBoundingRect()), p && (y = f ? Qx(r, h, S) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (_ = f ? Qx(r, d, S) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = _), v && (x = f || !t.__canvasFillPattern ? tS(r, h, t) : t.__canvasFillPattern, t.__canvasFillPattern = x), m && (b = f || !t.__canvasStrokePattern ? tS(r, d, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = b), p ? r.fillStyle = y : v && (x ? r.fillStyle = x : o = !1), g ? r.strokeStyle = _ : m && (b ? r.strokeStyle = b : a = !1);
  }
  var w = t.getGlobalScale();
  c.setScale(w[0], w[1], t.segmentIgnoreThreshold);
  var A, T;
  r.setLineDash && e.lineDash && (i = db(t), A = i[0], T = i[1]);
  var M = !0;
  (u || f & Cu) && (c.setDPR(r.dpr), l ? c.setContext(null) : (c.setContext(r), M = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), M && c.rebuildPath(r, l ? s : 1), A && (r.setLineDash(A), r.lineDashOffset = T), n || (e.strokeFirst ? (a && IE(r, e), o && RE(r, e)) : (o && RE(r, e), a && IE(r, e))), A && r.setLineDash([]);
}
function OY(r, t, e) {
  var n = t.__image = N1(e.image, t.__image, t, t.onload);
  if (!(!n || !Kg(n))) {
    var i = e.x || 0, a = e.y || 0, o = t.getWidth(), s = t.getHeight(), l = n.width / n.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), e.sWidth && e.sHeight) {
      var u = e.sx || 0, c = e.sy || 0;
      r.drawImage(n, u, c, e.sWidth, e.sHeight, i, a, o, s);
    } else if (e.sx && e.sy) {
      var u = e.sx, c = e.sy, f = o - u, h = s - c;
      r.drawImage(n, u, c, f, h, i, a, o, s);
    } else
      r.drawImage(n, i, a, o, s);
  }
}
function kY(r, t, e) {
  var n, i = e.text;
  if (i != null && (i += ""), i) {
    r.font = e.font || Ua, r.textAlign = e.textAlign, r.textBaseline = e.textBaseline;
    var a = void 0, o = void 0;
    r.setLineDash && e.lineDash && (n = db(t), a = n[0], o = n[1]), a && (r.setLineDash(a), r.lineDashOffset = o), e.strokeFirst ? (Wv(e) && r.strokeText(i, e.x, e.y), Xv(e) && r.fillText(i, e.x, e.y)) : (Xv(e) && r.fillText(i, e.x, e.y), Wv(e) && r.strokeText(i, e.x, e.y)), a && r.setLineDash([]);
  }
}
var PE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], NE = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function BO(r, t, e, n, i) {
  var a = !1;
  if (!n && (e = e || {}, t === e))
    return !1;
  if (n || t.opacity !== e.opacity) {
    xn(r, i), a = !0;
    var o = Math.max(Math.min(t.opacity, 1), 0);
    r.globalAlpha = isNaN(o) ? il.opacity : o;
  }
  (n || t.blend !== e.blend) && (a || (xn(r, i), a = !0), r.globalCompositeOperation = t.blend || il.blend);
  for (var s = 0; s < PE.length; s++) {
    var l = PE[s];
    (n || t[l] !== e[l]) && (a || (xn(r, i), a = !0), r[l] = r.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== e.shadowColor) && (a || (xn(r, i), a = !0), r.shadowColor = t.shadowColor || il.shadowColor), a;
}
function OE(r, t, e, n, i) {
  var a = dh(t, i.inHover), o = n ? null : e && dh(e, i.inHover) || {};
  if (a === o)
    return !1;
  var s = BO(r, a, o, n, i);
  if ((n || a.fill !== o.fill) && (s || (xn(r, i), s = !0), LE(a.fill) && (r.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (xn(r, i), s = !0), LE(a.stroke) && (r.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (xn(r, i), s = !0), r.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    r.lineWidth !== u && (s || (xn(r, i), s = !0), r.lineWidth = u);
  }
  for (var c = 0; c < NE.length; c++) {
    var f = NE[c], h = f[0];
    (n || a[h] !== o[h]) && (s || (xn(r, i), s = !0), r[h] = a[h] || f[1]);
  }
  return s;
}
function BY(r, t, e, n, i) {
  return BO(r, dh(t, i.inHover), e && dh(e, i.inHover), n, i);
}
function VO(r, t) {
  var e = t.transform, n = r.dpr || 1;
  e ? r.setTransform(n * e[0], n * e[1], n * e[2], n * e[3], n * e[4], n * e[5]) : r.setTransform(n, 0, 0, n, 0, 0);
}
function VY(r, t, e) {
  for (var n = !1, i = 0; i < r.length; i++) {
    var a = r[i];
    n = n || a.isZeroArea(), VO(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  e.allClipped = n;
}
function FY(r, t) {
  return r && t ? r[0] !== t[0] || r[1] !== t[1] || r[2] !== t[2] || r[3] !== t[3] || r[4] !== t[4] || r[5] !== t[5] : !(!r && !t);
}
var kE = 1, BE = 2, VE = 3, FE = 4;
function zY(r) {
  var t = Xv(r), e = Wv(r);
  return !(r.lineDash || !(+t ^ +e) || t && typeof r.fill != "string" || e && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
}
function xn(r, t) {
  t.batchFill && r.fill(), t.batchStroke && r.stroke(), t.batchFill = "", t.batchStroke = "";
}
function dh(r, t) {
  return t && r.__hoverStyle || r.style;
}
function FO(r, t) {
  el(r, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function el(r, t, e, n) {
  var i = t.transform;
  if (!t.shouldBePainted(e.viewWidth, e.viewHeight, !1, !1)) {
    t.__dirty &= ~In, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, o = e.prevElClipPaths, s = !1, l = !1;
  if ((!o || RY(a, o)) && (o && o.length && (xn(r, e), r.restore(), l = s = !0, e.prevElClipPaths = null, e.allClipped = !1, e.prevEl = null), a && a.length && (xn(r, e), r.save(), VY(a, r, e), s = !0), e.prevElClipPaths = a), e.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = e.prevEl;
  u || (l = s = !0);
  var c = t instanceof ne && t.autoBatch && zY(t.style);
  s || FY(i, u.transform) ? (xn(r, e), VO(r, t)) : c || xn(r, e);
  var f = dh(t, e.inHover);
  t instanceof ne ? (e.lastDrawType !== kE && (l = !0, e.lastDrawType = kE), OE(r, t, u, l, e), (!c || !e.batchFill && !e.batchStroke) && r.beginPath(), NY(r, t, f, c), c && (e.batchFill = f.fill || "", e.batchStroke = f.stroke || "")) : t instanceof nc ? (e.lastDrawType !== VE && (l = !0, e.lastDrawType = VE), OE(r, t, u, l, e), kY(r, t, f)) : t instanceof Fr ? (e.lastDrawType !== BE && (l = !0, e.lastDrawType = BE), BY(r, t, u, l, e), OY(r, t, f)) : t.getTemporalDisplayables && (e.lastDrawType !== FE && (l = !0, e.lastDrawType = FE), UY(r, t, e)), c && n && xn(r, e), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), e.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function UY(r, t, e) {
  var n = t.getDisplayables(), i = t.getTemporalDisplayables();
  r.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: e.viewWidth,
    viewHeight: e.viewHeight,
    inHover: e.inHover
  }, o, s;
  for (o = t.getCursor(), s = n.length; o < s; o++) {
    var l = n[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), el(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), el(r, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, r.restore();
}
var s0 = new xY(), zE = new tc(100), UE = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function oc(r, t) {
  if (r === "none")
    return null;
  var e = t.getDevicePixelRatio(), n = t.getZr(), i = n.painter.type === "svg";
  r.dirty && s0.delete(r);
  var a = s0.get(r);
  if (a)
    return a;
  var o = Bt(r, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / e, s0.set(r, s), r.dirty = !1, s;
  function l(u) {
    for (var c = [e], f = !0, h = 0; h < UE.length; ++h) {
      var d = o[UE[h]];
      if (d != null && !et(d) && !pt(d) && !fe(d) && typeof d != "boolean") {
        f = !1;
        break;
      }
      c.push(d);
    }
    var p;
    if (f) {
      p = c.join(",") + (i ? "-svg" : "");
      var g = zE.get(p);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var v = UO(o.dashArrayX), m = GY(o.dashArrayY), y = zO(o.symbol), _ = HY(v), x = GO(m), b = !i && Si.createCanvas(), S = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, w = T(), A;
    b && (b.width = w.width * e, b.height = w.height * e, A = b.getContext("2d")), M(), f && zE.put(p, b || S), u.image = b, u.svgElement = S, u.svgWidth = w.width, u.svgHeight = w.height;
    function T() {
      for (var C = 1, R = 0, E = _.length; R < E; ++R)
        C = tA(C, _[R]);
      for (var D = 1, R = 0, E = y.length; R < E; ++R)
        D = tA(D, y[R].length);
      C *= D;
      var I = x * _.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var P = function(O) {
          console.warn("Calculated decal size is greater than " + O + " due to decal option settings so " + O + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + O + " to be larger to avoid incontinuity.");
        };
        C > o.maxTileWidth && P("maxTileWidth"), I > o.maxTileHeight && P("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(C, o.maxTileWidth)),
        height: Math.max(1, Math.min(I, o.maxTileHeight))
      };
    }
    function M() {
      A && (A.clearRect(0, 0, b.width, b.height), o.backgroundColor && (A.fillStyle = o.backgroundColor, A.fillRect(0, 0, b.width, b.height)));
      for (var C = 0, R = 0; R < m.length; ++R)
        C += m[R];
      if (C <= 0)
        return;
      for (var E = -x, D = 0, I = 0, P = 0; E < w.height; ) {
        if (D % 2 === 0) {
          for (var O = I / 2 % y.length, N = 0, B = 0, F = 0; N < w.width * 2; ) {
            for (var G = 0, R = 0; R < v[P].length; ++R)
              G += v[P][R];
            if (G <= 0)
              break;
            if (B % 2 === 0) {
              var W = (1 - o.symbolSize) * 0.5, J = N + v[P][B] * W, U = E + m[D] * W, Y = v[P][B] * o.symbolSize, at = m[D] * o.symbolSize, st = F / 2 % y[O].length;
              ut(J, U, Y, at, y[O][st]);
            }
            N += v[P][B], ++F, ++B, B === v[P].length && (B = 0);
          }
          ++P, P === v.length && (P = 0);
        }
        E += m[D], ++I, ++D, D === m.length && (D = 0);
      }
      function ut(lt, H, ct, ot, Gt) {
        var yt = i ? 1 : e, Mt = hr(Gt, lt * yt, H * yt, ct * yt, ot * yt, o.color, o.symbolKeepAspect);
        if (i) {
          var Rt = n.painter.renderOneToVNode(Mt);
          Rt && S.children.push(Rt);
        } else
          FO(A, Mt);
      }
    }
  }
}
function zO(r) {
  if (!r || r.length === 0)
    return [["rect"]];
  if (pt(r))
    return [[r]];
  for (var t = !0, e = 0; e < r.length; ++e)
    if (!pt(r[e])) {
      t = !1;
      break;
    }
  if (t)
    return zO([r]);
  for (var n = [], e = 0; e < r.length; ++e)
    pt(r[e]) ? n.push([r[e]]) : n.push(r[e]);
  return n;
}
function UO(r) {
  if (!r || r.length === 0)
    return [[0, 0]];
  if (fe(r)) {
    var t = Math.ceil(r);
    return [[t, t]];
  }
  for (var e = !0, n = 0; n < r.length; ++n)
    if (!fe(r[n])) {
      e = !1;
      break;
    }
  if (e)
    return UO([r]);
  for (var i = [], n = 0; n < r.length; ++n)
    if (fe(r[n])) {
      var t = Math.ceil(r[n]);
      i.push([t, t]);
    } else {
      var t = rt(r[n], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t);
    }
  return i;
}
function GY(r) {
  if (!r || typeof r == "object" && r.length === 0)
    return [0, 0];
  if (fe(r)) {
    var t = Math.ceil(r);
    return [t, t];
  }
  var e = rt(r, function(n) {
    return Math.ceil(n);
  });
  return r.length % 2 ? e.concat(e) : e;
}
function HY(r) {
  return rt(r, function(t) {
    return GO(t);
  });
}
function GO(r) {
  for (var t = 0, e = 0; e < r.length; ++e)
    t += r[e];
  return r.length % 2 === 1 ? t * 2 : t;
}
function WY(r, t) {
  r.eachRawSeries(function(e) {
    if (!r.isSeriesFiltered(e)) {
      var n = e.getData();
      n.hasItemVisual() && n.each(function(o) {
        var s = n.getItemVisual(o, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(o, "style");
          l.decal = oc(s, t);
        }
      });
      var i = n.getVisual("decal");
      if (i) {
        var a = n.getVisual("style");
        a.decal = oc(i, t);
      }
    }
  });
}
var di = new si(), Yv = {};
function XY(r, t) {
  process.env.NODE_ENV !== "production" && Yv[r] && ce("Already has an implementation of " + r + "."), Yv[r] = t;
}
function YY(r) {
  return process.env.NODE_ENV !== "production" && (Yv[r] || ce("Implementation of " + r + " doesn't exists.")), Yv[r];
}
var HO = {};
function $Y(r, t) {
  HO[r] = t;
}
function ZY(r) {
  return HO[r];
}
var qY = 1, KY = 800, jY = 900, JY = 1e3, QY = 2e3, t$ = 5e3, WO = 1e3, e$ = 1100, pb = 2e3, XO = 3e3, r$ = 4e3, pm = 4500, n$ = 4600, i$ = 5e3, a$ = 6e3, YO = 7e3, o$ = {
  PROCESSOR: {
    FILTER: JY,
    SERIES_FILTER: KY,
    STATISTIC: t$
  },
  VISUAL: {
    LAYOUT: WO,
    PROGRESSIVE_LAYOUT: e$,
    GLOBAL: pb,
    CHART: XO,
    POST_CHART_LAYOUT: n$,
    COMPONENT: r$,
    BRUSH: i$,
    CHART_ITEM: pm,
    ARIA: a$,
    DECAL: YO
  }
}, gr = "__flagInMainProcess", jd = "__mainProcessVersion", Lr = "__pendingUpdate", l0 = "__needsUpdateStatus", GE = /^[a-zA-Z0-9_]+$/, u0 = "__connectUpdateStatus", HE = 0, s$ = 1, l$ = 2;
function $O(r) {
  return function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    if (this.isDisposed()) {
      mn(this.id);
      return;
    }
    return qO(this, r, t);
  };
}
function ZO(r) {
  return function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    return qO(this, r, t);
  };
}
function qO(r, t, e) {
  return e[0] = e[0] && e[0].toLowerCase(), si.prototype[t].apply(r, e);
}
var KO = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t;
  }(si)
), jO = KO.prototype;
jO.on = ZO("on");
jO.off = ZO("off");
var Cs, c0, Jd, xa, Qd, f0, h0, cu, fu, WE, XE, d0, YE, tp, $E, JO, Hn, ZE, hu, QO = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this, new pY()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, a._dom = e;
      var o = "canvas", s = "auto", l = !1;
      if (a[jd] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          oe.hasGlobalWindow ? window : global
        );
        u && (o = bt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = bt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = bt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && V8(function(d) {
        var p = zt(d), g = p.dataIndex;
        if (g != null) {
          var v = wt();
          return v.set("series_index", p.seriesIndex), v.set("data_index", g), p.ssrType && v.set("ssr_type", p.ssrType), v;
        }
      });
      var c = a._zr = KT(e, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: bt(i.useDirtyRect, l),
        useCoarsePointer: bt(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = fb(gt(c.flush, c), 17), a._updateTheme(n), a._locale = h9(i.locale || LN), a._coordSysMgr = new Cc();
      var f = a._api = $E(a);
      function h(d, p) {
        return d.__prio - p.__prio;
      }
      return Xp(qv, h), Xp(rS, h), a._scheduler = new LO(a, f, rS, qv), a._messageCenter = new KO(), a._initEvents(), a.resize = gt(a.resize, a), c.animation.on("frame", a._onframe, a), WE(c, a), XE(c, a), _v(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        ZE(this);
        var e = this._scheduler;
        if (this[Lr]) {
          var n = this[Lr].silent;
          this[gr] = !0, hu(this);
          try {
            Cs(this), xa.update.call(this, null, this[Lr].updateParams);
          } catch (l) {
            throw this[gr] = !1, this[Lr] = null, l;
          }
          this._zr.flush(), this[gr] = !1, this[Lr] = null, cu.call(this, n), fu.call(this, n);
        } else if (e.unfinished) {
          var i = qY, a = this._model, o = this._api;
          e.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            e.performSeriesTasks(a), e.performDataProcessorTasks(a), f0(this, a), e.performVisualTasks(a), tp(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && e.unfinished);
          e.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(e, n, i) {
      if (this[gr]) {
        process.env.NODE_ENV !== "production" && ce("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        mn(this.id);
        return;
      }
      var a, o, s;
      if (Lt(n) && (i = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[gr] = !0, hu(this), !this._model || n) {
        var l = new q9(this._api), u = this._theme, c = this._model = new sb();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(e, {
        replaceMerge: o
      }, nS);
      var f = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[Lr] = {
          silent: a,
          updateParams: f
        }, this[gr] = !1, this.getZr().wakeUp();
      else {
        try {
          Cs(this), xa.update.call(this, null, f);
        } catch (h) {
          throw this[Lr] = null, this[gr] = !1, h;
        }
        this._ssr || this._zr.flush(), this[Lr] = null, this[gr] = !1, cu.call(this, a), fu.call(this, a);
      }
    }, t.prototype.setTheme = function(e, n) {
      if (this[gr]) {
        process.env.NODE_ENV !== "production" && ce("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        mn(this.id);
        return;
      }
      var i = this._model;
      if (i) {
        var a = n && n.silent, o = null;
        this[Lr] && (a == null && (a = this[Lr].silent), o = this[Lr].updateParams, this[Lr] = null), this[gr] = !0, hu(this);
        try {
          this._updateTheme(e), i.setTheme(this._theme), Cs(this), xa.update.call(this, {
            type: "setTheme"
          }, o);
        } catch (s) {
          throw this[gr] = !1, s;
        }
        this[gr] = !1, cu.call(this, a), fu.call(this, a);
      }
    }, t.prototype._updateTheme = function(e) {
      pt(e) && (e = tk[e]), e && (e = Dt(e), e && aO(e, !0), this._theme = e);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || oe.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(e) {
      return process.env.NODE_ENV !== "production" && or("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(e);
    }, t.prototype.renderToCanvas = function(e) {
      e = e || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: e.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: e.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(e) {
      e = e || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: e.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var e = this._zr, n = e.storage.getDisplayList();
      return L(n, function(i) {
        i.stopAnimation(null, !0);
      }), e.painter.toDataURL();
    }, t.prototype.getDataURL = function(e) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      e = e || {};
      var n = e.excludeComponents, i = this._model, a = [], o = this;
      L(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(e).toDataURL("image/" + (e && e.type || "png"));
      return L(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(e) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      var n = e.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (qE[i]) {
        var l = s, u = s, c = -s, f = -s, h = [], d = e && e.pixelRatio || this.getDevicePixelRatio();
        L(Kf, function(_, x) {
          if (_.group === i) {
            var b = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(Dt(e)), S = _.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), c = o(S.right, c), f = o(S.bottom, f), h.push({
              dom: b,
              left: S.left,
              top: S.top
            });
          }
        }), l *= d, u *= d, c *= d, f *= d;
        var p = c - l, g = f - u, v = Si.createCanvas(), m = KT(v, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), n) {
          var y = "";
          return L(h, function(_) {
            var x = _.left - l, b = _.top - u;
            y += '<g transform="translate(' + x + "," + b + ')">' + _.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, e.connectedBackgroundColor && m.painter.setBackgroundColor(e.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return e.connectedBackgroundColor && m.add(new te({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: e.connectedBackgroundColor
            }
          })), L(h, function(_) {
            var x = new Fr({
              style: {
                x: _.left * d - l,
                y: _.top * d - u,
                image: _.dom
              }
            });
            m.add(x);
          }), m.refreshImmediately(), v.toDataURL("image/" + (e && e.type || "png"));
      } else
        return this.getDataURL(e);
    }, t.prototype.convertToPixel = function(e, n, i) {
      return Qd(this, "convertToPixel", e, n, i);
    }, t.prototype.convertToLayout = function(e, n, i) {
      return Qd(this, "convertToLayout", e, n, i);
    }, t.prototype.convertFromPixel = function(e, n, i) {
      return Qd(this, "convertFromPixel", e, n, i);
    }, t.prototype.containPixel = function(e, n) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      var i = this._model, a, o = Xu(i, e);
      return L(o, function(s, l) {
        l.indexOf("Models") >= 0 && L(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var f = this._chartsMap[u.__viewId];
            f && f.containPoint ? a = a || f.containPoint(n, u) : process.env.NODE_ENV !== "production" && Ye(l + ": " + (f ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && Ye(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(e, n) {
      var i = this._model, a = Xu(i, e, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      process.env.NODE_ENV !== "production" && (o || Ye("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? hb(s, l, n) : Gh(s, n);
    }, t.prototype.getViewOfComponentModel = function(e) {
      return this._componentsMap[e.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(e) {
      return this._chartsMap[e.__viewId];
    }, t.prototype._initEvents = function() {
      var e = this;
      L(u$, function(i) {
        var a = function(o) {
          var s = e.getModel(), l = o.target, u, c = i === "globalout";
          if (c ? u = {} : l && Qs(l, function(g) {
            var v = zt(g);
            if (v && v.dataIndex != null) {
              var m = v.dataModel || s.getSeriesByIndex(v.seriesIndex);
              return u = m && m.getDataParams(v.dataIndex, v.dataType, l) || {}, !0;
            } else if (v.eventData)
              return u = j({}, v.eventData), !0;
          }, !0), u) {
            var f = u.componentType, h = u.componentIndex;
            (f === "markLine" || f === "markPoint" || f === "markArea") && (f = "series", h = u.seriesIndex);
            var d = f && h != null && s.getComponent(f, h), p = d && e[d.mainType === "series" ? "_chartsMap" : "_componentsMap"][d.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(d && p) && Ye("model or view can not be found by params"), u.event = o, u.type = i, e._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: d,
              view: p
            }, e.trigger(i, u);
          }
        };
        a.zrEventfulCallAtLast = !0, e._zr.on(i, a, e);
      });
      var n = this._messageCenter;
      L(eS, function(i, a) {
        n.on(a, function(o) {
          e.trigger(a, o);
        });
      }), mY(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      this._disposed = !0;
      var e = this.getDom();
      e && FP(this.getDom(), gb, "");
      var n = this, i = n._api, a = n._model;
      L(n._componentsViews, function(o) {
        o.dispose(a, i);
      }), L(n._chartsViews, function(o) {
        o.dispose(a, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete Kf[n.id];
    }, t.prototype.resize = function(e) {
      if (this[gr]) {
        process.env.NODE_ENV !== "production" && ce("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        mn(this.id);
        return;
      }
      this._zr.resize(e);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var i = n.resetOption("media"), a = e && e.silent;
        this[Lr] && (a == null && (a = this[Lr].silent), i = !0, this[Lr] = null), this[gr] = !0, hu(this);
        try {
          i && Cs(this), xa.update.call(this, {
            type: "resize",
            animation: j({
              // Disable animation
              duration: 0
            }, e && e.animation)
          });
        } catch (o) {
          throw this[gr] = !1, o;
        }
        this[gr] = !1, cu.call(this, a), fu.call(this, a);
      }
    }, t.prototype.showLoading = function(e, n) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      if (Lt(e) && (n = e, e = ""), e = e || "default", this.hideLoading(), !iS[e]) {
        process.env.NODE_ENV !== "production" && Ye("Loading effects " + e + " not exists.");
        return;
      }
      var i = iS[e](this._api, n), a = this._zr;
      this._loadingFX = i, a.add(i);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(e) {
      var n = j({}, e);
      return n.type = Zv[e.type], n;
    }, t.prototype.dispatchAction = function(e, n) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      if (Lt(n) || (n = {
        silent: !!n
      }), !!$v[e.type] && this._model) {
        if (this[gr]) {
          this._pendingActions.push(e);
          return;
        }
        var i = n.silent;
        h0.call(this, e, i);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && oe.browser.weChat && this._throttledZrFlush(), cu.call(this, i), fu.call(this, i);
      }
    }, t.prototype.updateLabelLayout = function() {
      di.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(e) {
      if (this._disposed) {
        mn(this.id);
        return;
      }
      var n = e.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && St(e.data && a), a.appendData(e), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = function() {
      Cs = function(f) {
        var h = f._scheduler;
        h.restorePipelines(f._model), h.prepareStageTasks(), c0(f, !0), c0(f, !1), h.plan();
      }, c0 = function(f, h) {
        for (var d = f._model, p = f._scheduler, g = h ? f._componentsViews : f._chartsViews, v = h ? f._componentsMap : f._chartsMap, m = f._zr, y = f._api, _ = 0; _ < g.length; _++)
          g[_].__alive = !1;
        h ? d.eachComponent(function(S, w) {
          S !== "series" && x(w);
        }) : d.eachSeries(x);
        function x(S) {
          var w = S.__requireNewView;
          S.__requireNewView = !1;
          var A = "_ec_" + S.id + "_" + S.type, T = !w && v[A];
          if (!T) {
            var M = Zi(S.type), C = h ? Ge.getClass(M.main, M.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Re.getClass(M.sub)
            );
            process.env.NODE_ENV !== "production" && St(C, M.sub + " does not exist."), T = new C(), T.init(d, y), v[A] = T, g.push(T), m.add(T.group);
          }
          S.__viewId = T.__id = A, T.__alive = !0, T.__model = S, T.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !h && p.prepareView(T, S, d, y);
        }
        for (var _ = 0; _ < g.length; ) {
          var b = g[_];
          b.__alive ? _++ : (!h && b.renderTask.dispose(), m.remove(b.group), b.dispose(d, y), g.splice(_, 1), v[b.__id] === b && delete v[b.__id], b.__id = b.group.__ecComponentInfo = null);
        }
      }, Jd = function(f, h, d, p, g) {
        var v = f._model;
        if (v.setUpdatePayload(d), !p) {
          L([].concat(f._componentsViews).concat(f._chartsViews), b);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var _ = d.excludeSeriesId, x;
        _ != null && (x = wt(), L(Ie(_), function(S) {
          var w = yr(S, null);
          w != null && x.set(w, !0);
        })), v && v.eachComponent(y, function(S) {
          var w = x && x.get(S.id) != null;
          if (!w)
            if (IA(d))
              if (S instanceof ke)
                d.type === al && !d.notBlur && !S.get(["emphasis", "disabled"]) && c7(S, d, f._api);
              else {
                var A = U1(S.mainType, S.componentIndex, d.name, f._api), T = A.focusSelf, M = A.dispatchers;
                d.type === al && T && !d.notBlur && Rx(S.mainType, S.componentIndex, f._api), M && L(M, function(C) {
                  d.type === al ? Wa(C) : Xa(C);
                });
              }
            else
              Px(d) && S instanceof ke && (d7(S, d, f._api), LA(S), Hn(f));
        }, f), v && v.eachComponent(y, function(S) {
          var w = x && x.get(S.id) != null;
          w || b(f[p === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, f);
        function b(S) {
          S && S.__alive && S[h] && S[h](S.__model, v, f._api, d);
        }
      }, xa = {
        prepareAndUpdate: function(f) {
          Cs(this), xa.update.call(this, f, f && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: f.newOption != null
          });
        },
        update: function(f, h) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(f), m.restoreData(d, f), m.performSeriesTasks(d), v.create(d, p), m.performDataProcessorTasks(d, f), f0(this, d), v.update(d, p), n(d), m.performVisualTasks(d, f);
            var y = d.get("backgroundColor") || "transparent";
            g.setBackgroundColor(y);
            var _ = d.get("darkMode");
            _ != null && _ !== "auto" && g.setDarkMode(_), d0(this, d, p, f, h), di.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(f) {
          var h = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(f);
            var g = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var _ = h.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var x = _.updateTransform(y, d, p, f);
                    x && x.update && g.push(_);
                  } else
                    g.push(_);
              }
            });
            var v = wt();
            d.eachSeries(function(m) {
              var y = h._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(m, d, p, f);
                _ && _.update && v.set(m.uid, 1);
              } else
                v.set(m.uid, 1);
            }), n(d), this._scheduler.performVisualTasks(d, f, {
              setDirty: !0,
              dirtyMap: v
            }), tp(this, d, p, f, {}, v), di.trigger("afterupdate", d, p);
          }
        },
        updateView: function(f) {
          var h = this._model;
          h && (h.setUpdatePayload(f), Re.markUpdateMethod(f, "updateView"), n(h), this._scheduler.performVisualTasks(h, f, {
            setDirty: !0
          }), d0(this, h, this._api, f, {}), di.trigger("afterupdate", h, this._api));
        },
        updateVisual: function(f) {
          var h = this, d = this._model;
          d && (d.setUpdatePayload(f), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), Re.markUpdateMethod(f, "updateVisual"), n(d), this._scheduler.performVisualTasks(d, f, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = h.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, h._api, f);
            }
          }), d.eachSeries(function(p) {
            var g = h._chartsMap[p.__viewId];
            g.updateVisual(p, d, h._api, f);
          }), di.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(f) {
          xa.update.call(this, f);
        }
      };
      function e(f, h, d, p, g) {
        if (f._disposed) {
          mn(f.id);
          return;
        }
        for (var v = f._model, m = f._coordSysMgr.getCoordinateSystems(), y, _ = Xu(v, d), x = 0; x < m.length; x++) {
          var b = m[x];
          if (b[h] && (y = b[h](v, _, p, g)) != null)
            return y;
        }
        process.env.NODE_ENV !== "production" && Ye("No coordinate system that supports " + h + " found by the given finder.");
      }
      Qd = e, f0 = function(f, h) {
        var d = f._chartsMap, p = f._scheduler;
        h.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, h0 = function(f, h) {
        var d = this, p = this.getModel(), g = f.type, v = f.escapeConnect, m = $v[g], y = (m.update || "update").split(":"), _ = y.pop(), x = y[0] != null && Zi(y[0]);
        this[gr] = !0, hu(this);
        var b = [f], S = !1;
        f.batch && (S = !0, b = rt(f.batch, function(P) {
          return P = Bt(j({}, P), f), P.batch = null, P;
        }));
        var w = [], A, T = [], M = m.nonRefinedEventType, C = Px(f), R = IA(f);
        if (R && oN(this._api), L(b, function(P) {
          var O = m.action(P, p, d._api);
          if (m.refineEvent ? T.push(O) : A = O, A = A || j({}, P), A.type = M, w.push(A), R) {
            var N = I1(f), B = N.queryOptionMap, F = N.mainTypeSpecified, G = F ? B.keys()[0] : "series";
            Jd(d, _, P, G), Hn(d);
          } else
            C ? (Jd(d, _, P, "series"), Hn(d)) : x && Jd(d, _, P, x.main, x.sub);
        }), _ !== "none" && !R && !C && !x)
          try {
            this[Lr] ? (Cs(this), xa.update.call(this, f), this[Lr] = null) : xa[_].call(this, f);
          } catch (P) {
            throw this[gr] = !1, P;
          }
        if (S ? A = {
          type: M,
          escapeConnect: v,
          batch: w
        } : A = w[0], this[gr] = !1, !h) {
          var E = void 0;
          if (m.refineEvent) {
            var D = m.refineEvent(T, f, p, this._api).eventContent;
            St(Lt(D)), E = Bt({
              type: m.refinedEventType
            }, D), E.fromAction = f.type, E.fromActionPayload = f, E.escapeConnect = !0;
          }
          var I = this._messageCenter;
          I.trigger(A.type, A), E && I.trigger(E.type, E);
        }
      }, cu = function(f) {
        for (var h = this._pendingActions; h.length; ) {
          var d = h.shift();
          h0.call(this, d, f);
        }
      }, fu = function(f) {
        !f && this.trigger("updated");
      }, WE = function(f, h) {
        f.on("rendered", function(d) {
          h.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          f.animation.isFinished() && !h[Lr] && !h._scheduler.unfinished && !h._pendingActions.length && h.trigger("finished");
        });
      }, XE = function(f, h) {
        f.on("mouseover", function(d) {
          var p = d.target, g = Qs(p, Go);
          g && (f7(g, d, h._api), Hn(h));
        }).on("mouseout", function(d) {
          var p = d.target, g = Qs(p, Go);
          g && (h7(g, d, h._api), Hn(h));
        }).on("click", function(d) {
          var p = d.target, g = Qs(p, function(y) {
            return zt(y).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = zt(g);
            h._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(f) {
        f.clearColorPalette(), f.eachSeries(function(h) {
          h.clearColorPalette();
        });
      }
      function i(f) {
        var h = [], d = [], p = !1;
        if (f.eachComponent(function(y, _) {
          var x = _.get("zlevel") || 0, b = _.get("z") || 0, S = _.getZLevelKey();
          p = p || !!S, (y === "series" ? d : h).push({
            zlevel: x,
            z: b,
            idx: _.componentIndex,
            type: y,
            key: S
          });
        }), p) {
          var g = h.concat(d), v, m;
          Xp(g, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), L(g, function(y) {
            var _ = f.getComponent(y.type, y.idx), x = y.zlevel, b = y.key;
            v != null && (x = Math.max(v, x)), b ? (x === v && b !== m && x++, m = b) : m && (x === v && x++, m = ""), v = x, _.setZLevel(x);
          });
        }
      }
      d0 = function(f, h, d, p, g) {
        i(h), YE(f, h, d, p, g), L(f._chartsViews, function(v) {
          v.__alive = !1;
        }), tp(f, h, d, p, g), L(f._chartsViews, function(v) {
          v.__alive || v.remove(h, d);
        });
      }, YE = function(f, h, d, p, g, v) {
        L(v || f._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, h, d, p), l(y, m), c(y, m);
        });
      }, tp = function(f, h, d, p, g, v) {
        var m = f._scheduler;
        g = j(g || {}, {
          updatedSeries: h.getSeries()
        }), di.trigger("series:beforeupdate", h, d, g);
        var y = !1;
        h.eachSeries(function(_) {
          var x = f._chartsMap[_.__viewId];
          x.__alive = !0;
          var b = x.renderTask;
          m.updatePayload(b, p), u(_, x), v && v.get(_.uid) && b.dirty(), b.perform(m.getPerformArgs(b)) && (y = !0), x.group.silent = !!_.get("silent"), s(_, x), LA(_);
        }), m.unfinished = y || m.unfinished, di.trigger("series:layoutlabels", h, d, g), di.trigger("series:transition", h, d, g), h.eachSeries(function(_) {
          var x = f._chartsMap[_.__viewId];
          l(_, x), c(_, x);
        }), o(f, h), di.trigger("series:afterupdate", h, d, g);
      }, Hn = function(f) {
        f[l0] = !0, f.getZr().wakeUp();
      }, hu = function(f) {
        f[jd] = (f[jd] + 1) % 1e3;
      }, ZE = function(f) {
        f[l0] && (f.getZr().storage.traverse(function(h) {
          Yu(h) || a(h);
        }), f[l0] = !1);
      };
      function a(f) {
        for (var h = [], d = f.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || h.push(g);
        }
        f.selected && f.states.select && h.push("select"), f.hoverState === em && f.states.emphasis ? h.push("emphasis") : f.hoverState === Oh && f.states.blur && h.push("blur"), f.useStates(h);
      }
      function o(f, h) {
        var d = f._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > h.get("hoverLayerThreshold") && !oe.node && !oe.worker && h.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = f._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function s(f, h) {
        var d = f.get("blendMode") || null;
        h.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function l(f, h) {
        if (!f.preventAutoZ) {
          var d = yl(f);
          h.eachRendered(function(p) {
            return sm(p, d.z, d.zlevel), !0;
          });
        }
      }
      function u(f, h) {
        h.eachRendered(function(d) {
          if (!Yu(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(f, h) {
        var d = f.getModel("stateAnimation"), p = f.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        h.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Yu(m))
              return;
            if (m instanceof ne && _7(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var _ = m.getTextContent(), x = m.getTextGuideLine();
              _ && (_.stateTransition = v), x && (x.stateTransition = v);
            }
            m.__dirty && a(m);
          }
        });
      }
      $E = function(f) {
        return new /** @class */
        (function(h) {
          $(d, h);
          function d() {
            return h !== null && h.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return f._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return f._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            Wa(p, g), Hn(f);
          }, d.prototype.leaveEmphasis = function(p, g) {
            Xa(p, g), Hn(f);
          }, d.prototype.enterBlur = function(p) {
            rN(p), Hn(f);
          }, d.prototype.leaveBlur = function(p) {
            z1(p), Hn(f);
          }, d.prototype.enterSelect = function(p) {
            nN(p), Hn(f);
          }, d.prototype.leaveSelect = function(p) {
            iN(p), Hn(f);
          }, d.prototype.getModel = function() {
            return f.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return f.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return f.getViewOfSeriesModel(p);
          }, d.prototype.getMainProcessVersion = function() {
            return f[jd];
          }, d;
        }(nO))(f);
      }, JO = function(f) {
        function h(d, p) {
          for (var g = 0; g < d.length; g++) {
            var v = d[g];
            v[u0] = p;
          }
        }
        L(Zv, function(d, p) {
          f._messageCenter.on(p, function(g) {
            if (qE[f.group] && f[u0] !== HE) {
              if (g && g.escapeConnect)
                return;
              var v = f.makeActionFromEvent(g), m = [];
              L(Kf, function(y) {
                y !== f && y.group === f.group && m.push(y);
              }), h(m, HE), L(m, function(y) {
                y[u0] !== s$ && y.dispatchAction(v);
              }), h(m, l$);
            }
          });
        });
      };
    }(), t;
  }(si)
), vb = QO.prototype;
vb.on = $O("on");
vb.off = $O("off");
vb.one = function(r, t, e) {
  var n = this;
  aa("ECharts#one is deprecated.");
  function i() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    t && t.apply && t.apply(this, a), n.off(r, i);
  }
  this.on.call(this, r, i, e);
};
var u$ = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function mn(r) {
  process.env.NODE_ENV !== "production" && Ye("Instance " + r + " has been disposed");
}
var $v = {}, Zv = {}, eS = {}, rS = [], nS = [], qv = [], tk = {}, iS = {}, Kf = {}, qE = {}, c$ = +/* @__PURE__ */ new Date() - 0, gb = "_echarts_instance_";
function f$(r, t, e) {
  {
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("Initialize failed: invalid dom.");
    var n = h$(r);
    if (n)
      return process.env.NODE_ENV !== "production" && Ye("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && hl(r) && r.nodeName.toUpperCase() !== "CANVAS" && (!r.clientWidth && !e || !r.clientHeight && !e) && Ye("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var i = new QO(r, t, e);
  return i.id = "ec_" + c$++, Kf[i.id] = i, FP(r, gb, i.id), JO(i), di.trigger("afterinit", i), i;
}
function h$(r) {
  return Kf[o6(r, gb)];
}
function ek(r, t) {
  tk[r] = t;
}
function rk(r) {
  Zt(nS, r) < 0 && nS.push(r);
}
function nk(r, t) {
  yb(rS, r, t, QY);
}
function d$(r) {
  mb("afterinit", r);
}
function p$(r) {
  mb("afterupdate", r);
}
function mb(r, t) {
  di.on(r, t);
}
function fa(r, t, e) {
  var n, i, a, o, s;
  At(t) && (e = t, t = ""), Lt(r) ? (n = r.type, i = r.event, o = r.update, s = r.publishNonRefinedEvent, e || (e = r.action), a = r.refineEvent) : (n = r, i = t);
  function l(c) {
    return c.toLowerCase();
  }
  i = l(i || n);
  var u = a ? l(n) : i;
  $v[n] || (St(GE.test(n) && GE.test(i)), a && St(i !== n), $v[n] = {
    actionType: n,
    refinedEventType: i,
    nonRefinedEventType: u,
    update: o,
    action: e,
    refineEvent: a
  }, eS[i] = 1, a && s && (eS[u] = 1), process.env.NODE_ENV !== "production" && Zv[u] && ce(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), Zv[u] = n);
}
function v$(r, t) {
  Cc.register(r, t);
}
function g$(r, t) {
  yb(qv, r, t, WO, "layout");
}
function Rl(r, t) {
  yb(qv, r, t, XO, "visual");
}
var KE = [];
function yb(r, t, e, n, i) {
  if ((At(t) || Lt(t)) && (e = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    L(r, function(o) {
      St(o.__raw !== e);
    });
  }
  if (!(Zt(KE, e) >= 0)) {
    KE.push(e);
    var a = LO.wrapStageHandler(e, i);
    a.__prio = t, a.__raw = e, r.push(a);
  }
}
function ik(r, t) {
  iS[r] = t;
}
function m$(r, t, e) {
  var n = YY("registerMap");
  n && n(r, t, e);
}
var y$ = CX;
Rl(pb, tY);
Rl(pm, eY);
Rl(pm, rY);
Rl(pb, vY);
Rl(pm, gY);
Rl(YO, WY);
rk(aO);
nk(jY, sX);
ik("default", nY);
fa({
  type: al,
  event: al,
  update: al
}, rr);
fa({
  type: qp,
  event: qp,
  update: qp
}, rr);
fa({
  type: Iv,
  event: V1,
  update: Iv,
  action: rr,
  refineEvent: _b,
  publishNonRefinedEvent: !0
});
fa({
  type: Dx,
  event: V1,
  update: Dx,
  action: rr,
  refineEvent: _b,
  publishNonRefinedEvent: !0
});
fa({
  type: Pv,
  event: V1,
  update: Pv,
  action: rr,
  refineEvent: _b,
  publishNonRefinedEvent: !0
});
function _b(r, t, e, n) {
  return {
    eventContent: {
      selected: p7(e),
      isFromClick: t.isFromClick || !1
    }
  };
}
ek("default", {});
ek("dark", NO);
var jE = [], _$ = {
  registerPreprocessor: rk,
  registerProcessor: nk,
  registerPostInit: d$,
  registerPostUpdate: p$,
  registerUpdateLifecycle: mb,
  registerAction: fa,
  registerCoordinateSystem: v$,
  registerLayout: g$,
  registerVisual: Rl,
  registerTransform: y$,
  registerLoading: ik,
  registerMap: m$,
  registerImpl: XY,
  PRIORITY: o$,
  ComponentModel: re,
  ComponentView: Ge,
  SeriesModel: ke,
  ChartView: Re,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(r) {
    re.registerClass(r);
  },
  registerComponentView: function(r) {
    Ge.registerClass(r);
  },
  registerSeriesModel: function(r) {
    ke.registerClass(r);
  },
  registerChartView: function(r) {
    Re.registerClass(r);
  },
  registerCustomSeries: function(r, t) {
    $Y(r, t);
  },
  registerSubTypeDefaulter: function(r, t) {
    re.registerSubTypeDefaulter(r, t);
  },
  registerPainter: function(r, t) {
    k8(r, t);
  }
};
function jt(r) {
  if (et(r)) {
    L(r, function(t) {
      jt(t);
    });
    return;
  }
  Zt(jE, r) >= 0 || (jE.push(r), At(r) && (r = {
    install: r
  }), r.install(_$));
}
function nf(r) {
  return r == null ? 0 : r.length || 1;
}
function JE(r) {
  return r;
}
var Ya = (
  /** @class */
  function() {
    function r(t, e, n, i, a, o) {
      this._old = t, this._new = e, this._oldKeyGetter = n || JE, this._newKeyGetter = i || JE, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(t) {
      return this._add = t, this;
    }, r.prototype.update = function(t) {
      return this._update = t, this;
    }, r.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, r.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, r.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, r.prototype.remove = function(t) {
      return this._remove = t, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var t = this._old, e = this._new, n = {}, i = new Array(t.length), a = new Array(e.length);
      this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(e, n, a, "_newKeyGetter");
      for (var o = 0; o < t.length; o++) {
        var s = i[o], l = n[s], u = nf(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o);
        } else
          u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, r.prototype._executeMultiple = function() {
      var t = this._old, e = this._new, n = {}, i = {}, a = [], o = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(e, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], c = i[l], f = nf(u), h = nf(c);
        if (f > 1 && h === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (f === 1 && h > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (f === 1 && h === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (f > 1 && h > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (f > 1)
          for (var d = 0; d < f; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, r.prototype._performRestAdd = function(t, e) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n], a = e[i], o = nf(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else
          o === 1 && this._add && this._add(a);
        e[i] = null;
      }
    }, r.prototype._initIndexMap = function(t, e, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
        var s = "_ec_" + this[i](t[o], o);
        if (a || (n[o] = s), !!e) {
          var l = e[s], u = nf(l);
          u === 0 ? (e[s] = o, a && n.push(s)) : u === 1 ? e[s] = [l, o] : l.push(o);
        }
      }
    }, r;
  }()
), x$ = (
  /** @class */
  function() {
    function r(t, e) {
      this._encode = t, this._schema = e;
    }
    return r.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }()
);
function S$(r, t) {
  var e = {}, n = e.encode = {}, i = wt(), a = [], o = [], s = {};
  L(r.dimensions, function(h) {
    var d = r.getDimensionInfo(h), p = d.coordDim;
    if (p) {
      process.env.NODE_ENV !== "production" && St(Wx.get(p) == null);
      var g = d.coordDimIndex;
      p0(n, p)[g] = h, d.isExtraCoord || (i.set(p, 1), b$(d.type) && (a[0] = h), p0(s, p)[g] = r.getDimensionIndex(d.name)), d.defaultTooltip && o.push(h);
    }
    Wx.each(function(v, m) {
      var y = p0(n, m), _ = d.otherDims[m];
      _ != null && _ !== !1 && (y[_] = d.name);
    });
  });
  var l = [], u = {};
  i.each(function(h, d) {
    var p = n[d];
    u[d] = p[0], l = l.concat(p);
  }), e.dataDimsOnCoord = l, e.dataDimIndicesOnCoord = rt(l, function(h) {
    return r.getDimensionInfo(h).storeDimIndex;
  }), e.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var f = n.tooltip;
  return f && f.length ? o = f.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, e.userOutput = new x$(s, t), e;
}
function p0(r, t) {
  return r.hasOwnProperty(t) || (r[t] = []), r[t];
}
function Kv(r) {
  return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
}
function b$(r) {
  return !(r === "ordinal" || r === "time");
}
var rv = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.otherDims = {}, t != null && j(this, t);
    }
    return r;
  }()
), w$ = ee(), M$ = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, ak = (
  /** @class */
  function() {
    function r(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = lk(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(t) {
      return bt(this._dimNameMap.get(t), -1);
    }, r.prototype.getSourceDimension = function(t) {
      var e = this.source.dimensionsDefine;
      if (e)
        return e[t];
    }, r.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, e = sO(this.source), n = !uk(t), i = "", a = [], o = 0, s = 0; o < t; o++) {
        var l = void 0, u = void 0, c = void 0, f = this.dimensions[s];
        if (f && f.storeDimIndex === o)
          l = e ? f.name : null, u = f.type, c = f.ordinalMeta, s++;
        else {
          var h = this.getSourceDimension(o);
          h && (l = e ? h.name : null, u = h.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), e && l != null && (!f || !f.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += M$[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [d.seriesLayoutBy, d.startIndex, i].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var t = [], e = 0, n = 0; e < this._fullDimCount; e++) {
        var i = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === e)
          a.isCalculationCoord || (i = a.name), n++;
        else {
          var o = this.getSourceDimension(e);
          o && (i = o.name);
        }
        t.push(i);
      }
      return t;
    }, r.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, r;
  }()
);
function ok(r) {
  return r instanceof ak;
}
function sk(r) {
  for (var t = wt(), e = 0; e < (r || []).length; e++) {
    var n = r[e], i = Lt(n) ? n.name : n;
    i != null && t.get(i) == null && t.set(i, e);
  }
  return t;
}
function lk(r) {
  var t = w$(r);
  return t.dimNameMap || (t.dimNameMap = sk(r.dimensionsDefine));
}
function uk(r) {
  return r > 30;
}
var af = Lt, co = rt, T$ = typeof Int32Array > "u" ? Array : Int32Array, A$ = "e\0\0", QE = -1, E$ = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], C$ = ["_approximateExtent"], tC, ep, of, du, v0, sf, g0, cn = (
  /** @class */
  function() {
    function r(t, e) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, i = !1;
      ok(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var f = n[c], h = pt(f) ? new rv({
          name: f
        }) : f instanceof rv ? f : new rv(f), d = h.name;
        h.type = h.type || "float", h.coordDim || (h.coordDim = d, h.coordDimIndex = 0);
        var p = h.otherDims = h.otherDims || {};
        o.push(d), a[d] = h, u[d] != null && (l = !0), h.createInvertedIndices && (s[d] = []);
        var g = c;
        fe(h.storeDimIndex) && (g = h.storeDimIndex), p.itemName === 0 && (this._nameDimIdx = g), p.itemId === 0 && (this._idDimIdx = g), process.env.NODE_ENV !== "production" && St(i || h.storeDimIndex >= 0), i && (h.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = e, this._invertedIndicesMap = s, this._dimOmitted) {
        var v = this._dimIdxToName = wt();
        L(o, function(m) {
          v.set(a[m].storeDimIndex, m);
        });
      }
    }
    return r.prototype.getDimension = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e == null)
        return t;
      if (e = t, !this._dimOmitted)
        return this.dimensions[e];
      var n = this._dimIdxToName.get(e);
      if (n != null)
        return n;
      var i = this._schema.getSourceDimension(e);
      if (i)
        return i.name;
    }, r.prototype.getDimensionIndex = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e != null)
        return e;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, r.prototype._recognizeDimIndex = function(t) {
      if (fe(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, r.prototype._getStoreDimIndex = function(t) {
      var e = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && e == null)
        throw new Error("Unknown dimension " + t);
      return e;
    }, r.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, r.prototype._initGetDimensionInfo = function(t) {
      var e = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return e.hasOwnProperty(n) ? e[n] : void 0;
      } : function(n) {
        return e[n];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(t, e) {
      var n = this._dimSummary;
      if (e == null)
        return n.encodeFirstDimNotExtra[t];
      var i = n.encode[t];
      return i ? i[e] : null;
    }, r.prototype.mapDimensionsAll = function(t) {
      var e = this._dimSummary, n = e.encode[t];
      return (n || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(t, e, n) {
      var i = this, a;
      if (t instanceof Zx && (a = t), !a) {
        var o = this.dimensions, s = lb(t) || Kr(t) ? new lO(t, o.length) : t;
        a = new Zx();
        var l = co(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = S$(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(t) {
      var e = this._store.appendData(t);
      this._doInit(e[0], e[1]);
    }, r.prototype.appendValues = function(t, e) {
      var n = this._store.appendValues(t, e && e.length), i = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), e)
        for (var s = i; s < a; s++) {
          var l = s - i;
          this._nameList[s] = e[l], o && g0(this, s);
        }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, e = this.dimensions, n = 0; n < e.length; n++) {
        var i = this._dimInfos[e[n]];
        i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== Oa && !t.fillStorage;
    }, r.prototype._doInit = function(t, e) {
      if (!(t >= e)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === Vn;
        if (l && !i.pure)
          for (var u = [], c = t; c < e; c++) {
            var f = i.getItem(c, u);
            if (!this.hasItemOption && $8(f) && (this.hasItemOption = !0), f) {
              var h = f.name;
              a[c] == null && h != null && (a[c] = yr(h, null));
              var d = f.id;
              o[c] == null && d != null && (o[c] = yr(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < e; c++)
            g0(this, c);
        tC(this);
      }
    }, r.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, r.prototype.setApproximateExtent = function(t, e) {
      e = this.getDimension(e), this._approximateExtent[e] = t.slice();
    }, r.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, r.prototype.setCalculationInfo = function(t, e) {
      af(t) ? j(this._calculationInfo, t) : this._calculationInfo[t] = e;
    }, r.prototype.getName = function(t) {
      var e = this.getRawIndex(t), n = this._nameList[e];
      return n == null && this._nameDimIdx != null && (n = of(this, this._nameDimIdx, e)), n == null && (n = ""), n;
    }, r.prototype._getCategory = function(t, e) {
      var n = this._store.get(t, e), i = this._store.getOrdinalMeta(t);
      return i ? i.categories[n] : n;
    }, r.prototype.getId = function(t) {
      return ep(this, this.getRawIndex(t));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(t, e) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.get(i.storeDimIndex, e);
    }, r.prototype.getByRawIndex = function(t, e) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.getByRawIndex(i.storeDimIndex, e);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, r.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, r.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, r.prototype.getValues = function(t, e) {
      var n = this, i = this._store;
      return et(t) ? i.getValues(co(t, function(a) {
        return n._getStoreDimIndex(a);
      }), e) : i.getValues(t);
    }, r.prototype.hasValue = function(t) {
      for (var e = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = e.length; n < i; n++)
        if (isNaN(this._store.get(e[n], t)))
          return !1;
      return !0;
    }, r.prototype.indexOfName = function(t) {
      for (var e = 0, n = this._store.count(); e < n; e++)
        if (this.getName(e) === t)
          return e;
      return -1;
    }, r.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, r.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, r.prototype.rawIndexOf = function(t, e) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var i = n && n[e];
      return i == null || isNaN(i) ? QE : i;
    }, r.prototype.each = function(t, e, n) {
      At(t) && (n = e, e = t, t = []);
      var i = n || this, a = co(du(t), this._getStoreDimIndex, this);
      this._store.each(a, i ? gt(e, i) : e);
    }, r.prototype.filterSelf = function(t, e, n) {
      At(t) && (n = e, e = t, t = []);
      var i = n || this, a = co(du(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? gt(e, i) : e), this;
    }, r.prototype.selectRange = function(t) {
      var e = this, n = {}, i = se(t);
      return L(i, function(a) {
        var o = e._getStoreDimIndex(a);
        n[o] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, r.prototype.mapArray = function(t, e, n) {
      At(t) && (n = e, e = t, t = []), n = n || this;
      var i = [];
      return this.each(t, function() {
        i.push(e && e.apply(this, arguments));
      }, n), i;
    }, r.prototype.map = function(t, e, n, i) {
      var a = n || i || this, o = co(du(t), this._getStoreDimIndex, this), s = sf(this);
      return s._store = this._store.map(o, a ? gt(e, a) : e), s;
    }, r.prototype.modify = function(t, e, n, i) {
      var a = this, o = n || i || this;
      process.env.NODE_ENV !== "production" && L(du(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = co(du(t), this._getStoreDimIndex, this);
      this._store.modify(s, o ? gt(e, o) : e);
    }, r.prototype.downSample = function(t, e, n, i) {
      var a = sf(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), e, n, i), a;
    }, r.prototype.minmaxDownSample = function(t, e) {
      var n = sf(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), e), n;
    }, r.prototype.lttbDownSample = function(t, e) {
      var n = sf(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), n;
    }, r.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, r.prototype.getItemModel = function(t) {
      var e = this.hostModel, n = this.getRawDataItem(t);
      return new ue(n, e, e && e.ecModel);
    }, r.prototype.diff = function(t) {
      var e = this;
      return new Ya(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return ep(t, n);
      }, function(n) {
        return ep(e, n);
      });
    }, r.prototype.getVisual = function(t) {
      var e = this._visual;
      return e && e[t];
    }, r.prototype.setVisual = function(t, e) {
      this._visual = this._visual || {}, af(t) ? j(this._visual, t) : this._visual[t] = e;
    }, r.prototype.getItemVisual = function(t, e) {
      var n = this._itemVisuals[t], i = n && n[e];
      return i ?? this.getVisual(e);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(t, e) {
      var n = this._itemVisuals, i = n[t];
      i || (i = n[t] = {});
      var a = i[e];
      return a == null && (a = this.getVisual(e), et(a) ? a = a.slice() : af(a) && (a = j({}, a)), i[e] = a), a;
    }, r.prototype.setItemVisual = function(t, e, n) {
      var i = this._itemVisuals[t] || {};
      this._itemVisuals[t] = i, af(e) ? j(i, e) : i[e] = n;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(t, e) {
      af(t) ? j(this._layout, t) : this._layout[t] = e;
    }, r.prototype.getLayout = function(t) {
      return this._layout[t];
    }, r.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, r.prototype.setItemLayout = function(t, e, n) {
      this._itemLayouts[t] = n ? j(this._itemLayouts[t] || {}, e) : e;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(t, e) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      Cx(n, this.dataType, t, e), this._graphicEls[t] = e;
    }, r.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, r.prototype.eachItemGraphicEl = function(t, e) {
      L(this._graphicEls, function(n, i) {
        n && t && t.call(e, n, i);
      });
    }, r.prototype.cloneShallow = function(t) {
      return t || (t = new r(this._schema ? this._schema : co(this.dimensions, this._getDimInfo, this), this.hostModel)), v0(t, this), t._store = this._store, t;
    }, r.prototype.wrapMethod = function(t, e) {
      var n = this[t];
      At(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var i = n.apply(this, arguments);
        return e.apply(this, [i].concat(w1(arguments)));
      });
    }, r.internalField = function() {
      tC = function(t) {
        var e = t._invertedIndicesMap;
        L(e, function(n, i) {
          var a = t._dimInfos[i], o = a.ordinalMeta, s = t._store;
          if (o) {
            n = e[i] = new T$(o.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = QE;
            for (var l = 0; l < s.count(); l++)
              n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, of = function(t, e, n) {
        return yr(t._getCategory(e, n), null);
      }, ep = function(t, e) {
        var n = t._idList[e];
        return n == null && t._idDimIdx != null && (n = of(t, t._idDimIdx, e)), n == null && (n = A$ + e), n;
      }, du = function(t) {
        return et(t) || (t = t != null ? [t] : []), t;
      }, sf = function(t) {
        var e = new r(t._schema ? t._schema : co(t.dimensions, t._getDimInfo, t), t.hostModel);
        return v0(e, t), e;
      }, v0 = function(t, e) {
        L(E$.concat(e.__wrappedMethods || []), function(n) {
          e.hasOwnProperty(n) && (t[n] = e[n]);
        }), t.__wrappedMethods = e.__wrappedMethods, L(C$, function(n) {
          t[n] = Dt(e[n]);
        }), t._calculationInfo = j({}, e._calculationInfo);
      }, g0 = function(t, e) {
        var n = t._nameList, i = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = n[e], l = i[e];
        if (s == null && a != null && (n[e] = s = of(t, a, e)), l == null && o != null && (i[e] = l = of(t, o, e)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[e] = l;
        }
      };
    }(), r;
  }()
);
function Hh(r, t) {
  lb(r) || (r = ub(r)), t = t || {};
  var e = t.coordDimensions || [], n = t.dimensionsDefine || r.dimensionsDefine || [], i = wt(), a = [], o = L$(r, e, n, t.dimensionsCount), s = t.canOmitUnusedDimensions && uk(o), l = n === r.dimensionsDefine, u = l ? lk(r) : sk(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(r, o));
  for (var f = wt(c), h = new gO(o), d = 0; d < h.length; d++)
    h[d] = -1;
  function p(T) {
    var M = h[T];
    if (M < 0) {
      var C = n[T], R = Lt(C) ? C : {
        name: C
      }, E = new rv(), D = R.name;
      D != null && u.get(D) != null && (E.name = E.displayName = D), R.type != null && (E.type = R.type), R.displayName != null && (E.displayName = R.displayName);
      var I = a.length;
      return h[T] = I, E.storeDimIndex = T, a.push(E), E;
    }
    return a[M];
  }
  if (!s)
    for (var d = 0; d < o; d++)
      p(d);
  f.each(function(T, M) {
    var C = Ie(T).slice();
    if (C.length === 1 && !pt(C[0]) && C[0] < 0) {
      f.set(M, !1);
      return;
    }
    var R = f.set(M, []);
    L(C, function(E, D) {
      var I = pt(E) ? u.get(E) : E;
      I != null && I < o && (R[D] = I, v(p(I), M, D));
    });
  });
  var g = 0;
  L(e, function(T) {
    var M, C, R, E;
    if (pt(T))
      M = T, E = {};
    else {
      E = T, M = E.name;
      var D = E.ordinalMeta;
      E.ordinalMeta = null, E = j({}, E), E.ordinalMeta = D, C = E.dimsDef, R = E.otherDims, E.name = E.coordDim = E.coordDimIndex = E.dimsDef = E.otherDims = null;
    }
    var I = f.get(M);
    if (I !== !1) {
      if (I = Ie(I), !I.length)
        for (var P = 0; P < (C && C.length || 1); P++) {
          for (; g < o && p(g).coordDim != null; )
            g++;
          g < o && I.push(g++);
        }
      L(I, function(O, N) {
        var B = p(O);
        if (l && E.type != null && (B.type = E.type), v(Bt(B, E), M, N), B.name == null && C) {
          var F = C[N];
          !Lt(F) && (F = {
            name: F
          }), B.name = B.displayName = F.name, B.defaultTooltip = F.defaultTooltip;
        }
        R && Bt(B.otherDims, R);
      });
    }
  });
  function v(T, M, C) {
    Wx.get(M) != null ? T.otherDims[M] = C : (T.coordDim = M, T.coordDimIndex = C, i.set(M, !0));
  }
  var m = t.generateCoord, y = t.generateCoordCount, _ = y != null;
  y = m ? y || 1 : 0;
  var x = m || "value";
  function b(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (s)
    L(a, function(T) {
      b(T);
    }), a.sort(function(T, M) {
      return T.storeDimIndex - M.storeDimIndex;
    });
  else
    for (var S = 0; S < o; S++) {
      var w = p(S), A = w.coordDim;
      A == null && (w.coordDim = R$(x, i, _), w.coordDimIndex = 0, (!m || y <= 0) && (w.isExtraCoord = !0), y--), b(w), w.type == null && (tO(r, S) === zr.Must || w.isExtraCoord && (w.otherDims.itemName != null || w.otherDims.seriesName != null)) && (w.type = "ordinal");
    }
  return D$(a), new ak({
    source: r,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function D$(r) {
  for (var t = wt(), e = 0; e < r.length; e++) {
    var n = r[e], i = n.name, a = t.get(i) || 0;
    a > 0 && (n.name = i + (a - 1)), a++, t.set(i, a);
  }
}
function L$(r, t, e, n) {
  var i = Math.max(r.dimensionsDetectedCount || 1, t.length, e.length, n || 0);
  return L(t, function(a) {
    var o;
    Lt(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
  }), i;
}
function R$(r, t, e) {
  if (e || t.hasKey(r)) {
    for (var n = 0; t.hasKey(r + n); )
      n++;
    r += n;
  }
  return t.set(r, !0), r;
}
var I$ = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.coordSysDims = [], this.axisMap = wt(), this.categoryAxisMap = wt(), this.coordSysName = t;
    }
    return r;
  }()
);
function P$(r) {
  var t = r.get("coordinateSystem"), e = new I$(t), n = N$[t];
  if (n)
    return n(r, e, e.axisMap, e.categoryAxisMap), e;
}
var N$ = {
  cartesian2d: function(r, t, e, n) {
    var i = r.getReferringComponents("xAxis", je).models[0], a = r.getReferringComponents("yAxis", je).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + mr(r.get("xAxisIndex"), r.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + mr(r.get("xAxisIndex"), r.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], e.set("x", i), e.set("y", a), pu(i) && (n.set("x", i), t.firstCategoryDimIndex = 0), pu(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(r, t, e, n) {
    var i = r.getReferringComponents("singleAxis", je).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], e.set("single", i), pu(i) && (n.set("single", i), t.firstCategoryDimIndex = 0);
  },
  polar: function(r, t, e, n) {
    var i = r.getReferringComponents("polar", je).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], e.set("radius", a), e.set("angle", o), pu(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), pu(o) && (n.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(r, t, e, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(r, t, e, n) {
    var i = r.ecModel, a = i.getComponent("parallel", r.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
    L(a.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = o[l];
      e.set(c, u), pu(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(r, t, e, n) {
    var i = r.getReferringComponents("matrix", je).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = i.getDimensionModel("x"), o = i.getDimensionModel("y");
    e.set("x", a), e.set("y", o), n.set("x", a), n.set("y", o);
  }
};
function pu(r) {
  return r.get("type") === "category";
}
function O$(r, t, e) {
  e = e || {};
  var n = e.byIndex, i = e.stackedCoordDimension, a, o, s;
  k$(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
  var l = !!(r && r.get("stack")), u, c, f, h;
  if (L(a, function(y, _) {
    pt(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    f = "__\0ecstackresult_" + r.id, h = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = !0);
    var d = c.coordDim, p = c.type, g = 0;
    L(a, function(y) {
      y.coordDim === d && g++;
    });
    var v = {
      name: f,
      coordDim: d,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, m = {
      name: h,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: h,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (v.storeDimIndex = s.ensureCalculationDimension(h, p), m.storeDimIndex = s.ensureCalculationDimension(f, p)), o.appendCalculationDimension(v), o.appendCalculationDimension(m)) : (a.push(v), a.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: h,
    stackResultDimension: f
  };
}
function k$(r) {
  return !ok(r.schema);
}
function Wo(r, t) {
  return !!t && t === r.getCalculationInfo("stackedDimension");
}
function ck(r, t) {
  return Wo(r, t) ? r.getCalculationInfo("stackResultDimension") : t;
}
function B$(r, t) {
  var e = r.get("coordinateSystem"), n = Cc.get(e), i;
  return t && t.coordSysDims && (i = rt(t.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = t.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = Kv(l);
    }
    return o;
  })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), i;
}
function V$(r, t, e) {
  var n, i;
  return e && L(r, function(a, o) {
    var s = a.coordDim, l = e.categoryAxisMap.get(s);
    l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (i = !0);
  }), !i && n != null && (r[n].otherDims.itemName = 0), n;
}
function Ja(r, t, e) {
  e = e || {};
  var n = t.getSourceManager(), i, a = !1;
  r ? (a = !0, i = ub(r)) : (i = n.getSource(), a = i.sourceFormat === Vn);
  var o = P$(t), s = B$(t, o), l = e.useEncodeDefaulter, u = At(l) ? l : l ? Yt(QN, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: e.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, f = Hh(i, c), h = V$(f.dimensions, e.createInvertedIndices, o), d = a ? null : n.getSharedDataStore(f), p = O$(t, {
    schema: f,
    store: d
  }), g = new cn(f, t);
  g.setCalculationInfo(p);
  var v = h != null && F$(i) ? function(m, y, _, x) {
    return x === h ? _ : this.defaultDimValueGetter(m, y, _, x);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? i : d,
    null,
    v
  ), g;
}
function F$(r) {
  if (r.sourceFormat === Vn) {
    var t = z$(r.data || []);
    return !et(Sc(t));
  }
}
function z$(r) {
  for (var t = 0; t < r.length && r[t] == null; )
    t++;
  return r[t];
}
function U$(r) {
  var t = Math.pow(10, $g(Math.abs(r))), e = Math.abs(r / t);
  return e === 0 || e === 1 || e === 2 || e === 3 || e === 5;
}
function aS(r) {
  return r.type === "interval" || r.type === "log";
}
function G$(r, t, e, n, i) {
  var a = {}, o = a.interval = RP(t / e);
  n != null && o < n && (o = a.interval = n), i != null && o > i && (o = a.interval = i);
  var s = a.intervalPrecision = ph(o), l = a.niceTickExtent = [sr(Math.ceil(r[0] / o) * o, s), sr(Math.floor(r[1] / o) * o, s)];
  return H$(l, r), a;
}
function m0(r) {
  var t = Math.pow(10, $g(r)), e = r / t;
  return e ? e === 2 ? e = 3 : e === 3 ? e = 5 : e *= 2 : e = 1, sr(e * t);
}
function ph(r) {
  return $i(r) + 2;
}
function eC(r, t, e) {
  r[t] = Math.max(Math.min(r[t], e[1]), e[0]);
}
function H$(r, t) {
  !isFinite(r[0]) && (r[0] = t[0]), !isFinite(r[1]) && (r[1] = t[1]), eC(r, 0, t), eC(r, 1, t), r[0] > r[1] && (r[0] = r[1]);
}
function xb(r, t) {
  return r >= t[0] && r <= t[1];
}
var W$ = (
  /** @class */
  function() {
    function r() {
      this.normalize = rC, this.scale = nC;
    }
    return r.prototype.updateMethods = function(t) {
      t.hasBreaks() ? (this.normalize = gt(t.normalize, t), this.scale = gt(t.scale, t)) : (this.normalize = rC, this.scale = nC);
    }, r;
  }()
);
function rC(r, t) {
  return t[1] === t[0] ? 0.5 : (r - t[0]) / (t[1] - t[0]);
}
function nC(r, t) {
  return r * (t[1] - t[0]) + t[0];
}
function oS(r, t, e) {
  var n = Math.log(r);
  return [
    // log(negative) is NaN, so safe guard here.
    // PENDING: But even getting a -Infinity still does not make sense in extent.
    //  Just keep it as is, getting a NaN to make some previous cases works by coincidence.
    Math.log(e ? t[0] : Math.max(0, t[0])) / n,
    Math.log(e ? t[1] : Math.max(0, t[1])) / n
  ];
}
var Qo = (
  /** @class */
  function() {
    function r(t) {
      this._calculator = new W$(), this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
      var e = ur();
      e && (this._brkCtx = e.createScaleBreakContext(), this._brkCtx.update(this._extent));
    }
    return r.prototype.getSetting = function(t) {
      return this._setting[t];
    }, r.prototype._innerUnionExtent = function(t) {
      var e = this._extent;
      this._innerSetExtent(t[0] < e[0] ? t[0] : e[0], t[1] > e[1] ? t[1] : e[1]);
    }, r.prototype.unionExtentFromData = function(t, e) {
      this._innerUnionExtent(t.getApproximateExtent(e));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(t, e) {
      this._innerSetExtent(t, e);
    }, r.prototype._innerSetExtent = function(t, e) {
      var n = this._extent;
      isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e), this._brkCtx && this._brkCtx.update(n);
    }, r.prototype.setBreaksFromOption = function(t) {
      var e = ur();
      e && this._innerSetBreak(e.parseAxisBreakOption(t, gt(this.parse, this)));
    }, r.prototype._innerSetBreak = function(t) {
      this._brkCtx && (this._brkCtx.setBreaks(t), this._calculator.updateMethods(this._brkCtx), this._brkCtx.update(this._extent));
    }, r.prototype._innerGetBreaks = function() {
      return this._brkCtx ? this._brkCtx.breaks : [];
    }, r.prototype.hasBreaks = function() {
      return this._brkCtx ? this._brkCtx.hasBreaks() : !1;
    }, r.prototype._getExtentSpanWithBreaks = function() {
      return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
    }, r.prototype.isInExtentRange = function(t) {
      return this._extent[0] <= t && this._extent[1] >= t;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(t) {
      this._isBlank = t;
    }, r;
  }()
);
qg(Qo);
var X$ = 0, vh = (
  /** @class */
  function() {
    function r(t) {
      this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++X$, this._onCollect = t.onCollect;
    }
    return r.createByAxisModel = function(t) {
      var e = t.option, n = e.data, i = n && rt(n, Y$);
      return new r({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: e.dedplication !== !1
      });
    }, r.prototype.getOrdinal = function(t) {
      return this._getOrCreateMap().get(t);
    }, r.prototype.parseAndCollect = function(t) {
      var e, n = this._needCollect;
      if (!pt(t) && !n)
        return t;
      if (n && !this._deduplication)
        return e = this.categories.length, this.categories[e] = t, this._onCollect && this._onCollect(t, e), e;
      var i = this._getOrCreateMap();
      return e = i.get(t), e == null && (n ? (e = this.categories.length, this.categories[e] = t, i.set(t, e), this._onCollect && this._onCollect(t, e)) : e = NaN), e;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = wt(this.categories));
    }, r;
  }()
);
function Y$(r) {
  return Lt(r) && r.value != null ? r.value : r + "";
}
var sc = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new vh({})), et(i) && (i = new vh({
        categories: rt(i, function(a) {
          return Lt(a) ? a.value : a;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [0, i.categories.length - 1], n;
    }
    return t.prototype.parse = function(e) {
      return e == null ? NaN : pt(e) ? this._ordinalMeta.getOrdinal(e) : Math.round(e);
    }, t.prototype.contain = function(e) {
      return xb(e, this._extent) && e >= 0 && e < this._ordinalMeta.categories.length;
    }, t.prototype.normalize = function(e) {
      return e = this._getTickNumber(e), this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return e = Math.round(this._calculator.scale(e, this._extent)), this.getRawOrdinalNumber(e);
    }, t.prototype.getTicks = function() {
      for (var e = [], n = this._extent, i = n[0]; i <= n[1]; )
        e.push({
          value: i
        }), i++;
      return e;
    }, t.prototype.getMinorTicks = function(e) {
    }, t.prototype.setSortInfo = function(e) {
      if (e == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = e.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); o < l; ++o) {
        var u = n[o];
        i[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; )
          c++;
        i.push(c), a[c] = o;
      }
    }, t.prototype._getTickNumber = function(e) {
      var n = this._ticksByOrdinalNumber;
      return n && e >= 0 && e < n.length ? n[e] : e;
    }, t.prototype.getRawOrdinalNumber = function(e) {
      var n = this._ordinalNumbersByTick;
      return n && e >= 0 && e < n.length ? n[e] : e;
    }, t.prototype.getLabel = function(e) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(e.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, t.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, t.prototype.isInExtentRange = function(e) {
      return e = this._getTickNumber(e), this._extent[0] <= e && this._extent[1] >= e;
    }, t.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, t.prototype.calcNiceTicks = function() {
    }, t.prototype.calcNiceExtent = function() {
    }, t.type = "ordinal", t;
  }(Qo)
);
Qo.registerClass(sc);
var fo = sr, $a = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "interval", e._interval = 0, e._intervalPrecision = 2, e;
    }
    return t.prototype.parse = function(e) {
      return e == null || e === "" ? NaN : Number(e);
    }, t.prototype.contain = function(e) {
      return xb(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return this._calculator.scale(e, this._extent);
    }, t.prototype.getInterval = function() {
      return this._interval;
    }, t.prototype.setInterval = function(e) {
      this._interval = e, this._niceExtent = this._extent.slice(), this._intervalPrecision = ph(e);
    }, t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = ur(), l = [];
      if (!n)
        return l;
      if (e.breakTicks === "only_break" && s)
        return s.addBreaksToTicks(l, this._brkCtx.breaks, this._extent), l;
      var u = 1e4;
      i[0] < a[0] && (e.expandToNicedExtent ? l.push({
        value: fo(a[0] - n, o)
      }) : l.push({
        value: i[0]
      }));
      for (var c = function(p, g) {
        return Math.round((g - p) / n);
      }, f = a[0]; f <= a[1]; ) {
        if (l.push({
          value: f
        }), f = fo(f + n, o), this._brkCtx) {
          var h = this._brkCtx.calcNiceTickMultiple(f, c);
          h >= 0 && (f = fo(f + h * n, o));
        }
        if (l.length > 0 && f === l[l.length - 1].value)
          break;
        if (l.length > u)
          return [];
      }
      var d = l.length ? l[l.length - 1].value : a[1];
      return i[1] > d && (e.expandToNicedExtent ? l.push({
        value: fo(d + n, o)
      }) : l.push({
        value: i[1]
      })), s && s.pruneTicksByBreak(e.pruneByBreak, l, this._brkCtx.breaks, function(p) {
        return p.value;
      }, this._interval, this._extent), e.breakTicks !== "none" && s && s.addBreaksToTicks(l, this._brkCtx.breaks, this._extent), l;
    }, t.prototype.getMinorTicks = function(e) {
      for (var n = this.getTicks({
        expandToNicedExtent: !0
      }), i = [], a = this.getExtent(), o = 1; o < n.length; o++) {
        var s = n[o], l = n[o - 1];
        if (!(l.break || s.break)) {
          for (var u = 0, c = [], f = s.value - l.value, h = f / e, d = ph(h); u < e - 1; ) {
            var p = fo(l.value + (u + 1) * h, d);
            p > a[0] && p < a[1] && c.push(p), u++;
          }
          var g = ur();
          g && g.pruneTicksByBreak("auto", c, this._getNonTransBreaks(), function(v) {
            return v;
          }, this._interval, a), i.push(c);
        }
      }
      return i;
    }, t.prototype._getNonTransBreaks = function() {
      return this._brkCtx ? this._brkCtx.breaks : [];
    }, t.prototype.getLabel = function(e, n) {
      if (e == null)
        return "";
      var i = n && n.precision;
      i == null ? i = $i(e.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = fo(e.value, i, !0);
      return FN(a);
    }, t.prototype.calcNiceTicks = function(e, n, i) {
      e = e || 5;
      var a = this._extent.slice(), o = this._getExtentSpanWithBreaks();
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse(), this._innerSetExtent(a[0], a[1]), a = this._extent.slice());
        var s = G$(a, o, e, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      var n = this._extent.slice();
      if (n[0] === n[1])
        if (n[0] !== 0) {
          var i = Math.abs(n[0]);
          e.fixMax || (n[1] += i / 2), n[0] -= i / 2;
        } else
          n[1] = 1;
      var a = n[1] - n[0];
      isFinite(a) || (n[0] = 0, n[1] = 1), this._innerSetExtent(n[0], n[1]), n = this._extent.slice(), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
      var o = this._interval, s = this._intervalPrecision;
      e.fixMin || (n[0] = fo(Math.floor(n[0] / o) * o, s)), e.fixMax || (n[1] = fo(Math.ceil(n[1] / o) * o, s)), this._innerSetExtent(n[0], n[1]);
    }, t.prototype.setNiceExtent = function(e, n) {
      this._niceExtent = [e, n];
    }, t.type = "interval", t;
  }(Qo)
);
Qo.registerClass($a);
var fk = typeof Float32Array < "u", $$ = fk ? Float32Array : Array;
function qi(r) {
  return et(r) ? fk ? new Float32Array(r) : r : new $$(r);
}
var sS = "__ec_stack_";
function hk(r) {
  return r.get("stack") || sS + r.seriesIndex;
}
function Sb(r) {
  return r.dim + r.index;
}
function Z$(r) {
  var t = [], e = r.axis, n = "axis0";
  if (e.type === "category") {
    for (var i = e.getBandWidth(), a = 0; a < r.count; a++)
      t.push(Bt({
        bandWidth: i,
        axisKey: n,
        stackId: sS + a
      }, r));
    for (var o = vk(t), s = [], a = 0; a < r.count; a++) {
      var l = o[n][sS + a];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function dk(r, t) {
  var e = [];
  return t.eachSeriesByType(r, function(n) {
    yk(n) && e.push(n);
  }), e;
}
function q$(r) {
  var t = {};
  L(r, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var f = l.getData(), h = c.dim + "_" + c.index, d = f.getDimensionIndex(f.mapDimension(c.dim)), p = f.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(d, g);
        t[h] ? t[h].push(m) : t[h] = [m];
      }
  });
  var e = {};
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var i = t[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        e[n] = a;
      }
    }
  return e;
}
function pk(r) {
  var t = q$(r), e = [];
  return L(r, function(n) {
    var i = n.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = t[l], c = Math.abs(o[1] - o[0]), f = a.scale.getExtent(), h = Math.abs(f[1] - f[0]);
      s = u ? c / h * u : c;
    } else {
      var d = n.getData();
      s = Math.abs(o[1] - o[0]) / d.count();
    }
    var p = dt(n.get("barWidth"), s), g = dt(n.get("barMaxWidth"), s), v = dt(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      n.get("barMinWidth") || (_k(n) ? 0.5 : 1),
      s
    ), m = n.get("barGap"), y = n.get("barCategoryGap"), _ = n.get("defaultBarGap");
    e.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: m,
      barCategoryGap: y,
      defaultBarGap: _,
      axisKey: Sb(a),
      stackId: hk(n)
    });
  }), vk(e);
}
function vk(r) {
  var t = {};
  L(r, function(n, i) {
    var a = n.axisKey, o = n.bandWidth, s = t[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: n.defaultBarGap || 0,
      stacks: {}
    }, l = s.stacks;
    t[a] = s;
    var u = n.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = n.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var f = n.barMaxWidth;
    f && (l[u].maxWidth = f);
    var h = n.barMinWidth;
    h && (l[u].minWidth = h);
    var d = n.barGap;
    d != null && (s.gap = d);
    var p = n.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var e = {};
  return L(t, function(n, i) {
    e[i] = {};
    var a = n.stacks, o = n.bandWidth, s = n.categoryGap;
    if (s == null) {
      var l = se(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = dt(s, o), c = dt(n.gap, 1), f = n.remainedWidth, h = n.autoWidthCount, d = (f - u) / (h + (h - 1) * c);
    d = Math.max(d, 0), L(a, function(m) {
      var y = m.maxWidth, _ = m.minWidth;
      if (m.width) {
        var x = m.width;
        y && (x = Math.min(x, y)), _ && (x = Math.max(x, _)), m.width = x, f -= x + c * x, h--;
      } else {
        var x = d;
        y && y < x && (x = Math.min(y, f)), _ && _ > x && (x = _), x !== d && (m.width = x, f -= x + c * x, h--);
      }
    }), d = (f - u) / (h + (h - 1) * c), d = Math.max(d, 0);
    var p = 0, g;
    L(a, function(m, y) {
      m.width || (m.width = d), g = m, p += m.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    L(a, function(m, y) {
      e[i][y] = e[i][y] || {
        bandWidth: o,
        offset: v,
        width: m.width
      }, v += m.width * (1 + c);
    });
  }), e;
}
function K$(r, t, e) {
  if (r && t) {
    var n = r[Sb(t)];
    return n;
  }
}
function gk(r, t) {
  var e = dk(r, t), n = pk(e);
  L(e, function(i) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = hk(i), u = n[Sb(s)][l], c = u.offset, f = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: f
    });
  });
}
function mk(r) {
  return {
    seriesType: r,
    plan: Dc(),
    reset: function(t) {
      if (yk(t)) {
        var e = t.getData(), n = t.coordinateSystem, i = n.getBaseAxis(), a = n.getOtherAxis(i), o = e.getDimensionIndex(e.mapDimension(a.dim)), s = e.getDimensionIndex(e.mapDimension(i.dim)), l = t.get("showBackground", !0), u = e.mapDimension(a.dim), c = e.getCalculationInfo("stackResultDimension"), f = Wo(e, u) && !!e.getCalculationInfo("stackedOnSeries"), h = a.isHorizontal(), d = j$(i, a), p = _k(t), g = t.get("barMinHeight") || 0, v = c && e.getDimensionIndex(c), m = e.getLayout("size"), y = e.getLayout("offset");
        return {
          progress: function(_, x) {
            for (var b = _.count, S = p && qi(b * 3), w = p && l && qi(b * 3), A = p && qi(b), T = n.master.getRect(), M = h ? T.width : T.height, C, R = x.getStore(), E = 0; (C = _.next()) != null; ) {
              var D = R.get(f ? v : o, C), I = R.get(s, C), P = d, O = void 0;
              f && (O = +D - R.get(o, C));
              var N = void 0, B = void 0, F = void 0, G = void 0;
              if (h) {
                var W = n.dataToPoint([D, I]);
                if (f) {
                  var J = n.dataToPoint([O, I]);
                  P = J[0];
                }
                N = P, B = W[1] + y, F = W[0] - P, G = m, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
              } else {
                var W = n.dataToPoint([I, D]);
                if (f) {
                  var J = n.dataToPoint([I, O]);
                  P = J[1];
                }
                N = W[0] + y, B = P, F = m, G = W[1] - P, Math.abs(G) < g && (G = (G <= 0 ? -1 : 1) * g);
              }
              p ? (S[E] = N, S[E + 1] = B, S[E + 2] = h ? F : G, w && (w[E] = h ? T.x : N, w[E + 1] = h ? B : T.y, w[E + 2] = M), A[C] = C) : x.setItemLayout(C, {
                x: N,
                y: B,
                width: F,
                height: G
              }), E += 3;
            }
            p && x.setLayout({
              largePoints: S,
              largeDataIndices: A,
              largeBackgroundPoints: w,
              valueAxisHorizontal: h
            });
          }
        };
      }
    }
  };
}
function yk(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function _k(r) {
  return r.pipelineContext && r.pipelineContext.large;
}
function j$(r, t) {
  var e = t.model.get("startValue");
  return e || (e = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? e > 0 ? e : 1 : e));
}
var J$ = function(r, t, e, n) {
  for (; e < n; ) {
    var i = e + n >>> 1;
    r[i][1] < t ? e = i + 1 : n = i;
  }
  return e;
}, bb = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "time", n;
    }
    return t.prototype.getLabel = function(e) {
      var n = this.getSetting("useUTC");
      return um(e.value, $A[S9(Zf(this._minLevelUnit))] || $A.second, n, this.getSetting("locale"));
    }, t.prototype.getFormattedLabel = function(e, n, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return b9(e, n, i, o, a);
    }, t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._interval, i = this._extent, a = ur(), o = [];
      if (!n)
        return o;
      var s = this.getSetting("useUTC");
      if (a && e.breakTicks === "only_break")
        return ur().addBreaksToTicks(o, this._brkCtx.breaks, this._extent), o;
      var l = Vu(i[1], s);
      o.push({
        value: i[0],
        time: {
          level: 0,
          upperTimeUnit: l,
          lowerTimeUnit: l
        }
      });
      var u = aZ(this._minLevelUnit, this._approxInterval, s, i, this._getExtentSpanWithBreaks(), this._brkCtx);
      o = o.concat(u);
      var c = Vu(i[1], s);
      o.push({
        value: i[1],
        time: {
          level: 0,
          upperTimeUnit: c,
          lowerTimeUnit: c
        }
      });
      var f = this.getSetting("useUTC"), h = Dn.length - 1, d = 0;
      return L(o, function(p) {
        h = Math.min(h, Zt(Dn, p.time.upperTimeUnit)), d = Math.max(d, p.time.level);
      }), a && ur().pruneTicksByBreak(e.pruneByBreak, o, this._brkCtx.breaks, function(p) {
        return p.value;
      }, this._approxInterval, this._extent), a && e.breakTicks !== "none" && ur().addBreaksToTicks(o, this._brkCtx.breaks, this._extent, function(p) {
        for (var g = Math.max(Zt(Dn, Vu(p.vmin, f)), Zt(Dn, Vu(p.vmax, f))), v = 0, m = 0; m < Dn.length; m++)
          if (!xk(Dn[m], p.vmin, p.vmax, f)) {
            v = m;
            break;
          }
        var y = Math.min(v, h), _ = Math.max(y, g);
        return {
          level: d,
          lowerTimeUnit: Dn[_],
          upperTimeUnit: Dn[y]
        };
      }), o;
    }, t.prototype.calcNiceExtent = function(e) {
      var n = this.getExtent();
      if (n[0] === n[1] && (n[0] -= ti, n[1] += ti), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - ti;
      }
      this._innerSetExtent(n[0], n[1]), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
    }, t.prototype.calcNiceTicks = function(e, n, i) {
      e = e || 10;
      var a = this._getExtentSpanWithBreaks();
      this._approxInterval = a / e, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var o = rp.length, s = Math.min(J$(rp, this._approxInterval, 0, o), o - 1);
      this._interval = rp[s][1], this._intervalPrecision = ph(this._interval), this._minLevelUnit = rp[Math.max(s - 1, 0)][0];
    }, t.prototype.parse = function(e) {
      return fe(e) ? e : +Al(e);
    }, t.prototype.contain = function(e) {
      return xb(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return this._calculator.scale(e, this._extent);
    }, t.type = "time", t;
  }($a)
), rp = [
  // Format                           interval
  ["second", q1],
  ["minute", K1],
  ["hour", $f],
  ["quarter-day", $f * 6],
  ["half-day", $f * 12],
  ["day", ti * 1.2],
  ["half-week", ti * 3.5],
  ["week", ti * 7],
  ["month", ti * 31],
  ["quarter", ti * 95],
  ["half-year", YA / 2],
  ["year", YA]
  // 1Y
];
function xk(r, t, e, n) {
  return zx(new Date(t), r, n).getTime() === zx(new Date(e), r, n).getTime();
}
function Q$(r, t) {
  return r /= ti, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
}
function tZ(r) {
  var t = 30 * ti;
  return r /= t, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
}
function eZ(r) {
  return r /= $f, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
}
function iC(r, t) {
  return r /= t ? K1 : q1, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
}
function rZ(r) {
  return RP(r);
}
function nZ(r, t, e) {
  var n = Math.max(0, Zt(Dn, t) - 1);
  return zx(new Date(r), Dn[n], e).getTime();
}
function iZ(r, t) {
  var e = /* @__PURE__ */ new Date(0);
  e[r](1);
  var n = e.getTime();
  e[r](1 + t);
  var i = e.getTime() - n;
  return function(a, o) {
    return Math.max(0, Math.round((o - a) / i));
  };
}
function aZ(r, t, e, n, i, a) {
  var o = 1e4, s = m9, l = 0;
  function u(E, D, I, P, O, N, B) {
    for (var F = iZ(O, E), G = D, W = new Date(G); G < I && G <= n[1]; ) {
      if (B.push({
        value: G
      }), l++ > o) {
        process.env.NODE_ENV !== "production" && Ye("Exceed safe limit in time scale.");
        break;
      }
      if (W[O](W[P]() + E), G = W.getTime(), a) {
        var J = a.calcNiceTickMultiple(G, F);
        J > 0 && (W[O](W[P]() + J * E), G = W.getTime());
      }
    }
    B.push({
      value: G,
      notAdd: !0
    });
  }
  function c(E, D, I) {
    var P = [], O = !D.length;
    if (!xk(Zf(E), n[0], n[1], e)) {
      O && (D = [{
        value: nZ(n[0], E, e)
      }, {
        value: n[1]
      }]);
      for (var N = 0; N < D.length - 1; N++) {
        var B = D[N].value, F = D[N + 1].value;
        if (B !== F) {
          var G = void 0, W = void 0, J = void 0, U = !1;
          switch (E) {
            case "year":
              G = Math.max(1, Math.round(t / ti / 365)), W = IN(e), J = w9(e);
              break;
            case "half-year":
            case "quarter":
            case "month":
              G = tZ(t), W = j1(e), J = PN(e);
              break;
            case "week":
            case "half-week":
            case "day":
              G = Q$(t), W = J1(e), J = NN(e), U = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              G = eZ(t), W = Q1(e), J = ON(e);
              break;
            case "minute":
              G = iC(t, !0), W = tb(e), J = kN(e);
              break;
            case "second":
              G = iC(t, !1), W = eb(e), J = BN(e);
              break;
            case "millisecond":
              G = rZ(t), W = rb(e), J = VN(e);
              break;
          }
          F >= n[0] && B <= n[1] && u(G, B, F, W, J, U, P), E === "year" && I.length > 1 && N === 0 && I.unshift({
            value: I[0].value - G
          });
        }
      }
      for (var N = 0; N < P.length; N++)
        I.push(P[N]);
    }
  }
  for (var f = [], h = [], d = 0, p = 0, g = 0; g < s.length; ++g) {
    var v = Zf(s[g]);
    if (x9(s[g])) {
      c(s[g], f[f.length - 1] || [], h);
      var m = s[g + 1] ? Zf(s[g + 1]) : null;
      if (v !== m) {
        if (h.length) {
          p = d, h.sort(function(E, D) {
            return E.value - D.value;
          });
          for (var y = [], _ = 0; _ < h.length; ++_) {
            var x = h[_].value;
            (_ === 0 || h[_ - 1].value !== x) && (y.push(h[_]), x >= n[0] && x <= n[1] && d++);
          }
          var b = i / t;
          if (d > b * 1.5 && p > b / 1.5 || (f.push(y), d > b || r === s[g]))
            break;
        }
        h = [];
      }
    }
  }
  for (var S = Te(rt(f, function(E) {
    return Te(E, function(D) {
      return D.value >= n[0] && D.value <= n[1] && !D.notAdd;
    });
  }), function(E) {
    return E.length > 0;
  }), w = [], A = S.length - 1, g = 0; g < S.length; ++g)
    for (var T = S[g], M = 0; M < T.length; ++M) {
      var C = Vu(T[M].value, e);
      w.push({
        value: T[M].value,
        time: {
          level: A - g,
          upperTimeUnit: C,
          lowerTimeUnit: C
        }
      });
    }
  w.sort(function(E, D) {
    return E.value - D.value;
  });
  for (var R = [], g = 0; g < w.length; ++g)
    (g === 0 || w[g].value !== w[g - 1].value) && R.push(w[g]);
  return R;
}
Qo.registerClass(bb);
var lS = sr, oZ = Math.floor, sZ = Math.ceil, np = Math.pow, ip = Math.log, Sk = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "log", e.base = 10, e._originalScale = new $a(), e;
    }
    return t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._extent.slice(), i = this._originalScale.getExtent(), a = r.prototype.getTicks.call(this, e), o = this.base, s = this._originalScale._innerGetBreaks(), l = ur();
      return rt(a, function(u) {
        var c = u.value, f = null, h = np(o, c);
        c === n[0] && this._fixMin ? f = i[0] : c === n[1] && this._fixMax && (f = i[1]);
        var d;
        if (l) {
          var p = l.getTicksLogTransformBreak(u, o, s, ap);
          d = p.vBreak, f == null && (f = p.brkRoundingCriterion);
        }
        return f != null && (h = ap(h, f)), {
          value: h,
          break: d
        };
      }, this);
    }, t.prototype._getNonTransBreaks = function() {
      return this._originalScale._innerGetBreaks();
    }, t.prototype.setExtent = function(e, n) {
      this._originalScale.setExtent(e, n);
      var i = oS(this.base, [e, n]);
      r.prototype.setExtent.call(this, i[0], i[1]);
    }, t.prototype.getExtent = function() {
      var e = this.base, n = r.prototype.getExtent.call(this);
      n[0] = np(e, n[0]), n[1] = np(e, n[1]);
      var i = this._originalScale.getExtent();
      return this._fixMin && (n[0] = ap(n[0], i[0])), this._fixMax && (n[1] = ap(n[1], i[1])), n;
    }, t.prototype.unionExtentFromData = function(e, n) {
      this._originalScale.unionExtentFromData(e, n);
      var i = oS(this.base, e.getApproximateExtent(n), !0);
      this._innerUnionExtent(i);
    }, t.prototype.calcNiceTicks = function(e) {
      e = e || 10;
      var n = this._extent.slice(), i = this._getExtentSpanWithBreaks();
      if (!(!isFinite(i) || i <= 0)) {
        var a = W8(i), o = e / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [lS(sZ(n[0] / a) * a), lS(oZ(n[1] / a) * a)];
        this._interval = a, this._intervalPrecision = ph(a), this._niceExtent = s;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      r.prototype.calcNiceExtent.call(this, e), this._fixMin = e.fixMin, this._fixMax = e.fixMax;
    }, t.prototype.contain = function(e) {
      return e = ip(e) / ip(this.base), r.prototype.contain.call(this, e);
    }, t.prototype.normalize = function(e) {
      return e = ip(e) / ip(this.base), r.prototype.normalize.call(this, e);
    }, t.prototype.scale = function(e) {
      return e = r.prototype.scale.call(this, e), np(this.base, e);
    }, t.prototype.setBreaksFromOption = function(e) {
      var n = ur();
      if (n) {
        var i = n.logarithmicParseBreaksFromOption(e, this.base, gt(this.parse, this)), a = i.parsedOriginal, o = i.parsedLogged;
        this._originalScale._innerSetBreak(a), this._innerSetBreak(o);
      }
    }, t.type = "log", t;
  }($a)
);
function ap(r, t) {
  return lS(r, $i(t));
}
Qo.registerClass(Sk);
var lZ = (
  /** @class */
  function() {
    function r(t, e, n) {
      this._prepareParams(t, e, n);
    }
    return r.prototype._prepareParams = function(t, e, n) {
      n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = t.type === "ordinal";
      this._needCrossZero = t.type === "interval" && e.getNeedCrossZero && e.getNeedCrossZero();
      var a = e.get("min", !0);
      a == null && (a = e.get("startValue", !0));
      var o = this._modelMinRaw = a;
      At(o) ? this._modelMinNum = op(t, o({
        min: n[0],
        max: n[1]
      })) : o !== "dataMin" && (this._modelMinNum = op(t, o));
      var s = this._modelMaxRaw = e.get("max", !0);
      if (At(s) ? this._modelMaxNum = op(t, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = op(t, s)), i)
        this._axisDataLen = e.getCategories().length;
      else {
        var l = e.get("boundaryGap"), u = et(l) ? l : [l || 0, l || 0];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [wi(u[0], 1), wi(u[1], 1)];
      }
    }, r.prototype.calculate = function() {
      var t = this._isOrdinal, e = this._dataMin, n = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = t ? null : n - e || Math.abs(e), s = this._modelMinRaw === "dataMin" ? e : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = t ? i ? 0 : NaN : e - a[0] * o), l == null && (l = t ? i ? i - 1 : NaN : n + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var f = kr(s) || kr(l) || t && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var h = this._determinedMin, d = this._determinedMax;
      return h != null && (s = h, u = !0), d != null && (l = d, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: f
      };
    }, r.prototype.modifyDataMinMax = function(t, e) {
      process.env.NODE_ENV !== "production" && St(!this.frozen), this[cZ[t]] = e;
    }, r.prototype.setDeterminedMinMax = function(t, e) {
      var n = uZ[t];
      process.env.NODE_ENV !== "production" && St(!this.frozen && this[n] == null), this[n] = e;
    }, r.prototype.freeze = function() {
      this.frozen = !0;
    }, r;
  }()
), uZ = {
  min: "_determinedMin",
  max: "_determinedMax"
}, cZ = {
  min: "_dataMin",
  max: "_dataMax"
};
function bk(r, t, e) {
  var n = r.rawExtentInfo;
  return n || (n = new lZ(r, t, e), r.rawExtentInfo = n, n);
}
function op(r, t) {
  return t == null ? null : kr(t) ? NaN : r.parse(t);
}
function wk(r, t) {
  var e = r.type, n = bk(r, t, r.getExtent()).calculate();
  r.setBlank(n.isBlank);
  var i = n.min, a = n.max, o = t.ecModel;
  if (o && e === "time") {
    var s = dk("bar", o), l = !1;
    if (L(s, function(f) {
      l = l || f.getBaseAxis() === t.axis;
    }), l) {
      var u = pk(s), c = fZ(i, a, t, u);
      i = c.min, a = c.max;
    }
  }
  return {
    extent: [i, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: n.minFixed,
    fixMax: n.maxFixed
  };
}
function fZ(r, t, e, n) {
  var i = e.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = K$(n, e.axis);
  if (o === void 0)
    return {
      min: r,
      max: t
    };
  var s = 1 / 0;
  L(o, function(d) {
    s = Math.min(d.offset, s);
  });
  var l = -1 / 0;
  L(o, function(d) {
    l = Math.max(d.offset + d.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = t - r, f = 1 - (s + l) / a, h = c / f - c;
  return t += h * (l / u), r -= h * (s / u), {
    min: r,
    max: t
  };
}
function lc(r, t) {
  var e = t, n = wk(r, e), i = n.extent, a = e.get("splitNumber");
  r instanceof Sk && (r.base = e.get("logBase"));
  var o = r.type, s = e.get("interval"), l = o === "interval" || o === "time";
  r.setBreaksFromOption(Tk(e)), r.setExtent(i[0], i[1]), r.calcNiceExtent({
    splitNumber: a,
    fixMin: n.fixMin,
    fixMax: n.fixMax,
    minInterval: l ? e.get("minInterval") : null,
    maxInterval: l ? e.get("maxInterval") : null
  }), s != null && r.setInterval && r.setInterval(s);
}
function vm(r, t) {
  if (t = t || r.get("type"), t)
    switch (t) {
      case "category":
        return new sc({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new bb({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (Qo.getClass(t) || $a)();
    }
}
function hZ(r) {
  var t = r.scale.getExtent(), e = t[0], n = t[1];
  return !(e > 0 && n > 0 || e < 0 && n < 0);
}
function Ic(r) {
  var t = r.getLabelModel().get("formatter");
  if (r.type === "time") {
    var e = y9(t);
    return function(i, a) {
      return r.scale.getFormattedLabel(i, a, e);
    };
  } else {
    if (pt(t))
      return function(i) {
        var a = r.scale.getLabel(i), o = t.replace("{value}", a ?? "");
        return o;
      };
    if (At(t)) {
      if (r.type === "category")
        return function(i, a) {
          return t(
            jv(r, i),
            i.value - r.scale.getExtent()[0],
            null
            // Using `null` just for backward compat.
          );
        };
      var n = ur();
      return function(i, a) {
        var o = null;
        return n && (o = n.makeAxisLabelFormatterParamBreak(o, i.break)), t(jv(r, i), a, o);
      };
    } else
      return function(i) {
        return r.scale.getLabel(i);
      };
  }
}
function jv(r, t) {
  return r.type === "category" ? r.scale.getLabel(t) : t.value;
}
function wb(r) {
  var t = r.get("interval");
  return t ?? "auto";
}
function Mk(r) {
  return r.type === "category" && wb(r.getLabelModel()) === 0;
}
function Jv(r, t) {
  var e = {};
  return L(r.mapDimensionsAll(t), function(n) {
    e[ck(r, n)] = !0;
  }), se(e);
}
function dZ(r, t, e) {
  t && L(Jv(t, e), function(n) {
    var i = t.getApproximateExtent(n);
    i[0] < r[0] && (r[0] = i[0]), i[1] > r[1] && (r[1] = i[1]);
  });
}
function uc(r) {
  return r === "middle" || r === "center";
}
function gh(r) {
  return r.getShallow("show");
}
function Tk(r) {
  var t = r.get("breaks", !0);
  if (t != null) {
    if (!ur()) {
      process.env.NODE_ENV !== "production" && ce('Must `import {AxisBreak} from "echarts/features.js"; use(AxisBreak);` first if using breaks option.');
      return;
    }
    if (!pZ(r.axis)) {
      process.env.NODE_ENV !== "production" && ce("Axis '" + r.axis.dim + "'-'" + r.axis.type + "' does not support break.");
      return;
    }
    return t;
  }
}
function pZ(r) {
  return (r.dim === "x" || r.dim === "y" || r.dim === "z" || r.dim === "single") && r.type !== "category";
}
var Wh = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var t = this.option;
      return !t.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }()
), vZ = 1e-8;
function aC(r, t) {
  return Math.abs(r - t) < vZ;
}
function Hs(r, t, e) {
  var n = 0, i = r[0];
  if (!i)
    return !1;
  for (var a = 1; a < r.length; a++) {
    var o = r[a];
    n += Ta(i[0], i[1], o[0], o[1], t, e), i = o;
  }
  var s = r[0];
  return (!aC(i[0], s[0]) || !aC(i[1], s[1])) && (n += Ta(i[0], i[1], s[0], s[1], t, e)), n !== 0;
}
var gZ = [];
function y0(r, t) {
  for (var e = 0; e < r.length; e++)
    nr(r[e], r[e], t);
}
function oC(r, t, e, n) {
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    n && (a = n.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (bo(t, t, a), wo(e, e, a));
  }
}
function mZ(r) {
  for (var t = 0, e = 0, n = 0, i = r.length, a = r[i - 1][0], o = r[i - 1][1], s = 0; s < i; s++) {
    var l = r[s][0], u = r[s][1], c = a * u - l * o;
    t += c, e += (a + l) * c, n += (o + u) * c, a = l, o = u;
  }
  return t ? [e / t / 3, n / t / 3, t] : [r[0][0] || 0, r[0][1] || 0];
}
var Ak = (
  /** @class */
  function() {
    function r(t) {
      this.name = t;
    }
    return r.prototype.setCenter = function(t) {
      this._center = t;
    }, r.prototype.getCenter = function() {
      var t = this._center;
      return t || (t = this._center = this.calcCenter()), t;
    }, r;
  }()
), sC = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, e) {
      this.type = "polygon", this.exterior = t, this.interiors = e;
    }
    return r;
  }()
), lC = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.type = "linestring", this.points = t;
    }
    return r;
  }()
), Ek = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this, e) || this;
      return a.type = "geoJSON", a.geometries = n, a._center = i && [i[0], i[1]], a;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this.geometries, n, i = 0, a = 0; a < e.length; a++) {
        var o = e[a], s = o.exterior, l = s && s.length;
        l > i && (n = o, i = l);
      }
      if (n)
        return mZ(n.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, t.prototype.getBoundingRect = function(e) {
      var n = this._rect;
      if (n && !e)
        return n;
      var i = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return L(o, function(s) {
        s.type === "polygon" ? oC(s.exterior, i, a, e) : L(s.points, function(l) {
          oC(l, i, a, e);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), n = new Vt(i[0], i[1], a[0] - i[0], a[1] - i[1]), e || (this._rect = n), n;
    }, t.prototype.contain = function(e) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(e[0], e[1]))
        return !1;
      t:
        for (var a = 0, o = i.length; a < o; a++) {
          var s = i[a];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (Hs(l, e[0], e[1])) {
              for (var c = 0; c < (u ? u.length : 0); c++)
                if (Hs(u[c], e[0], e[1]))
                  continue t;
              return !0;
            }
          }
        }
      return !1;
    }, t.prototype.transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new Vt(e, n, i, a), u = o.calculateTransform(l), c = this.geometries, f = 0; f < c.length; f++) {
        var h = c[f];
        h.type === "polygon" ? (y0(h.exterior, u), L(h.interiors, function(d) {
          y0(d, u);
        })) : L(h.points, function(d) {
          y0(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, t.prototype.cloneShallow = function(e) {
      e == null && (e = this.name);
      var n = new t(e, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, t;
  }(Ak)
), yZ = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      var i = r.call(this, e) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this._elOnlyForCalculate, n = e.getBoundingRect(), i = [n.x + n.width / 2, n.y + n.height / 2], a = Gg(gZ), o = e; o && !o.isGeoSVGGraphicRoot; )
        Ji(a, o.getLocalTransform(), a), o = o.parent;
      return bi(a, a), nr(i, i, a), i;
    }, t;
  }(Ak)
);
function _Z(r) {
  if (!r.UTF8Encoding)
    return r;
  var t = r, e = t.UTF8Scale;
  e == null && (e = 1024);
  var n = t.features;
  return L(n, function(i) {
    var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = Ck(s, o, e);
          break;
        case "Polygon":
          _0(s, o, e);
          break;
        case "MultiLineString":
          _0(s, o, e);
          break;
        case "MultiPolygon":
          L(s, function(l, u) {
            return _0(l, o[u], e);
          });
      }
  }), t.UTF8Encoding = !1, t;
}
function _0(r, t, e) {
  for (var n = 0; n < r.length; n++)
    r[n] = Ck(r[n], t[n], e);
}
function Ck(r, t, e) {
  for (var n = [], i = t[0], a = t[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, n.push([s / e, l / e]);
  }
  return n;
}
function xZ(r, t) {
  return r = _Z(r), rt(Te(r.features, function(e) {
    return e.geometry && e.properties && e.geometry.coordinates.length > 0;
  }), function(e) {
    var n = e.properties, i = e.geometry, a = [];
    switch (i.type) {
      case "Polygon":
        var o = i.coordinates;
        a.push(new sC(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        L(i.coordinates, function(l) {
          l[0] && a.push(new sC(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new lC([i.coordinates]));
        break;
      case "MultiLineString":
        a.push(new lC(i.coordinates));
    }
    var s = new Ek(n[t || "name"], a, n.cp);
    return s.properties = n, s;
  });
}
var SZ = ee(), jf = ee(), Mi = {
  estimate: 1,
  determine: 2
};
function Qv(r) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: r
  };
}
function Dk(r, t) {
  var e = rt(t, function(n) {
    return r.scale.parse(n);
  });
  return r.type === "time" && e.length > 0 && (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])), e;
}
function bZ(r, t) {
  var e = r.getLabelModel().get("customValues");
  if (e) {
    var n = Ic(r), i = r.scale.getExtent(), a = Dk(r, e), o = Te(a, function(s) {
      return s >= i[0] && s <= i[1];
    });
    return {
      labels: rt(o, function(s) {
        var l = {
          value: s
        };
        return {
          formattedLabel: n(l),
          rawLabel: r.scale.getLabel(l),
          tickValue: s,
          time: void 0,
          break: void 0
        };
      })
    };
  }
  return r.type === "category" ? MZ(r, t) : AZ(r);
}
function wZ(r, t, e) {
  var n = r.getTickModel().get("customValues");
  if (n) {
    var i = r.scale.getExtent(), a = Dk(r, n);
    return {
      ticks: Te(a, function(o) {
        return o >= i[0] && o <= i[1];
      })
    };
  }
  return r.type === "category" ? TZ(r, t) : {
    ticks: rt(r.scale.getTicks(e), function(o) {
      return o.value;
    })
  };
}
function MZ(r, t) {
  var e = r.getLabelModel(), n = Lk(r, e, t);
  return !e.get("show") || r.scale.isBlank() ? {
    labels: []
  } : n;
}
function Lk(r, t, e) {
  var n = CZ(r), i = wb(t), a = e.kind === Mi.estimate;
  if (!a) {
    var o = Ik(n, i);
    if (o)
      return o;
  }
  var s, l;
  At(i) ? s = Ok(r, i) : (l = i === "auto" ? DZ(r, e) : i, s = Nk(r, l));
  var u = {
    labels: s,
    labelCategoryInterval: l
  };
  return a ? e.out.noPxChangeTryDetermine.push(function() {
    return uS(n, i, u), !0;
  }) : uS(n, i, u), u;
}
function TZ(r, t) {
  var e = EZ(r), n = wb(t), i = Ik(e, n);
  if (i)
    return i;
  var a, o;
  if ((!t.get("show") || r.scale.isBlank()) && (a = []), At(n))
    a = Ok(r, n, !0);
  else if (n === "auto") {
    var s = Lk(r, r.getLabelModel(), Qv(Mi.determine));
    o = s.labelCategoryInterval, a = rt(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = n, a = Nk(r, o, !0);
  return uS(e, n, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function AZ(r) {
  var t = r.scale.getTicks(), e = Ic(r);
  return {
    labels: rt(t, function(n, i) {
      return {
        formattedLabel: e(n, i),
        rawLabel: r.scale.getLabel(n),
        tickValue: n.value,
        time: n.time,
        break: n.break
      };
    })
  };
}
var EZ = Rk("axisTick"), CZ = Rk("axisLabel");
function Rk(r) {
  return function(e) {
    return jf(e)[r] || (jf(e)[r] = {
      list: []
    });
  };
}
function Ik(r, t) {
  for (var e = 0; e < r.list.length; e++)
    if (r.list[e].key === t)
      return r.list[e].value;
}
function uS(r, t, e) {
  return r.list.push({
    key: t,
    value: e
  }), e;
}
function DZ(r, t) {
  if (t.kind === Mi.estimate) {
    var e = r.calculateCategoryInterval(t);
    return t.out.noPxChangeTryDetermine.push(function() {
      return jf(r).autoInterval = e, !0;
    }), e;
  }
  var n = jf(r).autoInterval;
  return n ?? (jf(r).autoInterval = r.calculateCategoryInterval(t));
}
function LZ(r, t) {
  var e = t.kind, n = IZ(r), i = Ic(r), a = (n.axisRotate - n.labelRotate) / 180 * Math.PI, o = r.scale, s = o.getExtent(), l = o.count();
  if (s[1] - s[0] < 1)
    return 0;
  var u = 1, c = 40;
  l > c && (u = Math.max(1, Math.floor(l / c)));
  for (var f = s[0], h = r.dataToCoord(f + 1) - r.dataToCoord(f), d = Math.abs(h * Math.cos(a)), p = Math.abs(h * Math.sin(a)), g = 0, v = 0; f <= s[1]; f += u) {
    var m = 0, y = 0, _ = Xg(i({
      value: f
    }), n.font, "center", "top");
    m = _.width * 1.3, y = _.height * 1.3, g = Math.max(g, m, 7), v = Math.max(v, y, 7);
  }
  var x = g / d, b = v / p;
  isNaN(x) && (x = 1 / 0), isNaN(b) && (b = 1 / 0);
  var S = Math.max(0, Math.floor(Math.min(x, b)));
  if (e === Mi.estimate)
    return t.out.noPxChangeTryDetermine.push(gt(RZ, null, r, S, l)), S;
  var w = Pk(r, S, l);
  return w ?? S;
}
function RZ(r, t, e) {
  return Pk(r, t, e) == null;
}
function Pk(r, t, e) {
  var n = SZ(r.model), i = r.getExtent(), a = n.lastAutoInterval, o = n.lastTickCount;
  if (a != null && o != null && Math.abs(a - t) <= 1 && Math.abs(o - e) <= 1 && a > t && n.axisExtent0 === i[0] && n.axisExtent1 === i[1])
    return a;
  n.lastTickCount = e, n.lastAutoInterval = t, n.axisExtent0 = i[0], n.axisExtent1 = i[1];
}
function IZ(r) {
  var t = r.getLabelModel();
  return {
    axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
    labelRotate: t.get("rotate") || 0,
    font: t.getFont()
  };
}
function Nk(r, t, e) {
  var n = Ic(r), i = r.scale, a = i.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = a[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var f = Mk(r), h = o.get("showMinLabel") || f, d = o.get("showMaxLabel") || f;
  h && u !== a[0] && g(a[0]);
  for (var p = u; p <= a[1]; p += l)
    g(p);
  d && p - l !== a[1] && g(a[1]);
  function g(v) {
    var m = {
      value: v
    };
    s.push(e ? v : {
      formattedLabel: n(m),
      rawLabel: i.getLabel(m),
      tickValue: v,
      time: void 0,
      break: void 0
    });
  }
  return s;
}
function Ok(r, t, e) {
  var n = r.scale, i = Ic(r), a = [];
  return L(n.getTicks(), function(o) {
    var s = n.getLabel(o), l = o.value;
    t(o.value, s) && a.push(e ? l : {
      formattedLabel: i(o),
      rawLabel: s,
      tickValue: l,
      time: void 0,
      break: void 0
    });
  }), a;
}
var uC = [0, 1], Ei = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = e, this._extent = n || [0, 0];
    }
    return r.prototype.contain = function(t) {
      var e = this._extent, n = Math.min(e[0], e[1]), i = Math.max(e[0], e[1]);
      return t >= n && t <= i;
    }, r.prototype.containData = function(t) {
      return this.scale.contain(this.scale.parse(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(t) {
      return DP(t || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(t, e) {
      var n = this._extent;
      n[0] = t, n[1] = e;
    }, r.prototype.dataToCoord = function(t, e) {
      var n = this._extent, i = this.scale;
      return t = i.normalize(i.parse(t)), this.onBand && i.type === "ordinal" && (n = n.slice(), cC(n, i.count())), Me(t, uC, n, e);
    }, r.prototype.coordToData = function(t, e) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), cC(n, i.count()));
      var a = Me(t, n, uC, e);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(t, e) {
    }, r.prototype.getTicksCoords = function(t) {
      t = t || {};
      var e = t.tickModel || this.getTickModel(), n = wZ(this, e, {
        breakTicks: t.breakTicks,
        pruneByBreak: t.pruneByBreak
      }), i = n.ticks, a = rt(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = e.get("alignWithLabel");
      return PZ(this, a, o, t.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
      e > 0 && e < 100 || (e = 5);
      var n = this.scale.getMinorTicks(e), i = rt(n, function(a) {
        return rt(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, r.prototype.getViewLabels = function(t) {
      return t = t || Qv(Mi.determine), bZ(this, t).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var t = this._extent, e = this.scale.getExtent(), n = e[1] - e[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(t[1] - t[0]);
      return Math.abs(i) / n;
    }, r.prototype.calculateCategoryInterval = function(t) {
      return t = t || Qv(Mi.determine), LZ(this, t);
    }, r;
  }()
);
function cC(r, t) {
  var e = r[1] - r[0], n = t, i = e / n / 2;
  r[0] += i, r[1] -= i;
}
function PZ(r, t, e, n) {
  var i = t.length;
  if (!r.onBand || e || !i)
    return;
  var a = r.getExtent(), o, s;
  if (i === 1)
    t[0].coord = a[0], t[0].onBand = !0, o = t[1] = {
      coord: a[1],
      tickValue: t[0].tickValue,
      onBand: !0
    };
  else {
    var l = t[i - 1].tickValue - t[0].tickValue, u = (t[i - 1].coord - t[0].coord) / l;
    L(t, function(d) {
      d.coord -= u / 2, d.onBand = !0;
    });
    var c = r.scale.getExtent();
    s = 1 + c[1] - t[i - 1].tickValue, o = {
      coord: t[i - 1].coord + u * s,
      tickValue: c[1] + 1,
      onBand: !0
    }, t.push(o);
  }
  var f = a[0] > a[1];
  h(t[0].coord, a[0]) && (n ? t[0].coord = a[0] : t.shift()), n && h(a[0], t[0].coord) && t.unshift({
    coord: a[0],
    onBand: !0
  }), h(a[1], o.coord) && (n ? o.coord = a[1] : t.pop()), n && h(o.coord, a[1]) && t.push({
    coord: a[1],
    onBand: !0
  });
  function h(d, p) {
    return d = sr(d), p = sr(p), f ? d > p : d < p;
  }
}
var lf = Math.PI * 2, Ds = oa.CMD, NZ = ["top", "right", "bottom", "left"];
function OZ(r, t, e, n, i) {
  var a = e.width, o = e.height;
  switch (r) {
    case "top":
      n.set(e.x + a / 2, e.y - t), i.set(0, -1);
      break;
    case "bottom":
      n.set(e.x + a / 2, e.y + o + t), i.set(0, 1);
      break;
    case "left":
      n.set(e.x - t, e.y + o / 2), i.set(-1, 0);
      break;
    case "right":
      n.set(e.x + a + t, e.y + o / 2), i.set(1, 0);
      break;
  }
}
function kZ(r, t, e, n, i, a, o, s, l) {
  o -= r, s -= t;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var c = o * e + r, f = s * e + t;
  if (Math.abs(n - i) % lf < 1e-4)
    return l[0] = c, l[1] = f, u - e;
  if (a) {
    var h = n;
    n = Nn(i), i = Nn(h);
  } else
    n = Nn(n), i = Nn(i);
  n > i && (i += lf);
  var d = Math.atan2(s, o);
  if (d < 0 && (d += lf), d >= n && d <= i || d + lf >= n && d + lf <= i)
    return l[0] = c, l[1] = f, u - e;
  var p = e * Math.cos(n) + r, g = e * Math.sin(n) + t, v = e * Math.cos(i) + r, m = e * Math.sin(i) + t, y = (p - o) * (p - o) + (g - s) * (g - s), _ = (v - o) * (v - o) + (m - s) * (m - s);
  return y < _ ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(_));
}
function tg(r, t, e, n, i, a, o, s) {
  var l = i - r, u = a - t, c = e - r, f = n - t, h = Math.sqrt(c * c + f * f);
  c /= h, f /= h;
  var d = l * c + u * f, p = d / h;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= h;
  var g = o[0] = r + p * c, v = o[1] = t + p * f;
  return Math.sqrt((g - i) * (g - i) + (v - a) * (v - a));
}
function kk(r, t, e, n, i, a, o) {
  e < 0 && (r = r + e, e = -e), n < 0 && (t = t + n, n = -n);
  var s = r + e, l = t + n, u = o[0] = Math.min(Math.max(i, r), s), c = o[1] = Math.min(Math.max(a, t), l);
  return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
}
var pi = [];
function BZ(r, t, e) {
  var n = kk(t.x, t.y, t.width, t.height, r.x, r.y, pi);
  return e.set(pi[0], pi[1]), n;
}
function VZ(r, t, e) {
  for (var n = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, c = t.data, f = r.x, h = r.y, d = 0; d < c.length; ) {
    var p = c[d++];
    d === 1 && (n = c[d], i = c[d + 1], a = n, o = i);
    var g = u;
    switch (p) {
      case Ds.M:
        a = c[d++], o = c[d++], n = a, i = o;
        break;
      case Ds.L:
        g = tg(n, i, c[d], c[d + 1], f, h, pi, !0), n = c[d++], i = c[d++];
        break;
      case Ds.C:
        g = fP(n, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], f, h, pi), n = c[d++], i = c[d++];
        break;
      case Ds.Q:
        g = dP(n, i, c[d++], c[d++], c[d], c[d + 1], f, h, pi), n = c[d++], i = c[d++];
        break;
      case Ds.A:
        var v = c[d++], m = c[d++], y = c[d++], _ = c[d++], x = c[d++], b = c[d++];
        d += 1;
        var S = !!(1 - c[d++]);
        s = Math.cos(x) * y + v, l = Math.sin(x) * _ + m, d <= 1 && (a = s, o = l);
        var w = (f - v) * _ / y + v;
        g = kZ(v, m, _, x, x + b, S, w, h, pi), n = Math.cos(x + b) * y + v, i = Math.sin(x + b) * _ + m;
        break;
      case Ds.R:
        a = n = c[d++], o = i = c[d++];
        var A = c[d++], T = c[d++];
        g = kk(a, o, A, T, f, h, pi);
        break;
      case Ds.Z:
        g = tg(n, i, a, o, f, h, pi, !0), n = a, i = o;
        break;
    }
    g < u && (u = g, e.set(pi[0], pi[1]));
  }
  return u;
}
var gi = new Ot(), Ve = new Ot(), tr = new Ot(), Ki = new Ot(), Hi = new Ot();
function fC(r, t) {
  if (r) {
    var e = r.getTextGuideLine(), n = r.getTextContent();
    if (n && e) {
      var i = r.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = i.candidates || NZ, s = n.getBoundingRect().clone();
      s.applyTransform(n.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = r.getComputedTransform(), f = c && bi([], c), h = t.get("length2") || 0;
      u && tr.copy(u);
      for (var d = 0; d < o.length; d++) {
        var p = o[d];
        OZ(p, 0, s, gi, Ki), Ot.scaleAndAdd(Ve, gi, Ki, h), Ve.transform(f);
        var g = r.getBoundingRect(), v = u ? u.distance(Ve) : r instanceof ne ? VZ(Ve, r.path, tr) : BZ(Ve, g, tr);
        v < l && (l = v, Ve.transform(c), tr.transform(c), tr.toArray(a[0]), Ve.toArray(a[1]), gi.toArray(a[2]));
      }
      Bk(a, t.get("minTurnAngle")), e.setShape({
        points: a
      });
    }
  }
}
var eg = [], an = new Ot();
function Bk(r, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, gi.fromArray(r[0]), Ve.fromArray(r[1]), tr.fromArray(r[2]), Ot.sub(Ki, gi, Ve), Ot.sub(Hi, tr, Ve);
    var e = Ki.len(), n = Hi.len();
    if (!(e < 1e-3 || n < 1e-3)) {
      Ki.scale(1 / e), Hi.scale(1 / n);
      var i = Ki.dot(Hi), a = Math.cos(t);
      if (a < i) {
        var o = tg(Ve.x, Ve.y, tr.x, tr.y, gi.x, gi.y, eg, !1);
        an.fromArray(eg), an.scaleAndAdd(Hi, o / Math.tan(Math.PI - t));
        var s = tr.x !== Ve.x ? (an.x - Ve.x) / (tr.x - Ve.x) : (an.y - Ve.y) / (tr.y - Ve.y);
        if (isNaN(s))
          return;
        s < 0 ? Ot.copy(an, Ve) : s > 1 && Ot.copy(an, tr), an.toArray(r[1]);
      }
    }
  }
}
function FZ(r, t, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, gi.fromArray(r[0]), Ve.fromArray(r[1]), tr.fromArray(r[2]), Ot.sub(Ki, Ve, gi), Ot.sub(Hi, tr, Ve);
    var n = Ki.len(), i = Hi.len();
    if (!(n < 1e-3 || i < 1e-3)) {
      Ki.scale(1 / n), Hi.scale(1 / i);
      var a = Ki.dot(t), o = Math.cos(e);
      if (a < o) {
        var s = tg(Ve.x, Ve.y, tr.x, tr.y, gi.x, gi.y, eg, !1);
        an.fromArray(eg);
        var l = Math.PI / 2, u = Math.acos(Hi.dot(t)), c = l + u - e;
        if (c >= l)
          Ot.copy(an, tr);
        else {
          an.scaleAndAdd(Hi, s / Math.tan(Math.PI / 2 - c));
          var f = tr.x !== Ve.x ? (an.x - Ve.x) / (tr.x - Ve.x) : (an.y - Ve.y) / (tr.y - Ve.y);
          if (isNaN(f))
            return;
          f < 0 ? Ot.copy(an, Ve) : f > 1 && Ot.copy(an, tr);
        }
        an.toArray(r[1]);
      }
    }
  }
}
function x0(r, t, e, n) {
  var i = e === "normal", a = i ? r : r.ensureState(e);
  a.ignore = t;
  var o = n.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = n.getModel("lineStyle").getLineStyle();
  i ? r.useStyle(s) : a.style = s;
}
function zZ(r, t) {
  var e = t.smooth, n = t.points;
  if (n)
    if (r.moveTo(n[0][0], n[0][1]), e > 0 && n.length >= 3) {
      var i = So(n[0], n[1]), a = So(n[1], n[2]);
      if (!i || !a) {
        r.lineTo(n[1][0], n[1][1]), r.lineTo(n[2][0], n[2][1]);
        return;
      }
      var o = Math.min(i, a) * e, s = Wp([], n[1], n[0], o / i), l = Wp([], n[1], n[2], o / a), u = Wp([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else
      for (var c = 1; c < n.length; c++)
        r.lineTo(n[c][0], n[c][1]);
}
function Mb(r, t, e) {
  var n = r.getTextGuideLine(), i = r.getTextContent();
  if (!i) {
    n && r.removeTextGuideLine();
    return;
  }
  for (var a = t.normal, o = a.get("show"), s = i.ignore, l = 0; l < oh.length; l++) {
    var u = oh[l], c = t[u], f = u === "normal";
    if (c) {
      var h = c.get("show"), d = f ? s : bt(i.states[u] && i.states[u].ignore, s);
      if (d || !bt(h, o)) {
        var p = f ? n : n && n.states[u];
        p && (p.ignore = !0), n && x0(n, !0, u, c);
        continue;
      }
      n || (n = new Gr(), r.setTextGuideLine(n), !f && (s || !o) && x0(n, !0, "normal", t.normal), r.stateProxy && (n.stateProxy = r.stateProxy)), x0(n, !1, u, c);
    }
  }
  if (n) {
    Bt(n.style, e), n.style.fill = null;
    var g = a.get("showAbove"), v = r.textGuideLineConfig = r.textGuideLineConfig || {};
    v.showAbove = g || !1, n.buildPath = zZ;
  }
}
function Tb(r, t) {
  t = t || "labelLine";
  for (var e = {
    normal: r.getModel(t)
  }, n = 0; n < pn.length; n++) {
    var i = pn[n];
    e[i] = r.getModel([i, t]);
  }
  return e;
}
var hC = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], UZ = 1, rg = 2, Vk = UZ | rg;
function ng(r, t, e) {
  e = e || Vk, t ? r.dirty |= e : r.dirty &= ~e;
}
function Fk(r, t) {
  return t = t || Vk, r.dirty == null || !!(r.dirty & t);
}
function la(r) {
  if (r)
    return Fk(r) && zk(r, r.label, r), r;
}
function zk(r, t, e) {
  var n = t.getComputedTransform();
  r.transform = X1(r.transform, n);
  var i = r.localRect = lh(r.localRect, t.getBoundingRect()), a = t.style, o = a.margin, s = e && e.marginForce, l = e && e.minMarginForce, u = e && e.marginDefault, c = a.__marginType;
  c == null && u && (o = u, c = Bu.textMargin);
  for (var f = 0; f < 4; f++)
    S0[f] = c === Bu.minMargin && l && l[f] != null ? l[f] : s && s[f] != null ? s[f] : o ? o[f] : 0;
  c === Bu.textMargin && ml(i, S0, !1, !1);
  var h = r.rect = lh(r.rect, i);
  return n && h.applyTransform(n), c === Bu.minMargin && ml(h, S0, !1, !1), r.axisAligned = W1(n), (r.label = r.label || {}).ignore = t.ignore, ng(r, !1), ng(r, !0, rg), r;
}
var S0 = [0, 0, 0, 0];
function GZ(r, t, e) {
  return r.transform = X1(r.transform, e), r.localRect = lh(r.localRect, t), r.rect = lh(r.rect, t), e && r.rect.applyTransform(e), r.axisAligned = W1(e), r.obb = void 0, (r.label = r.label || {}).ignore = !1, r;
}
function cS(r, t) {
  if (r) {
    r.label.x += t.x, r.label.y += t.y, r.label.markRedraw();
    var e = r.transform;
    e && (e[4] += t.x, e[5] += t.y);
    var n = r.rect;
    n && (n.x += t.x, n.y += t.y);
    var i = r.obb;
    i && i.fromBoundingRect(r.localRect, e);
  }
}
function fS(r, t) {
  for (var e = 0; e < hC.length; e++) {
    var n = hC[e];
    r[n] == null && (r[n] = t[n]);
  }
  return la(r);
}
function dC(r) {
  var t = r.obb;
  return (!t || Fk(r, rg)) && (r.obb = t = t || new gN(), t.fromBoundingRect(r.localRect, r.transform), ng(r, !1, rg)), t;
}
function hS(r, t, e, n, i) {
  var a = r.length, o = Wt[t], s = cr[t];
  if (a < 2)
    return !1;
  r.sort(function(w, A) {
    return w.rect[o] - A.rect[o];
  });
  for (var l = 0, u, c = !1, f = 0; f < a; f++) {
    var h = r[f], d = h.rect;
    u = d[o] - l, u < 0 && (d[o] -= u, h.label[o] -= u, c = !0), l = d[o] + d[s];
  }
  var p = r[0], g = r[a - 1], v, m;
  y(), v < 0 && b(-v, 0.8), m < 0 && b(m, 0.8), y(), _(v, m, 1), _(m, v, -1), y(), v < 0 && S(-v), m < 0 && S(m);
  function y() {
    v = p.rect[o] - e, m = n - g.rect[o] - g.rect[s];
  }
  function _(w, A, T) {
    if (w < 0) {
      var M = Math.min(A, -w);
      if (M > 0) {
        x(M * T, 0, a);
        var C = M + w;
        C < 0 && b(-C * T, 1);
      } else
        b(-w * T, 1);
    }
  }
  function x(w, A, T) {
    w !== 0 && (c = !0);
    for (var M = A; M < T; M++) {
      var C = r[M], R = C.rect;
      R[o] += w, C.label[o] += w;
    }
  }
  function b(w, A) {
    for (var T = [], M = 0, C = 1; C < a; C++) {
      var R = r[C - 1].rect, E = Math.max(r[C].rect[o] - R[o] - R[s], 0);
      T.push(E), M += E;
    }
    if (M) {
      var D = Math.min(Math.abs(w) / M, A);
      if (w > 0)
        for (var C = 0; C < a - 1; C++) {
          var I = T[C] * D;
          x(I, 0, C + 1);
        }
      else
        for (var C = a - 1; C > 0; C--) {
          var I = T[C - 1] * D;
          x(-I, C, a);
        }
    }
  }
  function S(w) {
    var A = w < 0 ? -1 : 1;
    w = Math.abs(w);
    for (var T = Math.ceil(w / (a - 1)), M = 0; M < a - 1; M++)
      if (A > 0 ? x(T, 0, M + 1) : x(-T, a - M - 1, a), w -= T, w <= 0)
        return;
  }
  return c;
}
function HZ(r) {
  for (var t = 0; t < r.length; t++) {
    var e = r[t], n = e.defaultAttr, i = e.labelLine;
    e.label.attr("ignore", n.ignore), i && i.attr("ignore", n.labelGuideIgnore);
  }
}
function Uk(r) {
  var t = [];
  r.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function e(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < r.length; n++) {
    var i = la(r[n]);
    if (!i.label.ignore) {
      for (var a = i.label, o = i.labelLine, s = !1, l = 0; l < t.length; l++)
        if (gm(i, t[l], null, {
          touchThreshold: 0.05
        })) {
          s = !0;
          break;
        }
      s ? (e(a), o && e(o)) : t.push(i);
    }
  }
}
function gm(r, t, e, n) {
  return !r || !t || r.label && r.label.ignore || t.label && t.label.ignore || !r.rect.intersect(t.rect, e, n) ? !1 : r.axisAligned && t.axisAligned ? !0 : dC(r).intersect(dC(t), e, n);
}
function WZ(r) {
  if (r) {
    for (var t = [], e = 0; e < r.length; e++)
      t.push(r[e].slice());
    return t;
  }
}
function XZ(r, t) {
  var e = r.label, n = t && t.getTextGuideLine();
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: e.style.align,
    verticalAlign: e.style.verticalAlign,
    labelLinePoints: WZ(n && n.shape.points)
  };
}
var pC = ["align", "verticalAlign", "width", "height", "fontSize"], tn = new La(), b0 = ee(), YZ = ee();
function sp(r, t, e) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n];
    t[i] != null && (r[i] = t[i]);
  }
}
var lp = ["x", "y", "rotation"], $Z = (
  /** @class */
  function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(t, e, n, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      Vt.applyTransform(c, c, u), u ? tn.setLocalTransform(u) : (tn.x = tn.y = tn.rotation = tn.originX = tn.originY = 0, tn.scaleX = tn.scaleY = 1), tn.rotation = Nn(tn.rotation);
      var f = i.__hostTarget, h;
      if (f) {
        h = f.getBoundingRect().plain();
        var d = f.getComputedTransform();
        Vt.applyTransform(h, h, d);
      }
      var p = h && f.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: t,
        dataType: e,
        layoutOptionOrCb: a,
        layoutOption: null,
        rect: c,
        hostRect: h,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: h ? h.width * h.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: tn.x,
          y: tn.y,
          scaleX: tn.scaleX,
          scaleY: tn.scaleY,
          rotation: tn.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(t) {
      var e = this;
      this._chartViewList.push(t);
      var n = t.__model, i = n.get("labelLayout");
      (At(i) || se(i).length) && t.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = zt(a);
        o && !o.disableLabelLayout && e._addLabel(s.dataIndex, s.dataType, n, o, i);
      });
    }, r.prototype.updateLayoutConfig = function(t) {
      var e = t.getWidth(), n = t.getHeight();
      function i(_, x) {
        return function() {
          fC(_, x);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        At(o.layoutOptionOrCb) ? c = o.layoutOptionOrCb(XZ(o, l)) : c = o.layoutOptionOrCb, c = c || {}, o.layoutOption = c;
        var f = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * f : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var h = !1;
        if (c.x != null ? (s.x = dt(c.x, e), s.setStyle("x", 0), h = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = dt(c.y, n), s.setStyle("y", 0), h = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), h = !1);
        }
        var p = b0(s);
        p.needsUpdateLabelLine = h, s.rotation = c.rotate != null ? c.rotate * f : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < pC.length; g++) {
          var v = pC[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              m = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(t) {
      var e = t.getWidth(), n = t.getHeight(), i = [];
      L(this._labelList, function(l) {
        l.defaultAttr.ignore || i.push(fS({}, l));
      });
      var a = Te(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = Te(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      hS(a, 0, 0, e), hS(o, 1, 0, n);
      var s = Te(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      HZ(s), Uk(s);
    }, r.prototype.processLabelsOverall = function() {
      var t = this;
      L(this._chartViewList, function(e) {
        var n = e.__model, i = e.ignoreLabelLineUpdate, a = n.isAnimationEnabled();
        e.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !i, l = o.getTextContent();
          !s && l && (s = b0(l).needsUpdateLabelLine), s && t._updateLabelLine(o, n), a && t._animateLabels(o, n);
        });
      });
    }, r.prototype._updateLabelLine = function(t, e) {
      var n = t.getTextContent(), i = zt(t), a = i.dataIndex;
      if (n && a != null) {
        var o = e.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var f = s.getModel("labelLine");
        Mb(t, Tb(s), l), fC(t, f);
      }
    }, r.prototype._animateLabels = function(t, e) {
      var n = t.getTextContent(), i = t.getTextGuideLine();
      if (n && (t.forceLabelAnimation || !n.ignore && !n.invisible && !t.disableLabelAnimation && !Yu(t))) {
        var a = b0(n), o = a.oldLayout, s = zt(t), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = e.getData(s.dataType);
        if (o) {
          n.attr(o);
          var h = t.prevStates;
          h && (Zt(h, "select") >= 0 && n.attr(a.oldLayoutSelect), Zt(h, "emphasis") >= 0 && n.attr(a.oldLayoutEmphasis)), ve(n, u, e, l);
        } else if (n.attr(u), !Ac(n).valueAnimation) {
          var f = bt(n.style.opacity, 1);
          n.style.opacity = 0, ze(n, {
            style: {
              opacity: f
            }
          }, e, l);
        }
        if (a.oldLayout = u, n.states.select) {
          var d = a.oldLayoutSelect = {};
          sp(d, u, lp), sp(d, n.states.select, lp);
        }
        if (n.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          sp(p, u, lp), sp(p, n.states.emphasis, lp);
        }
        EN(n, l, c, e, e);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = YZ(i), o = a.oldLayout, g = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), ve(i, {
          shape: g
        }, e)) : (i.setShape(g), i.style.strokePercent = 0, ze(i, {
          style: {
            strokePercent: 1
          }
        }, e)), a.oldLayout = g;
      }
    }, r;
  }()
), w0 = ee();
function ZZ(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(t, e, n) {
    var i = w0(e).labelManager;
    i || (i = w0(e).labelManager = new $Z()), i.clearLabels();
  }), r.registerUpdateLifecycle("series:layoutlabels", function(t, e, n) {
    var i = w0(e).labelManager;
    n.updatedSeries.forEach(function(a) {
      i.addLabelsOfSeries(e.getViewOfSeriesModel(a));
    }), i.updateLayoutConfig(e), i.layout(e), i.processLabelsOverall();
  });
}
var M0 = Math.sin, T0 = Math.cos, Gk = Math.PI, Ls = Math.PI * 2, qZ = 180 / Gk, Hk = function() {
  function r() {
  }
  return r.prototype.reset = function(t) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
  }, r.prototype.moveTo = function(t, e) {
    this._add("M", t, e);
  }, r.prototype.lineTo = function(t, e) {
    this._add("L", t, e);
  }, r.prototype.bezierCurveTo = function(t, e, n, i, a, o) {
    this._add("C", t, e, n, i, a, o);
  }, r.prototype.quadraticCurveTo = function(t, e, n, i) {
    this._add("Q", t, e, n, i);
  }, r.prototype.arc = function(t, e, n, i, a, o) {
    this.ellipse(t, e, n, n, 0, i, a, o);
  }, r.prototype.ellipse = function(t, e, n, i, a, o, s, l) {
    var u = s - o, c = !l, f = Math.abs(u), h = Ao(f - Ls) || (c ? u >= Ls : -u >= Ls), d = u > 0 ? u % Ls : u % Ls + Ls, p = !1;
    h ? p = !0 : Ao(f) ? p = !1 : p = d >= Gk == !!c;
    var g = t + n * T0(o), v = e + i * M0(o);
    this._start && this._add("M", g, v);
    var m = Math.round(a * qZ);
    if (h) {
      var y = 1 / this._p, _ = (c ? 1 : -1) * (Ls - y);
      this._add("A", n, i, m, 1, +c, t + n * T0(o + _), e + i * M0(o + _)), y > 0.01 && this._add("A", n, i, m, 0, +c, g, v);
    } else {
      var x = t + n * T0(s), b = e + i * M0(s);
      this._add("A", n, i, m, +p, +c, x, b);
    }
  }, r.prototype.rect = function(t, e, n, i) {
    this._add("M", t, e), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
  }, r.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, r.prototype._add = function(t, e, n, i, a, o, s, l, u) {
    for (var c = [], f = this._p, h = 1; h < arguments.length; h++) {
      var d = arguments[h];
      if (isNaN(d)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(d * f) / f);
    }
    this._d.push(t + c.join(" ")), this._start = t === "Z";
  }, r.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, r.prototype.getStr = function() {
    return this._str;
  }, r;
}(), Ab = "none", KZ = Math.round;
function jZ(r) {
  var t = r.fill;
  return t != null && t !== Ab;
}
function JZ(r) {
  var t = r.stroke;
  return t != null && t !== Ab;
}
var dS = ["lineCap", "miterLimit", "lineJoin"], QZ = rt(dS, function(r) {
  return "stroke-" + r.toLowerCase();
});
function tq(r, t, e, n) {
  var i = t.opacity == null ? 1 : t.opacity;
  if (e instanceof Fr) {
    r("opacity", i);
    return;
  }
  if (jZ(t)) {
    var a = ih(t.fill);
    r("fill", a.color);
    var o = t.fillOpacity != null ? t.fillOpacity * a.opacity * i : a.opacity * i;
    o < 1 && r("fill-opacity", o);
  } else
    r("fill", Ab);
  if (JZ(t)) {
    var s = ih(t.stroke);
    r("stroke", s.color);
    var l = t.strokeNoScale ? e.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, c = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * i : s.opacity * i, f = t.strokeFirst;
    if (u !== 1 && r("stroke-width", u), f && r("paint-order", f ? "stroke" : "fill"), c < 1 && r("stroke-opacity", c), t.lineDash) {
      var h = db(e), d = h[0], p = h[1];
      d && (p = KZ(p || 0), r("stroke-dasharray", d.join(",")), (p || n) && r("stroke-dashoffset", p));
    }
    for (var g = 0; g < dS.length; g++) {
      var v = dS[g];
      if (t[v] !== Rv[v]) {
        var m = t[v] || Rv[v];
        m && r(QZ[g], m);
      }
    }
  }
}
var Wk = "http://www.w3.org/2000/svg", Xk = "http://www.w3.org/1999/xlink", eq = "http://www.w3.org/2000/xmlns/", rq = "http://www.w3.org/XML/1998/namespace", vC = "ecmeta_";
function Yk(r) {
  return document.createElementNS(Wk, r);
}
function Mr(r, t, e, n, i) {
  return {
    tag: r,
    attrs: e || {},
    children: n,
    text: i,
    key: t
  };
}
function nq(r, t) {
  var e = [];
  if (t)
    for (var n in t) {
      var i = t[n], a = n;
      i !== !1 && (i !== !0 && i != null && (a += '="' + i + '"'), e.push(a));
    }
  return "<" + r + " " + e.join(" ") + ">";
}
function iq(r) {
  return "</" + r + ">";
}
function Eb(r, t) {
  t = t || {};
  var e = t.newline ? `
` : "";
  function n(i) {
    var a = i.children, o = i.tag, s = i.attrs, l = i.text;
    return nq(o, s) + (o !== "style" ? sn(l) : l || "") + (a ? "" + e + rt(a, function(u) {
      return n(u);
    }).join(e) + e : "") + iq(o);
  }
  return n(r);
}
function aq(r, t, e) {
  e = e || {};
  var n = e.newline ? `
` : "", i = " {" + n, a = n + "}", o = rt(se(r), function(l) {
    return l + i + rt(se(r[l]), function(u) {
      return u + ":" + r[l][u] + ";";
    }).join(n) + a;
  }).join(n), s = rt(se(t), function(l) {
    return "@keyframes " + l + i + rt(se(t[l]), function(u) {
      return u + i + rt(se(t[l][u]), function(c) {
        var f = t[l][u][c];
        return c === "d" && (f = 'path("' + f + '")'), c + ":" + f + ";";
      }).join(n) + a;
    }).join(n) + a;
  }).join(n);
  return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(n);
}
function pS(r) {
  return {
    zrId: r,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function gC(r, t, e, n) {
  return Mr("svg", "root", {
    width: r,
    height: t,
    xmlns: Wk,
    "xmlns:xlink": Xk,
    version: "1.1",
    baseProfile: "full",
    viewBox: n ? "0 0 " + r + " " + t : !1
  }, e);
}
var oq = 0;
function $k() {
  return oq++;
}
var mC = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, Os = "transform-origin";
function sq(r, t, e) {
  var n = j({}, r.shape);
  j(n, t), r.buildPath(e, n);
  var i = new Hk();
  return i.reset(xP(r)), e.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function lq(r, t) {
  var e = t.originX, n = t.originY;
  (e || n) && (r[Os] = e + "px " + n + "px");
}
var uq = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function Zk(r, t) {
  var e = t.zrId + "-ani-" + t.cssAnimIdx++;
  return t.cssAnims[e] = r, e;
}
function cq(r, t, e) {
  var n = r.shape.paths, i = {}, a, o;
  if (L(n, function(l) {
    var u = pS(e.zrId);
    u.animation = !0, mm(l, {}, u, !0);
    var c = u.cssAnims, f = u.cssNodes, h = se(c), d = h.length;
    if (d) {
      o = h[d - 1];
      var p = c[o];
      for (var g in p) {
        var v = p[g];
        i[g] = i[g] || { d: "" }, i[g].d += v.d || "";
      }
      for (var m in f) {
        var y = f[m].animation;
        y.indexOf(o) >= 0 && (a = y);
      }
    }
  }), !!a) {
    t.d = !1;
    var s = Zk(i, e);
    return a.replace(o, s);
  }
}
function yC(r) {
  return pt(r) ? mC[r] ? "cubic-bezier(" + mC[r] + ")" : E1(r) ? r : "" : "";
}
function mm(r, t, e, n) {
  var i = r.animators, a = i.length, o = [];
  if (r instanceof am) {
    var s = cq(r, t, e);
    if (s)
      o.push(s);
    else if (!a)
      return;
  } else if (!a)
    return;
  for (var l = {}, u = 0; u < a; u++) {
    var c = i[u], f = [c.getMaxTime() / 1e3 + "s"], h = yC(c.getClip().easing), d = c.getDelay();
    h ? f.push(h) : f.push("linear"), d && f.push(d / 1e3 + "s"), c.getLoop() && f.push("infinite");
    var p = f.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(y) {
    var _ = y[1], x = _.length, b = {}, S = {}, w = {}, A = "animation-timing-function";
    function T(ut, lt, H) {
      for (var ct = ut.getTracks(), ot = ut.getMaxTime(), Gt = 0; Gt < ct.length; Gt++) {
        var yt = ct[Gt];
        if (yt.needsAnimate()) {
          var Mt = yt.keyframes, Rt = yt.propName;
          if (H && (Rt = H(Rt)), Rt)
            for (var Kt = 0; Kt < Mt.length; Kt++) {
              var Ae = Mt[Kt], z = Math.round(Ae.time / ot * 100) + "%", k = yC(Ae.easing), nt = Ae.rawValue;
              (pt(nt) || fe(nt)) && (lt[z] = lt[z] || {}, lt[z][Rt] = Ae.rawValue, k && (lt[z][A] = k));
            }
        }
      }
    }
    for (var M = 0; M < x; M++) {
      var C = _[M], R = C.targetName;
      R ? R === "shape" && T(C, S) : !n && T(C, b);
    }
    for (var E in b) {
      var D = {};
      Cv(D, r), j(D, b[E]);
      var I = SP(D), P = b[E][A];
      w[E] = I ? {
        transform: I
      } : {}, lq(w[E], D), P && (w[E][A] = P);
    }
    var O, N = !0;
    for (var E in S) {
      w[E] = w[E] || {};
      var B = !O, P = S[E][A];
      B && (O = new oa());
      var F = O.len();
      O.reset(), w[E].d = sq(r, S[E], O);
      var G = O.len();
      if (!B && F !== G) {
        N = !1;
        break;
      }
      P && (w[E][A] = P);
    }
    if (!N)
      for (var E in w)
        delete w[E].d;
    if (!n)
      for (var M = 0; M < x; M++) {
        var C = _[M], R = C.targetName;
        R === "style" && T(C, w, function(ct) {
          return uq[ct];
        });
      }
    for (var W = se(w), J = !0, U, M = 1; M < W.length; M++) {
      var Y = W[M - 1], at = W[M];
      if (w[Y][Os] !== w[at][Os]) {
        J = !1;
        break;
      }
      U = w[Y][Os];
    }
    if (J && U) {
      for (var E in w)
        w[E][Os] && delete w[E][Os];
      t[Os] = U;
    }
    if (Te(W, function(ut) {
      return se(w[ut]).length > 0;
    }).length) {
      var st = Zk(w, e);
      return st + " " + y[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && o.push(s);
  }
  if (o.length) {
    var m = e.zrId + "-cls-" + $k();
    e.cssNodes["." + m] = {
      animation: o.join(",")
    }, t.class = m;
  }
}
function fq(r, t, e) {
  if (!r.ignore)
    if (r.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      _C(n, t, e);
    } else {
      var i = r.states.emphasis && r.states.emphasis.style ? r.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var o = r.style && r.style.fill, s = r.states.select && r.states.select.style && r.states.select.style.fill, l = r.currentStates.indexOf("select") >= 0 && s || o;
        l && (a = cx(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && r.transform ? r.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      a && (n.fill = a), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), _C(n, t, e);
    }
}
function _C(r, t, e, n) {
  var i = JSON.stringify(r), a = e.cssStyleCache[i];
  a || (a = e.zrId + "-cls-" + $k(), e.cssStyleCache[i] = a, e.cssNodes["." + a + ":hover"] = r), t.class = t.class ? t.class + " " + a : a;
}
var mh = Math.round;
function qk(r) {
  return r && pt(r.src);
}
function Kk(r) {
  return r && At(r.toDataURL);
}
function Cb(r, t, e, n) {
  tq(function(i, a) {
    var o = i === "fill" || i === "stroke";
    o && _P(a) ? Jk(t, r, i, n) : o && C1(a) ? Qk(e, r, i, n) : r[i] = a, o && n.ssr && a === "none" && (r["pointer-events"] = "visible");
  }, t, e, !1), yq(e, r, n);
}
function Db(r, t) {
  var e = B8(t);
  e && (e.each(function(n, i) {
    n != null && (r[(vC + i).toLowerCase()] = n + "");
  }), t.isSilent() && (r[vC + "silent"] = "true"));
}
function xC(r) {
  return Ao(r[0] - 1) && Ao(r[1]) && Ao(r[2]) && Ao(r[3] - 1);
}
function hq(r) {
  return Ao(r[4]) && Ao(r[5]);
}
function Lb(r, t, e) {
  if (t && !(hq(t) && xC(t))) {
    var n = 1e4;
    r.transform = xC(t) ? "translate(" + mh(t[4] * n) / n + " " + mh(t[5] * n) / n + ")" : a8(t);
  }
}
function SC(r, t, e) {
  for (var n = r.points, i = [], a = 0; a < n.length; a++)
    i.push(mh(n[a][0] * e) / e), i.push(mh(n[a][1] * e) / e);
  t.points = i.join(" ");
}
function bC(r) {
  return !r.smooth;
}
function dq(r) {
  var t = rt(r, function(e) {
    return typeof e == "string" ? [e, e] : e;
  });
  return function(e, n, i) {
    for (var a = 0; a < t.length; a++) {
      var o = t[a], s = e[o[0]];
      s != null && (n[o[1]] = mh(s * i) / i);
    }
  };
}
var pq = {
  circle: [dq(["cx", "cy", "r"])],
  polyline: [SC, bC],
  polygon: [SC, bC]
};
function vq(r) {
  for (var t = r.animators, e = 0; e < t.length; e++)
    if (t[e].targetName === "shape")
      return !0;
  return !1;
}
function jk(r, t) {
  var e = r.style, n = r.shape, i = pq[r.type], a = {}, o = t.animation, s = "path", l = r.style.strokePercent, u = t.compress && xP(r) || 4;
  if (i && !t.willUpdate && !(i[1] && !i[1](n)) && !(o && vq(r)) && !(l < 1)) {
    s = r.type;
    var c = Math.pow(10, u);
    i[0](n, a, c);
  } else {
    var f = !r.path || r.shapeChanged();
    r.path || r.createPathProxy();
    var h = r.path;
    f && (h.beginPath(), r.buildPath(h, r.shape), r.pathUpdated());
    var d = h.getVersion(), p = r, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new Hk()), g.reset(u), h.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = g.getStr();
  }
  return Lb(a, r.transform), Cb(a, e, r, t), Db(a, r), t.animation && mm(r, a, t), t.emphasis && fq(r, a, t), Mr(s, r.id + "", a);
}
function gq(r, t) {
  var e = r.style, n = e.image;
  if (n && !pt(n) && (qk(n) ? n = n.src : Kk(n) && (n = n.toDataURL())), !!n) {
    var i = e.x || 0, a = e.y || 0, o = e.width, s = e.height, l = {
      href: n,
      width: o,
      height: s
    };
    return i && (l.x = i), a && (l.y = a), Lb(l, r.transform), Cb(l, e, r, t), Db(l, r), t.animation && mm(r, l, t), Mr("image", r.id + "", l);
  }
}
function mq(r, t) {
  var e = r.style, n = e.text;
  if (n != null && (n += ""), !(!n || isNaN(e.x) || isNaN(e.y))) {
    var i = e.font || Ua, a = e.x || 0, o = s8(e.y || 0, Nh(i), e.textBaseline), s = o8[e.textAlign] || e.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (jP(e)) {
      var u = "", c = e.fontStyle, f = KP(e.fontSize);
      if (!parseFloat(f))
        return;
      var h = e.fontFamily || ZI, d = e.fontWeight;
      u += "font-size:" + f + ";font-family:" + h + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return n.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), Lb(l, r.transform), Cb(l, e, r, t), Db(l, r), t.animation && mm(r, l, t), Mr("text", r.id + "", l, void 0, n);
  }
}
function wC(r, t) {
  if (r instanceof ne)
    return jk(r, t);
  if (r instanceof Fr)
    return gq(r, t);
  if (r instanceof nc)
    return mq(r, t);
}
function yq(r, t, e) {
  var n = r.style;
  if (l8(n)) {
    var i = u8(r), a = e.shadowCache, o = a[i];
    if (!o) {
      var s = r.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = n.shadowOffsetX || 0, f = n.shadowOffsetY || 0, h = n.shadowBlur, d = ih(n.shadowColor), p = d.opacity, g = d.color, v = h / 2 / l, m = h / 2 / u, y = v + " " + m;
      o = e.zrId + "-s" + e.shadowIdx++, e.defs[o] = Mr("filter", o, {
        id: o,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        Mr("feDropShadow", "", {
          dx: c / l,
          dy: f / u,
          stdDeviation: y,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), a[i] = o;
    }
    t.filter = Wg(o);
  }
}
function Jk(r, t, e, n) {
  var i = r[e], a, o = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (mP(i))
    a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
  else if (yP(i))
    a = "radialGradient", o.cx = bt(i.x, 0.5), o.cy = bt(i.y, 0.5), o.r = bt(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && mi("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var f = fx(s[u].offset) * 100 + "%", h = s[u].color, d = ih(h), p = d.color, g = d.opacity, v = {
      offset: f
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(Mr("stop", u + "", v));
  }
  var m = Mr(a, "", o, l), y = Eb(m), _ = n.gradientCache, x = _[y];
  x || (x = n.zrId + "-g" + n.gradientIdx++, _[y] = x, o.id = x, n.defs[x] = Mr(a, x, o, l)), t[e] = Wg(x);
}
function Qk(r, t, e, n) {
  var i = r.style[e], a = r.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", f;
  if (gP(i)) {
    var h = i.imageWidth, d = i.imageHeight, p = void 0, g = i.image;
    if (pt(g) ? p = g : qk(g) ? p = g.src : Kk(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      St(h, v), St(d, v);
    } else if (h == null || d == null) {
      var m = function(M, C) {
        if (M) {
          var R = M.elm, E = h || C.width, D = d || C.height;
          M.tag === "pattern" && (u ? (D = 1, E /= a.width) : c && (E = 1, D /= a.height)), M.attrs.width = E, M.attrs.height = D, R && (R.setAttribute("width", E), R.setAttribute("height", D));
        }
      }, y = N1(p, null, r, function(M) {
        l || m(S, M), m(f, M);
      });
      y && y.width && y.height && (h = h || y.width, d = d || y.height);
    }
    f = Mr("image", "img", {
      href: p,
      width: h,
      height: d
    }), o.width = h, o.height = d;
  } else
    i.svgElement && (f = Dt(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
  if (f) {
    var _, x;
    l ? _ = x = 1 : u ? (x = 1, _ = o.width / a.width) : c ? (_ = 1, x = o.height / a.height) : o.patternUnits = "userSpaceOnUse", _ != null && !isNaN(_) && (o.width = _), x != null && !isNaN(x) && (o.height = x);
    var b = SP(i);
    b && (o.patternTransform = b);
    var S = Mr("pattern", "", o, [f]), w = Eb(S), A = n.patternCache, T = A[w];
    T || (T = n.zrId + "-p" + n.patternIdx++, A[w] = T, o.id = T, S = n.defs[T] = Mr("pattern", T, o, [f])), t[e] = Wg(T);
  }
}
function _q(r, t, e) {
  var n = e.clipPathCache, i = e.defs, a = n[r.id];
  if (!a) {
    a = e.zrId + "-c" + e.clipPathIdx++;
    var o = {
      id: a
    };
    n[r.id] = a, i[a] = Mr("clipPath", a, o, [jk(r, e)]);
  }
  t["clip-path"] = Wg(a);
}
function MC(r) {
  return document.createTextNode(r);
}
function Ws(r, t, e) {
  r.insertBefore(t, e);
}
function TC(r, t) {
  r.removeChild(t);
}
function AC(r, t) {
  r.appendChild(t);
}
function t3(r) {
  return r.parentNode;
}
function e3(r) {
  return r.nextSibling;
}
function A0(r, t) {
  r.textContent = t;
}
var EC = 58, xq = 120, Sq = Mr("", "");
function vS(r) {
  return r === void 0;
}
function Fi(r) {
  return r !== void 0;
}
function bq(r, t, e) {
  for (var n = {}, i = t; i <= e; ++i) {
    var a = r[i].key;
    a !== void 0 && (process.env.NODE_ENV !== "production" && n[a] != null && console.error("Duplicate key " + a), n[a] = i);
  }
  return n;
}
function Nf(r, t) {
  var e = r.key === t.key, n = r.tag === t.tag;
  return n && e;
}
function yh(r) {
  var t, e = r.children, n = r.tag;
  if (Fi(n)) {
    var i = r.elm = Yk(n);
    if (Rb(Sq, r), et(e))
      for (t = 0; t < e.length; ++t) {
        var a = e[t];
        a != null && AC(i, yh(a));
      }
    else
      Fi(r.text) && !Lt(r.text) && AC(i, MC(r.text));
  } else
    r.elm = MC(r.text);
  return r.elm;
}
function r3(r, t, e, n, i) {
  for (; n <= i; ++n) {
    var a = e[n];
    a != null && Ws(r, yh(a), t);
  }
}
function ig(r, t, e, n) {
  for (; e <= n; ++e) {
    var i = t[e];
    if (i != null)
      if (Fi(i.tag)) {
        var a = t3(i.elm);
        TC(a, i.elm);
      } else
        TC(r, i.elm);
  }
}
function Rb(r, t) {
  var e, n = t.elm, i = r && r.attrs || {}, a = t.attrs || {};
  if (i !== a) {
    for (e in a) {
      var o = a[e], s = i[e];
      s !== o && (o === !0 ? n.setAttribute(e, "") : o === !1 ? n.removeAttribute(e) : e === "style" ? n.style.cssText = o : e.charCodeAt(0) !== xq ? n.setAttribute(e, o) : e === "xmlns:xlink" || e === "xmlns" ? n.setAttributeNS(eq, e, o) : e.charCodeAt(3) === EC ? n.setAttributeNS(rq, e, o) : e.charCodeAt(5) === EC ? n.setAttributeNS(Xk, e, o) : n.setAttribute(e, o));
    }
    for (e in i)
      e in a || n.removeAttribute(e);
  }
}
function wq(r, t, e) {
  for (var n = 0, i = 0, a = t.length - 1, o = t[0], s = t[a], l = e.length - 1, u = e[0], c = e[l], f, h, d, p; n <= a && i <= l; )
    o == null ? o = t[++n] : s == null ? s = t[--a] : u == null ? u = e[++i] : c == null ? c = e[--l] : Nf(o, u) ? (Du(o, u), o = t[++n], u = e[++i]) : Nf(s, c) ? (Du(s, c), s = t[--a], c = e[--l]) : Nf(o, c) ? (Du(o, c), Ws(r, o.elm, e3(s.elm)), o = t[++n], c = e[--l]) : Nf(s, u) ? (Du(s, u), Ws(r, s.elm, o.elm), s = t[--a], u = e[++i]) : (vS(f) && (f = bq(t, n, a)), h = f[u.key], vS(h) ? Ws(r, yh(u), o.elm) : (d = t[h], d.tag !== u.tag ? Ws(r, yh(u), o.elm) : (Du(d, u), t[h] = void 0, Ws(r, d.elm, o.elm))), u = e[++i]);
  (n <= a || i <= l) && (n > a ? (p = e[l + 1] == null ? null : e[l + 1].elm, r3(r, p, e, i, l)) : ig(r, t, n, a));
}
function Du(r, t) {
  var e = t.elm = r.elm, n = r.children, i = t.children;
  r !== t && (Rb(r, t), vS(t.text) ? Fi(n) && Fi(i) ? n !== i && wq(e, n, i) : Fi(i) ? (Fi(r.text) && A0(e, ""), r3(e, null, i, 0, i.length - 1)) : Fi(n) ? ig(e, n, 0, n.length - 1) : Fi(r.text) && A0(e, "") : r.text !== t.text && (Fi(n) && ig(e, n, 0, n.length - 1), A0(e, t.text)));
}
function Mq(r, t) {
  if (Nf(r, t))
    Du(r, t);
  else {
    var e = r.elm, n = t3(e);
    yh(t), n !== null && (Ws(n, t.elm, e3(e)), ig(n, [r], 0, 0));
  }
  return t;
}
var Tq = 0, Aq = function() {
  function r(t, e, n) {
    if (this.type = "svg", this.refreshHover = CC("refreshHover"), this.configLayer = CC("configLayer"), this.storage = e, this._opts = n = j({}, n), this.root = t, this._id = "zr" + Tq++, this._oldVNode = gC(n.width, n.height), t && !n.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var a = this._svgDom = this._oldVNode.elm = Yk("svg");
      Rb(null, this._oldVNode), i.appendChild(a), t.appendChild(i);
    }
    this.resize(n.width, n.height);
  }
  return r.prototype.getType = function() {
    return this.type;
  }, r.prototype.getViewportRoot = function() {
    return this._viewport;
  }, r.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, r.prototype.getSvgDom = function() {
    return this._svgDom;
  }, r.prototype.refresh = function() {
    if (this.root) {
      var t = this.renderToVNode({
        willUpdate: !0
      });
      t.attrs.style = "position:absolute;left:0;top:0;user-select:none", Mq(this._oldVNode, t), this._oldVNode = t;
    }
  }, r.prototype.renderOneToVNode = function(t) {
    return wC(t, pS(this._id));
  }, r.prototype.renderToVNode = function(t) {
    t = t || {};
    var e = this.storage.getDisplayList(!0), n = this._width, i = this._height, a = pS(this._id);
    a.animation = t.animation, a.willUpdate = t.willUpdate, a.compress = t.compress, a.emphasis = t.emphasis, a.ssr = this._opts.ssr;
    var o = [], s = this._bgVNode = Eq(n, i, this._backgroundColor, a);
    s && o.push(s);
    var l = t.compress ? null : this._mainVNode = Mr("g", "main", {}, []);
    this._paintList(e, a, l ? l.children : o), l && o.push(l);
    var u = rt(se(a.defs), function(h) {
      return a.defs[h];
    });
    if (u.length && o.push(Mr("defs", "defs", {}, u)), t.animation) {
      var c = aq(a.cssNodes, a.cssAnims, { newline: !0 });
      if (c) {
        var f = Mr("style", "stl", {}, [], c);
        o.push(f);
      }
    }
    return gC(n, i, o, t.useViewBox);
  }, r.prototype.renderToString = function(t) {
    return t = t || {}, Eb(this.renderToVNode({
      animation: bt(t.cssAnimation, !0),
      emphasis: bt(t.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: bt(t.useViewBox, !0)
    }), { newline: !0 });
  }, r.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t;
  }, r.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, r.prototype._paintList = function(t, e, n) {
    for (var i = t.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
      var f = t[c];
      if (!f.invisible) {
        var h = f.__clipPaths, d = h && h.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(d - 1, p - 1); g >= 0 && !(h && l && h[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          o--, s = a[o - 1];
        for (var m = g + 1; m < d; m++) {
          var y = {};
          _q(h[m], y, e);
          var _ = Mr("g", "clip-g-" + u++, y, []);
          (s ? s.children : n).push(_), a[o++] = _, s = _;
        }
        l = h;
        var x = wC(f, e);
        x && (s ? s.children : n).push(x);
      }
    }
  }, r.prototype.resize = function(t, e) {
    var n = this._opts, i = this.root, a = this._viewport;
    if (t != null && (n.width = t), e != null && (n.height = e), i && a && (a.style.display = "none", t = Fu(i, 0, n), e = Fu(i, 1, n), a.style.display = ""), this._width !== t || this._height !== e) {
      if (this._width = t, this._height = e, a) {
        var o = a.style;
        o.width = t + "px", o.height = e + "px";
      }
      if (C1(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", t), s.setAttribute("height", e));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", t), l.setAttribute("height", e));
      }
    }
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, r.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, r.prototype.toDataURL = function(t) {
    var e = this.renderToString(), n = "data:image/svg+xml;";
    return t ? (e = f8(e), e && n + "base64," + e) : n + "charset=UTF-8," + encodeURIComponent(e);
  }, r;
}();
function CC(r) {
  return function() {
    process.env.NODE_ENV !== "production" && mi('In SVG mode painter not support method "' + r + '"');
  };
}
function Eq(r, t, e, n) {
  var i;
  if (e && e !== "none")
    if (i = Mr("rect", "bg", {
      width: r,
      height: t,
      x: "0",
      y: "0"
    }), _P(e))
      Jk({ fill: e }, i.attrs, "fill", n);
    else if (C1(e))
      Qk({
        style: {
          fill: e
        },
        dirty: rr,
        getBoundingRect: function() {
          return { width: r, height: t };
        }
      }, i.attrs, "fill", n);
    else {
      var a = ih(e), o = a.color, s = a.opacity;
      i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
function Cq(r) {
  r.registerPainter("svg", Aq);
}
function DC(r, t, e) {
  var n = Si.createCanvas(), i = t.getWidth(), a = t.getHeight(), o = n.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", r)), n.width = i * e, n.height = a * e, n;
}
var E0 = function(r) {
  Ue(t, r);
  function t(e, n, i) {
    var a = r.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    i = i || Ev, typeof e == "string" ? o = DC(e, n, i) : Lt(e) && (o = e, e = o.id), a.id = e, a.dom = o;
    var s = o.style;
    return s && (eP(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = i, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var e = this.dpr;
    this.domBack = DC("back-" + this.id, this.painter, e), this.ctxBack = this.domBack.getContext("2d"), e !== 1 && this.ctxBack.scale(e, e);
  }, t.prototype.createRepaintRects = function(e, n, i, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new Vt(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (o.length === 0) {
          var _ = new Vt(0, 0, 0, 0);
          _.copy(y), o.push(_);
        } else {
          for (var x = !1, b = 1 / 0, S = 0, w = 0; w < o.length; ++w) {
            var A = o[w];
            if (A.intersect(y)) {
              var T = new Vt(0, 0, 0, 0);
              T.copy(A), T.union(y), o[w] = T, x = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(A);
              var M = y.width * y.height, C = A.width * A.height, R = u.width * u.height, E = R - M - C;
              E < b && (b = E, S = w);
            }
          }
          if (l && (o[S].union(y), x = !0), !x) {
            var _ = new Vt(0, 0, 0, 0);
            _.copy(y), o.push(_);
          }
          l || (l = o.length >= s);
        }
    }
    for (var f = this.__startIndex; f < this.__endIndex; ++f) {
      var h = e[f];
      if (h) {
        var d = h.shouldBePainted(i, a, !0, !0), p = h.__isRendered && (h.__dirty & In || !d) ? h.getPrevPaintRect() : null;
        p && c(p);
        var g = d && (h.__dirty & In || !h.__isRendered) ? h.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var f = this.__prevStartIndex; f < this.__prevEndIndex; ++f) {
      var h = n[f], d = h && h.shouldBePainted(i, a, !0, !0);
      if (h && (!d || !h.__zr) && h.__isRendered) {
        var p = h.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var f = 0; f < o.length; ) {
        if (o[f].isZero()) {
          o.splice(f, 1);
          continue;
        }
        for (var m = f + 1; m < o.length; )
          o[f].intersect(o[m]) ? (v = !0, o[f].union(o[m]), o.splice(m, 1)) : m++;
        f++;
      }
    } while (v);
    return this._paintRects = o, o;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(e, n) {
    var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = e + "px", o.height = n + "px"), a.width = e * i, a.height = n * i, s && (s.width = e * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
  }, t.prototype.clear = function(e, n, i) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !e, c = this.lastFrameAlpha, f = this.dpr, h = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / f, l / f));
    var d = this.domBack;
    function p(g, v, m, y) {
      if (o.clearRect(g, v, m, y), n && n !== "transparent") {
        var _ = void 0;
        if (Fg(n)) {
          var x = n.global || n.__width === m && n.__height === y;
          _ = x && n.__canvasGradient || Qx(o, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = _, n.__width = m, n.__height = y;
        } else
          mW(n) && (n.scaleX = n.scaleX || f, n.scaleY = n.scaleY || f, _ = tS(o, n, {
            dirty: function() {
              h.setUnpainted(), h.painter.refresh();
            }
          }));
        o.save(), o.fillStyle = _ || n, o.fillRect(g, v, m, y), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(d, g, v, m, y), o.restore());
    }
    !i || u ? p(0, 0, s, l) : i.length && L(i, function(g) {
      p(g.x * f, g.y * f, g.width * f, g.height * f);
    });
  }, t;
}(si), LC = 1e5, Rs = 314159, up = 0.01, Dq = 1e-3;
function Lq(r) {
  return r ? r.__builtin__ ? !0 : !(typeof r.resize != "function" || typeof r.refresh != "function") : !1;
}
function Rq(r, t) {
  var e = document.createElement("div");
  return e.style.cssText = [
    "position:relative",
    "width:" + r + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", e;
}
var Iq = function() {
  function r(t, e, n, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = j({}, n || {}), this.dpr = n.devicePixelRatio || Ev, this._singleCanvas = a, this.root = t;
    var o = t.style;
    o && (eP(t), t.innerHTML = ""), this.storage = e;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, f = c.width, h = c.height;
      n.width != null && (f = n.width), n.height != null && (h = n.height), this.dpr = n.devicePixelRatio || 1, c.width = f * this.dpr, c.height = h * this.dpr, this._width = f, this._height = h;
      var d = new E0(c, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Rs] = d, d.zlevel = Rs, s.push(Rs), this._domRoot = t;
    } else {
      this._width = Fu(t, 0, n), this._height = Fu(t, 1, n);
      var u = this._domRoot = Rq(this._width, this._height);
      t.appendChild(u);
    }
  }
  return r.prototype.getType = function() {
    return "canvas";
  }, r.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, r.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, r.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, r.prototype.refresh = function(t) {
    var e = this.storage.getDisplayList(!0), n = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(e, n, t, this._redrawId);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this;
  }, r.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, r.prototype._paintHoverList = function(t) {
    var e = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!e) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < e; o++) {
        var s = t[o];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(LC)), a || (a = n.ctx, a.save()), el(a, s, i, o === e - 1));
      }
      a && a.restore();
    }
  }, r.prototype.getHoverLayer = function() {
    return this.getLayer(LC);
  }, r.prototype.paintOne = function(t, e) {
    FO(t, e);
  }, r.prototype._paintList = function(t, e, n, i) {
    if (this._redrawId === i) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, e, n), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Sv(function() {
          l._paintList(t, e, n, i);
        });
      }
    }
  }, r.prototype._compositeManually = function() {
    var t = this.getLayer(Rs).ctx, e = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, e, n), this.eachBuiltinLayer(function(i) {
      i.virtual && t.drawImage(i.dom, 0, 0, e, n);
    });
  }, r.prototype._doPaintList = function(t, e, n) {
    for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, f = !1, h = function(g) {
      var v = a[g], m = v.ctx, y = o && v.createRepaintRects(t, e, d._width, d._height), _ = n ? v.__startIndex : v.__drawIndex, x = !n && v.incremental && Date.now, b = x && Date.now(), S = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, S, y);
      else if (_ === v.__startIndex) {
        var w = t[_];
        (!w.incremental || !w.notClear || n) && v.clear(!1, S, y);
      }
      _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = v.__startIndex);
      var A, T = function(E) {
        var D = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (A = _; A < v.__endIndex; A++) {
          var I = t[A];
          if (I.__inHover && (f = !0), i._doPaintEl(I, v, o, E, D, A === v.__endIndex - 1), x) {
            var P = Date.now() - b;
            if (P > 15)
              break;
          }
        }
        D.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          A = v.__endIndex;
        else
          for (var M = d.dpr, C = 0; C < y.length; ++C) {
            var R = y[C];
            m.save(), m.beginPath(), m.rect(R.x * M, R.y * M, R.width * M, R.height * M), m.clip(), T(R), m.restore();
          }
      else
        m.save(), T(), m.restore();
      v.__drawIndex = A, v.__drawIndex < v.__endIndex && (c = !1);
    }, d = this, p = 0; p < a.length; p++)
      h(p);
    return oe.wxa && L(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: f
    };
  }, r.prototype._doPaintEl = function(t, e, n, i, a, o) {
    var s = e.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!i || l && l.intersect(i)) && (el(s, t, a, o), t.setPrevPaintRect(l));
    } else
      el(s, t, a, o);
  }, r.prototype.getLayer = function(t, e) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Rs);
    var n = this._layers[t];
    return n || (n = new E0("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? qt(n, this._layerConfig[t], !0) : this._layerConfig[t - up] && qt(n, this._layerConfig[t - up], !0), e && (n.virtual = e), this.insertLayer(t, n), n.initContext()), n;
  }, r.prototype.insertLayer = function(t, e) {
    var n = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && mi("ZLevel " + t + " has been used already");
      return;
    }
    if (!Lq(e)) {
      process.env.NODE_ENV !== "production" && mi("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > i[0]) {
      for (l = 0; l < a - 1 && !(i[l] < t && i[l + 1] > t); l++)
        ;
      s = n[i[l]];
    }
    if (i.splice(l + 1, 0, t), n[t] = e, !e.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(e.dom, u.nextSibling) : o.appendChild(e.dom);
      } else
        o.firstChild ? o.insertBefore(e.dom, o.firstChild) : o.appendChild(e.dom);
    e.painter || (e.painter = this);
  }, r.prototype.eachLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i];
      t.call(e, this._layers[a], a);
    }
  }, r.prototype.eachBuiltinLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ && t.call(e, o, a);
    }
  }, r.prototype.eachOtherLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ || t.call(e, o, a);
    }
  }, r.prototype.getLayers = function() {
    return this._layers;
  }, r.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(f, h) {
      f.__dirty = f.__used = !1;
    });
    function e(f) {
      a && (a.__endIndex !== f && (a.__dirty = !0), a.__endIndex = f);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var i = t[n];
        if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var i = t[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, o = 0), i.incremental ? (c = this.getLayer(u + Dq, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? up : 0), this._needsManuallyCompositing), c.__builtin__ || mi("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, e(l), a = c), i.__dirty & In && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    e(l), this.eachBuiltinLayer(function(f, h) {
      !f.__used && f.getElementCount() > 0 && (f.__dirty = !0, f.__startIndex = f.__endIndex = f.__drawIndex = 0), f.__dirty && f.__drawIndex < 0 && (f.__drawIndex = f.__startIndex);
    });
  }, r.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, r.prototype._clearLayer = function(t) {
    t.clear();
  }, r.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, L(this._layers, function(e) {
      e.setUnpainted();
    });
  }, r.prototype.configLayer = function(t, e) {
    if (e) {
      var n = this._layerConfig;
      n[t] ? qt(n[t], e, !0) : n[t] = e;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var a = this._zlevelList[i];
        if (a === t || a === t + up) {
          var o = this._layers[a];
          qt(o, n[t], !0);
        }
      }
    }
  }, r.prototype.delLayer = function(t) {
    var e = this._layers, n = this._zlevelList, i = e[t];
    i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(Zt(n, t), 1));
  }, r.prototype.resize = function(t, e) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var i = this._opts, a = this.root;
      if (t != null && (i.width = t), e != null && (i.height = e), t = Fu(a, 0, i), e = Fu(a, 1, i), n.style.display = "", this._width !== t || e !== this._height) {
        n.style.width = t + "px", n.style.height = e + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
        this.refresh(!0);
      }
      this._width = t, this._height = e;
    } else {
      if (t == null || e == null)
        return;
      this._width = t, this._height = e, this.getLayer(Rs).resize(t, e);
    }
    return this;
  }, r.prototype.clearLayer = function(t) {
    var e = this._layers[t];
    e && e.clear();
  }, r.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, r.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Rs].dom;
    var e = new E0("image", this, t.pixelRatio || this.dpr);
    e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = e.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var i = e.dom.width, a = e.dom.height;
      this.eachLayer(function(f) {
        f.__builtin__ ? n.drawImage(f.dom, 0, 0, i, a) : f.renderToCanvas && (n.save(), f.renderToCanvas(n), n.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        el(n, c, o, l === u - 1);
      }
    return e.dom;
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r;
}();
function Pq(r) {
  r.registerPainter("canvas", Iq);
}
var Nq = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e) {
      if (process.env.NODE_ENV !== "production") {
        var n = e.coordinateSystem;
        if (n !== "polar" && n !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return Ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getLegendIcon = function(e) {
      var n = new Ct(), i = hr("line", 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, !1);
      n.add(i), i.setStyle(e.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = e.itemHeight * 0.8, u = hr(s, (e.itemWidth - l) / 2, (e.itemHeight - l) / 2, l, l, e.itemStyle.fill);
      n.add(u), u.setStyle(e.itemStyle);
      var c = e.iconRotate === "inherit" ? o : e.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = X.color.neutral00, u.style.lineWidth = 2), n;
    }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 6,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, t;
  }(ke)
);
function cc(r, t) {
  var e = r.mapDimensionsAll("defaultedLabel"), n = e.length;
  if (n === 1) {
    var i = ac(r, t, e[0]);
    return i != null ? i + "" : null;
  } else if (n) {
    for (var a = [], o = 0; o < e.length; o++)
      a.push(ac(r, t, e[o]));
    return a.join(" ");
  }
}
function n3(r, t) {
  var e = r.mapDimensionsAll("defaultedLabel");
  if (!et(t))
    return t + "";
  for (var n = [], i = 0; i < e.length; i++) {
    var a = r.getDimensionIndex(e[i]);
    a >= 0 && n.push(t[a]);
  }
  return n.join(" ");
}
var Xh = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      return o.updateData(e, n, i, a), o;
    }
    return t.prototype._createSymbol = function(e, n, i, a, o, s) {
      this.removeAll();
      var l = hr(e, -1, -1, 2, 2, null, s);
      l.attr({
        z2: bt(o, 100),
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), l.drift = Oq, this._symbolType = e, this.add(l);
    }, t.prototype.stopSymbolAnimation = function(e) {
      this.childAt(0).stopAnimation(null, e);
    }, t.prototype.getSymbolType = function() {
      return this._symbolType;
    }, t.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, t.prototype.highlight = function() {
      Wa(this.childAt(0));
    }, t.prototype.downplay = function() {
      Xa(this.childAt(0));
    }, t.prototype.setZ = function(e, n) {
      var i = this.childAt(0);
      i.zlevel = e, i.z = n;
    }, t.prototype.setDraggable = function(e, n) {
      var i = this.childAt(0);
      i.draggable = e, i.cursor = !n && e ? "move" : i.cursor;
    }, t.prototype.updateData = function(e, n, i, a) {
      this.silent = !1;
      var o = e.getItemVisual(n, "symbol") || "circle", s = e.hostModel, l = t.getSymbolSize(e, n), u = t.getSymbolZ2(e, n), c = o !== this._symbolType, f = a && a.disableAnimation;
      if (c) {
        var h = e.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(o, e, n, l, u, h);
      } else {
        var d = this.childAt(0);
        d.silent = !1;
        var p = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        f ? d.attr(p) : ve(d, p, s, n), oi(d);
      }
      if (this._updateCommon(e, n, l, i, a), c) {
        var d = this.childAt(0);
        if (!f) {
          var p = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: d.style.opacity
            }
          };
          d.scaleX = d.scaleY = 0, d.style.opacity = 0, ze(d, p, s, n);
        }
      }
      f && this.childAt(0).stopAnimation("leave");
    }, t.prototype._updateCommon = function(e, n, i, a, o) {
      var s = this.childAt(0), l = e.hostModel, u, c, f, h, d, p, g, v, m;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, f = a.selectItemStyle, h = a.focus, d = a.blurScope, g = a.labelStatesModels, v = a.hoverScale, m = a.cursorStyle, p = a.emphasisDisabled), !a || e.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : e.getItemModel(n), _ = y.getModel("emphasis");
        u = _.getModel("itemStyle").getItemStyle(), f = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), h = _.get("focus"), d = _.get("blurScope"), p = _.get("disabled"), g = xr(y), v = _.getShallow("scale"), m = y.getShallow("cursor");
      }
      var x = e.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (x || 0) * Math.PI / 180 || 0);
      var b = Ll(e.getItemVisual(n, "symbolOffset"), i);
      b && (s.x = b[0], s.y = b[1]), m && s.attr("cursor", m);
      var S = e.getItemVisual(n, "style"), w = S.fill;
      if (s instanceof Fr) {
        var A = s.style;
        s.useStyle(j({
          // TODO other properties like x, y ?
          image: A.image,
          x: A.x,
          y: A.y,
          width: A.width,
          height: A.height
        }, S));
      } else
        s.__isEmptyBrush ? s.useStyle(j({}, S)) : s.useStyle(S), s.style.decal = null, s.setColor(w, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var T = e.getItemVisual(n, "liftZ"), M = this._z2;
      T != null ? M == null && (this._z2 = s.z2, s.z2 += T) : M != null && (s.z2 = M, this._z2 = null);
      var C = o && o.useNameLabel;
      Cr(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: R,
        inheritColor: w,
        defaultOpacity: S.opacity
      });
      function R(I) {
        return C ? e.getName(I) : cc(e, I);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var E = s.ensureState("emphasis");
      E.style = u, s.ensureState("select").style = f, s.ensureState("blur").style = c;
      var D = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      E.scaleX = this._sizeX * D, E.scaleY = this._sizeY * D, this.setSymbolScale(1), He(this, h, d, p);
    }, t.prototype.setSymbolScale = function(e) {
      this.scaleX = this.scaleY = e;
    }, t.prototype.fadeOut = function(e, n, i) {
      var a = this.childAt(0), o = zt(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = !0, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && Ho(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      Ho(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: o,
        cb: e,
        removeOpt: s
      });
    }, t.getSymbolSize = function(e, n) {
      return Rc(e.getItemVisual(n, "symbolSize"));
    }, t.getSymbolZ2 = function(e, n) {
      return e.getItemVisual(n, "z2");
    }, t;
  }(Ct)
);
function Oq(r, t) {
  this.parent.drift(r, t);
}
function C0(r, t, e, n) {
  return t && !isNaN(t[0]) && !isNaN(t[1]) && !(n.isIgnore && n.isIgnore(e)) && !(n.clipShape && !n.clipShape.contain(t[0], t[1])) && r.getItemVisual(e, "symbol") !== "none";
}
function RC(r) {
  return r != null && !Lt(r) && (r = {
    isIgnore: r
  }), r || {};
}
function IC(r) {
  var t = r.hostModel, e = t.getModel("emphasis");
  return {
    emphasisItemStyle: e.getModel("itemStyle").getItemStyle(),
    blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: e.get("focus"),
    blurScope: e.get("blurScope"),
    emphasisDisabled: e.get("disabled"),
    hoverScale: e.get("scale"),
    labelStatesModels: xr(t),
    cursorStyle: t.get("cursor")
  };
}
var Yh = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Ct(), this._SymbolCtor = t || Xh;
    }
    return r.prototype.updateData = function(t, e) {
      this._progressiveEls = null, e = RC(e);
      var n = this.group, i = t.hostModel, a = this._data, o = this._SymbolCtor, s = e.disableAnimation, l = IC(t), u = {
        disableAnimation: s
      }, c = e.getSymbolPoint || function(f) {
        return t.getItemLayout(f);
      };
      a || n.removeAll(), t.diff(a).add(function(f) {
        var h = c(f);
        if (C0(t, h, f, e)) {
          var d = new o(t, f, l, u);
          d.setPosition(h), t.setItemGraphicEl(f, d), n.add(d);
        }
      }).update(function(f, h) {
        var d = a.getItemGraphicEl(h), p = c(f);
        if (!C0(t, p, f, e)) {
          n.remove(d);
          return;
        }
        var g = t.getItemVisual(f, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g)
          n.remove(d), d = new o(t, f, l, u), d.setPosition(p);
        else {
          d.updateData(t, f, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(m) : ve(d, m, i);
        }
        n.add(d), t.setItemGraphicEl(f, d);
      }).remove(function(f) {
        var h = a.getItemGraphicEl(f);
        h && h.fadeOut(function() {
          n.remove(h);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = t;
    }, r.prototype.updateLayout = function() {
      var t = this, e = this._data;
      e && e.eachItemGraphicEl(function(n, i) {
        var a = t._getSymbolPoint(i);
        n.setPosition(a), n.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = IC(t), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(t, e, n) {
      this._progressiveEls = [], n = RC(n);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = t.start; a < t.end; a++) {
        var o = e.getItemLayout(a);
        if (C0(e, o, a, n)) {
          var s = new this._SymbolCtor(e, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), e.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(t) {
      jo(this._progressiveEls || this.group, t);
    }, r.prototype.remove = function(t) {
      var e = this.group, n = this._data;
      n && t ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          e.remove(i);
        }, n.hostModel);
      }) : e.removeAll();
    }, r;
  }()
);
function i3(r, t, e) {
  var n = r.getBaseAxis(), i = r.getOtherAxis(n), a = kq(i, e), o = n.dim, s = i.dim, l = t.mapDimension(s), u = t.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, f = rt(r.dimensions, function(p) {
    return t.mapDimension(p);
  }), h = !1, d = t.getCalculationInfo("stackResultDimension");
  return Wo(
    t,
    f[0]
    /* , dims[1] */
  ) && (h = !0, f[0] = d), Wo(
    t,
    f[1]
    /* , dims[0] */
  ) && (h = !0, f[1] = d), {
    dataDimsForPoint: f,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!h,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: t.getCalculationInfo("stackedOverDimension")
  };
}
function kq(r, t) {
  var e = 0, n = r.scale.getExtent();
  return t === "start" ? e = n[0] : t === "end" ? e = n[1] : fe(t) && !isNaN(t) ? e = t : n[0] > 0 ? e = n[0] : n[1] < 0 && (e = n[1]), e;
}
function a3(r, t, e, n) {
  var i = NaN;
  r.stacked && (i = e.get(e.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = r.valueStart);
  var a = r.baseDataOffset, o = [];
  return o[a] = e.get(r.baseDim, n), o[1 - a] = i, t.dataToPoint(o);
}
function Bq(r, t) {
  var e = [];
  return t.diff(r).add(function(n) {
    e.push({
      cmd: "+",
      idx: n
    });
  }).update(function(n, i) {
    e.push({
      cmd: "=",
      idx: i,
      idx1: n
    });
  }).remove(function(n) {
    e.push({
      cmd: "-",
      idx: n
    });
  }).execute(), e;
}
function Vq(r, t, e, n, i, a, o, s) {
  for (var l = Bq(r, t), u = [], c = [], f = [], h = [], d = [], p = [], g = [], v = i3(i, t, o), m = r.getLayout("points") || [], y = t.getLayout("points") || [], _ = 0; _ < l.length; _++) {
    var x = l[_], b = !0, S = void 0, w = void 0;
    switch (x.cmd) {
      case "=":
        S = x.idx * 2, w = x.idx1 * 2;
        var A = m[S], T = m[S + 1], M = y[w], C = y[w + 1];
        (isNaN(A) || isNaN(T)) && (A = M, T = C), u.push(A, T), c.push(M, C), f.push(e[S], e[S + 1]), h.push(n[w], n[w + 1]), g.push(t.getRawIndex(x.idx1));
        break;
      case "+":
        var R = x.idx, E = v.dataDimsForPoint, D = i.dataToPoint([t.get(E[0], R), t.get(E[1], R)]);
        w = R * 2, u.push(D[0], D[1]), c.push(y[w], y[w + 1]);
        var I = a3(v, i, t, R);
        f.push(I[0], I[1]), h.push(n[w], n[w + 1]), g.push(t.getRawIndex(R));
        break;
      case "-":
        b = !1;
    }
    b && (d.push(x), p.push(p.length));
  }
  p.sort(function(Y, at) {
    return g[Y] - g[at];
  });
  for (var P = u.length, O = qi(P), N = qi(P), B = qi(P), F = qi(P), G = [], _ = 0; _ < p.length; _++) {
    var W = p[_], J = _ * 2, U = W * 2;
    O[J] = u[U], O[J + 1] = u[U + 1], N[J] = c[U], N[J + 1] = c[U + 1], B[J] = f[U], B[J + 1] = f[U + 1], F[J] = h[U], F[J + 1] = h[U + 1], G[_] = d[W];
  }
  return {
    current: O,
    next: N,
    stackedOnCurrent: B,
    stackedOnNext: F,
    status: G
  };
}
var ho = Math.min, po = Math.max;
function ul(r, t) {
  return isNaN(r) || isNaN(t);
}
function gS(r, t, e, n, i, a, o, s, l) {
  for (var u, c, f, h, d, p, g = e, v = 0; v < n; v++) {
    var m = t[g * 2], y = t[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (ul(m, y)) {
      if (l) {
        g += a;
        continue;
      }
      break;
    }
    if (g === e)
      r[a > 0 ? "moveTo" : "lineTo"](m, y), f = m, h = y;
    else {
      var _ = m - u, x = y - c;
      if (_ * _ + x * x < 0.5) {
        g += a;
        continue;
      }
      if (o > 0) {
        for (var b = g + a, S = t[b * 2], w = t[b * 2 + 1]; S === m && w === y && v < n; )
          v++, b += a, g += a, S = t[b * 2], w = t[b * 2 + 1], m = t[g * 2], y = t[g * 2 + 1], _ = m - u, x = y - c;
        var A = v + 1;
        if (l)
          for (; ul(S, w) && A < n; )
            A++, b += a, S = t[b * 2], w = t[b * 2 + 1];
        var T = 0.5, M = 0, C = 0, R = void 0, E = void 0;
        if (A >= n || ul(S, w))
          d = m, p = y;
        else {
          M = S - u, C = w - c;
          var D = m - u, I = S - m, P = y - c, O = w - y, N = void 0, B = void 0;
          if (s === "x") {
            N = Math.abs(D), B = Math.abs(I);
            var F = M > 0 ? 1 : -1;
            d = m - F * N * o, p = y, R = m + F * B * o, E = y;
          } else if (s === "y") {
            N = Math.abs(P), B = Math.abs(O);
            var G = C > 0 ? 1 : -1;
            d = m, p = y - G * N * o, R = m, E = y + G * B * o;
          } else
            N = Math.sqrt(D * D + P * P), B = Math.sqrt(I * I + O * O), T = B / (B + N), d = m - M * o * (1 - T), p = y - C * o * (1 - T), R = m + M * o * T, E = y + C * o * T, R = ho(R, po(S, m)), E = ho(E, po(w, y)), R = po(R, ho(S, m)), E = po(E, ho(w, y)), M = R - m, C = E - y, d = m - M * N / B, p = y - C * N / B, d = ho(d, po(u, m)), p = ho(p, po(c, y)), d = po(d, ho(u, m)), p = po(p, ho(c, y)), M = m - d, C = y - p, R = m + M * B / N, E = y + C * B / N;
        }
        r.bezierCurveTo(f, h, d, p, m, y), f = R, h = E;
      } else
        r.lineTo(m, y);
    }
    u = m, c = y, g += a;
  }
  return v;
}
var o3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return r;
  }()
), Fq = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-polyline", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: X.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new o3();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = 0, o = i.length / 2;
      if (n.connectNulls) {
        for (; o > 0 && ul(i[o * 2 - 2], i[o * 2 - 1]); o--)
          ;
        for (; a < o && ul(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += gS(e, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, t.prototype.getPointOn = function(e, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = oa.CMD, s, l, u = n === "x", c = [], f = 0; f < a.length; ) {
        var h = a[f++], d = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, _ = void 0;
        switch (h) {
          case o.M:
            s = a[f++], l = a[f++];
            break;
          case o.L:
            if (d = a[f++], p = a[f++], _ = u ? (e - s) / (d - s) : (e - l) / (p - l), _ <= 1 && _ >= 0) {
              var x = u ? (p - l) * _ + l : (d - s) * _ + s;
              return u ? [e, x] : [x, e];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[f++], p = a[f++], g = a[f++], v = a[f++], m = a[f++], y = a[f++];
            var b = u ? wv(s, d, g, m, e, c) : wv(l, p, v, y, e, c);
            if (b > 0)
              for (var S = 0; S < b; S++) {
                var w = c[S];
                if (w <= 1 && w >= 0) {
                  var x = u ? wr(l, p, v, y, w) : wr(s, d, g, m, w);
                  return u ? [e, x] : [x, e];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, t;
  }(ne)
), zq = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t;
  }(o3)
), s3 = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-polygon", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new zq();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = n.stackedOnPoints, o = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && ul(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; o < s && ul(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = gS(e, i, o, s, s, 1, n.smooth, l, n.connectNulls);
        gS(e, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), o += u + 1, e.closePath();
      }
    }, t;
  }(ne)
);
function l3(r, t, e, n, i) {
  var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = e.get(["lineStyle", "width"]) || 0;
  o -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
  var f = new te({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (t) {
    var h = r.getBaseAxis(), d = h.isHorizontal(), p = h.inverse;
    d ? (p && (f.shape.x += l), f.shape.width = 0) : (p || (f.shape.y += u), f.shape.height = 0);
    var g = At(i) ? function(v) {
      i(v, f);
    } : null;
    ze(f, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, e, null, n, g);
  }
  return f;
}
function u3(r, t, e) {
  var n = r.getArea(), i = sr(n.r0, 1), a = sr(n.r, 1), o = new jr({
    shape: {
      cx: sr(r.cx, 1),
      cy: sr(r.cy, 1),
      r0: i,
      r: a,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    }
  });
  if (t) {
    var s = r.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = n.startAngle : o.shape.r = i, ze(o, {
      shape: {
        endAngle: n.endAngle,
        r: a
      }
    }, e);
  }
  return o;
}
function $h(r, t, e, n, i) {
  if (r) {
    if (r.type === "polar")
      return u3(r, t, e);
    if (r.type === "cartesian2d")
      return l3(r, t, e, n, i);
  } else
    return null;
  return null;
}
function Xo(r, t) {
  return r.type === t;
}
function PC(r, t) {
  if (r.length === t.length) {
    for (var e = 0; e < r.length; e++)
      if (r[e] !== t[e])
        return;
    return !0;
  }
}
function NC(r) {
  for (var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < r.length; ) {
    var o = r[a++], s = r[a++];
    isNaN(o) || (t = Math.min(o, t), n = Math.max(o, n)), isNaN(s) || (e = Math.min(s, e), i = Math.max(s, i));
  }
  return [[t, e], [n, i]];
}
function OC(r, t) {
  var e = NC(r), n = e[0], i = e[1], a = NC(t), o = a[0], s = a[1];
  return Math.max(Math.abs(n[0] - o[0]), Math.abs(n[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function kC(r) {
  return fe(r) ? r : r ? 0.5 : 0;
}
function Uq(r, t, e) {
  if (!e.valueDim)
    return [];
  for (var n = t.count(), i = qi(n * 2), a = 0; a < n; a++) {
    var o = a3(e, r, t, a);
    i[a * 2] = o[0], i[a * 2 + 1] = o[1];
  }
  return i;
}
function vo(r, t, e, n, i) {
  var a = e.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, u = [], c = [], f = [], h = [];
  if (i) {
    for (l = 0; l < r.length; l += 2) {
      var d = t || r;
      !isNaN(d[l]) && !isNaN(d[l + 1]) && h.push(r[l], r[l + 1]);
    }
    r = h;
  }
  for (l = 0; l < r.length - 2; l += 2)
    switch (f[0] = r[l + 2], f[1] = r[l + 3], c[0] = r[l], c[1] = r[l + 1], s.push(c[0], c[1]), n) {
      case "end":
        u[o] = f[o], u[1 - o] = c[1 - o], s.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[o] + f[o]) / 2, g = [];
        u[o] = g[o] = p, u[1 - o] = c[1 - o], g[1 - o] = f[1 - o], s.push(u[0], u[1]), s.push(g[0], g[1]);
        break;
      default:
        u[o] = c[o], u[1 - o] = f[1 - o], s.push(u[0], u[1]);
    }
  return s.push(r[l++], r[l++]), s;
}
function Gq(r, t) {
  var e = [], n = r.length, i, a;
  function o(c, f, h) {
    var d = c.coord, p = (h - d) / (f.coord - d), g = i8(p, [c.color, f.color]);
    return {
      coord: h,
      color: g
    };
  }
  for (var s = 0; s < n; s++) {
    var l = r[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > t) {
      a ? e.push(o(a, l, t)) : i && e.push(o(i, l, 0), o(i, l, t));
      break;
    } else
      i && (e.push(o(i, l, 0)), i = null), e.push(l), a = l;
  }
  return e;
}
function Hq(r, t, e) {
  var n = r.getVisual("visualMeta");
  if (!(!n || !n.length || !r.count())) {
    if (t.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, a, o = n.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(n[o].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        a = n[o];
        break;
      }
    }
    if (!a) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = t.getAxis(i), u = rt(a.stops, function(_) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(_.value)),
        color: _.color
      };
    }), c = u.length, f = a.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), f.reverse());
    var h = Gq(u, i === "x" ? e.getWidth() : e.getHeight()), d = h.length;
    if (!d && c)
      return u[0].coord < 0 ? f[1] ? f[1] : u[c - 1].color : f[0] ? f[0] : u[0].color;
    var p = 10, g = h[0].coord - p, v = h[d - 1].coord + p, m = v - g;
    if (m < 1e-3)
      return "transparent";
    L(h, function(_) {
      _.offset = (_.coord - g) / m;
    }), h.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: d ? h[d - 1].offset : 0.5,
      color: f[1] || "transparent"
    }), h.unshift({
      offset: d ? h[0].offset : 0.5,
      color: f[0] || "transparent"
    });
    var y = new Mc(0, 0, 0, 0, h, !0);
    return y[i] = g, y[i + "2"] = v, y;
  }
}
function Wq(r, t, e) {
  var n = r.get("showAllSymbol"), i = n === "auto";
  if (!(n && !i)) {
    var a = e.getAxesByScale("ordinal")[0];
    if (a && !(i && Xq(a, t))) {
      var o = t.mapDimension(a.dim), s = {};
      return L(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(t.get(o, l));
      };
    }
  }
}
function Xq(r, t) {
  var e = r.getExtent(), n = Math.abs(e[1] - e[0]) / r.scale.count();
  isNaN(n) && (n = 0);
  for (var i = t.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a)
    if (Xh.getSymbolSize(
      t,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[r.isHorizontal() ? 1 : 0] * 1.5 > n)
      return !1;
  return !0;
}
function Yq(r, t) {
  return isNaN(r) || isNaN(t);
}
function $q(r) {
  for (var t = r.length / 2; t > 0 && Yq(r[t * 2 - 2], r[t * 2 - 1]); t--)
    ;
  return t - 1;
}
function BC(r, t) {
  return [r[t * 2], r[t * 2 + 1]];
}
function Zq(r, t, e) {
  for (var n = r.length / 2, i = e === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < n; u++)
    if (o = r[u * 2 + i], !(isNaN(o) || isNaN(r[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= t && o >= t || a >= t && o <= t) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (t - a) / (o - a)
  };
}
function c3(r) {
  if (r.get(["endLabel", "show"]))
    return !0;
  for (var t = 0; t < pn.length; t++)
    if (r.get([pn[t], "endLabel", "show"]))
      return !0;
  return !1;
}
function D0(r, t, e, n) {
  if (Xo(t, "cartesian2d")) {
    var i = n.getModel("endLabel"), a = i.get("valueAnimation"), o = n.getData(), s = {
      lastFrameIndex: 0
    }, l = c3(n) ? function(d, p) {
      r._endLabelOnDuring(d, p, o, s, a, i, t);
    } : null, u = t.getBaseAxis().isHorizontal(), c = l3(t, e, n, function() {
      var d = r._endLabel;
      d && e && s.originalX != null && d.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!n.get("clip", !0)) {
      var f = c.shape, h = Math.max(f.width, f.height);
      u ? (f.y -= h, f.height += h * 2) : (f.x -= h, f.width += h * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && n.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), u3(t, e, n);
}
function qq(r, t) {
  var e = t.getBaseAxis(), n = e.isHorizontal(), i = e.inverse, a = n ? i ? "right" : "left" : "center", o = n ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: r.get("align") || a,
      verticalAlign: r.get("verticalAlign") || o
    }
  };
}
var Kq = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function() {
      var e = new Ct(), n = new Yh();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = e, this._changePolyState = gt(this._changePolyState, this);
    }, t.prototype.render = function(e, n, i) {
      var a = e.coordinateSystem, o = this.group, s = e.getData(), l = e.getModel("lineStyle"), u = e.getModel("areaStyle"), c = s.getLayout("points") || [], f = a.type === "polar", h = this._coordSys, d = this._symbolDraw, p = this._polyline, g = this._polygon, v = this._lineGroup, m = !n.ssr && e.get("animation"), y = !u.isEmpty(), _ = u.get("origin"), x = i3(a, s, _), b = y && Uq(a, s, x), S = e.get("showSymbol"), w = e.get("connectNulls"), A = S && !f && Wq(e, s, a), T = this._data;
      T && T.eachItemGraphicEl(function(Y, at) {
        Y.__temp && (o.remove(Y), T.setItemGraphicEl(at, null));
      }), S || d.remove(), o.add(v);
      var M = f ? !1 : e.get("step"), C;
      a && a.getArea && e.get("clip", !0) && (C = a.getArea(), C.width != null ? (C.x -= 0.1, C.y -= 0.1, C.width += 0.2, C.height += 0.2) : C.r0 && (C.r0 -= 0.5, C.r += 0.5)), this._clipShapeForSymbol = C;
      var R = Hq(s, a, i) || s.getVisual("style")[s.getVisual("drawType")];
      if (!(p && h.type === a.type && M === this._step))
        S && d.updateData(s, {
          isIgnore: A,
          clipShape: C,
          disableAnimation: !0,
          getSymbolPoint: function(Y) {
            return [c[Y * 2], c[Y * 2 + 1]];
          }
        }), m && this._initSymbolLabelAnimation(s, a, C), M && (b && (b = vo(b, c, a, M, w)), c = vo(c, null, a, M, w)), p = this._newPolyline(c), y ? g = this._newPolygon(c, b) : g && (v.remove(g), g = this._polygon = null), f || this._initOrUpdateEndLabel(e, a, _l(R)), v.setClipPath(D0(this, a, !0, e));
      else {
        y && !g ? g = this._newPolygon(c, b) : g && !y && (v.remove(g), g = this._polygon = null), f || this._initOrUpdateEndLabel(e, a, _l(R));
        var E = v.getClipPath();
        if (E) {
          var D = D0(this, a, !1, e);
          ze(E, {
            shape: D.shape
          }, e);
        } else
          v.setClipPath(D0(this, a, !0, e));
        S && d.updateData(s, {
          isIgnore: A,
          clipShape: C,
          disableAnimation: !0,
          getSymbolPoint: function(Y) {
            return [c[Y * 2], c[Y * 2 + 1]];
          }
        }), (!PC(this._stackedOnPoints, b) || !PC(this._points, c)) && (m ? this._doUpdateAnimation(s, b, a, i, M, _, w) : (M && (b && (b = vo(b, c, a, M, w)), c = vo(c, null, a, M, w)), p.setShape({
          points: c
        }), g && g.setShape({
          points: c,
          stackedOnPoints: b
        })));
      }
      var I = e.getModel("emphasis"), P = I.get("focus"), O = I.get("blurScope"), N = I.get("disabled");
      if (p.useStyle(Bt(
        // Use color in lineStyle first
        l.getLineStyle(),
        {
          fill: "none",
          stroke: R,
          lineJoin: "bevel"
        }
      )), _r(p, e, "lineStyle"), p.style.lineWidth > 0 && e.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var B = p.getState("emphasis").style;
        B.lineWidth = +p.style.lineWidth + 1;
      }
      zt(p).seriesIndex = e.seriesIndex, He(p, P, O, N);
      var F = kC(e.get("smooth")), G = e.get("smoothMonotone");
      if (p.setShape({
        smooth: F,
        smoothMonotone: G,
        connectNulls: w
      }), g) {
        var W = s.getCalculationInfo("stackedOnSeries"), J = 0;
        g.useStyle(Bt(u.getAreaStyle(), {
          fill: R,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: s.getVisual("style").decal
        })), W && (J = kC(W.get("smooth"))), g.setShape({
          smooth: F,
          stackedOnSmooth: J,
          smoothMonotone: G,
          connectNulls: w
        }), _r(g, e, "areaStyle"), zt(g).seriesIndex = e.seriesIndex, He(g, P, O, N);
      }
      var U = this._changePolyState;
      s.eachItemGraphicEl(function(Y) {
        Y && (Y.onHoverStateChange = U);
      }), this._polyline.onHoverStateChange = U, this._data = s, this._coordSys = a, this._stackedOnPoints = b, this._points = c, this._step = M, this._valueOrigin = _, e.get("triggerLineEvent") && (this.packEventData(e, p), g && this.packEventData(e, g));
    }, t.prototype.packEventData = function(e, n) {
      zt(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: "line"
      };
    }, t.prototype.highlight = function(e, n, i, a) {
      var o = e.getData(), s = pl(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], f = l[s * 2 + 1];
          if (isNaN(c) || isNaN(f) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, f))
            return;
          var h = e.get("zlevel") || 0, d = e.get("z") || 0;
          u = new Xh(o, s), u.x = c, u.y = f, u.setZ(h, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = h, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        Re.prototype.highlight.call(this, e, n, i, a);
    }, t.prototype.downplay = function(e, n, i, a) {
      var o = e.getData(), s = pl(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        Re.prototype.downplay.call(this, e, n, i, a);
    }, t.prototype._changePolyState = function(e) {
      var n = this._polygon;
      Nv(this._polyline, e), n && Nv(n, e);
    }, t.prototype._newPolyline = function(e) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new Fq({
        shape: {
          points: e
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, t.prototype._newPolygon = function(e, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new s3({
        shape: {
          points: e,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, t.prototype._initSymbolLabelAnimation = function(e, n, i) {
      var a, o, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : n.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = e.hostModel, c = u.get("animationDuration");
      At(c) && (c = c(null));
      var f = u.get("animationDelay") || 0, h = At(f) ? f(null) : f;
      e.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [d.x, d.y], m = void 0, y = void 0, _ = void 0;
          if (i)
            if (o) {
              var x = i, b = n.pointToCoord(v);
              a ? (m = x.startAngle, y = x.endAngle, _ = -b[1] / 180 * Math.PI) : (m = x.r0, y = x.r, _ = b[0]);
            } else {
              var S = i;
              a ? (m = S.x, y = S.x + S.width, _ = d.x) : (m = S.y + S.height, y = S.y, _ = d.y);
            }
          var w = y === m ? 0 : (_ - m) / (y - m);
          l && (w = 1 - w);
          var A = At(f) ? f(p) : c * w + h, T = g.getSymbolPath(), M = T.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: A
          }), M && M.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: A
          }), T.disableLabelAnimation = !0;
        }
      });
    }, t.prototype._initOrUpdateEndLabel = function(e, n, i) {
      var a = e.getModel("endLabel");
      if (c3(e)) {
        var o = e.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new pe({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = $q(l);
        c >= 0 && (Cr(s, xr(e, "endLabel"), {
          inheritColor: i,
          labelFetcher: e,
          labelDataIndex: c,
          defaultText: function(f, h, d) {
            return d != null ? n3(o, d) : cc(o, f);
          },
          enableTextSetter: !0
        }, qq(a, n)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, t.prototype._endLabelOnDuring = function(e, n, i, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        e < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var f = i.getLayout("points"), h = i.hostModel, d = h.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, _ = n.shape, x = y ? m ? _.x : _.y + _.height : m ? _.x + _.width : _.y, b = (m ? g : 0) * (y ? -1 : 1), S = (m ? 0 : -g) * (y ? -1 : 1), w = m ? "x" : "y", A = Zq(f, x, w), T = A.range, M = T[1] - T[0], C = void 0;
        if (M >= 1) {
          if (M > 1 && !d) {
            var R = BC(f, T[0]);
            u.attr({
              x: R[0] + b,
              y: R[1] + S
            }), o && (C = h.getRawValue(T[0]));
          } else {
            var R = c.getPointOn(x, w);
            R && u.attr({
              x: R[0] + b,
              y: R[1] + S
            });
            var E = h.getRawValue(T[0]), D = h.getRawValue(T[1]);
            o && (C = zP(i, p, E, D, A.t));
          }
          a.lastFrameIndex = T[0];
        } else {
          var I = e === 1 || a.lastFrameIndex > 0 ? T[0] : 0, R = BC(f, I);
          o && (C = h.getRawValue(I)), u.attr({
            x: R[0] + b,
            y: R[1] + S
          });
        }
        if (o) {
          var P = Ac(u);
          typeof P.setLabelText == "function" && P.setLabelText(C);
        }
      }
    }, t.prototype._doUpdateAnimation = function(e, n, i, a, o, s, l) {
      var u = this._polyline, c = this._polygon, f = e.hostModel, h = Vq(this._data, e, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), d = h.current, p = h.stackedOnCurrent, g = h.next, v = h.stackedOnNext;
      if (o && (p = vo(h.stackedOnCurrent, h.current, i, o, l), d = vo(h.current, null, i, o, l), v = vo(h.stackedOnNext, h.next, i, o, l), g = vo(h.next, null, i, o, l)), OC(d, g) > 3e3 || c && OC(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = h.current, u.shape.points = d;
      var m = {
        shape: {
          points: g
        }
      };
      h.current !== d && (m.shape.__points = h.next), u.stopAnimation(), ve(u, m, f), c && (c.setShape({
        // Reuse the points with polyline.
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), ve(c, {
        shape: {
          stackedOnPoints: v
        }
      }, f), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], _ = h.status, x = 0; x < _.length; x++) {
        var b = _[x].cmd;
        if (b === "=") {
          var S = e.getItemGraphicEl(_[x].idx1);
          S && y.push({
            el: S,
            ptIdx: x
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var w = u.shape.__points, A = 0; A < y.length; A++) {
          var T = y[A].el, M = y[A].ptIdx * 2;
          T.x = w[M], T.y = w[M + 1], T.markRedraw();
        }
      });
    }, t.prototype.remove = function(e) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (n.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, t.type = "line", t;
  }(Re)
);
function Zh(r, t) {
  return {
    seriesType: r,
    plan: Dc(),
    reset: function(e) {
      var n = e.getData(), i = e.coordinateSystem, a = e.pipelineContext, o = t || a.large;
      if (i) {
        var s = rt(i.dimensions, function(d) {
          return n.mapDimension(d);
        }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
        Wo(n, s[0]) && (s[0] = u), Wo(n, s[1]) && (s[1] = u);
        var c = n.getStore(), f = n.getDimensionIndex(s[0]), h = n.getDimensionIndex(s[1]);
        return l && {
          progress: function(d, p) {
            for (var g = d.end - d.start, v = o && qi(g * l), m = [], y = [], _ = d.start, x = 0; _ < d.end; _++) {
              var b = void 0;
              if (l === 1) {
                var S = c.get(f, _);
                b = i.dataToPoint(S, null, y);
              } else
                m[0] = c.get(f, _), m[1] = c.get(h, _), b = i.dataToPoint(m, null, y);
              o ? (v[x++] = b[0], v[x++] = b[1]) : p.setItemLayout(_, b.slice());
            }
            o && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var jq = {
  average: function(r) {
    for (var t = 0, e = 0, n = 0; n < r.length; n++)
      isNaN(r[n]) || (t += r[n], e++);
    return e === 0 ? NaN : t / e;
  },
  sum: function(r) {
    for (var t = 0, e = 0; e < r.length; e++)
      t += r[e] || 0;
    return t;
  },
  max: function(r) {
    for (var t = -1 / 0, e = 0; e < r.length; e++)
      r[e] > t && (t = r[e]);
    return isFinite(t) ? t : NaN;
  },
  min: function(r) {
    for (var t = 1 / 0, e = 0; e < r.length; e++)
      r[e] < t && (t = r[e]);
    return isFinite(t) ? t : NaN;
  },
  // TODO
  // Median
  nearest: function(r) {
    return r[0];
  }
}, Jq = function(r) {
  return Math.round(r.length / 2);
};
function f3(r) {
  return {
    seriesType: r,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(t, e, n) {
      var i = t.getData(), a = t.get("sampling"), o = t.coordinateSystem, s = i.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), f = n.getDevicePixelRatio(), h = Math.abs(c[1] - c[0]) * (f || 1), d = Math.round(s / h);
        if (isFinite(d) && d > 1) {
          a === "lttb" ? t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d)) : a === "minmax" && t.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / d));
          var p = void 0;
          pt(a) ? p = jq[a] : At(a) && (p = a), p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, Jq));
        }
      }
    }
  };
}
function Qq(r) {
  r.registerChartView(Kq), r.registerSeriesModel(Nq), r.registerLayout(Zh("line", !0)), r.registerVisual({
    seriesType: "line",
    reset: function(t) {
      var e = t.getData(), n = t.getModel("lineStyle").getLineStyle();
      n && !n.stroke && (n.stroke = e.getVisual("style").fill), e.setVisual("legendLineStyle", n);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, f3("line"));
}
var _h = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getMarkerPosition = function(e, n, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(e), s = a.dataToPoint(o);
        if (i)
          L(a.getAxes(), function(h, d) {
            if (h.type === "category" && n != null) {
              var p = h.getTicksCoords(), g = h.getTickModel().get("alignWithLabel"), v = o[d], m = n[d] === "x1" || n[d] === "y1";
              if (m && !g && (v += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[d] = h.toGlobalCoord(h.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, _ = void 0, x = 1, b = 0; b < p.length; b++) {
                var S = p[b].coord, w = b === p.length - 1 ? p[b - 1].tickValue + x : p[b].tickValue;
                if (w === v) {
                  _ = S;
                  break;
                } else if (w < v)
                  y = S;
                else if (y != null && w > v) {
                  _ = (S + y) / 2;
                  break;
                }
                b === 1 && (x = w - p[0].tickValue);
              }
              _ == null && (y ? y && (_ = p[p.length - 1].coord) : _ = p[0].coord), s[d] = h.toGlobalCoord(_);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), f = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[f] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, t.type = "series.__base_bar__", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod",
      defaultBarGap: "10%"
    }, t;
  }(ke)
);
ke.registerClass(_h);
var tK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function() {
      return Ja(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, t.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > e && (e = n), e;
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.rect(n.getItemLayout(e));
    }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = Jo(_h.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: X.color.primary,
          borderWidth: 2
        }
      },
      realtimeSort: !1
    }), t;
  }(_h)
), eK = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return r;
  }()
), ag = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "sausage", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new eK();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - o) * 0.5, u = o + l, c = n.startAngle, f = n.endAngle, h = n.clockwise, d = Math.PI * 2, p = h ? f - c < d : c - f < d;
      p || (c = f - (h ? d : -d));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(f), y = Math.sin(f);
      p ? (e.moveTo(g * o + i, v * o + a), e.arc(g * u + i, v * u + a, l, -Math.PI + c, c, !h)) : e.moveTo(g * s + i, v * s + a), e.arc(i, a, s, c, f, !h), e.arc(m * u + i, y * u + a, l, f - Math.PI * 2, f - Math.PI, !h), o !== 0 && e.arc(i, a, o, f, c, h);
    }, t;
  }(ne)
);
function rK(r, t) {
  t = t || {};
  var e = t.isRoundCap;
  return function(n, i, a) {
    var o = i.position;
    if (!o || o instanceof Array)
      return Dv(n, i, a);
    var s = r(o), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, f = u.cy, h = u.r, d = u.r0, p = (h + d) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = e ? Math.abs(h - d) / 2 : 0, _ = Math.cos, x = Math.sin, b = c + h * _(g), S = f + h * x(g), w = "left", A = "top";
    switch (s) {
      case "startArc":
        b = c + (d - l) * _(m), S = f + (d - l) * x(m), w = "center", A = "top";
        break;
      case "insideStartArc":
        b = c + (d + l) * _(m), S = f + (d + l) * x(m), w = "center", A = "bottom";
        break;
      case "startAngle":
        b = c + p * _(g) + cp(g, l + y, !1), S = f + p * x(g) + fp(g, l + y, !1), w = "right", A = "middle";
        break;
      case "insideStartAngle":
        b = c + p * _(g) + cp(g, -l + y, !1), S = f + p * x(g) + fp(g, -l + y, !1), w = "left", A = "middle";
        break;
      case "middle":
        b = c + p * _(m), S = f + p * x(m), w = "center", A = "middle";
        break;
      case "endArc":
        b = c + (h + l) * _(m), S = f + (h + l) * x(m), w = "center", A = "bottom";
        break;
      case "insideEndArc":
        b = c + (h - l) * _(m), S = f + (h - l) * x(m), w = "center", A = "top";
        break;
      case "endAngle":
        b = c + p * _(v) + cp(v, l + y, !0), S = f + p * x(v) + fp(v, l + y, !0), w = "left", A = "middle";
        break;
      case "insideEndAngle":
        b = c + p * _(v) + cp(v, -l + y, !0), S = f + p * x(v) + fp(v, -l + y, !0), w = "right", A = "middle";
        break;
      default:
        return Dv(n, i, a);
    }
    return n = n || {}, n.x = b, n.y = S, n.align = w, n.verticalAlign = A, n;
  };
}
function nK(r, t, e, n) {
  if (fe(n)) {
    r.setTextConfig({
      rotation: n
    });
    return;
  } else if (et(t)) {
    r.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = r.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = e(t);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      r.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), r.setTextConfig({
    rotation: c
  });
}
function cp(r, t, e) {
  return t * Math.sin(r) * (e ? -1 : 1);
}
function fp(r, t, e) {
  return t * Math.cos(r) * (e ? 1 : -1);
}
function ji(r, t, e) {
  var n = r.get("borderRadius");
  if (n == null)
    return e ? {
      cornerRadius: 0
    } : null;
  et(n) || (n = [n, n, n, n]);
  var i = Math.abs(t.r || 0 - t.r0 || 0);
  return {
    cornerRadius: rt(n, function(a) {
      return wi(a, i);
    })
  };
}
var L0 = Math.max, R0 = Math.min;
function iK(r, t) {
  var e = r.getArea && r.getArea();
  if (Xo(r, "cartesian2d")) {
    var n = r.getBaseAxis();
    if (n.type !== "category" || !n.onBand) {
      var i = t.getLayout("bandWidth");
      n.isHorizontal() ? (e.x -= i, e.width += i * 2) : (e.y -= i, e.height += i * 2);
    }
  }
  return e;
}
var aK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.type = t.type, e._isFirstFrame = !0, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._model = e, this._removeOnRenderedListener(i), this._updateDrawMode(e);
      var o = e.get("coordinateSystem");
      o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(e, n, i) : this._renderNormal(e, n, i, a)) : process.env.NODE_ENV !== "production" && Ye("Only cartesian2d and polar supported for bar.");
    }, t.prototype.incrementalPrepareRender = function(e) {
      this._clear(), this._updateDrawMode(e), this._updateLargeClip(e);
    }, t.prototype.incrementalRender = function(e, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(e, n);
    }, t.prototype.eachRendered = function(e) {
      jo(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var n = e.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(e, n, i, a) {
      var o = this.group, s = e.getData(), l = this._data, u = e.coordinateSystem, c = u.getBaseAxis(), f;
      u.type === "cartesian2d" ? f = c.isHorizontal() : u.type === "polar" && (f = c.dim === "angle");
      var h = e.isAnimationEnabled() ? e : null, d = oK(e, u);
      d && this._enableRealtimeSort(d, s, i);
      var p = e.get("clip", !0) || d, g = iK(u, s);
      o.removeClipPath();
      var v = e.get("roundCap", !0), m = e.get("showBackground", !0), y = e.getModel("backgroundStyle"), _ = y.get("borderRadius") || 0, x = [], b = this._backgroundEls, S = a && a.isInitSort, w = a && a.type === "changeAxisOrder";
      function A(C) {
        var R = hp[u.type](s, C);
        if (!R)
          return null;
        var E = dK(u, f, R);
        return E.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? E.setShape("r", _) : E.setShape("cornerRadius", _), x[C] = E, E;
      }
      s.diff(l).add(function(C) {
        var R = s.getItemModel(C), E = hp[u.type](s, C, R);
        if (E && (m && A(C), !(!s.hasValue(C) || !GC[u.type](E)))) {
          var D = !1;
          p && (D = VC[u.type](g, E));
          var I = FC[u.type](e, s, C, E, f, h, c.model, !1, v);
          d && (I.forceLabelAnimation = !0), HC(I, s, C, R, E, e, f, u.type === "polar"), S ? I.attr({
            shape: E
          }) : d ? zC(d, h, I, E, C, f, !1, !1) : ze(I, {
            shape: E
          }, e, C), s.setItemGraphicEl(C, I), o.add(I), I.ignore = D;
        }
      }).update(function(C, R) {
        var E = s.getItemModel(C), D = hp[u.type](s, C, E);
        if (D) {
          if (m) {
            var I = void 0;
            b.length === 0 ? I = A(R) : (I = b[R], I.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? I.setShape("r", _) : I.setShape("cornerRadius", _), x[C] = I);
            var P = hp[u.type](s, C), O = d3(f, P, u);
            ve(I, {
              shape: O
            }, h, C);
          }
          var N = l.getItemGraphicEl(R);
          if (!s.hasValue(C) || !GC[u.type](D)) {
            o.remove(N);
            return;
          }
          var B = !1;
          p && (B = VC[u.type](g, D), B && o.remove(N));
          var F = N && (N.type === "sector" && v || N.type === "sausage" && !v);
          if (F && (N && Na(N, e, R), N = null), N ? oi(N) : N = FC[u.type](e, s, C, D, f, h, c.model, !0, v), d && (N.forceLabelAnimation = !0), w) {
            var G = N.getTextContent();
            if (G) {
              var W = Ac(G);
              W.prevValue != null && (W.prevValue = W.value);
            }
          } else
            HC(N, s, C, E, D, e, f, u.type === "polar");
          S ? N.attr({
            shape: D
          }) : d ? zC(d, h, N, D, C, f, !0, w) : ve(N, {
            shape: D
          }, e, C, null), s.setItemGraphicEl(C, N), N.ignore = B, o.add(N);
        }
      }).remove(function(C) {
        var R = l.getItemGraphicEl(C);
        R && Na(R, e, C);
      }).execute();
      var T = this._backgroundGroup || (this._backgroundGroup = new Ct());
      T.removeAll();
      for (var M = 0; M < x.length; ++M)
        T.add(x[M]);
      o.add(T), this._backgroundEls = x, this._data = s;
    }, t.prototype._renderLarge = function(e, n, i) {
      this._clear(), XC(e, this.group), this._updateLargeClip(e);
    }, t.prototype._incrementalRenderLarge = function(e, n) {
      this._removeBackground(), XC(n, this.group, this._progressiveEls, !0);
    }, t.prototype._updateLargeClip = function(e) {
      var n = e.get("clip", !0) && $h(e.coordinateSystem, !1, e), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, t.prototype._enableRealtimeSort = function(e, n, i) {
      var a = this;
      if (n.count()) {
        var o = e.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(n, e, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(n, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, t.prototype._dataSort = function(e, n, i) {
      var a = [];
      return e.each(e.mapDimension(n.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: rt(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, t.prototype._isOrderChangedWithinSameData = function(e, n, i) {
      for (var a = i.scale, o = e.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = e.rawIndexOf(o, a.getRawOrdinalNumber(l)), f = c < 0 ? Number.MIN_VALUE : n(e.indexOfRawIndex(c));
        if (f > s)
          return !0;
        s = f;
      }
      return !1;
    }, t.prototype._isOrderDifferentInView = function(e, n) {
      for (var i = n.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (e.ordinalNumbers[o] !== i.getRawOrdinalNumber(o))
          return !0;
    }, t.prototype._updateSortWithinSameData = function(e, n, i, a) {
      if (this._isOrderChangedWithinSameData(e, n, i)) {
        var o = this._dataSort(e, i, n);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, t.prototype._dispatchInitSort = function(e, n, i) {
      var a = n.baseAxis, o = this._dataSort(e, a, function(s) {
        return e.get(e.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, t.prototype.remove = function(e, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, t.prototype.dispose = function(e, n) {
      this._removeOnRenderedListener(n);
    }, t.prototype._removeOnRenderedListener = function(e) {
      this._onRendered && (e.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, t.prototype._clear = function(e) {
      var n = this.group, i = this._data;
      e && e.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        Na(a, e, zt(a).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, t.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, t.type = "bar", t;
  }(Re)
), VC = {
  cartesian2d: function(r, t) {
    var e = t.width < 0 ? -1 : 1, n = t.height < 0 ? -1 : 1;
    e < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height);
    var i = r.x + r.width, a = r.y + r.height, o = L0(t.x, r.x), s = R0(t.x + t.width, i), l = L0(t.y, r.y), u = R0(t.y + t.height, a), c = s < o, f = u < l;
    return t.x = c && o > i ? s : o, t.y = f && l > a ? u : l, t.width = c ? 0 : s - o, t.height = f ? 0 : u - l, e < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height), c || f;
  },
  polar: function(r, t) {
    var e = t.r0 <= t.r ? 1 : -1;
    if (e < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    var i = R0(t.r, r.r), a = L0(t.r0, r.r0);
    t.r = i, t.r0 = a;
    var o = i - a < 0;
    if (e < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    return o;
  }
}, FC = {
  cartesian2d: function(r, t, e, n, i, a, o, s, l) {
    var u = new te({
      shape: j({}, n),
      z2: 1
    });
    if (u.__dataIndex = e, u.name = "item", a) {
      var c = u.shape, f = i ? "height" : "width";
      c[f] = 0;
    }
    return u;
  },
  polar: function(r, t, e, n, i, a, o, s, l) {
    var u = !i && l ? ag : jr, c = new u({
      shape: n,
      z2: 1
    });
    c.name = "item";
    var f = h3(i);
    if (c.calculateTextPosition = rK(f, {
      isRoundCap: u === ag
    }), a) {
      var h = c.shape, d = i ? "r" : "endAngle", p = {};
      h[d] = i ? n.r0 : n.startAngle, p[d] = n[d], (s ? ve : ze)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return c;
  }
};
function oK(r, t) {
  var e = r.get("realtimeSort", !0), n = t.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && e && (n.type !== "category" && Ye("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && Ye("`realtimeSort` will not work because this bar series is not on cartesian2d.")), e && n.type === "category" && t.type === "cartesian2d")
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n)
    };
}
function zC(r, t, e, n, i, a, o, s) {
  var l, u;
  a ? (u = {
    x: n.x,
    width: n.width
  }, l = {
    y: n.y,
    height: n.height
  }) : (u = {
    y: n.y,
    height: n.height
  }, l = {
    x: n.x,
    width: n.width
  }), s || (o ? ve : ze)(e, {
    shape: l
  }, t, i, null);
  var c = t ? r.baseAxis.model : null;
  (o ? ve : ze)(e, {
    shape: u
  }, c, i);
}
function UC(r, t) {
  for (var e = 0; e < t.length; e++)
    if (!isFinite(r[t[e]]))
      return !0;
  return !1;
}
var sK = ["x", "y", "width", "height"], lK = ["cx", "cy", "r", "startAngle", "endAngle"], GC = {
  cartesian2d: function(r) {
    return !UC(r, sK);
  },
  polar: function(r) {
    return !UC(r, lK);
  }
}, hp = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(r, t, e) {
    var n = r.getItemLayout(t);
    if (!n)
      return null;
    var i = e ? cK(e, n) : 0, a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1;
    return {
      x: n.x + a * i / 2,
      y: n.y + o * i / 2,
      width: n.width - a * i,
      height: n.height - o * i
    };
  },
  polar: function(r, t, e) {
    var n = r.getItemLayout(t);
    return {
      cx: n.cx,
      cy: n.cy,
      r0: n.r0,
      r: n.r,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    };
  }
};
function uK(r) {
  return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
}
function h3(r) {
  return /* @__PURE__ */ function(t) {
    var e = t ? "Arc" : "Angle";
    return function(n) {
      switch (n) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return n + e;
        default:
          return n;
      }
    };
  }(r);
}
function HC(r, t, e, n, i, a, o, s) {
  var l = t.getItemVisual(e, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var c = r.shape, f = ji(n.getModel("itemStyle"), c, !0);
      j(c, f), r.setShape(c);
    }
  } else {
    var u = n.get(["itemStyle", "borderRadius"]) || 0;
    r.setShape("r", u);
  }
  r.useStyle(l);
  var h = n.getShallow("cursor");
  h && r.attr("cursor", h);
  var d = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = xr(n);
  Cr(r, p, {
    labelFetcher: a,
    labelDataIndex: e,
    defaultText: cc(a.getData(), e),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d
  });
  var g = r.getTextContent();
  if (s && g) {
    var v = n.get(["label", "position"]);
    r.textConfig.inside = v === "middle" ? !0 : null, nK(r, v === "outside" ? d : v, h3(o), n.get(["label", "rotate"]));
  }
  AN(g, p, a.getRawValue(e), function(y) {
    return n3(t, y);
  });
  var m = n.getModel(["emphasis"]);
  He(r, m.get("focus"), m.get("blurScope"), m.get("disabled")), _r(r, n), uK(i) && (r.style.fill = "none", r.style.stroke = "none", L(r.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function cK(r, t) {
  var e = r.get(["itemStyle", "borderColor"]);
  if (!e || e === "none")
    return 0;
  var n = r.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
  return Math.min(n, i, a);
}
var fK = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), WC = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "largeBar", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new fK();
    }, t.prototype.buildPath = function(e, n) {
      for (var i = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[a] = u, l[o] = i[c + 2], s[a] = i[c + a], s[o] = i[c + o], e.rect(s[0], s[1], l[0], l[1]);
    }, t;
  }(ne)
);
function XC(r, t, e, n) {
  var i = r.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = r.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new WC({
      shape: {
        points: u
      },
      incremental: !!n,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), t.add(c), e && e.push(c);
  }
  var f = new WC({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  f.baseDimIdx = a, f.largeDataIndices = o, f.barWidth = s, t.add(f), f.useStyle(i.getVisual("style")), f.style.stroke = null, zt(f).seriesIndex = r.seriesIndex, r.get("silent") || (f.on("mousedown", YC), f.on("mousemove", YC)), e && e.push(f);
}
var YC = fb(function(r) {
  var t = this, e = hK(t, r.offsetX, r.offsetY);
  zt(t).dataIndex = e >= 0 ? e : null;
}, 30, !1);
function hK(r, t, e) {
  for (var n = r.baseDimIdx, i = 1 - n, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, c = 0, f = a.length / 3; c < f; c++) {
    var h = c * 3;
    if (l[n] = u, l[i] = a[h + 2], s[n] = a[h + n], s[i] = a[h + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1])
      return o[c];
  }
  return -1;
}
function d3(r, t, e) {
  if (Xo(e, "cartesian2d")) {
    var n = t, i = e.getArea();
    return {
      x: r ? n.x : i.x,
      y: r ? i.y : n.y,
      width: r ? n.width : i.width,
      height: r ? i.height : n.height
    };
  } else {
    var i = e.getArea(), a = t;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: r ? i.r0 : a.r0,
      r: r ? i.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2
    };
  }
}
function dK(r, t, e) {
  var n = r.type === "polar" ? jr : te;
  return new n({
    shape: d3(t, e, r),
    silent: !0,
    z2: 0
  });
}
function pK(r) {
  r.registerChartView(aK), r.registerSeriesModel(tK), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Yt(gk, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, mk("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, f3("bar")), r.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(t, e) {
    var n = t.componentType || "series";
    e.eachComponent({
      mainType: n,
      query: t
    }, function(i) {
      t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo);
    });
  });
}
var $C = Math.PI * 2, dp = Math.PI / 180;
function vK(r, t, e) {
  t.eachSeriesByType(r, function(n) {
    var i = n.getData(), a = i.mapDimension("value"), o = YN(n, e), s = o.cx, l = o.cy, u = o.r, c = o.r0, f = o.viewRect, h = -n.get("startAngle") * dp, d = n.get("endAngle"), p = n.get("padAngle") * dp;
    d = d === "auto" ? h - $C : -d * dp;
    var g = n.get("minAngle") * dp, v = g + p, m = 0;
    i.each(a, function(O) {
      !isNaN(O) && m++;
    });
    var y = i.getSum(a), _ = Math.PI / (y || m) * 2, x = n.get("clockwise"), b = n.get("roseType"), S = n.get("stillShowZeroSum"), w = i.getDataExtent(a);
    w[0] = 0;
    var A = x ? 1 : -1, T = [h, d], M = A * p / 2;
    Qg(T, !x), h = T[0], d = T[1];
    var C = p3(n);
    C.startAngle = h, C.endAngle = d, C.clockwise = x, C.cx = s, C.cy = l, C.r = u, C.r0 = c;
    var R = Math.abs(d - h), E = R, D = 0, I = h;
    if (i.setLayout({
      viewRect: f,
      r: u
    }), i.each(a, function(O, N) {
      var B;
      if (isNaN(O)) {
        i.setItemLayout(N, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: x,
          cx: s,
          cy: l,
          r0: c,
          r: b ? NaN : u
        });
        return;
      }
      b !== "area" ? B = y === 0 && S ? _ : O * _ : B = R / m, B < v ? (B = v, E -= v) : D += O;
      var F = I + A * B, G = 0, W = 0;
      p > B ? (G = I + A * B / 2, W = G) : (G = I + M, W = F - M), i.setItemLayout(N, {
        angle: B,
        startAngle: G,
        endAngle: W,
        clockwise: x,
        cx: s,
        cy: l,
        r0: c,
        r: b ? Me(O, w, [c, u]) : u
      }), I = F;
    }), E < $C && m)
      if (E <= 1e-3) {
        var P = R / m;
        i.each(a, function(O, N) {
          if (!isNaN(O)) {
            var B = i.getItemLayout(N);
            B.angle = P;
            var F = 0, G = 0;
            P < p ? (F = h + A * (N + 1 / 2) * P, G = F) : (F = h + A * N * P + M, G = h + A * (N + 1) * P - M), B.startAngle = F, B.endAngle = G;
          }
        });
      } else
        _ = E / D, I = h, i.each(a, function(O, N) {
          if (!isNaN(O)) {
            var B = i.getItemLayout(N), F = B.angle === v ? v : O * _, G = 0, W = 0;
            F < p ? (G = I + A * F / 2, W = G) : (G = I + M, W = I + A * F - M), B.startAngle = G, B.endAngle = W, I += A * F;
          }
        });
  });
}
var p3 = ee();
function Pc(r) {
  return {
    seriesType: r,
    reset: function(t, e) {
      var n = e.findComponents({
        mainType: "legend"
      });
      if (!(!n || !n.length)) {
        var i = t.getData();
        i.filterSelf(function(a) {
          for (var o = i.getName(a), s = 0; s < n.length; s++)
            if (!n[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var gK = Math.PI / 180;
function ZC(r, t, e, n, i, a, o, s, l, u) {
  if (r.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var _ = g.list[y], x = Math.abs(_.label.y - e), b = n + _.len, S = b * b, w = Math.sqrt(Math.abs((1 - x * x / m) * S)), A = t + (w + _.len2) * i, T = A - _.label.x, M = _.targetTextWidth - T * i;
      v3(_, M, !0), _.label.x = A;
    }
  }
  function f(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var _ = g[y], x = _.label.y > e ? m : v, b = Math.abs(_.label.y - e);
        if (b >= x.maxY) {
          var S = _.label.x - t - _.len2 * i, w = n + _.len, A = Math.abs(S) < w ? Math.sqrt(b * b / (1 - S * S / w / w)) : w;
          x.rB = A, x.maxY = b;
        }
        x.list.push(_);
      }
    c(v), c(m);
  }
  for (var h = r.length, d = 0; d < h; d++)
    if (r[d].position === "outer" && r[d].labelAlignTo === "labelLine") {
      var p = r[d].label.x - u;
      r[d].linePoints[1][0] += p, r[d].label.x = u;
    }
  hS(r, 1, l, l + o) && f(r);
}
function mK(r, t, e, n, i, a, o, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, f = -Number.MAX_VALUE, h = 0; h < r.length; h++) {
    var d = r[h].label;
    I0(r[h]) || (d.x < t ? (c = Math.min(c, d.x), l.push(r[h])) : (f = Math.max(f, d.x), u.push(r[h])));
  }
  for (var h = 0; h < r.length; h++) {
    var p = r[h];
    if (!I0(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var d = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? d.x < t ? v = g[2][0] - p.labelDistance - o - p.edgeDistance : v = o + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < t ? v = c - o - p.bleedMargin : v = o + i - f - p.bleedMargin : d.x < t ? v = d.x - o - p.bleedMargin : v = o + i - d.x - p.bleedMargin, p.targetTextWidth = v, v3(p, v, !1);
    }
  }
  ZC(u, t, e, n, 1, i, a, o, s, f), ZC(l, t, e, n, -1, i, a, o, s, c);
  for (var h = 0; h < r.length; h++) {
    var p = r[h];
    if (!I0(p) && p.linePoints) {
      var d = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, _ = y ? y[1] + y[3] : 0, x = d.style.backgroundColor ? 0 : _, b = p.rect.width + x, S = g[1][0] - g[2][0];
      m ? d.x < t ? g[2][0] = o + p.edgeDistance + b + p.labelDistance : g[2][0] = o + i - p.edgeDistance - b - p.labelDistance : (d.x < t ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + S), g[1][1] = g[2][1] = d.y;
    }
  }
}
function v3(r, t, e) {
  if (r.labelStyleWidth == null) {
    var n = r.label, i = n.style, a = r.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = a.width + (o ? 0 : l);
    if (t < c || e) {
      if (u && u.match("break")) {
        n.setStyle("backgroundColor", null), n.setStyle("width", t - l);
        var f = n.getBoundingRect();
        n.setStyle("width", Math.ceil(f.width)), n.setStyle("backgroundColor", o);
      } else {
        var h = t - l, d = t < c ? h : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          e ? h > r.unconstrainedWidth ? null : h : null
        );
        n.setStyle("width", d);
      }
      g3(a, n);
    }
  }
}
function g3(r, t) {
  qC.rect = r, zk(qC, t, yK);
}
var yK = {
  minMarginForce: [null, 0, null, 0],
  marginDefault: [1, 0, 1, 0]
}, qC = {};
function I0(r) {
  return r.position === "center";
}
function _K(r) {
  var t = r.getData(), e = [], n, i, a = !1, o = (r.get("minShowLabelAngle") || 0) * gK, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, c = s.x, f = s.y, h = s.height;
  function d(S) {
    S.ignore = !0;
  }
  function p(S) {
    if (!S.ignore)
      return !0;
    for (var w in S.states)
      if (S.states[w].ignore === !1)
        return !0;
    return !1;
  }
  t.each(function(S) {
    var w = t.getItemGraphicEl(S), A = w.shape, T = w.getTextContent(), M = w.getTextGuideLine(), C = t.getItemModel(S), R = C.getModel("label"), E = R.get("position") || C.get(["emphasis", "label", "position"]), D = R.get("distanceToLabelLine"), I = R.get("alignTo"), P = dt(R.get("edgeDistance"), u), O = R.get("bleedMargin");
    O == null && (O = Math.min(u, h) > 200 ? 10 : 2);
    var N = C.getModel("labelLine"), B = N.get("length");
    B = dt(B, u);
    var F = N.get("length2");
    if (F = dt(F, u), Math.abs(A.endAngle - A.startAngle) < o) {
      L(T.states, d), T.ignore = !0, M && (L(M.states, d), M.ignore = !0);
      return;
    }
    if (p(T)) {
      var G = (A.startAngle + A.endAngle) / 2, W = Math.cos(G), J = Math.sin(G), U, Y, at, st;
      n = A.cx, i = A.cy;
      var ut = E === "inside" || E === "inner";
      if (E === "center")
        U = A.cx, Y = A.cy, st = "center";
      else {
        var lt = (ut ? (A.r + A.r0) / 2 * W : A.r * W) + n, H = (ut ? (A.r + A.r0) / 2 * J : A.r * J) + i;
        if (U = lt + W * 3, Y = H + J * 3, !ut) {
          var ct = lt + W * (B + l - A.r), ot = H + J * (B + l - A.r), Gt = ct + (W < 0 ? -1 : 1) * F, yt = ot;
          I === "edge" ? U = W < 0 ? c + P : c + u - P : U = Gt + (W < 0 ? -D : D), Y = yt, at = [[lt, H], [ct, ot], [Gt, yt]];
        }
        st = ut ? "center" : I === "edge" ? W > 0 ? "right" : "left" : W > 0 ? "left" : "right";
      }
      var Mt = Math.PI, Rt = 0, Kt = R.get("rotate");
      if (fe(Kt))
        Rt = Kt * (Mt / 180);
      else if (E === "center")
        Rt = 0;
      else if (Kt === "radial" || Kt === !0) {
        var Ae = W < 0 ? -G + Mt : -G;
        Rt = Ae;
      } else if (Kt === "tangential" && E !== "outside" && E !== "outer") {
        var z = Math.atan2(W, J);
        z < 0 && (z = Mt * 2 + z);
        var k = J > 0;
        k && (z = Mt + z), Rt = z - Mt;
      }
      if (a = !!Rt, T.x = U, T.y = Y, T.rotation = Rt, T.setStyle({
        verticalAlign: "middle"
      }), ut) {
        T.setStyle({
          align: st
        });
        var ht = T.states.select;
        ht && (ht.x += T.x, ht.y += T.y);
      } else {
        var nt = new Vt(0, 0, 0, 0);
        g3(nt, T), e.push({
          label: T,
          labelLine: M,
          position: E,
          len: B,
          len2: F,
          minTurnAngle: N.get("minTurnAngle"),
          maxSurfaceAngle: N.get("maxSurfaceAngle"),
          surfaceNormal: new Ot(W, J),
          linePoints: at,
          textAlign: st,
          labelDistance: D,
          labelAlignTo: I,
          edgeDistance: P,
          bleedMargin: O,
          rect: nt,
          unconstrainedWidth: nt.width,
          labelStyleWidth: T.style.width
        });
      }
      w.setTextConfig({
        inside: ut
      });
    }
  }), !a && r.get("avoidLabelOverlap") && mK(e, n, i, l, u, h, c, f);
  for (var g = 0; g < e.length; g++) {
    var v = e[g], m = v.label, y = v.labelLine, _ = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: v.textAlign
      }), _ && (L(m.states, d), m.ignore = !0);
      var x = m.states.select;
      x && (x.x += m.x, x.y += m.y);
    }
    if (y) {
      var b = v.linePoints;
      _ || !b ? (L(y.states, d), y.ignore = !0) : (Bk(b, v.minTurnAngle), FZ(b, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
        points: b
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new Ot(b[0][0], b[0][1])
      });
    }
  }
}
var xK = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new pe();
      return a.setTextContent(o), a.updateData(e, n, i, !0), a;
    }
    return t.prototype.updateData = function(e, n, i, a) {
      var o = this, s = e.hostModel, l = e.getItemModel(n), u = l.getModel("emphasis"), c = e.getItemLayout(n), f = j(ji(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(f.startAngle)) {
        o.setShape(f);
        return;
      }
      if (a) {
        o.setShape(f);
        var h = s.getShallow("animationType");
        s.ecModel.ssr ? (ze(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: !0
        }), o.originX = f.cx, o.originY = f.cy) : h === "scale" ? (o.shape.r = c.r0, ze(o, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), ze(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (o.shape.endAngle = c.startAngle, ve(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else
        oi(o), ve(o, {
          shape: f
        }, s, n);
      o.useStyle(e.getItemVisual(n, "style")), _r(o, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, m = l.getShallow("cursor");
      m && o.attr("cursor", m), this._updateLabel(s, e, n), o.ensureState("emphasis").shape = j({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, ji(u.getModel("itemStyle"), c)), j(o.ensureState("select"), {
        x: g,
        y: v,
        shape: ji(l.getModel(["select", "itemStyle"]), c)
      }), j(o.ensureState("blur"), {
        shape: ji(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = o.getTextGuideLine(), _ = o.getTextContent();
      y && j(y.ensureState("select"), {
        x: g,
        y: v
      }), j(_.ensureState("select"), {
        x: g,
        y: v
      }), He(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, n, i) {
      var a = this, o = n.getItemModel(i), s = o.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      Cr(a, xr(o), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: e.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var f = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), f.attr({
        z2: 10
      });
      var h = o.get(["label", "position"]);
      if (h !== "outside" && h !== "outer")
        a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new Gr(), this.setTextGuideLine(d)), Mb(this, Tb(o), {
          stroke: u,
          opacity: un(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, t;
  }(jr)
), SK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.ignoreLabelLineUpdate = !0, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = e.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), f = 1; isNaN(c && c.startAngle) && f < o.count(); ++f)
          c = o.getItemLayout(f);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && e.get("showEmptyCircle")) {
        var h = p3(e), d = new jr({
          shape: Dt(h)
        });
        d.useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = d, l.add(d);
      }
      o.diff(s).add(function(p) {
        var g = new xK(o, p, u);
        o.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        v.updateData(o, p, u), v.off("click"), l.add(v), o.setItemGraphicEl(p, v);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        Na(g, e, p);
      }).execute(), _K(e), e.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, t.prototype.dispose = function() {
    }, t.prototype.containPoint = function(e, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "pie", t;
  }(Re)
);
function Nc(r, t, e) {
  t = et(t) && {
    coordDimensions: t
  } || j({
    encodeDefine: r.getEncode()
  }, t);
  var n = r.getSource(), i = Hh(n, t).dimensions, a = new cn(i, r);
  return a.initData(n, e), a;
}
var Oc = (
  /** @class */
  function() {
    function r(t, e) {
      this._getDataWithEncodedVisual = t, this._getRawData = e;
    }
    return r.prototype.getAllNames = function() {
      var t = this._getRawData();
      return t.mapArray(t.getName);
    }, r.prototype.containName = function(t) {
      var e = this._getRawData();
      return e.indexOfName(t) >= 0;
    }, r.prototype.indexOfName = function(t) {
      var e = this._getDataWithEncodedVisual();
      return e.indexOfName(t);
    }, r.prototype.getItemVisual = function(t, e) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(t, e);
    }, r;
  }()
), bK = ee(), m3 = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Oc(gt(this.getData, this), gt(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.getInitialData = function() {
      return Nc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(ib, this)
      });
    }, t.prototype.getDataParams = function(e) {
      var n = this.getData(), i = bK(n), a = i.seats;
      if (!a) {
        var o = [];
        n.each(n.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = U8(o, n.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, e);
      return s.percent = a[e] || 0, s.$vars.push("percent"), s;
    }, t.prototype._defaultLabelLine = function(e) {
      dl(e, "labelLine", ["show"]);
      var n = e.labelLine, i = e.emphasis.labelLine;
      n.show = n.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.type = "series.pie", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      radius: [0, "50%"],
      // 
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 
      selectedOffset: 10,
      // singlemultiple
      // selectedMode: false,
      // 'radius' | 'area'
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      coordinateSystemUsage: "box",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        // The default `bleedMargin` is auto determined according to view rect size.
        // bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter:  tooltip.formatter
        //  textStyle
        // distance: positioninnerlabel()
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 
        length: 15,
        // 
        length2: 30,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: ,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, t;
  }(ke)
);
E9({
  fullType: m3.type,
  getCoord2: function(r) {
    return r.getShallow("center");
  }
});
function wK(r) {
  return {
    seriesType: r,
    reset: function(t, e) {
      var n = t.getData();
      n.filterSelf(function(i) {
        var a = n.mapDimension("value"), o = n.get(a, i);
        return !(fe(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function MK(r) {
  r.registerChartView(SK), r.registerSeriesModel(m3), kO("pie", r.registerAction), r.registerLayout(Yt(vK, "pie")), r.registerProcessor(Pc("pie")), r.registerProcessor(wK("pie"));
}
var TK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.point(n.getItemLayout(e));
    }, t.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, t;
  }(ke)
), y3 = 4, AK = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), EK = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.getDefaultShape = function() {
      return new AK();
    }, t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = n.size, o = this.symbolProxy, s = o.shape, l = e.getContext ? e.getContext() : e, u = l && a[0] < y3, c = this.softClipShape, f;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, f = this._off; f < i.length; ) {
        var h = i[f++], d = i[f++];
        isNaN(h) || isNaN(d) || c && !c.contain(h, d) || (s.x = h - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(e, s, !0));
      }
      this.incremental && (this._off = f, this.notClear = !0);
    }, t.prototype.afterBrush = function() {
      var e = this.shape, n = e.points, i = e.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, t.prototype.findDataIndex = function(e, n) {
      for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, f = a[c] - s / 2, h = a[c + 1] - l / 2;
        if (e >= f && n >= h && e <= f + s && n <= h + l)
          return u;
      }
      return -1;
    }, t.prototype.contain = function(e, n) {
      var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
      if (e = i[0], n = i[1], a.contain(e, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(e, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var n = this.shape, i = n.points, a = n.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, f = -1 / 0, h = 0; h < i.length; ) {
          var d = i[h++], p = i[h++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), f = Math.max(p, f);
        }
        e = this._rect = new Vt(l - o / 2, u - s / 2, c - l + o, f - u + s);
      }
      return e;
    }, t;
  }(ne)
), CK = (
  /** @class */
  function() {
    function r() {
      this.group = new Ct();
    }
    return r.prototype.updateData = function(t, e) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: t.getLayout("points")
      }), this._setCommon(n, t, e);
    }, r.prototype.updateLayout = function(t) {
      var e = t.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, a = n.startIndex * 4 * 2;
          e = new Float32Array(e.buffer, a, i);
        }
        n.setShape("points", e), n.reset();
      });
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._clear();
    }, r.prototype.incrementalUpdate = function(t, e, n) {
      var i = this._newAdded[0], a = e.getLayout("points"), o = i && i.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), i.endIndex = t.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = t.start, u.endIndex = t.end, u.incremental = !0, u.setShape({
          points: a
        }), this._setCommon(u, e, n);
      }
    }, r.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, r.prototype._create = function() {
      var t = new EK({
        cursor: "default"
      });
      return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t;
    }, r.prototype._setCommon = function(t, e, n) {
      var i = e.hostModel;
      n = n || {};
      var a = e.getVisual("symbolSize");
      t.setShape("size", a instanceof Array ? a : [a, a]), t.softClipShape = n.clipShape || null, t.symbolProxy = hr(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
      var o = t.shape.size[0] < y3;
      t.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = e.getVisual("style"), l = s && s.fill;
      l && t.setColor(l);
      var u = zt(t);
      u.seriesIndex = i.seriesIndex, t.on("mousemove", function(c) {
        u.dataIndex = null;
        var f = t.hoverDataIdx;
        f >= 0 && (u.dataIndex = f + (t.startIndex || 0));
      });
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
), DK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._updateSymbolDraw(a, e);
      o.updateData(a, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(e)
      }), this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      var a = e.getData(), o = this._updateSymbolDraw(a, e);
      o.incrementalPrepareUpdate(a), this._finished = !1;
    }, t.prototype.incrementalRender = function(e, n, i) {
      this._symbolDraw.incrementalUpdate(e, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = e.end === n.getData().count();
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4)
        return {
          update: !0
        };
      var o = Zh("").reset(e, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, t.prototype.eachRendered = function(e) {
      this._symbolDraw && this._symbolDraw.eachRendered(e);
    }, t.prototype._getClipShape = function(e) {
      if (e.get("clip", !0)) {
        var n = e.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, t.prototype._updateSymbolDraw = function(e, n) {
      var i = this._symbolDraw, a = n.pipelineContext, o = a.large;
      return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new CK() : new Yh(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i;
    }, t.prototype.remove = function(e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, t.prototype.dispose = function() {
    }, t.type = "scatter", t;
  }(Re)
), _3 = {
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
}, og = ["25%", "25%"], LK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = Cl(e.outerBounds);
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), i && e.outerBounds && sa(e.outerBounds, i);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.apply(this, arguments), this.option.outerBounds && e.outerBounds && sa(this.option.outerBounds, e.outerBounds);
    }, t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "15%",
      top: 65,
      right: "10%",
      bottom: 80,
      // If grid size contain label
      containLabel: !1,
      outerBoundsMode: "auto",
      outerBounds: _3,
      outerBoundsContain: "all",
      outerBoundsClampWidth: og[0],
      outerBoundsClampHeight: og[1],
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: X.color.transparent,
      borderWidth: 1,
      borderColor: X.color.neutral30
    }, t;
  }(re)
), mS = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", je).models[0];
    }, t.type = "cartesian2dAxis", t;
  }(re)
);
dr(mS, Wh);
var x3 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {
    // textMargin: never, // The default value will be specified based on `nameLocation`.
  },
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: X.color.axisLine,
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15],
    breakLine: !0
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12,
    color: X.color.axisLabel,
    // In scenarios like axis labels, when labels text's progression direction matches the label
    // layout direction (e.g., when all letters are in a single line), extra start/end margin is
    // needed to prevent the text from appearing visually joined. In the other case, when lables
    // are stacked (e.g., having rotation or horizontal labels on yAxis), the layout needs to be
    // compact, so NO extra top/bottom margin should be applied.
    textMargin: [0, 3]
  },
  splitLine: {
    show: !0,
    showMinLine: !0,
    showMaxLine: !0,
    lineStyle: {
      color: X.color.axisSplitLine,
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: [X.color.backgroundTint, X.color.backgroundTransparent]
    }
  },
  breakArea: {
    show: !0,
    itemStyle: {
      color: X.color.neutral00,
      // Break border color should be darker than the splitLine
      // because it has opacity and should be more prominent
      borderColor: X.color.border,
      borderWidth: 1,
      borderType: [3, 3],
      opacity: 0.6
    },
    zigzagAmplitude: 4,
    zigzagMinSpan: 4,
    zigzagMaxSpan: 20,
    zigzagZ: 100,
    expandOnClick: !0
  },
  breakLabelLayout: {
    moveOverlap: "auto"
  }
}, RK = qt({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  jitter: 0,
  jitterOverlap: !0,
  jitterMargin: 2,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto",
    show: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, x3), Ib = qt({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: X.color.axisMinorSplitLine,
      width: 1
    }
  }
}, x3), IK = qt({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, Ib), PK = Bt({
  logBase: 10
}, Ib);
const S3 = {
  category: RK,
  value: Ib,
  time: IK,
  log: PK
};
var NK = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
}, yS = null;
function OK(r) {
  yS || (yS = r);
}
function qh() {
  return yS;
}
function fc(r, t, e, n) {
  L(NK, function(i, a) {
    var o = qt(qt({}, S3[a], !0), n, !0), s = (
      /** @class */
      function(l) {
        $(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = t + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, f) {
          var h = uh(this), d = h ? Cl(c) : {}, p = f.getTheme();
          qt(c, p.get(a + "Axis")), qt(c, this.getDefaultOption()), c.type = KC(c), h && sa(c, d, h);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = vh.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var f = this.option;
          if (f.type === "category")
            return c ? f.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.prototype.updateAxisBreaks = function(c) {
          var f = qh();
          return f ? f.updateModelAxisBreak(this, c) : {
            breaks: []
          };
        }, u.type = t + "Axis." + a, u.defaultOption = o, u;
      }(e)
    );
    r.registerComponentModel(s);
  }), r.registerSubTypeDefaulter(t + "Axis", KC);
}
function KC(r) {
  return r.type || (r.data ? "category" : "value");
}
var kK = (
  /** @class */
  function() {
    function r(t) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
    }
    return r.prototype.getAxis = function(t) {
      return this._axes[t];
    }, r.prototype.getAxes = function() {
      return rt(this._dimList, function(t) {
        return this._axes[t];
      }, this);
    }, r.prototype.getAxesByScale = function(t) {
      return t = t.toLowerCase(), Te(this.getAxes(), function(e) {
        return e.scale.type === t;
      });
    }, r.prototype.addAxis = function(t) {
      var e = t.dim;
      this._axes[e] = t, this._dimList.push(e);
    }, r;
  }()
), _S = ["x", "y"];
function jC(r) {
  return (r.type === "interval" || r.type === "time") && !r.hasBreaks();
}
var BK = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "cartesian2d", e.dimensions = _S, e;
    }
    return t.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var e = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!jC(e) || !jC(n))) {
        var i = e.getExtent(), a = n.getExtent(), o = this.dataToPoint([i[0], a[0]]), s = this.dataToPoint([i[1], a[1]]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, f = (s[1] - o[1]) / u, h = o[0] - i[0] * c, d = o[1] - a[0] * f, p = this._transform = [c, 0, 0, f, h, d];
          this._invTransform = bi([], p);
        }
      }
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, t.prototype.containPoint = function(e) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]));
    }, t.prototype.containData = function(e) {
      return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]);
    }, t.prototype.containZone = function(e, n) {
      var i = this.dataToPoint(e), a = this.dataToPoint(n), o = this.getArea(), s = new Vt(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, t.prototype.dataToPoint = function(e, n, i) {
      i = i || [];
      var a = e[0], o = e[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return nr(i, e, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, n)), i[1] = l.toGlobalCoord(l.dataToCoord(o, n)), i;
    }, t.prototype.clampData = function(e, n) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(e[0]), u = a.parse(e[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, t.prototype.pointToData = function(e, n, i) {
      if (i = i || [], this._invTransform)
        return nr(i, e, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(e[0]), n), i[1] = o.coordToData(o.toLocalCoord(e[1]), n), i;
    }, t.prototype.getOtherAxis = function(e) {
      return this.getAxis(e.dim === "x" ? "y" : "x");
    }, t.prototype.getArea = function(e) {
      e = e || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - e, o = Math.min(i[0], i[1]) - e, s = Math.max(n[0], n[1]) - a + e, l = Math.max(i[0], i[1]) - o + e;
      return new Vt(a, o, s, l);
    }, t;
  }(kK)
), b3 = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.getGlobalExtent = function(e) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), e && n[0] > n[1] && n.reverse(), n;
    }, t.prototype.pointToData = function(e, n) {
      return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), n);
    }, t.prototype.setCategorySortInfo = function(e) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = e, this.scale.setSortInfo(e);
    }, t;
  }(Ei)
), ym = "expandAxisBreak", w3 = "collapseAxisBreak", M3 = "toggleAxisBreak", Pb = "axisbreakchanged", VK = {
  type: ym,
  event: Pb,
  update: "update",
  refineEvent: Nb
}, FK = {
  type: w3,
  event: Pb,
  update: "update",
  refineEvent: Nb
}, zK = {
  type: M3,
  event: Pb,
  update: "update",
  refineEvent: Nb
};
function Nb(r, t, e, n) {
  var i = [];
  return L(r, function(a) {
    i = i.concat(a.eventBreaks);
  }), {
    eventContent: {
      breaks: i
    }
  };
}
function UK(r) {
  r.registerAction(VK, t), r.registerAction(FK, t), r.registerAction(zK, t);
  function t(e, n) {
    var i = [], a = Xu(n, e);
    function o(s, l) {
      L(a[s], function(u) {
        var c = u.updateAxisBreaks(e);
        L(c.breaks, function(f) {
          var h;
          i.push(Bt((h = {}, h[l] = u.componentIndex, h), f));
        });
      });
    }
    return o("xAxisModels", "xAxisIndex"), o("yAxisModels", "yAxisIndex"), o("singleAxisModels", "singleAxisIndex"), {
      eventBreaks: i
    };
  }
}
var Eo = Math.PI, GK = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], HK = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], hc = ee(), T3 = ee(), A3 = (
  /** @class */
  function() {
    function r(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return r.prototype.ensureRecord = function(t) {
      var e = t.axis.dim, n = t.componentIndex, i = this.recordMap, a = i[e] || (i[e] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, r;
  }()
);
function WK(r, t, e, n) {
  var i = e.axis, a = t.ensureRecord(e), o = [], s, l = Ob(r.axisName) && uc(r.nameLocation);
  L(n, function(p) {
    var g = la(p);
    if (!(!g || g.label.ignore)) {
      o.push(g);
      var v = a.transGroup;
      l && (v.transform ? bi(uf, v.transform) : Gg(uf), g.transform && Ji(uf, uf, g.transform), Vt.copy(pp, g.localRect), pp.applyTransform(uf), s ? s.union(pp) : Vt.copy(s = new Vt(0, 0, 0, 0), pp));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (o.sort(function(p, g) {
    return Math.abs(p.label[u] - c) - Math.abs(g.label[u] - c);
  }), l && s) {
    var f = i.getExtent(), h = Math.min(f[0], f[1]), d = Math.max(f[0], f[1]) - h;
    s.union(new Vt(h, 0, d, 1));
  }
  a.stOccupiedRect = s, a.labelInfoList = o;
}
var uf = Br(), pp = new Vt(0, 0, 0, 0), E3 = function(r, t, e, n, i, a) {
  if (uc(r.nameLocation)) {
    var o = a.stOccupiedRect;
    o && C3(GZ({}, o, a.transGroup.transform), n, i);
  } else
    D3(a.labelInfoList, a.dirVec, n, i);
};
function C3(r, t, e) {
  var n = new Ot();
  gm(r, t, n, {
    direction: Math.atan2(e.y, e.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && cS(t, n);
}
function D3(r, t, e, n) {
  for (var i = Ot.dot(n, t) >= 0, a = 0, o = r.length; a < o; a++) {
    var s = r[i ? a : o - 1 - a];
    s.label.ignore || C3(s, e, n);
  }
}
var fn = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this.group = new Ct(), this._axisModel = t, this._api = e, this._local = {}, this._shared = i || new A3(E3), this._resetCfgDetermined(n);
    }
    return r.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var e = this._shared.ensureRecord(this._axisModel).ready;
        St(!e.axisLine && !e.axisTickLabelDetermine), e.axisName = e.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, r.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, r.prototype._resetCfgDetermined = function(t) {
      var e = this._axisModel, n = e.getDefaultOption ? e.getDefaultOption() : {}, i = bt(t.axisName, e.get("name")), a = e.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = bt(t.defaultNameMoveOverlap, !0));
      var o = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: bt(t.nameDirection, 1),
        tickDirection: bt(t.tickDirection, 1),
        labelDirection: bt(t.labelDirection, 1),
        labelOffset: bt(t.labelOffset, 0),
        silent: bt(t.silent, !0),
        axisName: i,
        nameLocation: un(e.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: Ob(i) && a,
        optionHideOverlap: e.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: e.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (St(o.position != null), St(o.rotation != null)), this._cfg = o;
      var s = new Ct({
        x: o.position[0],
        y: o.position[1],
        rotation: o.rotation
      });
      s.updateTransform(), this._transformGroup = s;
      var l = this._shared.ensureRecord(e);
      l.transGroup = this._transformGroup, l.dirVec = new Ot(Math.cos(-o.rotation), Math.sin(-o.rotation));
    }, r.prototype.build = function(t, e) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), L(XK, function(i) {
        t[i] && YK[i](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, e || {});
      }), this;
    }, r.innerTextLayout = function(t, e, n) {
      var i = LP(e - t), a, o;
      return ah(i) ? (o = n > 0 ? "top" : "bottom", a = "center") : ah(i - Eo) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < Eo ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(t) {
      var e = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return e[t.mainType + "Index"] = t.componentIndex, e;
    }, r.isLabelSilent = function(t) {
      var e = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
    }, r;
  }()
), XK = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], YK = {
  axisLine: function(r, t, e, n, i, a, o) {
    if (process.env.NODE_ENV !== "production") {
      var s = e.ensureRecord(n).ready;
      St(!s.axisLine), s.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, r.raw.axisLineAutoShow != null && (l = !!r.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, f = [u[0], 0], h = [u[1], 0], d = f[0] > h[0];
      c && (nr(f, f, c), nr(h, h, c));
      var p = j({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), g = {
        strokeContainThreshold: r.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: p
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        qh().buildAxisBreakLine(n, i, a, g);
      else {
        var v = new lr(j({
          shape: {
            x1: f[0],
            y1: f[1],
            x2: h[0],
            y2: h[1]
          }
        }, g));
        ic(v.shape, v.style.lineWidth), v.anid = "line", i.add(v);
      }
      var m = n.get(["axisLine", "symbol"]);
      if (m != null) {
        var y = n.get(["axisLine", "symbolSize"]);
        pt(m) && (m = [m, m]), (pt(y) || fe(y)) && (y = [y, y]);
        var _ = Ll(n.get(["axisLine", "symbolOffset"]) || 0, y), x = y[0], b = y[1];
        L([{
          rotate: r.rotation + Math.PI / 2,
          offset: _[0],
          r: 0
        }, {
          rotate: r.rotation - Math.PI / 2,
          offset: _[1],
          r: Math.sqrt((f[0] - h[0]) * (f[0] - h[0]) + (f[1] - h[1]) * (f[1] - h[1]))
        }], function(S, w) {
          if (m[w] !== "none" && m[w] != null) {
            var A = hr(m[w], -x / 2, -b / 2, x, b, p.stroke, !0), T = S.r + S.offset, M = d ? h : f;
            A.attr({
              rotation: S.rotate,
              x: M[0] + T * Math.cos(r.rotation),
              y: M[1] - T * Math.sin(r.rotation),
              silent: !0,
              z2: 11
            }), i.add(A);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(r, t, e, n, i, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = e.ensureRecord(n).ready;
      St(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = QC(t, i, s);
    u && JC(r, t, e, n, i, a, o, Mi.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(r, t, e, n, i, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = e.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = QC(t, i, s);
    u && JC(r, t, e, n, i, a, o, Mi.determine);
    var c = KK(r, i, a, n);
    qK(r, t.labelLayoutList, c), jK(r, i, a, n, r.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(r, t, e, n, i, a, o, s) {
    var l = e.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      St(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (i.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = r.axisName;
    if (Ob(c)) {
      var f = r.nameLocation, h = r.nameDirection, d = n.getModel("nameTextStyle"), p = n.get("nameGap") || 0, g = n.axis.getExtent(), v = n.axis.inverse ? -1 : 1, m = new Ot(0, 0), y = new Ot(0, 0);
      f === "start" ? (m.x = g[0] - v * p, y.x = -v) : f === "end" ? (m.x = g[1] + v * p, y.x = v) : (m.x = (g[0] + g[1]) / 2, m.y = r.labelOffset + h * p, y.y = h);
      var _ = Br();
      y.transform(Ko(_, _, r.rotation));
      var x = n.get("nameRotate");
      x != null && (x = x * Eo / 180);
      var b, S;
      uc(f) ? b = fn.innerTextLayout(
        r.rotation,
        x ?? r.rotation,
        // Adapt to axis.
        h
      ) : (b = $K(r.rotation, f, x || 0, g), S = r.raw.axisNameAvailableWidth, S != null && (S = Math.abs(S / Math.sin(b.rotation)), !isFinite(S) && (S = null)));
      var w = d.getFont(), A = n.get("nameTruncate", !0) || {}, T = A.ellipsis, M = mr(r.raw.nameTruncateMaxWidth, A.maxWidth, S), C = s.nameMarginLevel || 0, R = new pe({
        x: m.x,
        y: m.y,
        rotation: b.rotation,
        silent: fn.isLabelSilent(n),
        style: Oe(d, {
          text: c,
          font: w,
          overflow: "truncate",
          width: M,
          ellipsis: T,
          fill: d.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: d.get("align") || b.textAlign,
          verticalAlign: d.get("verticalAlign") || b.textVerticalAlign
        }),
        z2: 1
      });
      if (ja({
        el: R,
        componentModel: n,
        itemName: c
      }), R.__fullText = c, R.anid = "name", n.get("triggerEvent")) {
        var E = fn.makeAxisEventDataBase(n);
        E.targetType = "axisName", E.name = c, zt(R).eventData = E;
      }
      a.add(R), R.updateTransform(), t.nameEl = R;
      var D = l.nameLayout = la({
        label: R,
        priority: R.z2,
        defaultAttr: {
          ignore: R.ignore
        },
        marginDefault: uc(f) ? GK[C] : HK[C]
      });
      if (l.nameLocation = f, i.add(R), R.decomposeTransform(), r.shouldNameMoveOverlap && D) {
        var I = e.ensureRecord(n);
        process.env.NODE_ENV !== "production" && St(I.labelInfoList), e.resolveAxisNameOverlap(r, e, n, D, y, I);
      }
    }
  }
};
function JC(r, t, e, n, i, a, o, s) {
  R3(t) || JK(r, t, i, s, n, o);
  var l = t.labelLayoutList;
  QK(r, n, l, a), rj(n, r.rotation, l);
  var u = r.optionHideOverlap;
  ZK(n, l, u), u && Uk(
    // Filter the already ignored labels by the previous overlap resolving methods.
    Te(l, function(c) {
      return c && !c.label.ignore;
    })
  ), WK(r, e, n, l);
}
function $K(r, t, e, n) {
  var i = LP(e - r), a, o, s = n[0] > n[1], l = t === "start" && !s || t !== "start" && s;
  return ah(i - Eo / 2) ? (o = l ? "bottom" : "top", a = "center") : ah(i - Eo * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < Eo * 1.5 && i > Eo / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: i,
    textAlign: a,
    textVerticalAlign: o
  };
}
function ZK(r, t, e) {
  if (Mk(r.axis))
    return;
  function n(s, l, u) {
    var c = la(t[l]), f = la(t[u]);
    if (!(!c || !f)) {
      if (s === !1 || c.suggestIgnore) {
        Of(c.label);
        return;
      }
      if (f.suggestIgnore) {
        Of(f.label);
        return;
      }
      var h = 0.1;
      if (!e) {
        var d = [0, 0, 0, 0];
        c = fS({
          marginForce: d
        }, c), f = fS({
          marginForce: d
        }, f);
      }
      gm(c, f, null, {
        touchThreshold: h
      }) && Of(s ? f.label : c.label);
    }
  }
  var i = r.get(["axisLabel", "showMinLabel"]), a = r.get(["axisLabel", "showMaxLabel"]), o = t.length;
  n(i, 0, 1), n(a, o - 1, o - 2);
}
function qK(r, t, e) {
  r.showMinorTicks || L(t, function(n) {
    if (n && n.label.ignore)
      for (var i = 0; i < e.length; i++) {
        var a = e[i], o = T3(a), s = hc(n.label);
        if (o.tickValue != null && !o.onBand && o.tickValue === s.tickValue) {
          Of(a);
          return;
        }
      }
  });
}
function Of(r) {
  r && (r.ignore = !0);
}
function L3(r, t, e, n, i) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = e, t && (nr(o, o, t), nr(s, s, t));
    var c = new lr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    ic(c.shape, c.style.lineWidth), c.anid = i + "_" + r[l].tickValue, a.push(c);
    var f = T3(c);
    f.onBand = !!r[l].onBand, f.tickValue = r[l].tickValue;
  }
  return a;
}
function KK(r, t, e, n) {
  var i = n.axis, a = n.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && (o = !0, r.raw.axisTickAutoShow != null && (o = !!r.raw.axisTickAutoShow)), !o || i.scale.isBlank())
    return [];
  for (var s = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), u = i.getTicksCoords(), c = L3(u, e.transform, l, Bt(s.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), f = 0; f < c.length; f++)
    t.add(c[f]);
  return c;
}
function jK(r, t, e, n, i) {
  var a = n.axis, o = n.getModel("minorTick");
  if (!(!r.showMinorTicks || a.scale.isBlank())) {
    var s = a.getMinorTicksCoords();
    if (s.length)
      for (var l = o.getModel("lineStyle"), u = i * o.get("length"), c = Bt(l.getLineStyle(), Bt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), f = 0; f < s.length; f++)
        for (var h = L3(s[f], e.transform, u, c, "minorticks_" + f), d = 0; d < h.length; d++)
          t.add(h[d]);
  }
}
function QC(r, t, e) {
  if (R3(r)) {
    var n = r.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && St(r.labelGroup && n);
    var i = n.out.noPxChangeTryDetermine;
    if (e.noPxChange) {
      for (var a = !0, o = 0; o < i.length; o++)
        a = a && i[o]();
      if (a)
        return !1;
    }
    i.length && (t.remove(r.labelGroup), xS(r, null, null, null));
  }
  return !0;
}
function JK(r, t, e, n, i, a) {
  var o = i.axis, s = mr(r.raw.axisLabelShow, i.get(["axisLabel", "show"])), l = new Ct();
  e.add(l);
  var u = Qv(n);
  if (!s || o.scale.isBlank()) {
    xS(t, [], l, u);
    return;
  }
  var c = i.getModel("axisLabel"), f = o.getViewLabels(u), h = (mr(r.raw.labelRotate, c.get("rotate")) || 0) * Eo / 180, d = fn.innerTextLayout(r.rotation, h, r.labelDirection), p = i.getCategories && i.getCategories(!0), g = [], v = i.get("triggerEvent"), m = 1 / 0, y = -1 / 0;
  L(f, function(x, b) {
    var S, w = o.scale.type === "ordinal" ? o.scale.getRawOrdinalNumber(x.tickValue) : x.tickValue, A = x.formattedLabel, T = x.rawLabel, M = c;
    if (p && p[w]) {
      var C = p[w];
      Lt(C) && C.textStyle && (M = new ue(C.textStyle, c, i.ecModel));
    }
    var R = M.getTextColor() || i.get(["axisLine", "lineStyle", "color"]), E = M.getShallow("align", !0) || d.textAlign, D = bt(M.getShallow("alignMinLabel", !0), E), I = bt(M.getShallow("alignMaxLabel", !0), E), P = M.getShallow("verticalAlign", !0) || M.getShallow("baseline", !0) || d.textVerticalAlign, O = bt(M.getShallow("verticalAlignMinLabel", !0), P), N = bt(M.getShallow("verticalAlignMaxLabel", !0), P), B = 10 + (((S = x.time) === null || S === void 0 ? void 0 : S.level) || 0);
    m = Math.min(m, B), y = Math.max(y, B);
    var F = new pe({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: fn.isLabelSilent(i),
      z2: B,
      style: Oe(M, {
        text: A,
        align: b === 0 ? D : b === f.length - 1 ? I : E,
        verticalAlign: b === 0 ? O : b === f.length - 1 ? N : P,
        fill: At(R) ? R(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          o.type === "category" ? T : o.type === "value" ? w + "" : w,
          b
        ) : R
      })
    });
    F.anid = "label_" + w;
    var G = hc(F);
    if (G.break = x.break, G.tickValue = w, G.layoutRotation = d.rotation, ja({
      el: F,
      componentModel: i,
      itemName: A,
      formatterParamsExtra: {
        isTruncated: function() {
          return F.isTruncated;
        },
        value: T,
        tickIndex: b
      }
    }), v) {
      var W = fn.makeAxisEventDataBase(i);
      W.targetType = "axisLabel", W.value = T, W.tickIndex = b, x.break && (W.break = {
        // type: labelItem.break.type,
        start: x.break.parsedBreak.vmin,
        end: x.break.parsedBreak.vmax
      }), o.type === "category" && (W.dataIndex = w), zt(F).eventData = W, x.break && ej(i, a, F, x.break);
    }
    g.push(F), l.add(F);
  });
  var _ = rt(g, function(x) {
    return {
      label: x,
      priority: hc(x).break ? x.z2 + (y - m + 1) : x.z2,
      defaultAttr: {
        ignore: x.ignore
      }
    };
  });
  xS(t, _, l, u);
}
function R3(r) {
  return !!r.labelLayoutList;
}
function xS(r, t, e, n) {
  r.labelLayoutList = t, r.labelGroup = e, r.axisLabelsCreationContext = n;
}
function QK(r, t, e, n) {
  var i = t.get(["axisLabel", "margin"]);
  L(e, function(a, o) {
    var s = la(a);
    if (s) {
      var l = s.label, u = hc(l);
      s.suggestIgnore = l.ignore, l.ignore = !1, Cv(Sa, tj), Sa.x = t.axis.dataToCoord(u.tickValue), Sa.y = r.labelOffset + r.labelDirection * i, Sa.rotation = u.layoutRotation, n.add(Sa), Sa.updateTransform(), n.remove(Sa), Sa.decomposeTransform(), Cv(l, Sa), l.markRedraw(), ng(s, !0), la(s);
    }
  });
}
var Sa = new te(), tj = new te();
function Ob(r) {
  return !!r;
}
function ej(r, t, e, n) {
  e.on("click", function(i) {
    var a = {
      type: ym,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[r.axis.dim + "AxisIndex"] = r.componentIndex, t.dispatchAction(a);
  });
}
function rj(r, t, e) {
  var n = ur();
  if (n) {
    var i = n.retrieveAxisBreakPairs(e, function(o) {
      return o && hc(o.label).break;
    }, !0), a = r.get(["breakLabelLayout", "moveOverlap"], !0);
    (a === !0 || a === "auto") && L(i, function(o) {
      qh().adjustBreakLabelPair(r.axis.inverse, t, [la(e[o[0]]), la(e[o[1]])]);
    });
  }
}
function sg(r, t, e) {
  e = e || {};
  var n = t.axis, i = {}, a = n.getAxesOnZeroOf()[0], o = n.position, s = a ? "onZero" : o, l = n.dim, u = [r.x, r.x + r.width, r.y, r.y + r.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, f = t.get("offset") || 0, h = l === "x" ? [u[2] - f, u[3] + f] : [u[0] - f, u[1] + f];
  if (a) {
    var d = a.toGlobalCoord(a.dataToCoord(0));
    h[c.onZero] = Math.max(Math.min(d, h[1]), h[0]);
  }
  i.position = [l === "y" ? h[c[s]] : u[0], l === "x" ? h[c[s]] : u[3]], i.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var p = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = p[o], i.labelOffset = a ? h[c[o]] - h[c.onZero] : 0, t.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), mr(e.labelInside, t.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var g = t.get(["axisLabel", "rotate"]);
  return i.labelRotate = s === "top" ? -g : g, i.z2 = 1, i;
}
function nj(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function tD(r) {
  var t = {
    xAxisModel: null,
    yAxisModel: null
  };
  return L(t, function(e, n) {
    var i = n.replace(/Model$/, ""), a = r.getReferringComponents(i, je).models[0];
    if (process.env.NODE_ENV !== "production" && !a)
      throw new Error(i + ' "' + un(r.get(i + "Index"), r.get(i + "Id"), 0) + '" not found');
    t[n] = a;
  }), t;
}
function ij(r, t, e, n, i, a) {
  for (var o = sg(r, e), s = !1, l = !1, u = 0; u < t.length; u++)
    aS(t[u].getOtherAxis(e.axis).scale) && (s = l = !0, e.axis.type === "category" && e.axis.onBand && (l = !1));
  return o.axisLineAutoShow = s, o.axisTickAutoShow = l, o.defaultNameMoveOverlap = a, new fn(e, n, o, i);
}
function aj(r, t, e) {
  var n = sg(t, e);
  if (process.env.NODE_ENV !== "production") {
    var i = r.__getRawCfg();
    L(se(n), function(a) {
      a !== "position" && a !== "labelOffset" && St(n[a] === i[a]);
    });
  }
  r.updateCfg(n);
}
function I3(r, t, e) {
  var n, i = $a.prototype, a = i.getTicks.call(e), o = i.getTicks.call(e, {
    expandToNicedExtent: !0
  }), s = a.length - 1, l = i.getInterval.call(e), u = wk(r, t), c = u.extent, f = u.fixMin, h = u.fixMax;
  r.type === "log" && (c = oS(r.base, c, !0)), r.setBreaksFromOption(Tk(t)), r.setExtent(c[0], c[1]), r.calcNiceExtent({
    splitNumber: s,
    fixMin: f,
    fixMax: h
  });
  var d = i.getExtent.call(r);
  f && (c[0] = d[0]), h && (c[1] = d[1]);
  var p = i.getInterval.call(r), g = c[0], v = c[1];
  if (f && h)
    p = (v - g) / s;
  else if (f)
    for (v = c[0] + p * s; v < c[1] && isFinite(v) && isFinite(c[1]); )
      p = m0(p), v = c[0] + p * s;
  else if (h)
    for (g = c[1] - p * s; g > c[0] && isFinite(g) && isFinite(c[0]); )
      p = m0(p), g = c[1] - p * s;
  else {
    var m = r.getTicks().length - 1;
    m > s && (p = m0(p));
    var y = p * s;
    v = Math.ceil(c[1] / p) * p, g = sr(v - y), g < 0 && c[0] >= 0 ? (g = 0, v = sr(y)) : v > 0 && c[1] <= 0 && (v = 0, g = -sr(y));
  }
  var _ = (a[0].value - o[0].value) / l, x = (a[s].value - o[s].value) / l;
  if (i.setExtent.call(r, g + p * _, v + p * x), i.setInterval.call(r, p), (_ || x) && i.setNiceExtent.call(r, g + p, v - p), process.env.NODE_ENV !== "production") {
    var b = i.getTicks.call(r);
    b[1] && (!U$(p) || Sx(b[1].value) > Sx(p)) && Ye("The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + (" and alignTicks: true. (" + ((n = t.axis) === null || n === void 0 ? void 0 : n.dim) + "AxisIndex: " + t.componentIndex + ")"), !0);
  }
}
var eD = [
  [3, 1],
  [0, 2]
  // xyIdx 1 => 'y'
], oj = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = _S, this._initCartesian(t, e, n), this.model = t;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(t, e) {
      var n = this._axesMap;
      this._updateScale(t, this.model);
      function i(o) {
        var s, l = se(o), u = l.length;
        if (u) {
          for (var c = [], f = u - 1; f >= 0; f--) {
            var h = +l[f], d = o[h], p = d.model, g = d.scale;
            // Only value and log axis without interval support alignTicks.
            aS(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (lc(g, p), aS(g) && (s = d));
          }
          c.length && (s || (s = c.pop(), lc(s.scale, s.model)), L(c, function(v) {
            I3(v.scale, v.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var a = {};
      L(n.x, function(o) {
        rD(n, "y", o, a);
      }), L(n.y, function(o) {
        rD(n, "x", o, a);
      }), this.resize(this.model, e);
    }, r.prototype.resize = function(t, e, n) {
      var i = Sr(t, e), a = this._rect = We(t.getBoxLayoutParams(), i.refContainer), o = this._axesMap, s = this._coordsList, l = t.get("containLabel");
      if (SS(o, a), !n) {
        var u = uj(a, s, o, l, e), c = void 0;
        if (l)
          bS ? (bS(this._axesList, a), SS(o, a)) : (process.env.NODE_ENV !== "production" && NP("Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;use `grid.outerBounds` instead.", !0), c = aD(a.clone(), "axisLabel", null, a, o, u, i));
        else {
          var f = cj(t, a, i), h = f.outerBoundsRect, d = f.parsedOuterBoundsContain, p = f.outerBoundsClamp;
          h && (c = aD(h, d, p, a, o, u, i));
        }
        P3(a, o, Mi.determine, null, c, i);
      }
      L(this._coordsList, function(g) {
        g.calcAffineTransform();
      });
    }, r.prototype.getAxis = function(t, e) {
      var n = this._axesMap[t];
      if (n != null)
        return n[e || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(t, e) {
      if (t != null && e != null) {
        var n = "x" + t + "y" + e;
        return this._coordsMap[n];
      }
      Lt(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis("x").index === t || a[i].getAxis("y").index === e)
          return a[i];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, r.prototype._findConvertTarget = function(t) {
      var e = t.seriesModel, n = t.xAxisModel || e && e.getReferringComponents("xAxis", je).models[0], i = t.yAxisModel || e && e.getReferringComponents("yAxis", je).models[0], a = t.gridModel, o = this._coordsList, s, l;
      if (e)
        s = e.coordinateSystem, Zt(o, s) < 0 && (s = null);
      else if (n && i)
        s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n)
        l = this.getAxis("x", n.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(t) {
      var e = this._coordsList[0];
      if (e)
        return e.containPoint(t);
    }, r.prototype._initCartesian = function(t, e, n) {
      var i = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (e.eachComponent("xAxis", u("x"), this), e.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, L(s.x, function(c, f) {
        L(s.y, function(h, d) {
          var p = "x" + f + "y" + d, g = new BK(p);
          g.master = i, g.model = t, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(h);
        });
      });
      function u(c) {
        return function(f, h) {
          if (P0(f, t)) {
            var d = f.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = !0;
            var p = new b3(c, vm(f), [0, 0], f.get("type"), d), g = p.type === "category";
            p.onBand = g && f.get("boundaryGap"), p.inverse = f.get("inverse"), f.axis = p, p.model = f, p.grid = a, p.index = h, a._axesList.push(p), s[c][h] = p, l[c]++;
          }
        };
      }
    }, r.prototype._updateScale = function(t, e) {
      L(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), t.eachSeries(function(i) {
        if (nj(i)) {
          var a = tD(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!P0(o, e) || !P0(s, e))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), f = l.getAxis("y");
          n(u, c), n(u, f);
        }
      }, this);
      function n(i, a) {
        L(Jv(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(t) {
      var e = [], n = [];
      return L(this.getCartesians(), function(i) {
        var a = t != null && t !== "auto" ? i.getAxis(t) : i.getBaseAxis(), o = i.getOtherAxis(a);
        Zt(e, a) < 0 && e.push(a), Zt(n, o) < 0 && n.push(o);
      }), {
        baseAxes: e,
        otherAxes: n
      };
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("grid", function(i, a) {
        var o = new r(i, t, e);
        o.name = "grid_" + a, o.resize(i, e, !0), i.coordinateSystem = o, n.push(o);
      }), t.eachSeries(function(i) {
        Uh({
          targetModel: i,
          coordSysType: "cartesian2d",
          coordSysProvider: a
        });
        function a() {
          var o = tD(i), s = o.xAxisModel, l = o.yAxisModel, u = s.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!u)
              throw new Error('Grid "' + un(s.get("gridIndex"), s.get("gridId"), 0) + '" not found');
            if (s.getCoordSysModel() !== l.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var c = u.coordinateSystem;
          return c.getCartesian(s.componentIndex, l.componentIndex);
        }
      }), n;
    }, r.dimensions = _S, r;
  }()
);
function P0(r, t) {
  return r.getCoordSysModel() === t;
}
function rD(r, t, e, n) {
  e.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var i = r[t], a, o = e.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    nD(i[l]) && (a = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && nD(i[u]) && !n[c(i[u])]) {
        a = i[u];
        break;
      }
  a && (n[c(a)] = !0);
  function c(f) {
    return f.dim + "_" + f.index;
  }
}
function nD(r) {
  return r && r.type !== "category" && r.type !== "time" && hZ(r);
}
function sj(r, t) {
  var e = r.getExtent(), n = e[0] + e[1];
  r.toGlobalCoord = r.dim === "x" ? function(i) {
    return i + t;
  } : function(i) {
    return n - i + t;
  }, r.toLocalCoord = r.dim === "x" ? function(i) {
    return i - t;
  } : function(i) {
    return n - i + t;
  };
}
function SS(r, t) {
  L(r.x, function(e) {
    return iD(e, t.x, t.width);
  }), L(r.y, function(e) {
    return iD(e, t.y, t.height);
  });
}
function iD(r, t, e) {
  var n = [0, e], i = r.inverse ? 1 : 0;
  r.setExtent(n[i], n[1 - i]), sj(r, t);
}
var bS;
function lj(r) {
  bS = r;
}
function aD(r, t, e, n, i, a, o) {
  process.env.NODE_ENV !== "production" && St(t === "all" || t === "axisLabel"), P3(n, i, Mi.estimate, t, !1, o);
  var s = [0, 0, 0, 0];
  u(0), u(1), c(n, 0, NaN), c(n, 1, NaN);
  var l = Ml(s, function(h) {
    return h > 0;
  }) == null;
  return ml(n, s, !0, !0, e), SS(i, n), l;
  function u(h) {
    L(i[Wt[h]], function(d) {
      if (gh(d.model)) {
        var p = a.ensureRecord(d.model), g = p.labelInfoList;
        if (g)
          for (var v = 0; v < g.length; v++) {
            var m = g[v], y = d.scale.normalize(hc(m.label).tickValue);
            y = h === 1 ? 1 - y : y, c(m.rect, h, y), c(m.rect, 1 - h, NaN);
          }
        var _ = p.nameLayout;
        if (_) {
          var y = uc(p.nameLocation) ? 0.5 : NaN;
          c(_.rect, h, y), c(_.rect, 1 - h, NaN);
        }
      }
    });
  }
  function c(h, d, p) {
    var g = r[Wt[d]] - h[Wt[d]], v = h[cr[d]] + h[Wt[d]] - (r[cr[d]] + r[Wt[d]]);
    g = f(g, 1 - p), v = f(v, p);
    var m = eD[d][0], y = eD[d][1];
    s[m] = er(s[m], g), s[y] = er(s[y], v);
  }
  function f(h, d) {
    return h > 0 && !kr(d) && d > 1e-4 && (h /= d), h;
  }
}
function uj(r, t, e, n, i) {
  var a = new A3(fj);
  return L(e, function(o) {
    return L(o, function(s) {
      if (gh(s.model)) {
        var l = !n;
        s.axisBuilder = ij(r, t, s.model, i, a, l);
      }
    });
  }), a;
}
function P3(r, t, e, n, i, a) {
  var o = e === Mi.determine;
  L(t, function(u) {
    return L(u, function(c) {
      gh(c.model) && (aj(c.axisBuilder, r, c.model), c.axisBuilder.build(o ? {
        axisTickLabelDetermine: !0
      } : {
        axisTickLabelEstimate: !0
      }, {
        noPxChange: i
      }));
    });
  });
  var s = {
    x: 0,
    y: 0
  };
  l(0), l(1);
  function l(u) {
    s[Wt[1 - u]] = r[cr[u]] <= a.refContainer[cr[u]] * 0.5 ? 0 : 1 - u === 1 ? 2 : 1;
  }
  L(t, function(u, c) {
    return L(u, function(f) {
      gh(f.model) && ((n === "all" || o) && f.axisBuilder.build({
        axisName: !0
      }, {
        nameMarginLevel: s[c]
      }), o && f.axisBuilder.build({
        axisLine: !0
      }));
    });
  });
}
function cj(r, t, e) {
  var n, i = r.get("outerBoundsMode", !0);
  i === "same" ? n = t.clone() : i == null || i === "auto" ? n = We(r.get("outerBounds", !0) || _3, e.refContainer) : i !== "none" && process.env.NODE_ENV !== "production" && ce("Invalid grid[" + r.componentIndex + "].outerBoundsMode.");
  var a = r.get("outerBoundsContain", !0), o;
  a == null || a === "auto" ? o = "all" : Zt(["all", "axisLabel"], a) < 0 ? (process.env.NODE_ENV !== "production" && ce("Invalid grid[" + r.componentIndex + "].outerBoundsContain."), o = "all") : o = a;
  var s = [Lv(bt(r.get("outerBoundsClampWidth", !0), og[0]), t.width), Lv(bt(r.get("outerBoundsClampHeight", !0), og[1]), t.height)];
  return {
    outerBoundsRect: n,
    parsedOuterBoundsContain: o,
    outerBoundsClamp: s
  };
}
var fj = function(r, t, e, n, i, a) {
  var o = e.axis.dim === "x" ? "y" : "x";
  E3(r, t, e, n, i, a), uc(r.nameLocation) || L(t.recordMap[o], function(s) {
    s && s.labelInfoList && s.dirVec && D3(s.labelInfoList, s.dirVec, n, i);
  });
};
function hj(r, t) {
  var e = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return dj(e, r, t), e.seriesInvolved && vj(e, r), e;
}
function dj(r, t, e) {
  var n = t.getComponent("tooltip"), i = t.getComponent("axisPointer"), a = i.get("link", !0) || [], o = [];
  L(e.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = xh(s.model), u = r.coordSysAxesInfo[l] = {};
    r.coordSysMap[l] = s;
    var c = s.model, f = c.getModel("tooltip", n);
    if (L(s.getAxes(), Yt(g, !1, null)), s.getTooltipAxes && n && f.get("show")) {
      var h = f.get("trigger") === "axis", d = f.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(f.get(["axisPointer", "axis"]));
      (h || d) && L(p.baseAxes, Yt(g, d ? "cross" : !0, h)), d && L(p.otherAxes, Yt(g, "cross", !1));
    }
    function g(v, m, y) {
      var _ = y.model.getModel("axisPointer", i), x = _.get("show");
      if (!(!x || x === "auto" && !v && !wS(_))) {
        m == null && (m = _.get("triggerTooltip")), _ = v ? pj(y, f, i, t, v, m) : _;
        var b = _.get("snap"), S = _.get("triggerEmphasis"), w = xh(y.model), A = m || b || y.type === "category", T = r.axesInfo[w] = {
          key: w,
          axis: y,
          coordSys: s,
          axisPointerModel: _,
          triggerTooltip: m,
          triggerEmphasis: S,
          involveSeries: A,
          snap: b,
          useHandle: wS(_),
          seriesModels: [],
          linkGroup: null
        };
        u[w] = T, r.seriesInvolved = r.seriesInvolved || A;
        var M = gj(a, y);
        if (M != null) {
          var C = o[M] || (o[M] = {
            axesInfo: {}
          });
          C.axesInfo[w] = T, C.mapper = a[M].mapper, T.linkGroup = C;
        }
      }
    }
  });
}
function pj(r, t, e, n, i, a) {
  var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  L(s, function(h) {
    l[h] = Dt(o.get(h));
  }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var f = l.lineStyle = o.get("crossStyle");
      f && Bt(u, f.textStyle);
    }
  }
  return r.model.getModel("axisPointer", new ue(l, e, n));
}
function vj(r, t) {
  t.eachSeries(function(e) {
    var n = e.coordinateSystem, i = e.get(["tooltip", "trigger"], !0), a = e.get(["tooltip", "show"], !0);
    !n || !n.model || i === "none" || i === !1 || i === "item" || a === !1 || e.get(["axisPointer", "show"], !0) === !1 || L(r.coordSysAxesInfo[xh(n.model)], function(o) {
      var s = o.axis;
      n.getAxis(s.dim) === s && (o.seriesModels.push(e), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += e.getData().count());
    });
  });
}
function gj(r, t) {
  for (var e = t.model, n = t.dim, i = 0; i < r.length; i++) {
    var a = r[i] || {};
    if (N0(a[n + "AxisId"], e.id) || N0(a[n + "AxisIndex"], e.componentIndex) || N0(a[n + "AxisName"], e.name))
      return i;
  }
}
function N0(r, t) {
  return r === "all" || et(r) && Zt(r, t) >= 0 || r === t;
}
function mj(r) {
  var t = kb(r);
  if (t) {
    var e = t.axisPointerModel, n = t.axis.scale, i = e.option, a = e.get("status"), o = e.get("value");
    o != null && (o = n.parse(o));
    var s = wS(e);
    a == null && (i.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function kb(r) {
  var t = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[xh(r)];
}
function yj(r) {
  var t = kb(r);
  return t && t.axisPointerModel;
}
function wS(r) {
  return !!r.get(["handle", "show"]);
}
function xh(r) {
  return r.type + "||" + r.id;
}
var O0 = {}, Il = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.axisPointerClass && mj(e), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, i, !0);
    }, t.prototype.updateAxisPointer = function(e, n, i, a) {
      this._doUpdateAxisPointerClass(e, i, !1);
    }, t.prototype.remove = function(e, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, t.prototype.dispose = function(e, n) {
      this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(e, n, i) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = yj(e);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(e, o, n, i) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(e) {
      this._axisPointer && this._axisPointer.dispose(e), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(e, n) {
      if (process.env.NODE_ENV !== "production" && O0[e])
        throw new Error("axisPointer " + e + " exists");
      O0[e] = n;
    }, t.getAxisPointerClass = function(e) {
      return e && O0[e];
    }, t.type = "axis", t;
  }(Ge)
), MS = ee();
function N3(r, t, e, n) {
  var i = e.axis;
  if (!i.scale.isBlank()) {
    var a = e.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: a,
      clamp: !0,
      breakTicks: "none",
      pruneByBreak: "preserve_extent_bound"
    });
    if (u.length) {
      var c = s.length, f = MS(r).splitAreaColors, h = wt(), d = 0;
      if (f)
        for (var p = 0; p < u.length; p++) {
          var g = f.get(u[p].tickValue);
          if (g != null) {
            d = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = i.toGlobalCoord(u[0].coord), m = o.getAreaStyle();
      s = et(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord), _ = void 0, x = void 0, b = void 0, S = void 0;
        i.isHorizontal() ? (_ = v, x = l.y, b = y - _, S = l.height, v = _ + b) : (_ = l.x, x = v, b = l.width, S = y - x, v = x + S);
        var w = u[p - 1].tickValue;
        w != null && h.set(w, d), t.add(new te({
          anid: w != null ? "area_" + w : null,
          shape: {
            x: _,
            y: x,
            width: b,
            height: S
          },
          style: Bt({
            fill: s[d]
          }, m),
          autoBatch: !0,
          silent: !0
        })), d = (d + 1) % c;
      }
      MS(r).splitAreaColors = h;
    }
  }
}
function O3(r) {
  MS(r).splitAreaColors = null;
}
var _j = ["splitArea", "splitLine", "minorSplitLine", "breakArea"], k3 = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "CartesianAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!gh(e)) {
        this._axisGroup.add(e.axis.axisBuilder.group), L(_j, function(l) {
          e.get([l, "show"]) && xj[l](this, this._axisGroup, e, e.getCoordSysModel(), i);
        }, this);
        var s = a && a.type === "changeAxisOrder" && a.isInitSort;
        s || Vh(o, this._axisGroup, e), r.prototype.render.call(this, e, n, i, a);
      }
    }, t.prototype.remove = function() {
      O3(this);
    }, t.type = "cartesianAxis", t;
  }(Il)
), xj = {
  splitLine: function(r, t, e, n, i) {
    var a = e.axis;
    if (!a.scale.isBlank()) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = o.get("showMinLine") !== !1, c = o.get("showMaxLine") !== !1;
      l = et(l) ? l : [l];
      for (var f = n.coordinateSystem.getRect(), h = a.isHorizontal(), d = 0, p = a.getTicksCoords({
        tickModel: o,
        breakTicks: "none",
        pruneByBreak: "preserve_extent_bound"
      }), g = [], v = [], m = s.getLineStyle(), y = 0; y < p.length; y++) {
        var _ = a.toGlobalCoord(p[y].coord);
        if (!(y === 0 && !u || y === p.length - 1 && !c)) {
          var x = p[y].tickValue;
          h ? (g[0] = _, g[1] = f.y, v[0] = _, v[1] = f.y + f.height) : (g[0] = f.x, g[1] = _, v[0] = f.x + f.width, v[1] = _);
          var b = d++ % l.length, S = new lr({
            anid: x != null ? "line_" + x : null,
            autoBatch: !0,
            shape: {
              x1: g[0],
              y1: g[1],
              x2: v[0],
              y2: v[1]
            },
            style: Bt({
              stroke: l[b]
            }, m),
            silent: !0
          });
          ic(S.shape, m.lineWidth), t.add(S);
        }
      }
    }
  },
  minorSplitLine: function(r, t, e, n, i) {
    var a = e.axis, o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = n.coordinateSystem.getRect(), u = a.isHorizontal(), c = a.getMinorTicksCoords();
    if (c.length)
      for (var f = [], h = [], d = s.getLineStyle(), p = 0; p < c.length; p++)
        for (var g = 0; g < c[p].length; g++) {
          var v = a.toGlobalCoord(c[p][g].coord);
          u ? (f[0] = v, f[1] = l.y, h[0] = v, h[1] = l.y + l.height) : (f[0] = l.x, f[1] = v, h[0] = l.x + l.width, h[1] = v);
          var m = new lr({
            anid: "minor_line_" + c[p][g].tickValue,
            autoBatch: !0,
            shape: {
              x1: f[0],
              y1: f[1],
              x2: h[0],
              y2: h[1]
            },
            style: d,
            silent: !0
          });
          ic(m.shape, d.lineWidth), t.add(m);
        }
  },
  splitArea: function(r, t, e, n, i) {
    N3(r, t, e, n);
  },
  breakArea: function(r, t, e, n, i) {
    var a = qh(), o = e.axis.scale;
    a && o.type !== "ordinal" && a.rectCoordBuildBreakAxis(t, r, e, n.coordinateSystem.getRect(), i);
  }
}, B3 = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "xAxis", t;
  }(k3)
), Sj = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = B3.type, e;
    }
    return t.type = "yAxis", t;
  }(k3)
), bj = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "grid", e;
    }
    return t.prototype.render = function(e, n) {
      this.group.removeAll(), e.get("show") && this.group.add(new te({
        shape: e.coordinateSystem.getRect(),
        style: Bt({
          fill: e.get("backgroundColor")
        }, e.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, t.type = "grid", t;
  }(Ge)
), oD = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function V3(r) {
  r.registerComponentView(bj), r.registerComponentModel(LK), r.registerCoordinateSystem("cartesian2d", oj), fc(r, "x", mS, oD), fc(r, "y", mS, oD), r.registerComponentView(B3), r.registerComponentView(Sj), r.registerPreprocessor(function(t) {
    t.xAxis && t.yAxis && !t.grid && (t.grid = {});
  });
}
function wj(r, t) {
  var e = r.coordinateSystem, n = e && e.type, i = e && e.getBaseAxis && e.getBaseAxis(), a = i && i.scale && i.scale.type, o = n === "cartesian2d" && a === "ordinal" || n === "single", s = t.model.get("jitter") > 0;
  return o && s;
}
var Mj = ee();
function sD(r, t, e, n) {
  if (r instanceof b3) {
    var i = r.scale.type;
    if (i !== "category" && i !== "ordinal")
      return e;
  }
  var a = r.model, o = a.get("jitter"), s = a.get("jitterOverlap"), l = a.get("jitterMargin") || 0, u = r.scale.type === "ordinal" ? r.getBandWidth() : null;
  return o > 0 ? s ? F3(e, o, u, n) : Tj(r, t, e, n, o, l) : e;
}
function F3(r, t, e, n) {
  if (e === null)
    return r + (Math.random() - 0.5) * t;
  var i = e - n * 2, a = Math.min(Math.max(0, t), i);
  return r + (Math.random() - 0.5) * a;
}
function Tj(r, t, e, n, i, a) {
  var o = Mj(r);
  o.items || (o.items = []);
  var s = o.items, l = lD(s, t, e, n, i, a, 1), u = lD(s, t, e, n, i, a, -1), c = Math.abs(l - e) < Math.abs(u - e) ? l : u, f = r.scale.type === "ordinal" ? r.getBandWidth() : null, h = Math.abs(c - e);
  return h > i / 2 || f && h > f / 2 - n ? F3(e, i, f, n) : (s.push({
    fixedCoord: t,
    floatCoord: c,
    r: n
  }), c);
}
function lD(r, t, e, n, i, a, o) {
  for (var s = e, l = 0; l < r.length; l++) {
    var u = r[l], c = t - u.fixedCoord, f = s - u.floatCoord, h = c * c + f * f, d = n + u.r + a;
    if (h < d * d) {
      var p = u.floatCoord + Math.sqrt(d * d - c * c) * o;
      if (Math.abs(p - e) > i / 2)
        return Number.MAX_VALUE;
      if (o === 1 && p > s || o === -1 && p < s) {
        s = p, l = -1;
        continue;
      }
    }
  }
  return s;
}
function Aj(r) {
  r.eachSeriesByType("scatter", function(t) {
    var e = t.coordinateSystem;
    if (e && (e.type === "cartesian2d" || e.type === "single")) {
      var n = e.getBaseAxis ? e.getBaseAxis() : null, i = n && wj(t, n);
      if (i) {
        var a = t.getData();
        a.each(function(o) {
          var s = n.dim, l = n.orient, u = l === "horizontal" && n.type !== "category" || l === "vertical" && n.type === "category", c = a.getItemLayout(o), f = a.getItemVisual(o, "symbolSize"), h = f instanceof Array ? (f[1] + f[0]) / 2 : f;
          if (s === "y" || s === "single" && u) {
            var d = sD(n, c[0], c[1], h / 2);
            a.setItemLayout(o, [c[0], d]);
          } else if (s === "x" || s === "single" && !u) {
            var d = sD(n, c[1], c[0], h / 2);
            a.setItemLayout(o, [d, c[1]]);
          }
        });
      }
    }
  });
}
function Ej(r) {
  jt(V3), r.registerSeriesModel(TK), r.registerChartView(DK), r.registerLayout(Zh("scatter"));
}
function Cj(r) {
  r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, Aj);
}
function Dj(r) {
  r.eachSeriesByType("radar", function(t) {
    var e = t.getData(), n = [], i = t.coordinateSystem;
    if (i) {
      var a = i.getIndicatorAxes();
      L(a, function(o, s) {
        e.each(e.mapDimension(a[s].dim), function(l, u) {
          n[u] = n[u] || [];
          var c = i.dataToPoint(l, s);
          n[u][s] = uD(c) ? c : cD(i);
        });
      }), e.each(function(o) {
        var s = Ml(n[o], function(l) {
          return uD(l);
        }) || cD(i);
        n[o].push(s.slice()), e.setItemLayout(o, n[o]);
      });
    }
  });
}
function uD(r) {
  return !isNaN(r[0]) && !isNaN(r[1]);
}
function cD(r) {
  return [r.cx, r.cy];
}
function Lj(r) {
  var t = r.polar;
  if (t) {
    et(t) || (t = [t]);
    var e = [];
    L(t, function(n, i) {
      n.indicator ? (n.type && !n.shape && (n.shape = n.type), r.radar = r.radar || [], et(r.radar) || (r.radar = [r.radar]), r.radar.push(n)) : e.push(n);
    }), r.polar = e;
  }
  L(r.series, function(n) {
    n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
  });
}
var Rj = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.coordinateSystem, o = this.group, s = e.getData(), l = this._data;
      function u(h, d) {
        var p = h.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = Rc(h.getItemVisual(d, "symbolSize")), v = hr(p, -1, -1, 2, 2), m = h.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(h, d, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var _ = u(g, v);
          _ && (_.__dimIdx = y, h[y] ? (_.setPosition(h[y]), El[m ? "initProps" : "updateProps"](_, {
            x: d[y][0],
            y: d[y][1]
          }, e, v)) : _.setPosition(d[y]), p.add(_));
        }
      }
      function f(h) {
        return rt(h, function(d) {
          return [a.cx, a.cy];
        });
      }
      s.diff(l).add(function(h) {
        var d = s.getItemLayout(h);
        if (d) {
          var p = new Jr(), g = new Gr(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = f(d), g.shape.points = f(d), ze(p, v, e, h), ze(g, v, e, h);
          var m = new Ct(), y = new Ct();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, d, y, s, h, !0), s.setItemGraphicEl(h, m);
        }
      }).update(function(h, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(h)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, s, h, !1), oi(v), oi(g), ve(g, y, e), ve(v, y, e), s.setItemGraphicEl(h, p));
      }).remove(function(h) {
        o.remove(l.getItemGraphicEl(h));
      }).execute(), s.eachItemGraphicEl(function(h, d) {
        var p = s.getItemModel(d), g = h.childAt(0), v = h.childAt(1), m = h.childAt(2), y = s.getItemVisual(d, "style"), _ = y.fill;
        o.add(h), g.useStyle(Bt(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: _
        })), _r(g, p, "lineStyle"), _r(v, p, "areaStyle");
        var x = p.getModel("areaStyle"), b = x.isEmpty() && x.parentModel.isEmpty();
        v.ignore = b, L(["emphasis", "select", "blur"], function(w) {
          var A = p.getModel([w, "areaStyle"]), T = A.isEmpty() && A.parentModel.isEmpty();
          v.ensureState(w).ignore = T && b;
          var M = p.getModel([w, "lineStyle"]).getLineStyle();
          g.ensureState(w).style = M;
          var C = A.getAreaStyle();
          v.ensureState(w).style = C;
          var R = p.getModel([w, "itemStyle"]).getItemStyle();
          m.eachChild(function(E) {
            E.ensureState(w).style = Dt(R);
          });
        }), v.useStyle(Bt(p.getModel("areaStyle").getAreaStyle(), {
          fill: _,
          opacity: 0.7,
          decal: y.decal
        }));
        var S = p.getModel("emphasis");
        m.eachChild(function(w) {
          if (w instanceof Fr) {
            var A = w.style;
            w.useStyle(j({
              // TODO other properties like x, y ?
              image: A.image,
              x: A.x,
              y: A.y,
              width: A.width,
              height: A.height
            }, y));
          } else
            w.useStyle(y), w.setColor(_), w.style.strokeNoScale = !0;
          var T = s.getStore().get(s.getDimensionIndex(w.__dimIdx), d);
          (T == null || isNaN(T)) && (T = ""), Cr(w, xr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: w.__dimIdx,
            defaultText: T,
            inheritColor: _,
            defaultOpacity: y.opacity
          });
        }), He(h, S.get("focus"), S.get("blurScope"), S.get("disabled"));
      }), this._data = s;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "radar", t;
  }(Re)
), Ij = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Oc(gt(this.getData, this), gt(this.getRawData, this));
    }, t.prototype.getInitialData = function(e, n) {
      return Nc(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(e), u = l === "" ? this.name : l, c = MO(this, e);
      return fr("section", {
        header: u,
        sortBlocks: !0,
        blocks: rt(s, function(f) {
          var h = a.get(a.mapDimension(f.dim), e);
          return fr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: f.name,
            value: h,
            sortParam: h
          });
        })
      });
    }, t.prototype.getTooltipPosition = function(e) {
      if (e != null) {
        for (var n = this.getData(), i = this.coordinateSystem, a = n.getValues(rt(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), e), o = 0, s = a.length; o < s; o++)
          if (!isNaN(a[o])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[o].dataToCoord(a[o]), o);
          }
      }
    }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, t;
  }(ke)
), cf = S3.value;
function vp(r, t) {
  return Bt({
    show: t
  }, r);
}
var Pj = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      var e = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), f = this.get("axisNameGap"), h = this.get("triggerEvent"), d = rt(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = Bt({
          color: p.color
        }, l));
        var v = qt(Dt(p), {
          boundaryGap: e,
          splitNumber: n,
          scale: i,
          axisLine: a,
          axisTick: o,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: f,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: h
        }, !1);
        if (pt(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else
          At(c) && (v.name = c(v.name, v));
        var y = new ue(v, null, this.ecModel);
        return dr(y, Wh.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, t.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, t.type = "radar", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "50%",
      startAngle: 90,
      axisName: {
        show: !0,
        color: X.color.axisLabel
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: qt({
        lineStyle: {
          color: X.color.neutral20
        }
      }, cf.axisLine),
      axisLabel: vp(cf.axisLabel, !1),
      axisTick: vp(cf.axisTick, !1),
      // axisType: 'value',
      splitLine: vp(cf.splitLine, !0),
      splitArea: vp(cf.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, t;
  }(re)
), Nj = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(e, i), this._buildSplitLineAndArea(e);
    }, t.prototype._buildAxes = function(e, n) {
      var i = e.coordinateSystem, a = i.getIndicatorAxes(), o = rt(a, function(s) {
        var l = s.model.get("showName") ? s.name : "", u = new fn(s.model, n, {
          axisName: l,
          position: [i.cx, i.cy],
          rotation: s.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return u;
      });
      L(o, function(s) {
        s.build(), this.group.add(s.group);
      }, this);
    }, t.prototype._buildSplitLineAndArea = function(e) {
      var n = e.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length)
        return;
      var a = e.get("shape"), o = e.getModel("splitLine"), s = e.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), f = s.get("show"), h = l.get("color"), d = u.get("color"), p = et(h) ? h : [h], g = et(d) ? d : [d], v = [], m = [];
      function y(I, P, O) {
        var N = O % P.length;
        return I[N] = I[N] || [], N;
      }
      if (a === "circle")
        for (var _ = i[0].getTicksCoords(), x = n.cx, b = n.cy, S = 0; S < _.length; S++) {
          if (c) {
            var w = y(v, p, S);
            v[w].push(new Ka({
              shape: {
                cx: x,
                cy: b,
                r: _[S].coord
              }
            }));
          }
          if (f && S < _.length - 1) {
            var w = y(m, g, S);
            m[w].push(new kh({
              shape: {
                cx: x,
                cy: b,
                r0: _[S].coord,
                r: _[S + 1].coord
              }
            }));
          }
        }
      else
        for (var A, T = rt(i, function(I, P) {
          var O = I.getTicksCoords();
          return A = A == null ? O.length - 1 : Math.min(O.length - 1, A), rt(O, function(N) {
            return n.coordToPoint(N.coord, P);
          });
        }), M = [], S = 0; S <= A; S++) {
          for (var C = [], R = 0; R < i.length; R++)
            C.push(T[R][S]);
          if (C[0] ? C.push(C[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + S), c) {
            var w = y(v, p, S);
            v[w].push(new Gr({
              shape: {
                points: C
              }
            }));
          }
          if (f && M) {
            var w = y(m, g, S - 1);
            m[w].push(new Jr({
              shape: {
                points: C.concat(M)
              }
            }));
          }
          M = C.slice().reverse();
        }
      var E = l.getLineStyle(), D = u.getAreaStyle();
      L(m, function(I, P) {
        this.group.add(Qn(I, {
          style: Bt({
            stroke: "none",
            fill: g[P % g.length]
          }, D),
          silent: !0
        }));
      }, this), L(v, function(I, P) {
        this.group.add(Qn(I, {
          style: Bt({
            fill: "none",
            stroke: p[P % p.length]
          }, E),
          silent: !0
        }));
      }, this);
    }, t.type = "radar", t;
  }(Ge)
), Oj = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, n, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return t;
  }(Ei)
), kj = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dimensions = [], this._model = t, this._indicatorAxes = rt(t.getIndicatorModels(), function(i, a) {
        var o = "indicator_" + a, s = new Oj(
          o,
          new $a()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(t, n);
    }
    return r.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, r.prototype.dataToPoint = function(t, e) {
      var n = this._indicatorAxes[e];
      return this.coordToPoint(n.dataToCoord(t), e);
    }, r.prototype.coordToPoint = function(t, e) {
      var n = this._indicatorAxes[e], i = n.angle, a = this.cx + t * Math.cos(i), o = this.cy - t * Math.sin(i);
      return [a, o];
    }, r.prototype.pointToData = function(t) {
      var e = t[0] - this.cx, n = t[1] - this.cy, i = Math.sqrt(e * e + n * n);
      e /= i, n /= i;
      for (var a = Math.atan2(-n, e), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], f = Math.abs(a - c.angle);
        f < o && (s = c, l = u, o = f);
      }
      return [l, +(s && s.coordToData(i))];
    }, r.prototype.resize = function(t, e) {
      var n = Sr(t, e).refContainer, i = t.get("center"), a = Math.min(n.width, n.height) / 2;
      this.cx = dt(i[0], n.width) + n.x, this.cy = dt(i[1], n.height) + n.y, this.startAngle = t.get("startAngle") * Math.PI / 180;
      var o = t.get("radius");
      (pt(o) || fe(o)) && (o = [0, o]), this.r0 = dt(o[0], a), this.r = dt(o[1], a), L(this._indicatorAxes, function(s, l) {
        s.setExtent(this.r0, this.r);
        var u = this.startAngle + l * Math.PI * 2 / this._indicatorAxes.length;
        u = Math.atan2(Math.sin(u), Math.cos(u)), s.angle = u;
      }, this);
    }, r.prototype.update = function(t, e) {
      var n = this._indicatorAxes, i = this._model;
      L(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), t.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          L(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), o = new $a();
      o.setExtent(0, a), o.setInterval(1), L(n, function(s, l) {
        I3(s.scale, s.model, o);
      });
    }, r.prototype.convertToPixel = function(t, e, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("radar", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, r.dimensions = [], r;
  }()
);
function Bj(r) {
  r.registerCoordinateSystem("radar", kj), r.registerComponentModel(Pj), r.registerComponentView(Nj), r.registerVisual({
    seriesType: "radar",
    reset: function(t) {
      var e = t.getData();
      e.each(function(n) {
        e.setItemVisual(n, "legendIcon", "roundRect");
      }), e.setVisual("legendIcon", "roundRect");
    }
  });
}
function Vj(r) {
  jt(Bj), r.registerChartView(Rj), r.registerSeriesModel(Ij), r.registerLayout(Dj), r.registerProcessor(Pc("radar")), r.registerPreprocessor(Lj);
}
var Bb = ee();
function Fj(r, t, e) {
  Bb(r)[t] = e;
}
function zj(r, t, e) {
  var n = Bb(r), i = n[t];
  i === e && (n[t] = null);
}
function fD(r, t) {
  return !!Bb(r)[t];
}
fa({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, rr);
var Uj = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function z3(r, t, e) {
  var n = t.getComponentByElement(r.topTarget);
  if (!n || n === e || Uj.hasOwnProperty(n.mainType))
    return !1;
  var i = n.coordinateSystem;
  if (!i || i.model === e)
    return !1;
  var a = yl(n), o = yl(e);
  return !((a.zlevel - o.zlevel || a.z - o.z) <= 0);
}
var Pl = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this) || this;
      n._zr = e;
      var i = gt(n._mousedownHandler, n), a = gt(n._mousemoveHandler, n), o = gt(n._mouseupHandler, n), s = gt(n._mousewheelHandler, n), l = gt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var f = c.zInfo, h = yl(f.component), d = h.z, p = h.zlevel, g = {
          component: f.component,
          z: d,
          zlevel: p,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: bt(f.z2, -1 / 0)
        }, v = j({}, c.triggerInfo);
        this._opt = Bt(j({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: g,
          triggerInfo: v
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (hf(e, "mousedown", i, g), hf(e, "mousemove", a, g), hf(e, "mouseup", o, g)), (u === !0 || u === "scale" || u === "zoom") && (hf(e, "mousewheel", s, g), hf(e, "pinch", l, g)));
      }, n.disable = function() {
        this._enabled = !1, df(e, "mousedown", i), df(e, "mousemove", a), df(e, "mouseup", o), df(e, "mousewheel", s), df(e, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(e, n, i) {
      var a = this._opt, o = a.zInfoParsed;
      if (z3(e, a.api, o.component))
        return !1;
      var s = a.triggerInfo, l = s.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = s.isInSelf(e, n, i)), u && s.isInClip && !s.isInClip(e, n, i) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(e, n, i, a) {
      var o = e.target;
      if (!o && this._checkPointer(e, n, i))
        return "grab";
      if (a)
        return o && o.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(e) {
      if (!(AT(e) || ff(e))) {
        for (var n = e.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var i = e.offsetX, a = e.offsetY;
        this._checkPointer(e, i, a) && (this._x = i, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(e) {
      var n = this._zr;
      if (!(e.gestureEvent === "pinch" || fD(n, "globalPan") || ff(e))) {
        var i = e.offsetX, a = e.offsetY;
        if (!this._dragging || !nv("moveOnMouseMove", e, this._opt)) {
          var o = this._decideCursorStyle(e, i, a, !1);
          o && n.setCursorStyle(o);
          return;
        }
        n.setCursorStyle("grabbing");
        var s = this._x, l = this._y, u = i - s, c = a - l;
        this._x = i, this._y = a, this._opt.preventDefaultMouseMove && Ga(e.event), e.__ecRoamConsumed = !0, hD(this, "pan", "moveOnMouseMove", e, {
          dx: u,
          dy: c,
          oldX: s,
          oldY: l,
          newX: i,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(e) {
      if (!ff(e)) {
        var n = this._zr;
        if (!AT(e)) {
          this._dragging = !1;
          var i = this._decideCursorStyle(e, e.offsetX, e.offsetY, !0);
          i && n.setCursorStyle(i);
        }
      }
    }, t.prototype._mousewheelHandler = function(e) {
      if (!ff(e)) {
        var n = nv("zoomOnMouseWheel", e, this._opt), i = nv("moveOnMouseWheel", e, this._opt), a = e.wheelDelta, o = Math.abs(a), s = e.offsetX, l = e.offsetY;
        if (!(a === 0 || !n && !i)) {
          if (n) {
            var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", e, {
              scale: c,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (i) {
            var f = Math.abs(a), h = (a > 0 ? 1 : -1) * (f > 3 ? 0.4 : f > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", e, {
              scrollDelta: h,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(e) {
      if (!(fD(this._zr, "globalPan") || ff(e))) {
        var n = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, e, {
          scale: n,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(e, n, i, a, o) {
      e._checkPointer(a, o.originX, o.originY) && (Ga(a.event), a.__ecRoamConsumed = !0, hD(e, n, i, a, o));
    }, t;
  }(si)
);
function ff(r) {
  return r.__ecRoamConsumed;
}
var Gj = ee();
function _m(r) {
  var t = Gj(r);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function hf(r, t, e, n) {
  for (var i = _m(r), a = i.roam, o = a[t] = a[t] || [], s = 0; s < o.length; s++) {
    var l = o[s].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  o.splice(s, 0, {
    listener: e,
    zInfoParsed: n
  }), Hj(r, t);
}
function df(r, t, e) {
  for (var n = _m(r), i = n.roam[t] || [], a = 0; a < i.length; a++)
    if (i[a].listener === e) {
      i.splice(a, 1), i.length || Wj(r, t);
      return;
    }
}
function Hj(r, t) {
  var e = _m(r);
  e.uniform[t] || r.on(t, e.uniform[t] = function(n) {
    var i = e.roam[t];
    if (i)
      for (var a = 0; a < i.length; a++)
        i[a].listener(n);
  });
}
function Wj(r, t) {
  var e = _m(r), n = e.uniform;
  n[t] && (r.off(t, n[t]), n[t] = null);
}
function hD(r, t, e, n, i) {
  i.isAvailableBehavior = gt(nv, null, e, n), r.trigger(t, i);
}
function nv(r, t, e) {
  var n = e[r];
  return !r || n && (!pt(n) || t.event[n + "Key"]);
}
function Vb(r, t, e) {
  var n = r.target;
  n.x += t, n.y += e, n.dirty();
}
function Fb(r, t, e, n) {
  var i = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
  o *= t, o = zb(o, a);
  var s = o / r.zoom;
  r.zoom = o, G3(i, e, n, s), i.dirty();
}
function U3(r, t, e, n, i, a) {
  var o = new Vt(0, 0, 0, 0);
  n.enable(r.get("roam"), {
    api: t,
    zInfo: {
      component: r
    },
    triggerInfo: {
      roamTrigger: r.get("roamTrigger"),
      isInSelf: function(u, c, f) {
        return o.copy(e.getBoundingRect()), o.applyTransform(e.getComputedTransform()), o.contain(c, f);
      },
      isInClip: function(u, c, f) {
        return !a || a.contain(c, f);
      }
    }
  }), i.zoomLimit = r.get("scaleLimit");
  var s = r.coordinateSystem;
  i.zoom = s ? s.getZoom() : 1;
  var l = r.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    Vb(i, u.dx, u.dy), t.dispatchAction({
      seriesId: r.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    Fb(i, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: r.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function dD(r, t) {
  return r.pointToProjected ? r.pointToProjected(t) : r.pointToData(t);
}
function xm(r, t, e) {
  var n = r.getZoom(), i = r.getCenter(), a = t.zoom, o = r.projectedToPoint ? r.projectedToPoint(i) : r.dataToPoint(i);
  return t.dx != null && t.dy != null && (o[0] -= t.dx, o[1] -= t.dy, r.setCenter(dD(r, o))), a != null && (a = zb(n * a, e) / n, G3(r, t.originX, t.originY, a), r.updateTransform(), r.setCenter(dD(r, o)), r.setZoom(a * n)), {
    center: r.getCenter(),
    zoom: r.getZoom()
  };
}
function G3(r, t, e, n) {
  r.x -= (t - r.x) * (n - 1), r.y -= (e - r.y) * (n - 1), r.scaleX *= n, r.scaleY *= n;
}
function zb(r, t) {
  if (t) {
    var e = t.min || 0, n = t.max || 1 / 0;
    r = Math.max(Math.min(n, r), e);
  }
  return r;
}
function H3(r) {
  if (pt(r)) {
    var t = new DOMParser();
    r = t.parseFromString(r, "text/xml");
  }
  var e = r;
  for (e.nodeType === 9 && (e = e.firstChild); e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1; )
    e = e.nextSibling;
  return e;
}
var k0, lg = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, pD = se(lg), ug = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, vD = se(ug), Xj = function() {
  function r() {
    this._defs = {}, this._root = null;
  }
  return r.prototype.parse = function(t, e) {
    e = e || {};
    var n = H3(t);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new Ct();
    this._root = i;
    var a = [], o = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || e.width), l = parseFloat(n.getAttribute("height") || e.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), Cn(n, i, null, !0, !1);
    for (var u = n.firstChild; u; )
      this._parseNode(u, i, a, null, !1, !1), u = u.nextSibling;
    Zj(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, f;
    if (o) {
      var h = Sm(o);
      h.length >= 4 && (c = {
        x: parseFloat(h[0] || 0),
        y: parseFloat(h[1] || 0),
        width: parseFloat(h[2]),
        height: parseFloat(h[3])
      });
    }
    if (c && s != null && l != null && (f = X3(c, { x: 0, y: 0, width: s, height: l }), !e.ignoreViewBox)) {
      var d = i;
      i = new Ct(), i.add(d), d.scaleX = d.scaleY = f.scale, d.x = f.x, d.y = f.y;
    }
    return !e.ignoreRootClip && s != null && l != null && i.setClipPath(new te({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: f,
      named: a
    };
  }, r.prototype._parseNode = function(t, e, n, i, a, o) {
    var s = t.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = e;
    else {
      if (!a) {
        var c = k0[s];
        if (c && _t(k0, s)) {
          l = c.call(this, t, e);
          var f = t.getAttribute("name");
          if (f) {
            var h = {
              name: f,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            n.push(h), s === "g" && (u = h);
          } else
            i && n.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
          e.add(l);
        }
      }
      var d = gD[s];
      if (d && _t(gD, s)) {
        var p = d.call(this, t), g = t.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = t.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, n, u, a, o) : v.nodeType === 3 && o && this._parseText(v, l), v = v.nextSibling;
  }, r.prototype._parseText = function(t, e) {
    var n = new nc({
      style: {
        text: t.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), Yj(n, e);
    var i = n.style, a = i.fontSize;
    a && a < 9 && (i.fontSize = 9, n.scaleX *= a / 9, n.scaleY *= a / 9);
    var o = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = o;
    var s = n.getBoundingRect();
    return this._textX += s.width, e.add(n), n;
  }, r.internalField = function() {
    k0 = {
      g: function(t, e) {
        var n = new Ct();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n;
      },
      rect: function(t, e) {
        var n = new te();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n.setShape({
          x: parseFloat(t.getAttribute("x") || "0"),
          y: parseFloat(t.getAttribute("y") || "0"),
          width: parseFloat(t.getAttribute("width") || "0"),
          height: parseFloat(t.getAttribute("height") || "0")
        }), n.silent = !0, n;
      },
      circle: function(t, e) {
        var n = new Ka();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          r: parseFloat(t.getAttribute("r") || "0")
        }), n.silent = !0, n;
      },
      line: function(t, e) {
        var n = new lr();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n.setShape({
          x1: parseFloat(t.getAttribute("x1") || "0"),
          y1: parseFloat(t.getAttribute("y1") || "0"),
          x2: parseFloat(t.getAttribute("x2") || "0"),
          y2: parseFloat(t.getAttribute("y2") || "0")
        }), n.silent = !0, n;
      },
      ellipse: function(t, e) {
        var n = new nm();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          rx: parseFloat(t.getAttribute("rx") || "0"),
          ry: parseFloat(t.getAttribute("ry") || "0")
        }), n.silent = !0, n;
      },
      polygon: function(t, e) {
        var n = t.getAttribute("points"), i;
        n && (i = _D(n));
        var a = new Jr({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Wn(e, a), Cn(t, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(t, e) {
        var n = t.getAttribute("points"), i;
        n && (i = _D(n));
        var a = new Gr({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Wn(e, a), Cn(t, a, this._defsUsePending, !1, !1), a;
      },
      image: function(t, e) {
        var n = new Fr();
        return Wn(e, n), Cn(t, n, this._defsUsePending, !1, !1), n.setStyle({
          image: t.getAttribute("xlink:href") || t.getAttribute("href"),
          x: +t.getAttribute("x"),
          y: +t.getAttribute("y"),
          width: +t.getAttribute("width"),
          height: +t.getAttribute("height")
        }), n.silent = !0, n;
      },
      text: function(t, e) {
        var n = t.getAttribute("x") || "0", i = t.getAttribute("y") || "0", a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0";
        this._textX = parseFloat(n) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
        var s = new Ct();
        return Wn(e, s), Cn(t, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(t, e) {
        var n = t.getAttribute("x"), i = t.getAttribute("y");
        n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
        var a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0", s = new Ct();
        return Wn(e, s), Cn(t, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(t, e) {
        var n = t.getAttribute("d") || "", i = fN(n);
        return Wn(e, i), Cn(t, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), r;
}(), gD = {
  lineargradient: function(r) {
    var t = parseInt(r.getAttribute("x1") || "0", 10), e = parseInt(r.getAttribute("y1") || "0", 10), n = parseInt(r.getAttribute("x2") || "10", 10), i = parseInt(r.getAttribute("y2") || "0", 10), a = new Mc(t, e, n, i);
    return mD(r, a), yD(r, a), a;
  },
  radialgradient: function(r) {
    var t = parseInt(r.getAttribute("cx") || "0", 10), e = parseInt(r.getAttribute("cy") || "0", 10), n = parseInt(r.getAttribute("r") || "0", 10), i = new vN(t, e, n);
    return mD(r, i), yD(r, i), i;
  }
};
function mD(r, t) {
  var e = r.getAttribute("gradientUnits");
  e === "userSpaceOnUse" && (t.global = !0);
}
function yD(r, t) {
  for (var e = r.firstChild; e; ) {
    if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === "stop") {
      var n = e.getAttribute("offset"), i = void 0;
      n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
      var a = {};
      W3(e, a, a);
      var o = a.stopColor || e.getAttribute("stop-color") || "#000000", s = a.stopOpacity || e.getAttribute("stop-opacity");
      if (s) {
        var l = wn(o), u = l && l[3];
        u && (l[3] *= No(s), o = Qi(l, "rgba"));
      }
      t.colorStops.push({
        offset: i,
        color: o
      });
    }
    e = e.nextSibling;
  }
}
function Wn(r, t) {
  r && r.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), Bt(t.__inheritedStyle, r.__inheritedStyle));
}
function _D(r) {
  for (var t = Sm(r), e = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]), a = parseFloat(t[n + 1]);
    e.push([i, a]);
  }
  return e;
}
function Cn(r, t, e, n, i) {
  var a = t, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  r.nodeType === 1 && (jj(r, t), W3(r, o, s), n || Jj(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = xD(a, "fill", o.fill, e)), o.stroke != null && (a.style.stroke = xD(a, "stroke", o.stroke, e)), L([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), L([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = rt(Sm(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function Yj(r, t) {
  var e = t.__selfStyle;
  if (e) {
    var n = e.textBaseline, i = n;
    !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), r.style.textBaseline = i;
  }
  var a = t.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), r.style.textAlign = s);
  }
}
var $j = /^url\(\s*#(.*?)\)/;
function xD(r, t, e, n) {
  var i = e && e.match($j);
  if (i) {
    var a = ei(i[1]);
    n.push([r, t, a]);
    return;
  }
  return e === "none" && (e = null), e;
}
function Zj(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n[0].style[n[1]] = r[n[2]];
  }
}
var qj = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function Sm(r) {
  return r.match(qj) || [];
}
var Kj = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, B0 = Math.PI / 180;
function jj(r, t) {
  var e = r.getAttribute("transform");
  if (e) {
    e = e.replace(/,/g, " ");
    var n = [], i = null;
    e.replace(Kj, function(f, h, d) {
      return n.push(h, d), "";
    });
    for (var a = n.length - 1; a > 0; a -= 2) {
      var o = n[a], s = n[a - 1], l = Sm(o);
      switch (i = i || Br(), s) {
        case "translate":
          na(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          A1(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          Ko(i, i, -parseFloat(l[0]) * B0, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * B0);
          Ji(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * B0);
          Ji(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    t.setLocalTransform(i);
  }
}
var SD = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function W3(r, t, e) {
  var n = r.getAttribute("style");
  if (n) {
    SD.lastIndex = 0;
    for (var i; (i = SD.exec(n)) != null; ) {
      var a = i[1], o = _t(lg, a) ? lg[a] : null;
      o && (t[o] = i[2]);
      var s = _t(ug, a) ? ug[a] : null;
      s && (e[s] = i[2]);
    }
  }
}
function Jj(r, t, e) {
  for (var n = 0; n < pD.length; n++) {
    var i = pD[n], a = r.getAttribute(i);
    a != null && (t[lg[i]] = a);
  }
  for (var n = 0; n < vD.length; n++) {
    var i = vD[n], a = r.getAttribute(i);
    a != null && (e[ug[i]] = a);
  }
}
function X3(r, t) {
  var e = t.width / r.width, n = t.height / r.height, i = Math.min(e, n);
  return {
    scale: i,
    x: -(r.x + r.width / 2) * i + (t.x + t.width / 2),
    y: -(r.y + r.height / 2) * i + (t.y + t.height / 2)
  };
}
function Qj(r, t) {
  var e = new Xj();
  return e.parse(r, t);
}
var tJ = wt([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), eJ = (
  /** @class */
  function() {
    function r(t, e) {
      this.type = "geoSVG", this._usedGraphicMap = wt(), this._freedGraphics = [], this._mapName = t, this._parsedXML = H3(e);
    }
    return r.prototype.load = function() {
      var t = this._firstGraphic;
      if (!t) {
        t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var e = nJ(t.named), n = e.regions, i = e.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(t) {
      var e, n;
      try {
        e = t && Qj(t, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, n = e.root, St(n != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new Ct();
      i.add(n), i.isGeoSVGGraphicRoot = !0;
      var a = e.width, o = e.height, s = e.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, f = void 0, h = void 0;
        if (a != null ? (u = 0, f = a) : s && (u = s.x, f = s.width), o != null ? (c = 0, h = o) : s && (c = s.y, h = s.height), u == null || c == null) {
          var d = n.getBoundingRect();
          u == null && (u = d.x, f = d.width), c == null && (c = d.y, h = d.height);
        }
        l = this._boundingRect = new Vt(u, c, f, h);
      }
      if (s) {
        var p = X3(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new te({
        shape: l.plain()
      }));
      var g = [];
      return L(e.named, function(v) {
        tJ.get(v.svgNodeTagLower) != null && (g.push(v), rJ(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, r.prototype.useGraphic = function(t) {
      var e = this._usedGraphicMap, n = e.get(t);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), e.set(t, n), n);
    }, r.prototype.freeGraphic = function(t) {
      var e = this._usedGraphicMap, n = e.get(t);
      n && (e.removeKey(t), this._freedGraphics.push(n));
    }, r;
  }()
);
function rJ(r) {
  r.silent = !1, r.isGroup && r.traverse(function(t) {
    t.silent = !1;
  });
}
function nJ(r) {
  var t = [], e = wt();
  return L(r, function(n) {
    if (n.namedFrom == null) {
      var i = new yZ(n.name, n.el);
      t.push(i), e.set(n.name, i);
    }
  }), {
    regions: t,
    regionsMap: e
  };
}
var TS = [126, 25], bD = "", ks = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Is = 0; Is < ks.length; Is++)
  for (var vu = 0; vu < ks[Is].length; vu++)
    ks[Is][vu][0] /= 10.5, ks[Is][vu][1] /= -10.5 / 0.75, ks[Is][vu][0] += TS[0], ks[Is][vu][1] += TS[1];
function iJ(r, t) {
  if (r === "china") {
    for (var e = 0; e < t.length; e++)
      if (t[e].name === bD)
        return;
    t.push(new Ek(bD, rt(ks, function(n) {
      return {
        type: "polygon",
        exterior: n
      };
    }), TS));
  }
}
var aJ = {
  : [32, 80],
  // 
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  // '': [-10, 0],
  : [5, 5]
};
function oJ(r, t) {
  if (r === "china") {
    var e = aJ[t.name];
    if (e) {
      var n = t.getCenter();
      n[0] += e[0] / 10.5, n[1] += -e[1] / (10.5 / 0.75), t.setCenter(n);
    }
  }
}
var sJ = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function lJ(r, t) {
  r === "china" && t.name === "" && t.geometries.push({
    type: "polygon",
    exterior: sJ[0]
  });
}
var uJ = "name", cJ = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "geoJSON", this._parsedMap = wt(), this._mapName = t, this._specialAreas = n, this._geoJSON = hJ(e);
    }
    return r.prototype.load = function(t, e) {
      e = e || uJ;
      var n = this._parsedMap.get(e);
      if (!n) {
        var i = this._parseToRegions(e);
        n = this._parsedMap.set(e, {
          regions: i,
          boundingRect: fJ(i)
        });
      }
      var a = wt(), o = [];
      return L(n.regions, function(s) {
        var l = s.name;
        t && _t(t, l) && (s = s.cloneShallow(l = t[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: n.boundingRect || new Vt(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(t) {
      var e = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? xZ(n, t) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return iJ(e, i), L(i, function(a) {
        var o = a.name;
        oJ(e, a), lJ(e, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, r.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }()
);
function fJ(r) {
  for (var t, e = 0; e < r.length; e++) {
    var n = r[e].getBoundingRect();
    t = t || n.clone(), t.union(n);
  }
  return t;
}
function hJ(r) {
  return pt(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
}
var pf = wt();
const Za = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(r, t, e) {
    if (t.svg) {
      var n = new eJ(r, t.svg);
      pf.set(r, n);
    } else {
      var i = t.geoJson || t.geoJSON;
      i && !t.features ? e = t.specialAreas : i = t;
      var n = new cJ(r, i, e);
      pf.set(r, n);
    }
  },
  getGeoResource: function(r) {
    return pf.get(r);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(r) {
    var t = pf.get(r);
    return t && t.type === "geoJSON" && t.getMapForUser();
  },
  load: function(r, t, e) {
    var n = pf.get(r);
    if (!n) {
      process.env.NODE_ENV !== "production" && console.error("Map " + r + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return n.load(t, e);
  }
};
var Ub = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], dJ = wt(Ub), pJ = wt(Ub.concat(["g"])), vJ = wt(Ub.concat(["g"])), Y3 = ee();
function gp(r) {
  var t = r.getItemStyle(), e = r.get("areaColor");
  return e != null && (t.fill = e), t;
}
function wD(r) {
  var t = r.style;
  t && (t.stroke = t.stroke || t.fill, t.fill = null);
}
var $3 = (
  /** @class */
  function() {
    function r(t) {
      var e = this.group = new Ct(), n = this._transformGroup = new Ct();
      e.add(n), this.uid = Ec("ec_map_draw"), this._controller = new Pl(t.getZr()), this._controllerHost = {
        target: n
      }, n.add(this._regionsGroup = new Ct()), n.add(this._svgGroup = new Ct());
    }
    return r.prototype.draw = function(t, e, n, i, a) {
      var o = t.mainType === "geo", s = t.getData && t.getData();
      o && e.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(_) {
        !s && _.getHostGeoModel() === t && (s = _.getData());
      });
      var l = t.coordinateSystem, u = this._regionsGroup, c = this._transformGroup, f = l.getTransformInfo(), h = f.raw, d = f.roam, p = !u.childAt(0) || a, g = t.getShallow("clip", !0), v;
      g ? (v = l.getViewRect().clone(), this.group.setClipPath(new te({
        shape: v.clone()
      }))) : this.group.removeClipPath(), p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : ve(c, d, t);
      var m = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, y = {
        api: n,
        geo: l,
        mapOrGeoModel: t,
        data: s,
        isVisualEncodedByVisualMap: m,
        isGeo: o,
        transformInfoRaw: h
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(y) : l.resourceType === "geoSVG" && this._buildSVG(y), this._updateController(t, v, e, n), this._updateMapSelectHandler(t, u, n, i);
    }, r.prototype._buildGeoJSON = function(t) {
      var e = this._regionsGroupByName = wt(), n = wt(), i = this._regionsGroup, a = t.transformInfoRaw, o = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y];
      }
      function f(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g);
          m && p.push(m);
        }
        return p;
      }
      function h(d) {
        return {
          shape: {
            points: f(d)
          }
        };
      }
      i.removeAll(), L(t.geo.regions, function(d) {
        var p = d.name, g = e.get(p), v = n.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        if (!g) {
          g = e.set(p, new Ct()), i.add(g), m = s ? s.indexOfName(p) : null, y = t.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null;
          var _ = y.get("silent", !0);
          _ != null && (g.silent = _), n.set(p, {
            dataIdx: m,
            regionModel: y
          });
        }
        var x = [], b = [];
        L(d.geometries, function(A) {
          if (A.type === "polygon") {
            var T = [A.exterior].concat(A.interiors || []);
            u && (T = DD(T, u)), L(T, function(C) {
              x.push(new Jr(h(C)));
            });
          } else {
            var M = A.points;
            u && (M = DD(M, u, !0)), L(M, function(C) {
              b.push(new Gr(h(C)));
            });
          }
        });
        var S = c(d.getCenter(), l && l.project);
        function w(A, T) {
          if (A.length) {
            var M = new am({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: A
              }
            });
            g.add(M), MD(t, M, m, y), TD(t, M, p, y, o, m, S), T && (wD(M), L(M.states, wD));
          }
        }
        w(x), w(b, !0);
      }), e.each(function(d, p) {
        var g = n.get(p), v = g.dataIdx, m = g.regionModel;
        AD(t, d, p, m, o, v), ED(t, d, p, m, o), CD(t, d, p, m, o);
      }, this);
    }, r.prototype._buildSVG = function(t) {
      var e = t.geo.map, n = t.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e));
      var i = this._svgDispatcherMap = wt(), a = !1;
      L(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = t.mapOrGeoModel, u = t.data, c = o.svgNodeTagLower, f = o.el, h = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        dJ.get(c) != null && f instanceof ai && MD(t, f, h, d), f instanceof ai && (f.culling = !0);
        var p = d.get("silent", !0);
        if (p != null && (f.silent = p), f.z2EmphasisLift = 0, !o.namedFrom && (vJ.get(c) != null && TD(t, f, s, d, l, h, null), AD(t, f, s, d, l, h), ED(t, f, s, d, l), pJ.get(c) != null)) {
          var g = CD(t, f, s, d, l);
          g === "self" && (a = !0);
          var v = i.get(s) || i.set(s, []);
          v.push(f);
        }
      }, this), this._enableBlurEntireSVG(a, t);
    }, r.prototype._enableBlurEntireSVG = function(t, e) {
      if (t && e.isGeo) {
        var n = e.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            gl(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(t, e) {
      if (t == null)
        return [];
      var n = e.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(t);
          return a ? [a] : [];
        }
      } else if (n.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
    }, r.prototype._svgResourceChanged = function(t) {
      return this._svgMapName !== t;
    }, r.prototype._useSVG = function(t) {
      var e = Za.getGeoResource(t);
      if (e && e.type === "geoSVG") {
        var n = e.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = t;
      }
    }, r.prototype._freeSVG = function() {
      var t = this._svgMapName;
      if (t != null) {
        var e = Za.getGeoResource(t);
        e && e.type === "geoSVG" && e.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(t, e, n, i) {
      var a = t.coordinateSystem, o = this._controller, s = this._controllerHost;
      s.zoomLimit = t.get("scaleLimit"), s.zoom = a.getZoom(), o.enable(t.get("roam") || !1, {
        api: i,
        zInfo: {
          component: t
        },
        triggerInfo: {
          roamTrigger: t.get("roamTrigger"),
          isInSelf: function(c, f, h) {
            return a.containPoint([f, h]);
          },
          isInClip: function(c, f, h) {
            return !e || e.contain(f, h);
          }
        }
      });
      var l = t.mainType;
      function u() {
        var c = {
          type: "geoRoam",
          componentType: l
        };
        return c[l + "Id"] = t.id, c;
      }
      o.off("pan").on("pan", function(c) {
        this._mouseDownFlag = !1, Vb(s, c.dx, c.dy), i.dispatchAction(j(u(), {
          dx: c.dx,
          dy: c.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), o.off("zoom").on("zoom", function(c) {
        this._mouseDownFlag = !1, Fb(s, c.scale, c.originX, c.originY), i.dispatchAction(j(u(), {
          totalZoom: s.zoom,
          zoom: c.scale,
          originX: c.originX,
          originY: c.originY,
          animation: {
            duration: 0
          }
        }));
      }, this);
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(t) {
        var e = t.getTextContent();
        e && (e.ignore = Y3(e).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(t, e, n, i) {
      var a = this;
      e.off("mousedown"), e.off("click"), t.get("selectedMode") && (e.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), e.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, r;
  }()
);
function MD(r, t, e, n) {
  var i = n.getModel("itemStyle"), a = n.getModel(["emphasis", "itemStyle"]), o = n.getModel(["blur", "itemStyle"]), s = n.getModel(["select", "itemStyle"]), l = gp(i), u = gp(a), c = gp(s), f = gp(o), h = r.data;
  if (h) {
    var d = h.getItemVisual(e, "style"), p = h.getItemVisual(e, "decal");
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = oc(p, r.api));
  }
  t.setStyle(l), t.style.strokeNoScale = !0, t.ensureState("emphasis").style = u, t.ensureState("select").style = c, t.ensureState("blur").style = f, gl(t);
}
function TD(r, t, e, n, i, a, o) {
  var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
  if (l || u || c && c.showLabel) {
    var f = l ? e : a, h = void 0;
    (!s || a >= 0) && (h = i);
    var d = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    Cr(t, xr(n), {
      labelFetcher: h,
      labelDataIndex: f,
      defaultText: e
    }, d);
    var p = t.getTextContent();
    if (p && (Y3(p).ignore = p.ignore, t.textConfig && o)) {
      var g = t.getBoundingRect().clone();
      t.textConfig.layoutRect = g, t.textConfig.position = [(o[0] - g.x) / g.width * 100 + "%", (o[1] - g.y) / g.height * 100 + "%"];
    }
    t.disableLabelAnimation = !0;
  } else
    t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
}
function AD(r, t, e, n, i, a) {
  r.data ? r.data.setItemGraphicEl(a, t) : zt(t).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: e,
    region: n && n.option || {}
  };
}
function ED(r, t, e, n, i) {
  r.data || ja({
    el: t,
    componentModel: i,
    itemName: e,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: n.get("tooltip")
  });
}
function CD(r, t, e, n, i) {
  t.highDownSilentOnTouch = !!i.get("selectedMode");
  var a = n.getModel("emphasis"), o = a.get("focus");
  return He(t, o, a.get("blurScope"), a.get("disabled")), r.isGeo && m7(t, i, e), o;
}
function DD(r, t, e) {
  var n = [], i;
  function a() {
    i = [];
  }
  function o() {
    i.length && (n.push(i), i = []);
  }
  var s = t({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !e && s.polygonStart(), L(r, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !e && s.polygonEnd(), n;
}
var gJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !e.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === e.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (e.needsDrawMap) {
            var s = this._mapDraw || new $3(i);
            o.add(s.group), s.draw(e, n, i, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          e.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(e, n, i);
        }
      }
    }, t.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, t.prototype._renderSymbols = function(e, n, i) {
      var a = e.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, f = u.offset, h = new Ka({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: e.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + f * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (f ? 0 : wc + 1)
            });
            if (!f) {
              var d = e.mainSeries.getData(), p = a.getName(l), g = d.indexOfName(p), v = a.getItemModel(l), m = v.getModel("label"), y = d.getItemGraphicEl(g);
              Cr(h, xr(v), {
                labelFetcher: {
                  getFormattedLabel: function(_, x) {
                    return e.getFormattedLabel(g, x);
                  }
                },
                defaultText: p
              }), h.disableLabelAnimation = !0, m.get("position") || h.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(_) {
                Nv(h, _);
              };
            }
            o.add(h);
          }
        }
      });
    }, t.type = "map", t;
  }(Re)
), mJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.needsDrawMap = !1, e.seriesGroup = [], e.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, e;
    }
    return t.prototype.getInitialData = function(e) {
      for (var n = Nc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(ib, this)
      }), i = wt(), a = [], o = 0, s = n.count(); o < s; o++) {
        var l = n.getName(o);
        i.set(l, o);
      }
      var u = Za.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return L(u.regions, function(c) {
        var f = c.name, h = i.get(f), d = c.properties && c.properties.echartsStyle, p;
        h == null ? (p = {
          name: f
        }, a.push(p)) : p = n.getRawDataItem(h), d && qt(p, d);
      }), n.appendData(a), n;
    }, t.prototype.getHostGeoModel = function() {
      if (GN(this).kind !== Gi.boxCoordSys)
        return this.getReferringComponents("geo", {
          useDefault: !1,
          enableAll: !1,
          enableNone: !1
        }).models[0];
    }, t.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, t.prototype.getRawValue = function(e) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), e);
    }, t.prototype.getRegionModel = function(e) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(e));
    }, t.prototype.formatTooltip = function(e, n, i) {
      for (var a = this.getData(), o = this.getRawValue(e), s = a.getName(e), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var f = l[c].originalData.indexOfName(s), h = a.mapDimension("value");
        isNaN(l[c].originalData.get(h, f)) || u.push(l[c].name);
      }
      return fr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [fr("nameValue", {
          name: s,
          value: o
        })]
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.getLegendIcon = function(e) {
      var n = e.icon || "roundRect", i = hr(n, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill);
      return i.setStyle(e.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = X.color.neutral00, i.style.lineWidth = 2), i;
    }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = {
      // 
      // zlevel: 0,
      // 
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: X.color.tertiary
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: X.color.border,
        areaColor: X.color.background
      },
      emphasis: {
        label: {
          show: !0,
          color: X.color.primary
        },
        itemStyle: {
          areaColor: X.color.highlight
        }
      },
      select: {
        label: {
          show: !0,
          color: X.color.primary
        },
        itemStyle: {
          color: X.color.highlight
        }
      },
      nameProperty: "name"
    }, t;
  }(ke)
);
function yJ(r, t) {
  var e = {};
  return L(r, function(n) {
    n.each(n.mapDimension("value"), function(i, a) {
      var o = "ec-" + n.getName(a);
      e[o] = e[o] || [], isNaN(i) || e[o].push(i);
    });
  }), r[0].map(r[0].mapDimension("value"), function(n, i) {
    for (var a = "ec-" + r[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = e[a].length, c = 0; c < u; c++)
      s = Math.min(s, e[a][c]), l = Math.max(l, e[a][c]), o += e[a][c];
    var f;
    return t === "min" ? f = s : t === "max" ? f = l : t === "average" ? f = o / u : f = o, u === 0 ? NaN : f;
  });
}
function _J(r) {
  var t = {};
  r.eachSeriesByType("map", function(e) {
    var n = e.getHostGeoModel(), i = n ? "o" + n.id : "i" + e.getMapType();
    (t[i] = t[i] || []).push(e);
  }), L(t, function(e, n) {
    for (var i = yJ(rt(e, function(o) {
      return o.getData();
    }), e[0].get("mapValueCalculation")), a = 0; a < e.length; a++)
      e[a].originalData = e[a].getData();
    for (var a = 0; a < e.length; a++)
      e[a].seriesGroup = e, e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel(), e[a].setData(i.cloneShallow()), e[a].mainSeries = e[0];
  });
}
function xJ(r) {
  var t = {};
  r.eachSeriesByType("map", function(e) {
    var n = e.getMapType();
    if (!(e.getHostGeoModel() || t[n])) {
      var i = {};
      L(e.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var f = l.getName(c), h = s.getRegion(f);
          if (!(!h || isNaN(u))) {
            var d = i[f] || 0, p = s.dataToPoint(h.getCenter());
            i[f] = d + 1, l.setItemLayout(c, {
              point: p,
              offset: d
            });
          }
        });
      });
      var a = e.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !i[s], a.setItemLayout(o, l);
      }), t[n] = !0;
    }
  });
}
var LD = nr, Nl = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      var i = r.call(this) || this;
      return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new La(), i._rawTransformable = new La(), i.name = e, i._opt = n, i;
    }
    return t.prototype.setBoundingRect = function(e, n, i, a) {
      return this._rect = new Vt(e, n, i, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(e, n, i, a) {
      this._transformTo(e, n, i, a), this._viewRect = new Vt(e, n, i, a);
    }, t.prototype._transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Vt(e, n, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(e) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && e && (e = [dt(e[0], n.api.getWidth()), dt(e[1], n.api.getWidth())]), this._centerOption = Dt(e), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(e) {
      this._zoom = zb(e || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var e = this.getBoundingRect(), n = e.x + e.width / 2, i = e.y + e.height / 2;
      return [n, i];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var e = this._centerOption, n = this._rect;
      e && n && (this._center = [dt(e[0], n.width, n.x), dt(e[1], n.height, n.y)]);
      var i = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, o = this.getDefaultCenter(), s = this.getCenter(), l = this.getZoom();
      s = nr([], s, i), o = nr([], o, i), a.originX = s[0], a.originY = s[1], a.x = o[0] - s[0], a.y = o[1] - s[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var e = this._roamTransformable, n = this._rawTransformable;
      n.parent = e, e.updateTransform(), n.updateTransform(), Hg(this.transform || (this.transform = []), n.transform || Br()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], bi(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var e = this._rawTransformable, n = this._roamTransformable, i = new La();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: e.x,
          y: e.y,
          scaleX: e.scaleX,
          scaleY: e.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var e = this.getBoundingRect().clone();
      return e.applyTransform(this.transform), e;
    }, t.prototype.dataToPoint = function(e, n, i) {
      var a = n ? this._rawTransform : this.transform;
      return i = i || [], a ? LD(i, e, a) : rn(i, e);
    }, t.prototype.pointToData = function(e, n, i) {
      i = i || [];
      var a = this.invTransform;
      return a ? LD(i, e, a) : (i[0] = e[0], i[1] = e[1], i);
    }, t.prototype.convertToPixel = function(e, n, i) {
      var a = RD(n);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, n, i) {
      var a = RD(n);
      return a === this ? a.pointToData(i) : null;
    }, t.prototype.containPoint = function(e) {
      return this.getViewRectAfterRoam().contain(e[0], e[1]);
    }, t.dimensions = ["x", "y"], t;
  }(La)
);
function RD(r) {
  var t = r.seriesModel;
  return t ? t.coordinateSystem : null;
}
var SJ = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, Z3 = ["lng", "lat"], AS = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, {
        api: i.api,
        ecModel: i.ecModel
      }) || this;
      a.dimensions = Z3, a.type = "geo", a._nameCoordMap = wt(), a.map = n;
      var o = i.projection, s = Za.load(n, i.nameMap, i.nameProperty), l = Za.getGeoResource(n), u = a.resourceType = l ? l.type : null, c = a.regions = s.regions, f = SJ[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, process.env.NODE_ENV !== "production" && o && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && Ye("Map " + n + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || (process.env.NODE_ENV !== "production" && Ye("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
      var h;
      if (o)
        for (var d = 0; d < c.length; d++) {
          var p = c[d].getBoundingRect(o);
          h = h || p.clone(), h.union(p);
        }
      else
        h = s.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = o ? 1 : bt(i.aspectScale, f.aspectScale), a._invertLongitute = o ? !1 : f.invertLongitute, a;
    }
    return t.prototype._transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Vt(e, n, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, t.prototype.getRegion = function(e) {
      return this._regionsMap.get(e);
    }, t.prototype.getRegionByCoord = function(e) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var a = n[i];
        if (a.type === "geoJSON" && a.contain(e))
          return n[i];
      }
    }, t.prototype.addGeoCoord = function(e, n) {
      this._nameCoordMap.set(e, n);
    }, t.prototype.getGeoCoord = function(e) {
      var n = this._regionsMap.get(e);
      return this._nameCoordMap.get(e) || n && n.getCenter();
    }, t.prototype.dataToPoint = function(e, n, i) {
      if (pt(e) && (e = this.getGeoCoord(e)), e) {
        var a = this.projection;
        return a && (e = a.project(e)), e && this.projectedToPoint(e, n, i);
      }
    }, t.prototype.pointToData = function(e, n, i) {
      var a = this.projection;
      return a && (e = a.unproject(e)), e && this.pointToProjected(e, i);
    }, t.prototype.pointToProjected = function(e, n) {
      return r.prototype.pointToData.call(this, e, 0, n);
    }, t.prototype.projectedToPoint = function(e, n, i) {
      return r.prototype.dataToPoint.call(this, e, n, i);
    }, t.prototype.convertToPixel = function(e, n, i) {
      var a = ID(n);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, n, i) {
      var a = ID(n);
      return a === this ? a.pointToData(i) : null;
    }, t;
  }(Nl)
);
dr(AS, Nl);
function ID(r) {
  var t = r.geoModel, e = r.seriesModel;
  return t ? t.coordinateSystem : e ? e.coordinateSystem || (e.getReferringComponents("geo", je).models[0] || {}).coordinateSystem : null;
}
function PD(r, t) {
  var e = r.get("boundingCoords");
  if (e != null) {
    var n = e[0], i = e[1];
    if (!(isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var a = this.projection;
      if (a) {
        var o = n[0], s = n[1], l = i[0], u = i[1];
        n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(b, S, w, A) {
          for (var T = w - b, M = A - S, C = 0; C <= 100; C++) {
            var R = C / 100, E = a.project([b + T * R, S + M * R]);
            bo(n, n, E), wo(i, i, E);
          }
        };
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
    }
  }
  var f = this.getBoundingRect(), h = r.get("layoutCenter"), d = r.get("layoutSize"), p = Sr(r, t).refContainer, g = f.width / f.height * this.aspectScale, v = !1, m, y;
  h && d && (m = [dt(h[0], p.width) + p.x, dt(h[1], p.height) + p.y], y = dt(d, Math.min(p.width, p.height)), !isNaN(m[0]) && !isNaN(m[1]) && !isNaN(y) ? v = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var _;
  if (v)
    _ = {}, g > 1 ? (_.width = y, _.height = y / g) : (_.height = y, _.width = y * g), _.y = m[1] - _.height / 2, _.x = m[0] - _.width / 2;
  else {
    var x = r.getBoxLayoutParams();
    x.aspect = g, _ = We(x, p), _ = $N(r, _, g);
  }
  this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(r.get("center")), this.setZoom(r.get("zoom"));
}
function bJ(r, t) {
  L(t.get("geoCoord"), function(e, n) {
    r.addGeoCoord(n, e);
  });
}
var wJ = (
  /** @class */
  function() {
    function r() {
      this.dimensions = Z3;
    }
    return r.prototype.create = function(t, e) {
      var n = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      t.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new AS(l + s, l, j({
          nameMap: o.get("nameMap"),
          api: e,
          ecModel: t
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), n.push(u), o.coordinateSystem = u, u.model = o, u.resize = PD, u.resize(o, e);
      }), t.eachSeries(function(o) {
        Uh({
          targetModel: o,
          coordSysType: "geo",
          coordSysProvider: function() {
            var s = o.subType === "map" ? o.getHostGeoModel() : o.getReferringComponents("geo", je).models[0];
            return s && s.coordinateSystem;
          },
          allowNotFound: !0
        });
      });
      var a = {};
      return t.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), L(a, function(o, s) {
        var l = rt(o, function(c) {
          return c.get("nameMap");
        }), u = new AS(s, s, j({
          nameMap: b1(l),
          api: e,
          ecModel: t
        }, i(o[0])));
        u.zoomLimit = mr.apply(null, rt(o, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = PD, u.resize(o[0], e), L(o, function(c) {
          c.coordinateSystem = u, bJ(u, c);
        });
      }), n;
    }, r.prototype.getFilledRegions = function(t, e, n, i) {
      for (var a = (t || []).slice(), o = wt(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = Za.load(e, n, i);
      return L(l.regions, function(u) {
        var c = u.name, f = o.get(c), h = u.properties && u.properties.echartsStyle;
        f || (f = {
          name: c
        }, a.push(f)), h && qt(f, h);
      }), a;
    }, r;
  }()
), q3 = new wJ(), MJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
      var a = Za.getGeoResource(e.map);
      if (a && a.type === "geoJSON") {
        var o = e.itemStyle = e.itemStyle || {};
        "color" in o || (o.color = e.defaultItemStyleColor || X.color.backgroundTint);
      }
      dl(e, "label", ["show"]);
    }, t.prototype.optionUpdated = function() {
      var e = this, n = this.option;
      n.regions = q3.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = ra(n.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new ue(o, e, e.ecModel)), o.selected && (i[s] = !0)), a;
      }, wt()), n.selectedMap || (n.selectedMap = i);
    }, t.prototype.getRegionModel = function(e) {
      return this._optionModelMap.get(e) || new ue(null, this, this.ecModel);
    }, t.prototype.getFormattedLabel = function(e, n) {
      var i = this.getRegionModel(e), a = n === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), o = {
        name: e
      };
      if (At(a))
        return o.status = n, a(o);
      if (pt(a))
        return a.replace("{a}", e ?? "");
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.select = function(e) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var a = n.selectedMap || (n.selectedMap = {});
        a[e] = !0;
      }
    }, t.prototype.unSelect = function(e) {
      var n = this.option.selectedMap;
      n && (n[e] = !1);
    }, t.prototype.toggleSelected = function(e) {
      this[this.isSelected(e) ? "unSelect" : "select"](e);
    }, t.prototype.isSelected = function(e) {
      var n = this.option.selectedMap;
      return !!(n && n[e]);
    }, t.type = "geo", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: X.color.tertiary
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: X.color.border
      },
      emphasis: {
        label: {
          show: !0,
          color: X.color.primary
        },
        itemStyle: {
          color: X.color.highlight
        }
      },
      select: {
        label: {
          show: !0,
          color: X.color.primary
        },
        itemStyle: {
          color: X.color.highlight
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, t;
  }(re)
), TJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.focusBlurEnabled = !0, e;
    }
    return t.prototype.init = function(e, n) {
      this._api = n;
    }, t.prototype.render = function(e, n, i, a) {
      if (this._model = e, !e.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new $3(i));
      var o = this._mapDraw;
      o.draw(e, n, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = e.get("silent"), this.group.add(o.group), this.updateSelectStatus(e, n, i);
    }, t.prototype._handleRegionClick = function(e) {
      var n;
      Qs(e.target, function(i) {
        return (n = zt(i).eventData) != null;
      }, !0), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, t.prototype.updateSelectStatus = function(e, n, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = zt(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0;
      });
    }, t.prototype.findHighDownDispatchers = function(e) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model);
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, t.type = "geo", t;
  }(Ge)
);
function AJ(r, t, e) {
  Za.registerMap(r, t, e);
}
function K3(r) {
  r.registerCoordinateSystem("geo", q3), r.registerComponentModel(MJ), r.registerComponentView(TJ), r.registerImpl("registerMap", AJ), r.registerImpl("getMap", function(e) {
    return Za.getMapForUser(e);
  });
  function t(e, n) {
    n.update = "geo:updateSelectStatus", r.registerAction(n, function(i, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[e](i.name);
        var u = l.coordinateSystem;
        L(u.regions, function(f) {
          o[f.name] = l.isSelected(f.name) || !1;
        });
        var c = [];
        L(o, function(f, h) {
          o[h] && c.push(h);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: o,
        allSelected: s,
        name: i.name
      };
    });
  }
  t("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), t("select", {
    type: "geoSelect",
    event: "geoselected"
  }), t("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), r.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(e, n, i) {
    var a = e.componentType;
    a || (e.geoId != null ? a = "geo" : e.seriesId != null && (a = "series")), a || (a = "series"), n.eachComponent({
      mainType: a,
      query: e
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = xm(s, e, o.get("scaleLimit"));
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && L(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function EJ(r) {
  jt(K3), r.registerChartView(gJ), r.registerSeriesModel(mJ), r.registerLayout(xJ), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, _J), kO("map", r.registerAction);
}
function CJ(r) {
  var t = r;
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var e = [t], n, i; n = e.pop(); )
    if (i = n.children, n.isExpand && i.length)
      for (var a = i.length, o = a - 1; o >= 0; o--) {
        var s = i[o];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null
        }, e.push(s);
      }
}
function DJ(r, t) {
  var e = r.isExpand ? r.children : [], n = r.parentNode.children, i = r.hierNode.i ? n[r.hierNode.i - 1] : null;
  if (e.length) {
    RJ(r);
    var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2;
    i ? (r.hierNode.prelim = i.hierNode.prelim + t(r, i), r.hierNode.modifier = r.hierNode.prelim - a) : r.hierNode.prelim = a;
  } else
    i && (r.hierNode.prelim = i.hierNode.prelim + t(r, i));
  r.parentNode.hierNode.defaultAncestor = IJ(r, i, r.parentNode.hierNode.defaultAncestor || n[0], t);
}
function LJ(r) {
  var t = r.hierNode.prelim + r.parentNode.hierNode.modifier;
  r.setLayout({
    x: t
  }, !0), r.hierNode.modifier += r.parentNode.hierNode.modifier;
}
function ND(r) {
  return arguments.length ? r : OJ;
}
function kf(r, t) {
  return r -= Math.PI / 2, {
    x: t * Math.cos(r),
    y: t * Math.sin(r)
  };
}
function RJ(r) {
  for (var t = r.children, e = t.length, n = 0, i = 0; --e >= 0; ) {
    var a = t[e];
    a.hierNode.prelim += n, a.hierNode.modifier += n, i += a.hierNode.change, n += a.hierNode.shift + i;
  }
}
function IJ(r, t, e, n) {
  if (t) {
    for (var i = r, a = r, o = a.parentNode.children[0], s = t, l = i.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, f = s.hierNode.modifier; s = V0(s), a = F0(a), s && a; ) {
      i = V0(i), o = F0(o), i.hierNode.ancestor = r;
      var h = s.hierNode.prelim + f - a.hierNode.prelim - u + n(s, a);
      h > 0 && (NJ(PJ(s, r, e), r, h), u += h, l += h), f += s.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += o.hierNode.modifier;
    }
    s && !V0(i) && (i.hierNode.thread = s, i.hierNode.modifier += f - l), a && !F0(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, e = r);
  }
  return e;
}
function V0(r) {
  var t = r.children;
  return t.length && r.isExpand ? t[t.length - 1] : r.hierNode.thread;
}
function F0(r) {
  var t = r.children;
  return t.length && r.isExpand ? t[0] : r.hierNode.thread;
}
function PJ(r, t, e) {
  return r.hierNode.ancestor.parentNode === t.parentNode ? r.hierNode.ancestor : e;
}
function NJ(r, t, e) {
  var n = e / (t.hierNode.i - r.hierNode.i);
  t.hierNode.change -= n, t.hierNode.shift += e, t.hierNode.modifier += e, t.hierNode.prelim += e, r.hierNode.change += n;
}
function OJ(r, t) {
  return r.parentNode === t.parentNode ? 1 : 2;
}
var kJ = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.parentPoint = [], this.childPoints = [];
    }
    return r;
  }()
), BJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: X.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new kJ();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.childPoints, a = i.length, o = n.parentPoint, s = i[0], l = i[a - 1];
      if (a === 1) {
        e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, f = 1 - c, h = dt(n.forkPosition, 1), d = [];
      d[c] = o[c], d[f] = o[f] + (l[f] - o[f]) * h, e.moveTo(o[0], o[1]), e.lineTo(d[0], d[1]), e.moveTo(s[0], s[1]), d[c] = s[c], e.lineTo(d[0], d[1]), d[c] = l[c], e.lineTo(d[0], d[1]), e.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = i[p];
        e.moveTo(g[0], g[1]), d[c] = g[c], e.lineTo(d[0], d[1]);
      }
    }, t;
  }(ne)
), VJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._mainGroup = new Ct(), e;
    }
    return t.prototype.init = function(e, n) {
      this._controller = new Pl(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = e.layoutInfo, s = this._mainGroup, l = e.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(e, i), this._updateController(e, null, n, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        OD(a, c) && kD(a, c, null, s, e);
      }).update(function(c, f) {
        var h = u.getItemGraphicEl(f);
        if (!OD(a, c)) {
          h && VD(u, f, h, s, e);
          return;
        }
        kD(a, c, h, s, e);
      }).remove(function(c) {
        var f = u.getItemGraphicEl(c);
        f && VD(u, c, f, s, e);
      }).execute(), this._nodeScaleRatio = e.get("nodeScaleRatio"), this._updateNodeAndLinkScale(e), e.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(c, f) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: e.id,
            dataIndex: f
          });
        });
      }), this._data = a;
    }, t.prototype._updateViewCoordSys = function(e, n) {
      var i = e.getData(), a = [];
      i.each(function(f) {
        var h = i.getItemLayout(f);
        h && !isNaN(h.x) && !isNaN(h.y) && a.push([+h.x, +h.y]);
      });
      var o = [], s = [];
      Jg(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = e.coordinateSystem = new Nl(null, {
        api: n,
        ecModel: e.ecModel
      });
      c.zoomLimit = e.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(e.get("center")), c.setZoom(e.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, t.prototype._updateController = function(e, n, i, a) {
      var o = this;
      U3(e, a, this.group, this._controller, this._controllerHost, n), this._controller.on("zoom", function(s) {
        o._updateNodeAndLinkScale(e);
      });
    }, t.prototype._updateNodeAndLinkScale = function(e) {
      var n = e.getData(), i = this._getNodeGlobalScale(e);
      n.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(i);
      });
    }, t.prototype._getNodeGlobalScale = function(e) {
      var n = e.coordinateSystem;
      if (n.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, a = n.scaleX || 1, o = n.getZoom(), s = (o - 1) * i + 1;
      return s / a;
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, t.type = "tree", t;
  }(Re)
);
function OD(r, t) {
  var e = r.getItemLayout(t);
  return e && !isNaN(e.x) && !isNaN(e.y);
}
function kD(r, t, e, n, i) {
  var a = !e, o = r.tree.getNodeByDataIndex(t), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === !1 && o.children.length !== 0 ? l : X.color.neutral00, c = r.tree.root, f = o.parentNode === c ? o : o.parentNode || o, h = r.getItemGraphicEl(f.dataIndex), d = f.getLayout(), p = h ? {
    x: h.__oldX,
    y: h.__oldY,
    rawX: h.__radialOldRawX,
    rawY: h.__radialOldRawY
  } : d, g = o.getLayout();
  a ? (e = new Xh(r, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), e.x = p.x, e.y = p.y) : e.updateData(r, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), e.__radialOldRawX = e.__radialRawX, e.__radialOldRawY = e.__radialRawY, e.__radialRawX = g.rawX, e.__radialRawY = g.rawY, n.add(e), r.setItemGraphicEl(t, e), e.__oldX = e.x, e.__oldY = e.y, ve(e, {
    x: g.x,
    y: g.y
  }, i);
  var v = e.getSymbolPath();
  if (i.get("layout") === "radial") {
    var m = c.children[0], y = m.getLayout(), _ = m.children.length, x = void 0, b = void 0;
    if (g.x === y.x && o.isExpand === !0 && m.children.length) {
      var S = {
        x: (m.children[0].getLayout().x + m.children[_ - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[_ - 1].getLayout().y) / 2
      };
      x = Math.atan2(S.y - y.y, S.x - y.x), x < 0 && (x = Math.PI * 2 + x), b = S.x < y.x, b && (x = x - Math.PI);
    } else
      x = Math.atan2(g.y - y.y, g.x - y.x), x < 0 && (x = Math.PI * 2 + x), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (b = g.x < y.x, b && (x = x - Math.PI)) : (b = g.x > y.x, b || (x = x - Math.PI));
    var w = b ? "left" : "right", A = s.getModel("label"), T = A.get("rotate"), M = T * (Math.PI / 180), C = v.getTextContent();
    C && (v.setTextConfig({
      position: A.get("position") || w,
      rotation: T == null ? -x : M,
      origin: "center"
    }), C.setStyle("verticalAlign", "middle"));
  }
  var R = s.get(["emphasis", "focus"]), E = R === "relative" ? eh(o.getAncestorsIndices(), o.getDescendantIndices()) : R === "ancestor" ? o.getAncestorsIndices() : R === "descendant" ? o.getDescendantIndices() : null;
  E && (zt(e).focus = E), FJ(i, o, c, e, p, d, g, n), e.__edge && (e.onHoverStateChange = function(D) {
    if (D !== "blur") {
      var I = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex);
      I && I.hoverState === Oh || Nv(e.__edge, D);
    }
  });
}
function FJ(r, t, e, n, i, a, o, s) {
  var l = t.getModel(), u = r.get("edgeShape"), c = r.get("layout"), f = r.getOrient(), h = r.get(["lineStyle", "curveness"]), d = r.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = n.__edge;
  if (u === "curve")
    t.parentNode && t.parentNode !== e && (g || (g = n.__edge = new Bh({
      shape: ES(c, f, h, i, i)
    })), ve(g, {
      shape: ES(c, f, h, a, o)
    }, r));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (t !== e && t.children && t.children.length !== 0 && t.isExpand === !0) {
        for (var v = t.children, m = [], y = 0; y < v.length; y++) {
          var _ = v[y].getLayout();
          m.push([_.x, _.y]);
        }
        g || (g = n.__edge = new BJ({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: f,
            forkPosition: d
          }
        })), ve(g, {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: m
          }
        }, r);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !t.isExpand) && (g.useStyle(Bt({
    strokeNoScale: !0,
    fill: null
  }, p)), _r(g, l, "lineStyle"), gl(g), s.add(g));
}
function BD(r, t, e, n, i) {
  var a = t.tree.root, o = j3(a, r), s = o.source, l = o.sourceLayout, u = t.getItemGraphicEl(r.dataIndex);
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex), f = c.__edge, h = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? f : void 0), d = n.get("edgeShape"), p = n.get("layout"), g = n.get("orient"), v = n.get(["lineStyle", "curveness"]);
    h && (d === "curve" ? Ho(h, {
      shape: ES(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        e.remove(h);
      },
      removeOpt: i
    }) : d === "polyline" && n.get("layout") === "orthogonal" && Ho(h, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        e.remove(h);
      },
      removeOpt: i
    }));
  }
}
function j3(r, t) {
  for (var e = t.parentNode === r ? t : t.parentNode || t, n; n = e.getLayout(), n == null; )
    e = e.parentNode === r ? e : e.parentNode || e;
  return {
    source: e,
    sourceLayout: n
  };
}
function VD(r, t, e, n, i) {
  var a = r.tree.getNodeByDataIndex(t), o = r.tree.root, s = j3(o, a).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  Ho(e, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      n.remove(e), r.setItemGraphicEl(t, null);
    },
    removeOpt: l
  }), e.fadeOut(null, r.hostModel, {
    fadeLabel: !0,
    animation: l
  }), a.children.forEach(function(u) {
    BD(u, r, n, i, l);
  }), BD(a, r, n, i, l);
}
function ES(r, t, e, n, i) {
  var a, o, s, l, u, c, f, h;
  if (r === "radial") {
    u = n.rawX, f = n.rawY, c = i.rawX, h = i.rawY;
    var d = kf(u, f), p = kf(u, f + (h - f) * e), g = kf(c, h + (f - h) * e), v = kf(c, h);
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = n.x, f = n.y, c = i.x, h = i.y, (t === "LR" || t === "RL") && (a = u + (c - u) * e, o = f, s = c + (u - c) * e, l = h), (t === "TB" || t === "BT") && (a = u, o = f + (h - f) * e, s = c, l = h + (f - h) * e);
  return {
    x1: u,
    y1: f,
    x2: c,
    y2: h,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l
  };
}
var ii = ee();
function J3(r) {
  var t = r.mainData, e = r.datas;
  e || (e = {
    main: t
  }, r.datasAttr = {
    main: "data"
  }), r.datas = r.mainData = null, Q3(t, e, r), L(e, function(n) {
    L(t.TRANSFERABLE_METHODS, function(i) {
      n.wrapMethod(i, Yt(zJ, r));
    });
  }), t.wrapMethod("cloneShallow", Yt(GJ, r)), L(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, Yt(UJ, r));
  }), St(e[t.dataType] === t);
}
function zJ(r, t) {
  if (XJ(this)) {
    var e = j({}, ii(this).datas);
    e[this.dataType] = t, Q3(t, e, r);
  } else
    Gb(t, this.dataType, ii(this).mainData, r);
  return t;
}
function UJ(r, t) {
  return r.struct && r.struct.update(), t;
}
function GJ(r, t) {
  return L(ii(t).datas, function(e, n) {
    e !== t && Gb(e.cloneShallow(), n, t, r);
  }), t;
}
function HJ(r) {
  var t = ii(this).mainData;
  return r == null || t == null ? t : ii(t).datas[r];
}
function WJ() {
  var r = ii(this).mainData;
  return r == null ? [{
    data: r
  }] : rt(se(ii(r).datas), function(t) {
    return {
      type: t,
      data: ii(r).datas[t]
    };
  });
}
function XJ(r) {
  return ii(r).mainData === r;
}
function Q3(r, t, e) {
  ii(r).datas = {}, L(t, function(n, i) {
    Gb(n, i, r, e);
  });
}
function Gb(r, t, e, n) {
  ii(e).datas[t] = r, ii(r).mainData = e, r.dataType = t, n.struct && (r[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = r), r.getLinkedData = HJ, r.getLinkedDataAll = WJ;
}
var YJ = (
  /** @class */
  function() {
    function r(t, e) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || "", this.hostTree = e;
    }
    return r.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, r.prototype.eachNode = function(t, e, n) {
      At(t) && (n = e, e = t, t = null), t = t || {}, pt(t) && (t = {
        order: t
      });
      var i = t.order || "preorder", a = this[t.attr || "children"], o;
      i === "preorder" && (o = e.call(n, this));
      for (var s = 0; !o && s < a.length; s++)
        a[s].eachNode(t, e, n);
      i === "postorder" && e.call(n, this);
    }, r.prototype.updateDepthAndHeight = function(t) {
      var e = 0;
      this.depth = t;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height);
      }
      this.height = e + 1;
    }, r.prototype.getNodeById = function(t) {
      if (this.getId() === t)
        return this;
      for (var e = 0, n = this.children, i = n.length; e < i; e++) {
        var a = n[e].getNodeById(t);
        if (a)
          return a;
      }
    }, r.prototype.contains = function(t) {
      if (t === this)
        return !0;
      for (var e = 0, n = this.children, i = n.length; e < i; e++) {
        var a = n[e].contains(t);
        if (a)
          return a;
      }
    }, r.prototype.getAncestors = function(t) {
      for (var e = [], n = t ? this : this.parentNode; n; )
        e.push(n), n = n.parentNode;
      return e.reverse(), e;
    }, r.prototype.getAncestorsIndices = function() {
      for (var t = [], e = this; e; )
        t.push(e.dataIndex), e = e.parentNode;
      return t.reverse(), t;
    }, r.prototype.getDescendantIndices = function() {
      var t = [];
      return this.eachNode(function(e) {
        t.push(e.dataIndex);
      }), t;
    }, r.prototype.getValue = function(t) {
      var e = this.hostTree.data;
      return e.getStore().get(e.getDimensionIndex(t || "value"), this.dataIndex);
    }, r.prototype.setLayout = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
    }, r.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostTree, n = e.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, r.prototype.setVisual = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
    }, r.prototype.getVisual = function(t) {
      return this.hostTree.data.getItemVisual(this.dataIndex, t);
    }, r.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, r.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, r.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var t = this.parentNode.children, e = 0; e < t.length; ++e)
          if (t[e] === this)
            return e;
        return -1;
      }
      return -1;
    }, r.prototype.isAncestorOf = function(t) {
      for (var e = t.parentNode; e; ) {
        if (e === this)
          return !0;
        e = e.parentNode;
      }
      return !1;
    }, r.prototype.isDescendantOf = function(t) {
      return t !== this && t.isAncestorOf(this);
    }, r;
  }()
), Hb = (
  /** @class */
  function() {
    function r(t) {
      this.type = "tree", this._nodes = [], this.hostModel = t;
    }
    return r.prototype.eachNode = function(t, e, n) {
      this.root.eachNode(t, e, n);
    }, r.prototype.getNodeByDataIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this._nodes[e];
    }, r.prototype.getNodeById = function(t) {
      return this.root.getNodeById(t);
    }, r.prototype.update = function() {
      for (var t = this.data, e = this._nodes, n = 0, i = e.length; n < i; n++)
        e[n].dataIndex = -1;
      for (var n = 0, i = t.count(); n < i; n++)
        e[t.getRawIndex(n)].dataIndex = n;
    }, r.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, r.createTree = function(t, e, n) {
      var i = new r(e), a = [], o = 1;
      s(t);
      function s(c, f) {
        var h = c.value;
        o = Math.max(o, et(h) ? h.length : 1), a.push(c);
        var d = new YJ(yr(c.name, ""), i);
        f ? $J(d, f) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = Hh(a, {
        coordDimensions: ["value"],
        dimensionsCount: o
      }).dimensions, u = new cn(l, e);
      return u.initData(a), n && n(u), J3({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, r;
  }()
);
function $J(r, t) {
  var e = t.children;
  r.parentNode !== t && (e.push(r), r.parentNode = t);
}
function Sh(r, t, e) {
  if (r && Zt(t, r.type) >= 0) {
    var n = e.getData().tree.root, i = r.targetNode;
    if (pt(i) && (i = n.getNodeById(i)), i && n.contains(i))
      return {
        node: i
      };
    var a = r.targetNodeId;
    if (a != null && (i = n.getNodeById(a)))
      return {
        node: i
      };
  }
}
function tB(r) {
  for (var t = []; r; )
    r = r.parentNode, r && t.push(r);
  return t.reverse();
}
function Wb(r, t) {
  var e = tB(r);
  return Zt(e, t) >= 0;
}
function bm(r, t) {
  for (var e = []; r; ) {
    var n = r.dataIndex;
    e.push({
      name: r.name,
      dataIndex: n,
      value: t.getRawValue(n)
    }), r = r.parentNode;
  }
  return e.reverse(), e;
}
var ZJ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.hasSymbolVisual = !0, e.ignoreStyleOnData = !0, e;
    }
    return t.prototype.getInitialData = function(e) {
      var n = {
        name: e.name,
        children: e.data
      }, i = e.leaves || {}, a = new ue(i, this, this.ecModel), o = Hb.createTree(n, this, s);
      function s(f) {
        f.wrapMethod("getItemModel", function(h, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (h.parentModel = a), h;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(f) {
        f.depth > l && (l = f.depth);
      });
      var u = e.expandAndCollapse, c = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(f) {
        var h = f.hostTree.data.getRawDataItem(f.dataIndex);
        f.isExpand = h && h.collapsed != null ? !h.collapsed : f.depth <= c;
      }), o.data;
    }, t.prototype.getOrient = function() {
      var e = this.get("orient");
      return e === "horizontal" ? e = "LR" : e === "vertical" && (e = "TB"), e;
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.formatTooltip = function(e, n, i) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(e), l = s.getValue(), u = s.name; s && s !== o; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return fr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treeAncestors = bm(i, this), n.collapsed = !i.isExpand, n;
    }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: X.color.borderTint,
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, t;
  }(ke)
);
function qJ(r, t, e) {
  for (var n = [r], i = [], a; a = n.pop(); )
    if (i.push(a), a.isExpand) {
      var o = a.children;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          n.push(o[s]);
    }
  for (; a = i.pop(); )
    t(a, e);
}
function vf(r, t) {
  for (var e = [r], n; n = e.pop(); )
    if (t(n), n.isExpand) {
      var i = n.children;
      if (i.length)
        for (var a = i.length - 1; a >= 0; a--)
          e.push(i[a]);
    }
}
function KJ(r, t) {
  r.eachSeriesByType("tree", function(e) {
    jJ(e, t);
  });
}
function jJ(r, t) {
  var e = Sr(r, t).refContainer, n = We(r.getBoxLayoutParams(), e);
  r.layoutInfo = n;
  var i = r.get("layout"), a = 0, o = 0, s = null;
  i === "radial" ? (a = 2 * Math.PI, o = Math.min(n.height, n.width) / 2, s = ND(function(x, b) {
    return (x.parentNode === b.parentNode ? 1 : 2) / x.depth;
  })) : (a = n.width, o = n.height, s = ND());
  var l = r.getData().tree.root, u = l.children[0];
  if (u) {
    CJ(l), qJ(u, DJ, s), l.hierNode.modifier = -u.hierNode.prelim, vf(u, LJ);
    var c = u, f = u, h = u;
    vf(u, function(x) {
      var b = x.getLayout().x;
      b < c.getLayout().x && (c = x), b > f.getLayout().x && (f = x), x.depth > h.depth && (h = x);
    });
    var d = c === f ? 1 : s(c, f) / 2, p = d - c.getLayout().x, g = 0, v = 0, m = 0, y = 0;
    if (i === "radial")
      g = a / (f.getLayout().x + d + p), v = o / (h.depth - 1 || 1), vf(u, function(x) {
        m = (x.getLayout().x + p) * g, y = (x.depth - 1) * v;
        var b = kf(m, y);
        x.setLayout({
          x: b.x,
          y: b.y,
          rawX: m,
          rawY: y
        }, !0);
      });
    else {
      var _ = r.getOrient();
      _ === "RL" || _ === "LR" ? (v = o / (f.getLayout().x + d + p), g = a / (h.depth - 1 || 1), vf(u, function(x) {
        y = (x.getLayout().x + p) * v, m = _ === "LR" ? (x.depth - 1) * g : a - (x.depth - 1) * g, x.setLayout({
          x: m,
          y
        }, !0);
      })) : (_ === "TB" || _ === "BT") && (g = a / (f.getLayout().x + d + p), v = o / (h.depth - 1 || 1), vf(u, function(x) {
        m = (x.getLayout().x + p) * g, y = _ === "TB" ? (x.depth - 1) * v : o - (x.depth - 1) * v, x.setLayout({
          x: m,
          y
        }, !0);
      }));
    }
  }
}
function JJ(r) {
  r.eachSeriesByType("tree", function(t) {
    var e = t.getData(), n = e.tree;
    n.eachNode(function(i) {
      var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = e.ensureUniqueItemVisual(i.dataIndex, "style");
      j(s, o);
    });
  });
}
function QJ(r) {
  r.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(n) {
      var i = t.dataIndex, a = n.getData().tree, o = a.getNodeByDataIndex(i);
      o.isExpand = !o.isExpand;
    });
  }), r.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(i) {
      var a = i.coordinateSystem, o = xm(a, t, i.get("scaleLimit"));
      i.setCenter(o.center), i.setZoom(o.zoom);
    });
  });
}
function tQ(r) {
  r.registerChartView(VJ), r.registerSeriesModel(ZJ), r.registerLayout(KJ), r.registerVisual(JJ), QJ(r);
}
var FD = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function eQ(r) {
  for (var t = 0; t < FD.length; t++)
    r.registerAction({
      type: FD[t],
      update: "updateView"
    }, rr);
  r.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(e, n) {
    n.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: e
    }, i);
    function i(a, o) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = Sh(e, s, a);
      if (l) {
        var u = a.getViewRoot();
        u && (e.direction = Wb(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
      }
    }
  });
}
function eB(r) {
  var t = r.getData(), e = t.tree, n = {};
  e.eachNode(function(i) {
    for (var a = i; a && a.depth > 1; )
      a = a.parentNode;
    var o = Yx(r.ecModel, a.name || a.dataIndex + "", n);
    i.setVisual("decal", o);
  });
}
var rQ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventUsingHoverLayer = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = {
        name: e.name,
        children: e.data
      };
      rB(i);
      var a = e.levels || [], o = this.designatedVisualItemStyle = {}, s = new ue({
        itemStyle: o
      }, this, n);
      a = e.levels = nQ(a, n);
      var l = rt(a || [], function(f) {
        return new ue(f, s, n);
      }, this), u = Hb.createTree(i, this, c);
      function c(f) {
        f.wrapMethod("getItemModel", function(h, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return h.parentModel = g || s, h;
        });
      }
      return u.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
      return fr("nameValue", {
        name: s,
        value: o
      });
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treeAncestors = bm(i, this), n.treePathInfo = n.treeAncestors, n;
    }, t.prototype.setLayoutInfo = function(e) {
      this.layoutInfo = this.layoutInfo || {}, j(this.layoutInfo, e);
    }, t.prototype.mapIdToIndex = function(e) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = wt(), this._idIndexMapCount = 0);
      var i = n.get(e);
      return i == null && n.set(e, i = this._idIndexMapCount++), i;
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!e || e !== n && !n.contains(e)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      eB(this);
    }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: X.size.l,
      top: X.size.xxxl,
      right: X.size.l,
      bottom: X.size.xxxl,
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "",
      // to align specialized icon. 
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: {
        max: 5,
        min: 0.2
      },
      roam: !0,
      roamTrigger: "global",
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        bottom: X.size.m,
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: X.color.backgroundShade,
          textStyle: {
            color: X.color.secondary
          }
        },
        emphasis: {
          itemStyle: {
            color: X.color.background
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: X.color.neutral00,
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: X.color.neutral00,
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, t;
  }(ke)
);
function rB(r) {
  var t = 0;
  L(r.children, function(n) {
    rB(n);
    var i = n.value;
    et(i) && (i = i[0]), t += i;
  });
  var e = r.value;
  et(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), et(r.value) ? r.value[0] = e : r.value = e;
}
function nQ(r, t) {
  var e = Ie(t.get("color")), n = Ie(t.get(["aria", "decal", "decals"]));
  if (e) {
    r = r || [];
    var i, a;
    L(r, function(s) {
      var l = new ue(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (a = !0);
    });
    var o = r[0] || (r[0] = {});
    return i || (o.color = e.slice()), !a && n && (o.decal = n.slice()), r;
  }
}
var iQ = 8, zD = 8, z0 = 5, aQ = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Ct(), t.add(this.group);
    }
    return r.prototype.render = function(t, e, n, i) {
      var a = t.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !n)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), f = Sr(t, e).refContainer, h = {
          left: a.get("left"),
          right: a.get("right"),
          top: a.get("top"),
          bottom: a.get("bottom")
        }, d = {
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        }, p = We(h, f);
        this._prepare(n, d, u), this._renderContent(t, d, p, s, l, u, c, i), cm(o, h, f);
      }
    }, r.prototype._prepare = function(t, e, n) {
      for (var i = t; i; i = i.parentNode) {
        var a = yr(i.getModel().get("name"), ""), o = n.getTextRect(a), s = Math.max(o.width + iQ * 2, e.emptyItemWidth);
        e.totalWidth += s + zD, e.renderList.push({
          node: i,
          text: a,
          width: s
        });
      }
    }, r.prototype._renderContent = function(t, e, n, i, a, o, s, l) {
      for (var u = 0, c = e.emptyItemWidth, f = t.get(["breadcrumb", "height"]), h = e.totalWidth, d = e.renderList, p = a.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], m = v.node, y = v.width, _ = v.text;
        h > n.width && (h -= y - c, y = c, _ = null);
        var x = new Jr({
          shape: {
            points: oQ(u, 0, y, f, g === d.length - 1, g === 0)
          },
          style: Bt(i.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new pe({
            style: Oe(o, {
              text: _
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: wc * 1e4,
          onclick: Yt(l, m)
        });
        x.disableLabelAnimation = !0, x.getTextContent().ensureState("emphasis").style = Oe(s, {
          text: _
        }), x.ensureState("emphasis").style = p, He(x, a.get("focus"), a.get("blurScope"), a.get("disabled")), this.group.add(x), sQ(x, t, m), u += y + zD;
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r;
  }()
);
function oQ(r, t, e, n, i, a) {
  var o = [[i ? r : r - z0, t], [r + e, t], [r + e, t + n], [i ? r : r - z0, t + n]];
  return !a && o.splice(2, 0, [r + e + z0, t + n / 2]), !i && o.push([r, t + n / 2]), o;
}
function sQ(r, t, e) {
  zt(r).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: e && e.dataIndex,
      name: e && e.name
    },
    treePathInfo: e && bm(e, t)
  };
}
var lQ = (
  /** @class */
  function() {
    function r() {
      this._storage = [], this._elExistsMap = {};
    }
    return r.prototype.add = function(t, e, n, i, a) {
      return this._elExistsMap[t.id] ? !1 : (this._elExistsMap[t.id] = !0, this._storage.push({
        el: t,
        target: e,
        duration: n,
        delay: i,
        easing: a
      }), !0);
    }, r.prototype.finished = function(t) {
      return this._finishedCallback = t, this;
    }, r.prototype.start = function() {
      for (var t = this, e = this._storage.length, n = function() {
        e--, e <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var o = this._storage[i];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: n,
          aborted: n
        });
      }
      return this;
    }, r;
  }()
);
function uQ() {
  return new lQ();
}
var CS = Ct, UD = te, GD = 3, HD = "label", WD = "upperLabel", cQ = wc * 10, fQ = wc * 2, hQ = wc * 3, Bs = vl([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), XD = function(r) {
  var t = Bs(r);
  return t.stroke = t.fill = t.lineWidth = null, t;
}, cg = ee(), dQ = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._state = "ready", e._storage = gf(), e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Zt(o, e) < 0)) {
        this.seriesModel = e, this.api = i, this.ecModel = n;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = Sh(a, s, e), u = a && a.type, c = e.layoutInfo, f = !this._oldTree, h = this._storage, d = u === "treemapRootToNode" && l && h ? {
          rootNodeGroup: h.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), g = e.get("animation"), v = this._doRender(p, e, d);
        g && !f && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, e, d) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(e, i, l);
      }
    }, t.prototype._giveContainerGroup = function(e) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new CS(), this._initEvents(n), this.group.add(n)), n.x = e.x, n.y = e.y, n;
    }, t.prototype._doRender = function(e, n, i) {
      var a = n.getData().tree, o = this._oldTree, s = gf(), l = gf(), u = this._storage, c = [];
      function f(y, _, x, b) {
        return pQ(n, l, u, i, s, c, y, _, x, b);
      }
      g(a.root ? [a.root] : [], o && o.root ? [o.root] : [], e, a === o || !o, 0);
      var h = v(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var d = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === d.width && p.height === d.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: h,
        renderFinally: m
      };
      function g(y, _, x, b, S) {
        b ? (_ = y, L(y, function(T, M) {
          !T.isRemoved() && A(M, M);
        })) : new Ya(_, y, w, w).add(A).update(A).remove(Yt(A, null)).execute();
        function w(T) {
          return T.getId();
        }
        function A(T, M) {
          var C = T != null ? y[T] : null, R = M != null ? _[M] : null, E = f(C, R, x, S);
          E && g(C && C.viewChildren || [], R && R.viewChildren || [], E, b, S + 1);
        }
      }
      function v(y) {
        var _ = gf();
        return y && L(y, function(x, b) {
          var S = _[b];
          L(x, function(w) {
            w && (S.push(w), cg(w).willDelete = !0);
          });
        }), _;
      }
      function m() {
        L(h, function(y) {
          L(y, function(_) {
            _.parent && _.parent.remove(_);
          });
        }), L(c, function(y) {
          y.invisible = !0, y.dirty();
        });
      }
    }, t.prototype._doAnimation = function(e, n, i, a) {
      var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (At(o) ? 0 : o) || 0, u = (At(s) ? null : s) || "cubicOut", c = uQ();
      L(n.willDeleteEls, function(f, h) {
        L(f, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, m = cg(g);
            if (a && a.direction === "drillDown")
              v = g === a.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: m.nodeWidth,
                  height: m.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, _ = 0;
              m.willDelete || (y = m.nodeWidth / 2, _ = m.nodeHeight / 2), v = h === "nodeGroup" ? {
                x: y,
                y: _,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: _,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(d, v, l, 0, u);
          }
        });
      }), L(this._storage, function(f, h) {
        L(f, function(d, p) {
          var g = n.lastsForAnimation[h][p], v = {};
          g && (d instanceof Ct ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = j({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(gt(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, t.prototype._resetController = function(e) {
      var n = this, i = this._controller, a = this._controllerHost;
      a || (this._controllerHost = {
        target: this.group
      }, a = this._controllerHost);
      var o = this.seriesModel;
      i || (i = this._controller = new Pl(e.getZr()), i.on("pan", gt(this._onPan, this)), i.on("zoom", gt(this._onZoom, this))), i.enable(o.get("roam"), {
        api: e,
        zInfo: {
          component: o
        },
        triggerInfo: {
          roamTrigger: o.get("roamTrigger"),
          isInSelf: function(s, l, u) {
            var c = n._containerGroup;
            return c ? c.getBoundingRect().contain(l - c.x, u - c.y) : !1;
          }
        }
      }), a.zoomLimit = o.get("scaleLimit"), a.zoom = o.get("zoom");
    }, t.prototype._clearController = function() {
      var e = this._controller;
      this._controllerHost = null, e && (e.dispose(), e = null);
    }, t.prototype._onPan = function(e) {
      if (this._state !== "animating" && (Math.abs(e.dx) > GD || Math.abs(e.dy) > GD)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n)
          return;
        var i = n.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + e.dx,
            y: i.y + e.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, t.prototype._onZoom = function(e) {
      var n = e.originX, i = e.originY, a = e.scale;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o)
          return;
        var s = o.getLayout();
        if (!s)
          return;
        var l = new Vt(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var f = c.zoom = c.zoom || 1;
        if (f *= a, u) {
          var h = u.min || 0, d = u.max || 1 / 0;
          f = Math.max(Math.min(d, f), h);
        }
        var p = f / c.zoom;
        c.zoom = f;
        var g = this.seriesModel.layoutInfo;
        n -= g.x, i -= g.y;
        var v = Br();
        na(v, v, [-n, -i]), A1(v, v, [p, p]), na(v, v, [n, i]), l.applyTransform(v), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, t.prototype._initEvents = function(e) {
      var n = this;
      e.on("click", function(i) {
        if (n._state === "ready") {
          var a = n.seriesModel.get("nodeClick", !0);
          if (a) {
            var o = n.findTarget(i.offsetX, i.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot)
                n._rootToNode(o);
              else if (a === "zoomToNode")
                n._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && Vv(u, c);
              }
            }
          }
        }
      }, this);
    }, t.prototype._renderBreadcrumb = function(e, n, i) {
      var a = this;
      i || (i = e.get("leafDepth", !0) != null ? {
        node: e.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: e.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new aQ(this.group))).render(e, n, i.node, function(o) {
        a._state !== "animating" && (Wb(e.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, t.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = gf(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, t.prototype.dispose = function() {
      this._clearController();
    }, t.prototype._zoomToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype._rootToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype.findTarget = function(e, n) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(e, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: o,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, t.type = "treemap", t;
  }(Re)
);
function gf() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function pQ(r, t, e, n, i, a, o, s, l, u) {
  if (!o)
    return;
  var c = o.getLayout(), f = r.getData(), h = o.getModel();
  if (f.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)
    return;
  var d = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = o.getRawIndex(), y = s && s.getRawIndex(), _ = o.viewChildren, x = c.upperHeight, b = _ && _.length, S = h.getModel("itemStyle"), w = h.getModel(["emphasis", "itemStyle"]), A = h.getModel(["blur", "itemStyle"]), T = h.getModel(["select", "itemStyle"]), M = S.get("borderRadius") || 0, C = Y("nodeGroup", CS);
  if (!C)
    return;
  if (l.add(C), C.x = c.x || 0, C.y = c.y || 0, C.markRedraw(), cg(C).nodeWidth = d, cg(C).nodeHeight = p, c.isAboveViewRoot)
    return C;
  var R = Y("background", UD, u, fQ);
  R && F(C, R, b && c.upperLabelHeight);
  var E = h.getModel("emphasis"), D = E.get("focus"), I = E.get("blurScope"), P = E.get("disabled"), O = D === "ancestor" ? o.getAncestorsIndices() : D === "descendant" ? o.getDescendantIndices() : D;
  if (b)
    Go(C) && js(C, !1), R && (js(R, !P), f.setItemGraphicEl(o.dataIndex, R), Ix(R, O, I));
  else {
    var N = Y("content", UD, u, hQ);
    N && G(C, N), R.disableMorphing = !0, R && Go(R) && js(R, !1), js(C, !P), f.setItemGraphicEl(o.dataIndex, C);
    var B = h.getShallow("cursor");
    B && N.attr("cursor", B), Ix(C, O, I);
  }
  return C;
  function F(ut, lt, H) {
    var ct = zt(lt);
    if (ct.dataIndex = o.dataIndex, ct.seriesIndex = r.seriesIndex, lt.setShape({
      x: 0,
      y: 0,
      width: d,
      height: p,
      r: M
    }), v)
      W(lt);
    else {
      lt.invisible = !1;
      var ot = o.getVisual("style"), Gt = ot.stroke, yt = XD(S);
      yt.fill = Gt;
      var Mt = Bs(w);
      Mt.fill = w.get("borderColor");
      var Rt = Bs(A);
      Rt.fill = A.get("borderColor");
      var Kt = Bs(T);
      if (Kt.fill = T.get("borderColor"), H) {
        var Ae = d - 2 * g;
        J(
          // PENDING: convert ZRColor to ColorString for text.
          lt,
          Gt,
          ot.opacity,
          {
            x: g,
            y: 0,
            width: Ae,
            height: x
          }
        );
      } else
        lt.removeTextContent();
      lt.setStyle(yt), lt.ensureState("emphasis").style = Mt, lt.ensureState("blur").style = Rt, lt.ensureState("select").style = Kt, gl(lt);
    }
    ut.add(lt);
  }
  function G(ut, lt) {
    var H = zt(lt);
    H.dataIndex = o.dataIndex, H.seriesIndex = r.seriesIndex;
    var ct = Math.max(d - 2 * g, 0), ot = Math.max(p - 2 * g, 0);
    if (lt.culling = !0, lt.setShape({
      x: g,
      y: g,
      width: ct,
      height: ot,
      r: M
    }), v)
      W(lt);
    else {
      lt.invisible = !1;
      var Gt = o.getVisual("style"), yt = Gt.fill, Mt = XD(S);
      Mt.fill = yt, Mt.decal = Gt.decal;
      var Rt = Bs(w), Kt = Bs(A), Ae = Bs(T);
      J(lt, yt, Gt.opacity, null), lt.setStyle(Mt), lt.ensureState("emphasis").style = Rt, lt.ensureState("blur").style = Kt, lt.ensureState("select").style = Ae, gl(lt);
    }
    ut.add(lt);
  }
  function W(ut) {
    !ut.invisible && a.push(ut);
  }
  function J(ut, lt, H, ct) {
    var ot = h.getModel(ct ? WD : HD), Gt = yr(h.get("name"), null), yt = ot.getShallow("show");
    Cr(ut, xr(h, ct ? WD : HD), {
      defaultText: yt ? Gt : null,
      inheritColor: lt,
      defaultOpacity: H,
      labelFetcher: r,
      labelDataIndex: o.dataIndex
    });
    var Mt = ut.getTextContent();
    if (Mt) {
      var Rt = Mt.style, Kt = zg(Rt.padding || 0);
      ct && (ut.setTextConfig({
        layoutRect: ct
      }), Mt.disableLabelLayout = !0), Mt.beforeUpdate = function() {
        var z = Math.max((ct ? ct.width : ut.shape.width) - Kt[1] - Kt[3], 0), k = Math.max((ct ? ct.height : ut.shape.height) - Kt[0] - Kt[2], 0);
        (Rt.width !== z || Rt.height !== k) && Mt.setStyle({
          width: z,
          height: k
        });
      }, Rt.truncateMinChar = 2, Rt.lineOverflow = "truncate", U(Rt, ct, c);
      var Ae = Mt.getState("emphasis");
      U(Ae ? Ae.style : null, ct, c);
    }
  }
  function U(ut, lt, H) {
    var ct = ut ? ut.text : null;
    if (!lt && H.isLeafRoot && ct != null) {
      var ot = r.get("drillDownIcon", !0);
      ut.text = ot ? ot + " " + ct : ct;
    }
  }
  function Y(ut, lt, H, ct) {
    var ot = y != null && e[ut][y], Gt = i[ut];
    return ot ? (e[ut][y] = null, at(Gt, ot)) : v || (ot = new lt(), ot instanceof ai && (ot.z2 = vQ(H, ct)), st(Gt, ot)), t[ut][m] = ot;
  }
  function at(ut, lt) {
    var H = ut[m] = {};
    lt instanceof CS ? (H.oldX = lt.x, H.oldY = lt.y) : H.oldShape = j({}, lt.shape);
  }
  function st(ut, lt) {
    var H = ut[m] = {}, ct = o.parentNode, ot = lt instanceof Ct;
    if (ct && (!n || n.direction === "drillDown")) {
      var Gt = 0, yt = 0, Mt = i.background[ct.getRawIndex()];
      !n && Mt && Mt.oldShape && (Gt = Mt.oldShape.width, yt = Mt.oldShape.height), ot ? (H.oldX = 0, H.oldY = yt) : H.oldShape = {
        x: Gt,
        y: yt,
        width: 0,
        height: 0
      };
    }
    H.fadein = !ot;
  }
}
function vQ(r, t) {
  return r * cQ + t;
}
var bh = L, gQ = Lt, fg = -1, Tr = (
  /** @class */
  function() {
    function r(t) {
      var e = t.mappingMethod, n = t.type, i = this.option = Dt(t);
      this.type = n, this.mappingMethod = e, this._normalizeData = _Q[e];
      var a = r.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[e], e === "piecewise" ? (U0(i), mQ(i)) : e === "category" ? i.categories ? yQ(i) : U0(i, !0) : (St(e !== "linear" || i.dataExtent), U0(i));
    }
    return r.prototype.mapValueToVisual = function(t) {
      var e = this._normalizeData(t);
      return this._normalizedToVisual(e, t);
    }, r.prototype.getNormalizer = function() {
      return gt(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return se(r.visualHandlers);
    }, r.isValidType = function(t) {
      return r.visualHandlers.hasOwnProperty(t);
    }, r.eachVisual = function(t, e, n) {
      Lt(t) ? L(t, e, n) : e.call(n, t);
    }, r.mapVisual = function(t, e, n) {
      var i, a = et(t) ? [] : Lt(t) ? {} : (i = !0, null);
      return r.eachVisual(t, function(o, s) {
        var l = e.call(n, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(t) {
      var e = {}, n;
      return t && bh(r.visualHandlers, function(i, a) {
        t.hasOwnProperty(a) && (e[a] = t[a], n = !0);
      }), n ? e : null;
    }, r.prepareVisualTypes = function(t) {
      if (et(t))
        t = t.slice();
      else if (gQ(t)) {
        var e = [];
        bh(t, function(n, i) {
          e.push(i);
        }), t = e;
      } else
        return [];
      return t.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, r.dependsOn = function(t, e) {
      return e === "color" ? !!(t && t.indexOf(e) === 0) : t === e;
    }, r.findPieceIndex = function(t, e, n) {
      for (var i, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
        var l = e[o].value;
        if (l != null) {
          if (l === t || pt(l) && l === t + "")
            return o;
          n && h(l, o);
        }
      }
      for (var o = 0, s = e.length; o < s; o++) {
        var u = e[o], c = u.interval, f = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (yp(f[1], t, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (yp(f[0], c[0], t))
              return o;
          } else if (yp(f[0], c[0], t) && yp(f[1], t, c[1]))
            return o;
          n && h(c[0], o), n && h(c[1], o);
        }
      }
      if (n)
        return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : i;
      function h(d, p) {
        var g = Math.abs(d - t);
        g < a && (a = g, i = p);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: mf("color"),
        getColorMapper: function() {
          var t = this.option;
          return gt(t.mappingMethod === "category" ? function(e, n) {
            return !n && (e = this._normalizeData(e)), Bf.call(this, e);
          } : function(e, n, i) {
            var a = !!i;
            return !n && (e = this._normalizeData(e)), i = _y(e, t.parsedVisual, i), a ? i : Qi(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Qi(_y(t, this.option.parsedVisual), "rgba");
          },
          category: Bf,
          piecewise: function(t, e) {
            var n = LS.call(this, e);
            return n == null && (n = Qi(_y(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Vs
        }
      },
      colorHue: mp(function(t, e) {
        return Oo(t, e);
      }),
      colorSaturation: mp(function(t, e) {
        return Oo(t, null, e);
      }),
      colorLightness: mp(function(t, e) {
        return Oo(t, null, null, e);
      }),
      colorAlpha: mp(function(t, e) {
        return Mv(t, e);
      }),
      decal: {
        applyVisual: mf("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Bf,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: mf("opacity"),
        _normalizedToVisual: DS([0, 1])
      },
      liftZ: {
        applyVisual: mf("liftZ"),
        _normalizedToVisual: {
          linear: Vs,
          category: Vs,
          piecewise: Vs,
          fixed: Vs
        }
      },
      symbol: {
        applyVisual: function(t, e, n) {
          var i = this.mapValueToVisual(t);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: YD,
          category: Bf,
          piecewise: function(t, e) {
            var n = LS.call(this, e);
            return n == null && (n = YD.call(this, t)), n;
          },
          fixed: Vs
        }
      },
      symbolSize: {
        applyVisual: mf("symbolSize"),
        _normalizedToVisual: DS([0, 1])
      }
    }, r;
  }()
);
function mQ(r) {
  var t = r.pieceList;
  r.hasSpecialVisual = !1, L(t, function(e, n) {
    e.originIndex = n, e.visual != null && (r.hasSpecialVisual = !0);
  });
}
function yQ(r) {
  var t = r.categories, e = r.categoryMap = {}, n = r.visual;
  if (bh(t, function(o, s) {
    e[o] = s;
  }), !et(n)) {
    var i = [];
    Lt(n) ? bh(n, function(o, s) {
      var l = e[s];
      i[l ?? fg] = o;
    }) : i[fg] = n, n = nB(r, i);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete e[t[a]], t.pop());
}
function U0(r, t) {
  var e = r.visual, n = [];
  Lt(e) ? bh(e, function(a) {
    n.push(a);
  }) : e != null && n.push(e);
  var i = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), nB(r, n);
}
function mp(r) {
  return {
    applyVisual: function(t, e, n) {
      var i = this.mapValueToVisual(t);
      n("color", r(e("color"), i));
    },
    _normalizedToVisual: DS([0, 1])
  };
}
function YD(r) {
  var t = this.option.visual;
  return t[Math.round(Me(r, [0, 1], [0, t.length - 1], !0))] || {};
}
function mf(r) {
  return function(t, e, n) {
    n(r, this.mapValueToVisual(t));
  };
}
function Bf(r) {
  var t = this.option.visual;
  return t[this.option.loop && r !== fg ? r % t.length : r];
}
function Vs() {
  return this.option.visual[0];
}
function DS(r) {
  return {
    linear: function(t) {
      return Me(t, r, this.option.visual, !0);
    },
    category: Bf,
    piecewise: function(t, e) {
      var n = LS.call(this, e);
      return n == null && (n = Me(t, r, this.option.visual, !0)), n;
    },
    fixed: Vs
  };
}
function LS(r) {
  var t = this.option, e = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = Tr.findPieceIndex(r, e), i = e[n];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function nB(r, t) {
  return r.visual = t, r.type === "color" && (r.parsedVisual = rt(t, function(e) {
    var n = wn(e);
    return !n && process.env.NODE_ENV !== "production" && Ye("'" + e + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var _Q = {
  linear: function(r) {
    return Me(r, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(r) {
    var t = this.option.pieceList, e = Tr.findPieceIndex(r, t, !0);
    if (e != null)
      return Me(e, [0, t.length - 1], [0, 1], !0);
  },
  category: function(r) {
    var t = this.option.categories ? this.option.categoryMap[r] : r;
    return t ?? fg;
  },
  fixed: rr
};
function yp(r, t, e) {
  return r ? t <= e : t < e;
}
var xQ = "itemStyle", iB = ee();
const SQ = {
  seriesType: "treemap",
  reset: function(r) {
    var t = r.getData().tree, e = t.root;
    e.isRemoved() || aB(
      e,
      // Visual should calculate from tree root but not view root.
      {},
      r.getViewRoot().getAncestors(),
      r
    );
  }
};
function aB(r, t, e, n) {
  var i = r.getModel(), a = r.getLayout(), o = r.hostTree.data;
  if (!(!a || a.invisible || !a.isInView)) {
    var s = i.getModel(xQ), l = bQ(s, t, n), u = o.ensureUniqueItemVisual(r.dataIndex, "style"), c = s.get("borderColor"), f = s.get("borderColorSaturation"), h;
    f != null && (h = $D(l), c = wQ(f, h)), u.stroke = c;
    var d = r.viewChildren;
    if (!d || !d.length)
      h = $D(l), u.fill = h;
    else {
      var p = MQ(r, i, a, s, l, d);
      L(d, function(g, v) {
        if (g.depth >= e.length || g === e[g.depth]) {
          var m = TQ(i, l, g, v, p, n);
          aB(g, m, e, n);
        }
      });
    }
  }
}
function bQ(r, t, e) {
  var n = j({}, t), i = e.designatedVisualItemStyle;
  return L(["color", "colorAlpha", "colorSaturation"], function(a) {
    i[a] = t[a];
    var o = r.get(a);
    i[a] = null, o != null && (n[a] = o);
  }), n;
}
function $D(r) {
  var t = G0(r, "color");
  if (t) {
    var e = G0(r, "colorAlpha"), n = G0(r, "colorSaturation");
    return n && (t = Oo(t, null, null, n)), e && (t = Mv(t, e)), t;
  }
}
function wQ(r, t) {
  return t != null ? Oo(t, null, null, r) : null;
}
function G0(r, t) {
  var e = r[t];
  if (e != null && e !== "none")
    return e;
}
function MQ(r, t, e, n, i, a) {
  if (!(!a || !a.length)) {
    var o = H0(t, "color") || i.color != null && i.color !== "none" && (H0(t, "colorAlpha") || H0(t, "colorSaturation"));
    if (o) {
      var s = t.get("visualMin"), l = t.get("visualMax"), u = e.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = t.get("colorMappingBy"), f = {
        type: o.name,
        dataExtent: u,
        visual: o.range
      };
      f.type === "color" && (c === "index" || c === "id") ? (f.mappingMethod = "category", f.loop = !0) : f.mappingMethod = "linear";
      var h = new Tr(f);
      return iB(h).drColorMappingBy = c, h;
    }
  }
}
function H0(r, t) {
  var e = r.get(t);
  return et(e) && e.length ? {
    name: t,
    range: e
  } : null;
}
function TQ(r, t, e, n, i, a) {
  var o = j({}, t);
  if (i) {
    var s = i.type, l = s === "color" && iB(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? a.mapIdToIndex(e.getId()) : e.getValue(r.get("visualDimension"));
    o[s] = i.mapValueToVisual(u);
  }
  return o;
}
var wh = Math.max, hg = Math.min, ZD = mr, Xb = L, oB = ["itemStyle", "borderWidth"], AQ = ["itemStyle", "gapWidth"], EQ = ["upperLabel", "show"], CQ = ["upperLabel", "height"];
const DQ = {
  seriesType: "treemap",
  reset: function(r, t, e, n) {
    var i = r.option, a = Sr(r, e).refContainer, o = We(r.getBoxLayoutParams(), a), s = i.size || [], l = dt(ZD(o.width, s[0]), a.width), u = dt(ZD(o.height, s[1]), a.height), c = n && n.type, f = ["treemapZoomToNode", "treemapRootToNode"], h = Sh(n, f, r), d = c === "treemapRender" || c === "treemapMove" ? n.rootRect : null, p = r.getViewRoot(), g = tB(p);
    if (c !== "treemapMove") {
      var v = c === "treemapZoomToNode" ? OQ(r, h, p, l, u) : d ? [d.width, d.height] : [l, u], m = i.sort;
      m && m !== "asc" && m !== "desc" && (m = "desc");
      var y = {
        squareRatio: i.squareRatio,
        sort: m,
        leafDepth: i.leafDepth
      };
      p.hostTree.clearLayouts();
      var _ = {
        x: 0,
        y: 0,
        width: v[0],
        height: v[1],
        area: v[0] * v[1]
      };
      p.setLayout(_), sB(p, y, !1, 0), _ = p.getLayout(), Xb(g, function(b, S) {
        var w = (g[S + 1] || p).getValue();
        b.setLayout(j({
          dataExtent: [w, w],
          borderWidth: 0,
          upperHeight: 0
        }, _));
      });
    }
    var x = r.getData().tree.root;
    x.setLayout(kQ(o, d, h), !0), r.setLayoutInfo(o), lB(
      x,
      // Transform to base element coordinate system.
      new Vt(-o.x, -o.y, e.getWidth(), e.getHeight()),
      g,
      p,
      0
    );
  }
};
function sB(r, t, e, n) {
  var i, a;
  if (!r.isRemoved()) {
    var o = r.getLayout();
    i = o.width, a = o.height;
    var s = r.getModel(), l = s.get(oB), u = s.get(AQ) / 2, c = uB(s), f = Math.max(l, c), h = l - u, d = f - u;
    r.setLayout({
      borderWidth: l,
      upperHeight: f,
      upperLabelHeight: c
    }, !0), i = wh(i - 2 * h, 0), a = wh(a - h - d, 0);
    var p = i * a, g = LQ(r, s, p, t, e, n);
    if (g.length) {
      var v = {
        x: h,
        y: d,
        width: i,
        height: a
      }, m = hg(i, a), y = 1 / 0, _ = [];
      _.area = 0;
      for (var x = 0, b = g.length; x < b; ) {
        var S = g[x];
        _.push(S), _.area += S.getLayout().area;
        var w = NQ(_, m, t.squareRatio);
        w <= y ? (x++, y = w) : (_.area -= _.pop().getLayout().area, qD(_, m, v, u, !1), m = hg(v.width, v.height), _.length = _.area = 0, y = 1 / 0);
      }
      if (_.length && qD(_, m, v, u, !0), !e) {
        var A = s.get("childrenVisibleMin");
        A != null && p < A && (e = !0);
      }
      for (var x = 0, b = g.length; x < b; x++)
        sB(g[x], t, e, n + 1);
    }
  }
}
function LQ(r, t, e, n, i, a) {
  var o = r.children || [], s = n.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = n.leafDepth != null && n.leafDepth <= a;
  if (i && !l)
    return r.viewChildren = [];
  o = Te(o, function(d) {
    return !d.isRemoved();
  }), IQ(o, s);
  var u = PQ(t, o, s);
  if (u.sum === 0)
    return r.viewChildren = [];
  if (u.sum = RQ(t, e, u.sum, s, o), u.sum === 0)
    return r.viewChildren = [];
  for (var c = 0, f = o.length; c < f; c++) {
    var h = o[c].getValue() / u.sum * e;
    o[c].setLayout({
      area: h
    });
  }
  return l && (o.length && r.setLayout({
    isLeafRoot: !0
  }, !0), o.length = 0), r.viewChildren = o, r.setLayout({
    dataExtent: u.dataExtent
  }, !0), o;
}
function RQ(r, t, e, n, i) {
  if (!n)
    return e;
  for (var a = r.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
    var u = i[n === "asc" ? o - l - 1 : l].getValue();
    u / e * t < a && (s = l, e -= u);
  }
  return n === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), e;
}
function IQ(r, t) {
  return t && r.sort(function(e, n) {
    var i = t === "asc" ? e.getValue() - n.getValue() : n.getValue() - e.getValue();
    return i === 0 ? t === "asc" ? e.dataIndex - n.dataIndex : n.dataIndex - e.dataIndex : i;
  }), r;
}
function PQ(r, t, e) {
  for (var n = 0, i = 0, a = t.length; i < a; i++)
    n += t[i].getValue();
  var o = r.get("visualDimension"), s;
  return !t || !t.length ? s = [NaN, NaN] : o === "value" && e ? (s = [t[t.length - 1].getValue(), t[0].getValue()], e === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], Xb(t, function(l) {
    var u = l.getValue(o);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: n,
    dataExtent: s
  };
}
function NQ(r, t, e) {
  for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    o = r[a].getLayout().area, o && (o < i && (i = o), o > n && (n = o));
  var l = r.area * r.area, u = t * t * e;
  return l ? wh(u * n / l, l / (u * i)) : 1 / 0;
}
function qD(r, t, e, n, i) {
  var a = t === e.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = e[s[a]], c = t ? r.area / t : 0;
  (i || c > e[l[o]]) && (c = e[l[o]]);
  for (var f = 0, h = r.length; f < h; f++) {
    var d = r[f], p = {}, g = c ? d.getLayout().area / c : 0, v = p[l[o]] = wh(c - 2 * n, 0), m = e[s[a]] + e[l[a]] - u, y = f === h - 1 || m < g ? m : g, _ = p[l[a]] = wh(y - 2 * n, 0);
    p[s[o]] = e[s[o]] + hg(n, v / 2), p[s[a]] = u + hg(n, _ / 2), u += y, d.setLayout(p, !0);
  }
  e[s[o]] += c, e[l[o]] -= c;
}
function OQ(r, t, e, n, i) {
  var a = (t || {}).node, o = [n, i];
  if (!a || a === e)
    return o;
  for (var s, l = n * i, u = l * r.option.zoomToNodeRatio; s = a.parentNode; ) {
    for (var c = 0, f = s.children, h = 0, d = f.length; h < d; h++)
      c += f[h].getValue();
    var p = a.getValue();
    if (p === 0)
      return o;
    u *= c / p;
    var g = s.getModel(), v = g.get(oB), m = Math.max(v, uB(g));
    u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > JT && (u = JT), a = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [n * y, i * y];
}
function kQ(r, t, e) {
  if (t)
    return {
      x: t.x,
      y: t.y
    };
  var n = {
    x: 0,
    y: 0
  };
  if (!e)
    return n;
  var i = e.node, a = i.getLayout();
  if (!a)
    return n;
  for (var o = [a.width / 2, a.height / 2], s = i; s; ) {
    var l = s.getLayout();
    o[0] += l.x, o[1] += l.y, s = s.parentNode;
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1]
  };
}
function lB(r, t, e, n, i) {
  var a = r.getLayout(), o = e[i], s = o && o === r;
  if (!(o && !s || i === e.length && r !== n)) {
    r.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !t.intersect(a),
      isAboveViewRoot: s
    }, !0);
    var l = new Vt(t.x - a.x, t.y - a.y, t.width, t.height);
    Xb(r.viewChildren || [], function(u) {
      lB(u, l, e, n, i + 1);
    });
  }
}
function uB(r) {
  return r.get(EQ) ? r.get(CQ) : 0;
}
function BQ(r) {
  r.registerSeriesModel(rQ), r.registerChartView(dQ), r.registerVisual(SQ), r.registerLayout(DQ), eQ(r);
}
function VQ(r) {
  var t = r.findComponents({
    mainType: "legend"
  });
  !t || !t.length || r.eachSeriesByType("graph", function(e) {
    var n = e.getCategoriesData(), i = e.getGraph(), a = i.data, o = n.mapArray(n.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        fe(u) && (u = o[u]);
        for (var c = 0; c < t.length; c++)
          if (!t[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function FQ(r) {
  var t = {};
  r.eachSeriesByType("graph", function(e) {
    var n = e.getCategoriesData(), i = e.getData(), a = {};
    n.each(function(o) {
      var s = n.getName(o);
      a["ec-" + s] = o;
      var l = n.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = e.getColorFromPalette(s, t)), n.setItemVisual(o, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < c.length; f++) {
        var h = l.getShallow(c[f], !0);
        h != null && n.setItemVisual(o, c[f], h);
      }
    }), n.count() && i.each(function(o) {
      var s = i.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        pt(l) && (l = a["ec-" + l]);
        var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(o, "style");
        j(c, u);
        for (var f = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < f.length; h++)
          i.setItemVisual(o, f[h], n.getItemVisual(l, f[h]));
      }
    });
  });
}
function _p(r) {
  return r instanceof Array || (r = [r, r]), r;
}
function zQ(r) {
  r.eachSeriesByType("graph", function(t) {
    var e = t.getGraph(), n = t.getEdgeData(), i = _p(t.get("edgeSymbol")), a = _p(t.get("edgeSymbolSize"));
    n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("style", t.getModel("lineStyle").getLineStyle()), n.each(function(o) {
      var s = n.getItemModel(o), l = e.getEdgeByIndex(o), u = _p(s.getShallow("symbol", !0)), c = _p(s.getShallow("symbolSize", !0)), f = s.getModel("lineStyle").getLineStyle(), h = n.ensureUniqueItemVisual(o, "style");
      switch (j(h, f), h.stroke) {
        case "source": {
          var d = l.node1.getVisual("style");
          h.stroke = d && d.fill;
          break;
        }
        case "target": {
          var d = l.node2.getVisual("style");
          h.stroke = d && d.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var RS = "-->", wm = function(r) {
  return r.get("autoCurveness") || null;
}, cB = function(r, t) {
  var e = wm(r), n = 20, i = [];
  if (fe(e))
    n = e;
  else if (et(e)) {
    r.__curvenessList = e;
    return;
  }
  t > n && (n = t);
  var a = n % 2 ? n + 2 : n + 3;
  i = [];
  for (var o = 0; o < a; o++)
    i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  r.__curvenessList = i;
}, Mh = function(r, t, e) {
  var n = [r.id, r.dataIndex].join("."), i = [t.id, t.dataIndex].join(".");
  return [e.uid, n, i].join(RS);
}, fB = function(r) {
  var t = r.split(RS);
  return [t[0], t[2], t[1]].join(RS);
}, UQ = function(r, t) {
  var e = Mh(r.node1, r.node2, t);
  return t.__edgeMap[e];
}, GQ = function(r, t) {
  var e = IS(Mh(r.node1, r.node2, t), t), n = IS(Mh(r.node2, r.node1, t), t);
  return e + n;
}, IS = function(r, t) {
  var e = t.__edgeMap;
  return e[r] ? e[r].length : 0;
};
function HQ(r) {
  wm(r) && (r.__curvenessList = [], r.__edgeMap = {}, cB(r));
}
function WQ(r, t, e, n) {
  if (wm(e)) {
    var i = Mh(r, t, e), a = e.__edgeMap, o = a[fB(i)];
    a[i] && !o ? a[i].isForward = !0 : o && a[i] && (o.isForward = !0, a[i].isForward = !1), a[i] = a[i] || [], a[i].push(n);
  }
}
function Yb(r, t, e, n) {
  var i = wm(t), a = et(i);
  if (!i)
    return null;
  var o = UQ(r, t);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === e) {
      s = l;
      break;
    }
  var u = GQ(r, t);
  cB(t, u), r.lineStyle = r.lineStyle || {};
  var c = Mh(r.node1, r.node2, t), f = t.__curvenessList, h = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return f[h + s];
  var d = fB(c), p = IS(d, t), g = f[s + p + h];
  return n ? a ? i && i[0] === 0 ? (p + h) % 2 ? g : -g : ((p % 2 ? 0 : 1) + h) % 2 ? g : -g : (p + h) % 2 ? g : -g : f[s + p + h];
}
function hB(r) {
  var t = r.coordinateSystem;
  if (!(t && t.type !== "view")) {
    var e = r.getGraph();
    e.eachNode(function(n) {
      var i = n.getModel();
      n.setLayout([+i.get("x"), +i.get("y")]);
    }), $b(e, r);
  }
}
function $b(r, t) {
  r.eachEdge(function(e, n) {
    var i = un(e.getModel().get(["lineStyle", "curveness"]), -Yb(e, t, n, !0), 0), a = Pa(e.node1.getLayout()), o = Pa(e.node2.getLayout()), s = [a, o];
    +i && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * i, (a[1] + o[1]) / 2 - (o[0] - a[0]) * i]), e.setLayout(s);
  });
}
function XQ(r, t) {
  r.eachSeriesByType("graph", function(e) {
    var n = e.get("layout"), i = e.coordinateSystem;
    if (i && i.type !== "view") {
      var a = e.getData(), o = [];
      L(i.dimensions, function(h) {
        o = o.concat(a.mapDimensionsAll(h));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var f = a.get(o[c], s);
          isNaN(f) || (u = !0), l.push(f);
        }
        u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      $b(a.graph, e);
    } else
      (!n || n === "none") && hB(e);
  });
}
function Vf(r) {
  var t = r.coordinateSystem;
  if (t.type !== "view")
    return 1;
  var e = r.option.nodeScaleRatio, n = t.scaleX, i = t.getZoom(), a = (i - 1) * e + 1;
  return a / n;
}
function Ff(r) {
  var t = r.getVisual("symbolSize");
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
}
var KD = Math.PI, W0 = [];
function Zb(r, t, e, n) {
  var i = r.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var a = i.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, f = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!f) {
      if (e) {
        var h = i.pointToData(n), d = h[0], p = h[1], g = [d - l, p - u];
        xc(g, g), Hp(g, g, c), e.setLayout([l + g[0], u + g[1]], !0);
        var v = r.get(["circular", "rotateLabel"]);
        dB(e, v, l, u);
      }
      YQ[t](r, s, o, c, l, u, f), s.eachEdge(function(m, y) {
        var _ = un(m.getModel().get(["lineStyle", "curveness"]), Yb(m, r, y), 0), x = Pa(m.node1.getLayout()), b = Pa(m.node2.getLayout()), S, w = (x[0] + b[0]) / 2, A = (x[1] + b[1]) / 2;
        +_ && (_ *= 3, S = [l * _ + w * (1 - _), u * _ + A * (1 - _)]), m.setLayout([x, b, S]);
      });
    }
  }
}
var YQ = {
  value: function(r, t, e, n, i, a, o) {
    var s = 0, l = e.getSum("value"), u = Math.PI * 2 / (l || o);
    t.eachNode(function(c) {
      var f = c.getValue("value"), h = u * (l ? f : 1) / 2;
      s += h, c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + a]), s += h;
    });
  },
  symbolSize: function(r, t, e, n, i, a, o) {
    var s = 0;
    W0.length = o;
    var l = Vf(r);
    t.eachNode(function(f) {
      var h = Ff(f);
      isNaN(h) && (h = 2), h < 0 && (h = 0), h *= l;
      var d = Math.asin(h / 2 / n);
      isNaN(d) && (d = KD / 2), W0[f.dataIndex] = d, s += d * 2;
    });
    var u = (2 * KD - s) / o / 2, c = 0;
    t.eachNode(function(f) {
      var h = u + W0[f.dataIndex];
      c += h, (!f.getLayout() || !f.getLayout().fixed) && f.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + a]), c += h;
    });
  }
};
function dB(r, t, e, n) {
  var i = r.getGraphicEl();
  if (i) {
    var a = r.getModel(), o = a.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (t) {
      var l = r.getLayout(), u = Math.atan2(l[1] - n, l[0] - e);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < e;
      c && (u = u - Math.PI);
      var f = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: f,
        origin: "center"
      });
      var h = s.ensureState("emphasis");
      j(h.textConfig || (h.textConfig = {}), {
        position: f
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function $Q(r) {
  r.eachSeriesByType("graph", function(t) {
    t.get("layout") === "circular" && Zb(t, "symbolSize");
  });
}
var gu = j_;
function ZQ(r, t, e) {
  for (var n = r, i = t, a = e.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = e.gravity == null ? 0.1 : e.gravity, c = 0; c < n.length; c++) {
    var f = n[c];
    f.p || (f.p = Tl(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), f.pp = Pa(f.p), f.edges = null;
  }
  var h = e.friction == null ? 0.6 : e.friction, d = h, p, g;
  return {
    warmUp: function() {
      d = h * 0.8;
    },
    setFixed: function(v) {
      n[v].fixed = !0;
    },
    setUnfixed: function(v) {
      n[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(n, i);
      for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
        var x = i[_];
        if (!x.ignoreForceLayout) {
          var b = x.n1, S = x.n2;
          qs(m, S.p, b.p);
          var w = J_(m) - x.d, A = S.w / (b.w + S.w);
          isNaN(A) && (A = 0), xc(m, m), !b.fixed && gu(b.p, b.p, m, A * w * d), !S.fixed && gu(S.p, S.p, m, -(1 - A) * w * d);
        }
      }
      for (var _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (qs(m, l, T.p), gu(T.p, T.p, m, u * d));
      }
      for (var _ = 0; _ < y; _++)
        for (var b = n[_], M = _ + 1; M < y; M++) {
          var S = n[M];
          qs(m, S.p, b.p);
          var w = J_(m);
          w === 0 && (M1(m, Math.random() - 0.5, Math.random() - 0.5), w = 1);
          var C = (b.rep + S.rep) / w / w;
          !b.fixed && gu(b.pp, b.pp, m, C), !S.fixed && gu(S.pp, S.pp, m, -C);
        }
      for (var R = [], _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (qs(R, T.p, T.pp), gu(T.p, T.p, R, d), rn(T.pp, T.p));
      }
      d = d * 0.992;
      var E = d < 0.01;
      g && g(n, i, E), v && v(E);
    }
  };
}
function qQ(r) {
  r.eachSeriesByType("graph", function(t) {
    var e = t.coordinateSystem;
    if (!(e && e.type !== "view"))
      if (t.get("layout") === "force") {
        var n = t.preservedPoints || {}, i = t.getGraph(), a = i.data, o = i.edgeData, s = t.getModel("force"), l = s.get("initLayout");
        t.preservedPoints ? a.each(function(_) {
          var x = a.getId(_);
          a.setItemLayout(_, n[x] || [NaN, NaN]);
        }) : !l || l === "none" ? hB(t) : l === "circular" && Zb(t, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), f = s.get("repulsion"), h = s.get("edgeLength"), d = et(f) ? f : [f, f], p = et(h) ? h : [h, h];
        p = [p[1], p[0]];
        var g = a.mapArray("value", function(_, x) {
          var b = a.getItemLayout(x), S = Me(_, u, d);
          return isNaN(S) && (S = (d[0] + d[1]) / 2), {
            w: S,
            rep: S,
            fixed: a.getItemModel(x).get("fixed"),
            p: !b || isNaN(b[0]) || isNaN(b[1]) ? null : b
          };
        }), v = o.mapArray("value", function(_, x) {
          var b = i.getEdgeByIndex(x), S = Me(_, c, p);
          isNaN(S) && (S = (p[0] + p[1]) / 2);
          var w = b.getModel(), A = un(b.getModel().get(["lineStyle", "curveness"]), -Yb(b, t, x, !0), 0);
          return {
            n1: g[b.node1.dataIndex],
            n2: g[b.node2.dataIndex],
            d: S,
            curveness: A,
            ignoreForceLayout: w.get("ignoreForceLayout")
          };
        }), m = e.getBoundingRect(), y = ZQ(g, v, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(_, x) {
          for (var b = 0, S = _.length; b < S; b++)
            _[b].fixed && rn(_[b].p, i.getNodeByIndex(b).getLayout());
        }), y.afterStep(function(_, x, b) {
          for (var S = 0, w = _.length; S < w; S++)
            _[S].fixed || i.getNodeByIndex(S).setLayout(_[S].p), n[a.getId(S)] = _[S].p;
          for (var S = 0, w = x.length; S < w; S++) {
            var A = x[S], T = i.getEdgeByIndex(S), M = A.n1.p, C = A.n2.p, R = T.getLayout();
            R = R ? R.slice() : [], R[0] = R[0] || [], R[1] = R[1] || [], rn(R[0], M), rn(R[1], C), +A.curveness && (R[2] = [(M[0] + C[0]) / 2 - (M[1] - C[1]) * A.curveness, (M[1] + C[1]) / 2 - (C[0] - M[0]) * A.curveness]), T.setLayout(R);
          }
        }), t.forceLayout = y, t.preservedPoints = n, y.step();
      } else
        t.forceLayout = null;
  });
}
function KQ(r, t, e) {
  var n = Sr(r, t), i = j(r.getBoxLayoutParams(), {
    aspect: e
  }), a = We(i, n.refContainer);
  return $N(r, a, e);
}
function jQ(r, t) {
  var e = [];
  return r.eachSeriesByType("graph", function(n) {
    Uh({
      targetModel: n,
      coordSysType: "view",
      coordSysProvider: i,
      isDefaultDataCoordSys: !0
    });
    function i() {
      var a = n.getData(), o = a.mapArray(function(p) {
        var g = a.getItemModel(p);
        return [+g.get("x"), +g.get("y")];
      }), s = [], l = [];
      Jg(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = KQ(n, t, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var f = l[0] - s[0], h = l[1] - s[1], d = new Nl(null, {
        api: t,
        ecModel: r
      });
      return d.zoomLimit = n.get("scaleLimit"), d.setBoundingRect(s[0], s[1], f, h), d.setViewRect(c.x, c.y, c.width, c.height), d.setCenter(n.get("center")), d.setZoom(n.get("zoom")), e.push(d), d;
    }
  }), e;
}
var jD = lr.prototype, X0 = Bh.prototype, pB = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }()
);
(function(r) {
  $(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t;
})(pB);
function Y0(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1);
}
var vB = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-line", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: X.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new pB();
    }, t.prototype.buildPath = function(e, n) {
      Y0(n) ? jD.buildPath.call(this, e, n) : X0.buildPath.call(this, e, n);
    }, t.prototype.pointAt = function(e) {
      return Y0(this.shape) ? jD.pointAt.call(this, e) : X0.pointAt.call(this, e);
    }, t.prototype.tangentAt = function(e) {
      var n = this.shape, i = Y0(n) ? [n.x2 - n.x1, n.y2 - n.y1] : X0.tangentAt.call(this, e);
      return xc(i, i);
    }, t;
  }(ne)
), $0 = ["fromSymbol", "toSymbol"];
function JD(r) {
  return "_" + r + "Type";
}
function QD(r, t, e) {
  var n = t.getItemVisual(e, r);
  if (!n || n === "none")
    return n;
  var i = t.getItemVisual(e, r + "Size"), a = t.getItemVisual(e, r + "Rotate"), o = t.getItemVisual(e, r + "Offset"), s = t.getItemVisual(e, r + "KeepAspect"), l = Rc(i), u = Ll(o || 0, l);
  return n + l + u + (a || "") + (s || "");
}
function tL(r, t, e) {
  var n = t.getItemVisual(e, r);
  if (!(!n || n === "none")) {
    var i = t.getItemVisual(e, r + "Size"), a = t.getItemVisual(e, r + "Rotate"), o = t.getItemVisual(e, r + "Offset"), s = t.getItemVisual(e, r + "KeepAspect"), l = Rc(i), u = Ll(o || 0, l), c = hr(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = r, c;
  }
}
function JQ(r) {
  var t = new vB({
    name: "line",
    subPixelOptimize: !0
  });
  return PS(t.shape, r), t;
}
function PS(r, t) {
  r.x1 = t[0][0], r.y1 = t[0][1], r.x2 = t[1][0], r.y2 = t[1][1], r.percent = 1;
  var e = t[2];
  e ? (r.cpx1 = e[0], r.cpy1 = e[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
}
var qb = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a._createLine(e, n, i), a;
    }
    return t.prototype._createLine = function(e, n, i) {
      var a = e.hostModel, o = e.getItemLayout(n), s = e.getItemVisual(n, "z2"), l = JQ(o);
      l.shape.percent = 0, ze(l, {
        z2: bt(s, 0),
        shape: {
          percent: 1
        }
      }, a, n), this.add(l), L($0, function(u) {
        var c = tL(u, e, n);
        this.add(c), this[JD(u)] = QD(u, e, n);
      }, this), this._updateCommonStl(e, n, i);
    }, t.prototype.updateData = function(e, n, i) {
      var a = e.hostModel, o = this.childOfName("line"), s = e.getItemLayout(n), l = {
        shape: {}
      };
      PS(l.shape, s), ve(o, l, a, n), L($0, function(u) {
        var c = QD(u, e, n), f = JD(u);
        if (this[f] !== c) {
          this.remove(this.childOfName(u));
          var h = tL(u, e, n);
          this.add(h);
        }
        this[f] = c;
      }, this), this._updateCommonStl(e, n, i);
    }, t.prototype.getLinePath = function() {
      return this.childAt(0);
    }, t.prototype._updateCommonStl = function(e, n, i) {
      var a = e.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, f = i && i.emphasisDisabled, h = i && i.focus, d = i && i.blurScope;
      if (!i || e.hasItemOption) {
        var p = e.getItemModel(n), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), f = g.get("disabled"), h = g.get("focus"), d = g.get("blurScope"), c = xr(p);
      }
      var v = e.getItemVisual(n, "style"), m = v.stroke;
      o.useStyle(v), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, L($0, function(S) {
        var w = this.childOfName(S);
        if (w) {
          w.setColor(m), w.style.opacity = v.opacity;
          for (var A = 0; A < pn.length; A++) {
            var T = pn[A], M = o.getState(T);
            if (M) {
              var C = M.style || {}, R = w.ensureState(T), E = R.style || (R.style = {});
              C.stroke != null && (E[w.__isEmptyBrush ? "stroke" : "fill"] = C.stroke), C.opacity != null && (E.opacity = C.opacity);
            }
          }
          w.markRedraw();
        }
      }, this);
      var y = a.getRawValue(n);
      Cr(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(S, w) {
            return a.getFormattedLabel(S, w, e.dataType);
          }
        },
        inheritColor: m || X.color.neutral99,
        defaultOpacity: v.opacity,
        defaultText: (y == null ? e.getName(n) : isFinite(y) ? sr(y) : y) + ""
      });
      var _ = this.getTextContent();
      if (_) {
        var x = c.normal;
        _.__align = _.style.align, _.__verticalAlign = _.style.verticalAlign, _.__position = x.get("position") || "middle";
        var b = x.get("distance");
        et(b) || (b = [b, b]), _.__labelDistance = b;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), He(this, h, d, f);
    }, t.prototype.highlight = function() {
      Wa(this);
    }, t.prototype.downplay = function() {
      Xa(this);
    }, t.prototype.updateLayout = function(e, n) {
      this.setLinePoints(e.getItemLayout(n));
    }, t.prototype.setLinePoints = function(e) {
      var n = this.childOfName("line");
      PS(n.shape, e), n.dirty();
    }, t.prototype.beforeUpdate = function() {
      var e = this, n = e.childOfName("fromSymbol"), i = e.childOfName("toSymbol"), a = e.getTextContent();
      if (!n && !i && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = e.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), f = l.pointAt(u), h = qs([], f, c);
      xc(h, h);
      function d(M, C) {
        var R = M.__specifiedRotation;
        if (R == null) {
          var E = l.tangentAt(C);
          M.attr("rotation", (C === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(E[1], E[0]));
        } else
          M.attr("rotation", R);
      }
      if (n && (n.setPosition(c), d(n, 0), n.scaleX = n.scaleY = o * u, n.markRedraw()), i && (i.setPosition(f), d(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, v = a.__labelDistance, m = v[0] * o, y = v[1] * o, _ = u / 2, x = l.tangentAt(_), b = [x[1], -x[0]], S = l.pointAt(_);
        b[1] > 0 && (b[0] = -b[0], b[1] = -b[1]);
        var w = x[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var A = -Math.atan2(x[1], x[0]);
          f[0] < c[0] && (A = Math.PI + A), a.rotation = A;
        }
        var T = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            T = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            T = y, g = "top";
            break;
          default:
            T = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = h[0] * m + f[0], a.y = h[1] * y + f[1], p = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", g = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -h[0] * m + c[0], a.y = -h[1] * y + c[1], p = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", g = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * w + c[0], a.y = c[1] + T, p = x[0] < 0 ? "right" : "left", a.originX = -m * w, a.originY = -T;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = S[0], a.y = S[1] + T, p = "center", a.originY = -T;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * w + f[0], a.y = f[1] + T, p = x[0] >= 0 ? "right" : "left", a.originX = m * w, a.originY = -T;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, t;
  }(Ct)
), Kb = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Ct(), this._LineCtor = t || qb;
    }
    return r.prototype.updateData = function(t) {
      var e = this;
      this._progressiveEls = null;
      var n = this, i = n.group, a = n._lineData;
      n._lineData = t, a || i.removeAll();
      var o = eL(t);
      t.diff(a).add(function(s) {
        e._doAdd(t, s, o);
      }).update(function(s, l) {
        e._doUpdate(a, t, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var t = this._lineData;
      t && t.eachItemGraphicEl(function(e, n) {
        e.updateLayout(t, n);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = eL(t), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(t, e) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !QQ(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = t.start; i < t.end; i++) {
        var a = e.getItemLayout(i);
        if (Z0(a)) {
          var o = new this._LineCtor(e, i, this._seriesScope);
          o.traverse(n), this.group.add(o), e.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(t) {
      jo(this._progressiveEls || this.group, t);
    }, r.prototype._doAdd = function(t, e, n) {
      var i = t.getItemLayout(e);
      if (Z0(i)) {
        var a = new this._LineCtor(t, e, n);
        t.setItemGraphicEl(e, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(t, e, n, i, a) {
      var o = t.getItemGraphicEl(n);
      if (!Z0(e.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(e, i, a) : o = new this._LineCtor(e, i, a), e.setItemGraphicEl(i, o), this.group.add(o);
    }, r;
  }()
);
function QQ(r) {
  return r.animators && r.animators.length > 0;
}
function eL(r) {
  var t = r.hostModel, e = t.getModel("emphasis");
  return {
    lineStyle: t.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: e.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: e.get("disabled"),
    blurScope: e.get("blurScope"),
    focus: e.get("focus"),
    labelStatesModels: xr(t)
  };
}
function rL(r) {
  return isNaN(r[0]) || isNaN(r[1]);
}
function Z0(r) {
  return r && !rL(r[0]) && !rL(r[1]);
}
var q0 = [], K0 = [], j0 = [], mu = Pr, J0 = rl, nL = Math.abs;
function iL(r, t, e) {
  for (var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = e * e, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    q0[0] = mu(n[0], i[0], a[0], c), q0[1] = mu(n[1], i[1], a[1], c);
    var f = nL(J0(q0, t) - l);
    f < o && (o = f, s = c);
  }
  for (var h = 0; h < 32; h++) {
    var d = s + u;
    K0[0] = mu(n[0], i[0], a[0], s), K0[1] = mu(n[1], i[1], a[1], s), j0[0] = mu(n[0], i[0], a[0], d), j0[1] = mu(n[1], i[1], a[1], d);
    var f = J0(K0, t) - l;
    if (nL(f) < 0.01)
      break;
    var p = J0(j0, t) - l;
    u /= 2, f < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function Q0(r, t) {
  var e = [], n = rh, i = [[], [], []], a = [[], []], o = [];
  t /= 2, r.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), f = s.getVisual("toSymbol");
    u.__original || (u.__original = [Pa(u[0]), Pa(u[1])], u[2] && u.__original.push(Pa(u[2])));
    var h = u.__original;
    if (u[2] != null) {
      if (rn(i[0], h[0]), rn(i[1], h[2]), rn(i[2], h[1]), c && c !== "none") {
        var d = Ff(s.node1), p = iL(i, h[0], d * t);
        n(i[0][0], i[1][0], i[2][0], p, e), i[0][0] = e[3], i[1][0] = e[4], n(i[0][1], i[1][1], i[2][1], p, e), i[0][1] = e[3], i[1][1] = e[4];
      }
      if (f && f !== "none") {
        var d = Ff(s.node2), p = iL(i, h[1], d * t);
        n(i[0][0], i[1][0], i[2][0], p, e), i[1][0] = e[1], i[2][0] = e[2], n(i[0][1], i[1][1], i[2][1], p, e), i[1][1] = e[1], i[2][1] = e[2];
      }
      rn(u[0], i[0]), rn(u[1], i[2]), rn(u[2], i[1]);
    } else {
      if (rn(a[0], h[0]), rn(a[1], h[1]), qs(o, a[1], a[0]), xc(o, o), c && c !== "none") {
        var d = Ff(s.node1);
        j_(a[0], a[0], o, d * t);
      }
      if (f && f !== "none") {
        var d = Ff(s.node2);
        j_(a[1], a[1], o, -d * t);
      }
      rn(u[0], a[0]), rn(u[1], a[1]);
    }
  });
}
var gB = ee();
function ttt(r) {
  if (r)
    return gB(r).bridge;
}
function aL(r, t) {
  r && (gB(r).bridge = t);
}
function oL(r) {
  return r.type === "view";
}
var ett = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      var i = new Yh(), a = new Kb(), o = this.group, s = new Ct();
      this._controller = new Pl(n.getZr()), this._controllerHost = {
        target: s
      }, s.add(i.group), s.add(a.group), o.add(s), this._symbolDraw = i, this._lineDraw = a, this._mainGroup = s, this._firstRender = !0;
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = e.coordinateSystem, s = !1;
      this._model = e, this._api = i, this._active = !0;
      var l = this._getThumbnailInfo();
      l && l.bridge.reset(i);
      var u = this._symbolDraw, c = this._lineDraw;
      if (oL(o)) {
        var f = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? this._mainGroup.attr(f) : ve(this._mainGroup, f, e);
      }
      Q0(e.getGraph(), Vf(e));
      var h = e.getData();
      u.updateData(h);
      var d = e.getEdgeData();
      c.updateData(d), this._updateNodeAndLinkScale(), this._updateController(null, e, i), clearTimeout(this._layoutTimeout);
      var p = e.forceLayout, g = e.get(["force", "layoutAnimation"]);
      p && (s = !0, this._startForceLayoutIteration(p, i, g));
      var v = e.get("layout");
      h.graph.eachNode(function(x) {
        var b = x.dataIndex, S = x.getGraphicEl(), w = x.getModel();
        if (S) {
          S.off("drag").off("dragend");
          var A = w.get("draggable");
          A && S.on("drag", function(M) {
            switch (v) {
              case "force":
                p.warmUp(), !a._layouting && a._startForceLayoutIteration(p, i, g), p.setFixed(b), h.setItemLayout(b, [S.x, S.y]);
                break;
              case "circular":
                h.setItemLayout(b, [S.x, S.y]), x.setLayout({
                  fixed: !0
                }, !0), Zb(e, "symbolSize", x, [M.offsetX, M.offsetY]), a.updateLayout(e);
                break;
              case "none":
              default:
                h.setItemLayout(b, [S.x, S.y]), $b(e.getGraph(), e), a.updateLayout(e);
                break;
            }
          }).on("dragend", function() {
            p && p.setUnfixed(b);
          }), S.setDraggable(A, !!w.get("cursor"));
          var T = w.get(["emphasis", "focus"]);
          T === "adjacency" && (zt(S).focus = x.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(x) {
        var b = x.getGraphicEl(), S = x.getModel().get(["emphasis", "focus"]);
        b && S === "adjacency" && (zt(b).focus = {
          edge: [x.dataIndex],
          node: [x.node1.dataIndex, x.node2.dataIndex]
        });
      });
      var m = e.get("layout") === "circular" && e.get(["circular", "rotateLabel"]), y = h.getLayout("cx"), _ = h.getLayout("cy");
      h.graph.eachNode(function(x) {
        dB(x, m, y, _);
      }), this._firstRender = !1, s || this._renderThumbnail(e, i, this._symbolDraw, this._lineDraw);
    }, t.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._startForceLayoutIteration = function(e, n, i) {
      var a = this, o = !1;
      (function s() {
        e.step(function(l) {
          a.updateLayout(a._model), (l || !o) && (o = !0, a._renderThumbnail(a._model, n, a._symbolDraw, a._lineDraw)), (a._layouting = !l) && (i ? a._layoutTimeout = setTimeout(s, 16) : s());
        });
      })();
    }, t.prototype._updateController = function(e, n, i) {
      var a = this._controller, o = this._controllerHost, s = n.coordinateSystem;
      if (!oL(s)) {
        a.disable();
        return;
      }
      a.enable(n.get("roam"), {
        api: i,
        zInfo: {
          component: n
        },
        triggerInfo: {
          roamTrigger: n.get("roamTrigger"),
          isInSelf: function(l, u, c) {
            return s.containPoint([u, c]);
          },
          isInClip: function(l, u, c) {
            return !e || e.contain(u, c);
          }
        }
      }), o.zoomLimit = n.get("scaleLimit"), o.zoom = s.getZoom(), a.off("pan").off("zoom").on("pan", function(l) {
        i.dispatchAction({
          seriesId: n.id,
          type: "graphRoam",
          dx: l.dx,
          dy: l.dy
        });
      }).on("zoom", function(l) {
        i.dispatchAction({
          seriesId: n.id,
          type: "graphRoam",
          zoom: l.scale,
          originX: l.originX,
          originY: l.originY
        });
      });
    }, t.prototype.updateViewOnPan = function(e, n, i) {
      this._active && (Vb(this._controllerHost, i.dx, i.dy), this._updateThumbnailWindow());
    }, t.prototype.updateViewOnZoom = function(e, n, i) {
      this._active && (Fb(this._controllerHost, i.zoom, i.originX, i.originY), this._updateNodeAndLinkScale(), Q0(e.getGraph(), Vf(e)), this._lineDraw.updateLayout(), n.updateLabelLayout(), this._updateThumbnailWindow());
    }, t.prototype._updateNodeAndLinkScale = function() {
      var e = this._model, n = e.getData(), i = Vf(e);
      n.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, t.prototype.updateLayout = function(e) {
      this._active && (Q0(e.getGraph(), Vf(e)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout());
    }, t.prototype.remove = function() {
      this._active = !1, clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove(), this._controller && this._controller.disable();
    }, t.prototype._getThumbnailInfo = function() {
      var e = this._model, n = e.coordinateSystem;
      if (n.type === "view") {
        var i = ttt(e);
        if (i)
          return {
            bridge: i,
            coordSys: n
          };
      }
    }, t.prototype._updateThumbnailWindow = function() {
      var e = this._getThumbnailInfo();
      e && e.bridge.updateWindow(e.coordSys.transform, this._api);
    }, t.prototype._renderThumbnail = function(e, n, i, a) {
      var o = this._getThumbnailInfo();
      if (o) {
        var s = new Ct(), l = i.group.children(), u = a.group.children(), c = new Ct(), f = new Ct();
        s.add(f), s.add(c);
        for (var h = 0; h < l.length; h++) {
          var d = l[h], p = d.children()[0], g = d.x, v = d.y, m = Dt(p.shape), y = j(m, {
            width: p.scaleX,
            height: p.scaleY,
            x: g - p.scaleX / 2,
            y: v - p.scaleY / 2
          }), _ = Dt(p.style), x = new p.constructor({
            shape: y,
            style: _,
            z2: 151
          });
          f.add(x);
        }
        for (var h = 0; h < u.length; h++) {
          var d = u[h], b = d.children()[0], _ = Dt(b.style), y = Dt(b.shape), S = new vB({
            style: _,
            shape: y,
            z2: 151
          });
          c.add(S);
        }
        o.bridge.renderContent({
          api: n,
          roamType: e.get("roam"),
          viewportRect: null,
          group: s,
          targetTrans: o.coordSys.transform
        });
      }
    }, t.type = "graph", t;
  }(Re)
);
function yu(r) {
  return "_EC_" + r;
}
var rtt = (
  /** @class */
  function() {
    function r(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(t, e) {
      t = t == null ? "" + e : "" + t;
      var n = this._nodesMap;
      if (n[yu(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new Fs(t, e);
      return i.hostGraph = this, this.nodes.push(i), n[yu(t)] = i, i;
    }, r.prototype.getNodeByIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this.nodes[e];
    }, r.prototype.getNodeById = function(t) {
      return this._nodesMap[yu(t)];
    }, r.prototype.addEdge = function(t, e, n) {
      var i = this._nodesMap, a = this._edgesMap;
      if (fe(t) && (t = this.nodes[t]), fe(e) && (e = this.nodes[e]), t instanceof Fs || (t = i[yu(t)]), e instanceof Fs || (e = i[yu(e)]), !(!t || !e)) {
        var o = t.id + "-" + e.id, s = new mB(t, e, n);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), e.inEdges.push(s)), t.edges.push(s), t !== e && e.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(t) {
      var e = this.edgeData.getRawIndex(t);
      return this.edges[e];
    }, r.prototype.getEdge = function(t, e) {
      t instanceof Fs && (t = t.id), e instanceof Fs && (e = e.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + e] : n[t + "-" + e] || n[e + "-" + t];
    }, r.prototype.eachNode = function(t, e) {
      for (var n = this.nodes, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && t.call(e, n[a], a);
    }, r.prototype.eachEdge = function(t, e) {
      for (var n = this.edges, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(e, n[a], a);
    }, r.prototype.breadthFirstTraverse = function(t, e, n, i) {
      if (e instanceof Fs || (e = this._nodesMap[yu(e)]), !!e) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!t.call(i, e, null))
          for (var s = [e]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], f = c.node1 === l ? c.node2 : c.node1;
              if (!f.__visited) {
                if (t.call(i, f, l))
                  return;
                s.push(f), f.__visited = !0;
              }
            }
      }
    }, r.prototype.update = function() {
      for (var t = this.data, e = this.edgeData, n = this.nodes, i = this.edges, a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      e.filterSelf(function(s) {
        var l = i[e.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        i[e.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var t = new r(this._directed), e = this.nodes, n = this.edges, i = 0; i < e.length; i++)
        t.addNode(e[i].id, e[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, r;
  }()
), Fs = (
  /** @class */
  function() {
    function r(t, e) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = e ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, n = e.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, e = 0; e < this.edges.length; e++) {
        var n = this.edges[e];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var t = wt(), e = wt(), n = 0, i = this.edges.length; n < i; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var o = [a.node1], s = [a.node2], l = 0; l < o.length; ) {
            var u = o[l];
            l++, e.set(u.dataIndex, !0);
            for (var c = u.inEdges, f = 0, h = c.length, d = void 0, p = void 0; f < h; f++)
              d = c[f], p = d.dataIndex, p >= 0 && !t.hasKey(p) && (t.set(p, !0), o.push(d.node1));
          }
          for (l = 0; l < s.length; ) {
            var g = s[l];
            l++, e.set(g.dataIndex, !0);
            for (var v = g.outEdges, f = 0, m = v.length, y = void 0, _ = void 0; f < m; f++)
              y = v[f], _ = y.dataIndex, _ >= 0 && !t.hasKey(_) && (t.set(_, !0), s.push(y.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, r;
  }()
), mB = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = n ?? -1;
    }
    return r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, n = e.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var t = wt(), e = wt();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], i = [this.node2], a = 0; a < n.length; ) {
        var o = n[a];
        a++, e.set(o.dataIndex, !0);
        for (var s = o.inEdges, l = 0, u = s.length, c = void 0, f = void 0; l < u; l++)
          c = o.inEdges[l], f = c.dataIndex, f >= 0 && !t.hasKey(f) && (t.set(f, !0), n.push(c.node1));
      }
      for (a = 0; a < i.length; ) {
        var h = i[a];
        a++, e.set(h.dataIndex, !0);
        for (var d = h.outEdges, l = 0, u = d.length, p = void 0, g = void 0; l < u; l++)
          p = h.outEdges[l], g = p.dataIndex, g >= 0 && !t.hasKey(g) && (t.set(g, !0), i.push(p.node2));
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, r;
  }()
);
function yB(r, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(e) {
      var n = this[r][t];
      return n.getStore().get(n.getDimensionIndex(e || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(e, n) {
      this.dataIndex >= 0 && this[r][t].setItemVisual(this.dataIndex, e, n);
    },
    getVisual: function(e) {
      return this[r][t].getItemVisual(this.dataIndex, e);
    },
    setLayout: function(e, n) {
      this.dataIndex >= 0 && this[r][t].setItemLayout(this.dataIndex, e, n);
    },
    getLayout: function() {
      return this[r][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[r][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[r][t].getRawIndex(this.dataIndex);
    }
  };
}
dr(Fs, yB("hostGraph", "data"));
dr(mB, yB("hostGraph", "edgeData"));
function jb(r, t, e, n, i) {
  for (var a = new rtt(n), o = 0; o < r.length; o++)
    a.addNode(mr(
      // Id, name, dataIndex
      r[o].id,
      r[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o], f = c.source, h = c.target;
    a.addEdge(f, h, u) && (l.push(c), s.push(mr(yr(c.id, null), f + " > " + h)), u++);
  }
  var d = e.get("coordinateSystem"), p;
  if (d === "cartesian2d" || d === "polar" || d === "matrix")
    p = Ja(r, e);
  else {
    var g = Cc.get(d), v = g ? g.dimensions || [] : [];
    Zt(v, "value") < 0 && v.concat(["value"]);
    var m = Hh(r, {
      coordDimensions: v,
      encodeDefine: e.getEncode()
    }).dimensions;
    p = new cn(m, e), p.initData(r);
  }
  var y = new cn(["value"], e);
  return y.initData(l, s), i && i(p, y), J3({
    mainData: p,
    struct: a,
    structAttr: "graph",
    datas: {
      node: p,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var ntt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new Oc(i, i), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeDefaultAndTheme = function(e) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), dl(e, "edgeLabel", ["show"]);
    }, t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], o = this;
      if (a && i) {
        HQ(this);
        var s = jb(a, i, this, !0, l);
        return L(s.edges, function(u) {
          WQ(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = o._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var f = ue.prototype.getModel;
        function h(p, g) {
          var v = f.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = h, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(e, i), s = a.graph.getEdgeByIndex(e), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), fr("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var f = AO({
        series: this,
        dataIndex: e,
        multipleSeries: n
      });
      return f;
    }, t.prototype._updateCategoriesData = function() {
      var e = rt(this.option.categories || [], function(i) {
        return i.value != null ? i : j({
          value: 0
        }, i);
      }), n = new cn(["value"], this);
      n.initData(e), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        // Don't use tokens.color.border because of the opacity
        color: X.color.neutral50,
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      }
    }, t;
  }(ke)
);
function itt(r) {
  r.registerChartView(ett), r.registerSeriesModel(ntt), r.registerProcessor(VQ), r.registerVisual(FQ), r.registerVisual(zQ), r.registerLayout(XQ), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, $Q), r.registerLayout(qQ), r.registerCoordinateSystem("graphView", {
    dimensions: Nl.dimensions,
    create: jQ
  }), r.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, rr), r.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, rr), r.registerAction({
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      query: t
    }, function(i) {
      var a = n.getViewOfSeriesModel(i);
      a && (t.dx != null && t.dy != null && a.updateViewOnPan(i, n, t), t.zoom != null && t.originX != null && t.originY != null && a.updateViewOnZoom(i, n, t));
      var o = i.coordinateSystem, s = xm(o, t, i.get("scaleLimit"));
      i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
    });
  });
}
var sL = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      zt(a).dataType = "node", a.z2 = 2;
      var o = new pe();
      return a.setTextContent(o), a.updateData(e, n, i, !0), a;
    }
    return t.prototype.updateData = function(e, n, i, a) {
      var o = this, s = e.graph.getNodeByIndex(n), l = e.hostModel, u = s.getModel(), c = u.getModel("emphasis"), f = e.getItemLayout(n), h = j(ji(u.getModel("itemStyle"), f, !0), f), d = this;
      if (isNaN(h.startAngle)) {
        d.setShape(h);
        return;
      }
      a ? d.setShape(h) : ve(d, {
        shape: h
      }, l, n);
      var p = j(ji(u.getModel("itemStyle"), f, !0), f);
      o.setShape(p), o.useStyle(e.getItemVisual(n, "style")), _r(o, u), this._updateLabel(l, u, s), e.setItemGraphicEl(n, d), _r(d, u, "itemStyle");
      var g = c.get("focus");
      He(this, g === "adjacency" ? s.getAdjacentDataIndices() : g, c.get("blurScope"), c.get("disabled"));
    }, t.prototype._updateLabel = function(e, n, i) {
      var a = this.getTextContent(), o = i.getLayout(), s = (o.startAngle + o.endAngle) / 2, l = Math.cos(s), u = Math.sin(s), c = n.getModel("label");
      a.ignore = !c.get("show");
      var f = xr(n), h = i.getVisual("style");
      Cr(a, f, {
        labelFetcher: {
          getFormattedLabel: function(y, _, x, b, S, w) {
            return e.getFormattedLabel(
              y,
              _,
              "node",
              b,
              // ensure edgeLabel formatter is provided
              // to prevent the inheritance from `label.formatter` of the series
              un(S, f.normal && f.normal.get("formatter"), n.get("name")),
              w
            );
          }
        },
        labelDataIndex: i.dataIndex,
        defaultText: i.dataIndex + "",
        inheritColor: h.fill,
        defaultOpacity: h.opacity,
        defaultOutsidePosition: "startArc"
      });
      var d = c.get("position") || "outside", p = c.get("distance") || 0, g;
      d === "outside" ? g = o.r + p : g = (o.r + o.r0) / 2, this.textConfig = {
        inside: d !== "outside"
      };
      var v = d !== "outside" ? c.get("align") || "center" : l > 0 ? "left" : "right", m = d !== "outside" ? c.get("verticalAlign") || "middle" : u > 0 ? "top" : "bottom";
      a.attr({
        x: l * g + o.cx,
        y: u * g + o.cy,
        rotation: 0,
        style: {
          align: v,
          verticalAlign: m
        }
      });
    }, t;
  }(jr)
), att = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      return zt(o).dataType = "edge", o.updateData(e, n, i, a, !0), o;
    }
    return t.prototype.buildPath = function(e, n) {
      e.moveTo(n.s1[0], n.s1[1]);
      var i = 0.7, a = n.clockwise;
      e.arc(n.cx, n.cy, n.r, n.sStartAngle, n.sEndAngle, !a), e.bezierCurveTo((n.cx - n.s2[0]) * i + n.s2[0], (n.cy - n.s2[1]) * i + n.s2[1], (n.cx - n.t1[0]) * i + n.t1[0], (n.cy - n.t1[1]) * i + n.t1[1], n.t1[0], n.t1[1]), e.arc(n.cx, n.cy, n.r, n.tStartAngle, n.tEndAngle, !a), e.bezierCurveTo((n.cx - n.t2[0]) * i + n.t2[0], (n.cy - n.t2[1]) * i + n.t2[1], (n.cx - n.s1[0]) * i + n.s1[0], (n.cy - n.s1[1]) * i + n.s1[1], n.s1[0], n.s1[1]), e.closePath();
    }, t.prototype.updateData = function(e, n, i, a, o) {
      var s = e.hostModel, l = n.graph.getEdgeByIndex(i), u = l.getLayout(), c = l.node1.getModel(), f = n.getItemModel(l.dataIndex), h = f.getModel("lineStyle"), d = f.getModel("emphasis"), p = d.get("focus"), g = j(ji(c.getModel("itemStyle"), u, !0), u), v = this;
      if (isNaN(g.sStartAngle) || isNaN(g.tStartAngle)) {
        v.setShape(g);
        return;
      }
      o ? (v.setShape(g), lL(v, l, e, h)) : (oi(v), lL(v, l, e, h), ve(v, {
        shape: g
      }, s, i)), He(this, p === "adjacency" ? l.getAdjacentDataIndices() : p, d.get("blurScope"), d.get("disabled")), _r(v, f, "lineStyle"), n.setItemGraphicEl(l.dataIndex, v);
    }, t;
  }(ne)
);
function lL(r, t, e, n) {
  var i = t.node1, a = t.node2, o = r.style;
  r.setStyle(n.getLineStyle());
  var s = n.get("color");
  switch (s) {
    case "source":
      o.fill = e.getItemVisual(i.dataIndex, "style").fill, o.decal = i.getVisual("style").decal;
      break;
    case "target":
      o.fill = e.getItemVisual(a.dataIndex, "style").fill, o.decal = a.getVisual("style").decal;
      break;
    case "gradient":
      var l = e.getItemVisual(i.dataIndex, "style").fill, u = e.getItemVisual(a.dataIndex, "style").fill;
      if (pt(l) && pt(u)) {
        var c = r.shape, f = (c.s1[0] + c.s2[0]) / 2, h = (c.s1[1] + c.s2[1]) / 2, d = (c.t1[0] + c.t2[0]) / 2, p = (c.t1[1] + c.t2[1]) / 2;
        o.fill = new Mc(f, h, d, p, [{
          offset: 0,
          color: l
        }, {
          offset: 1,
          color: u
        }], !0);
      }
      break;
  }
}
var ott = Math.PI / 180, stt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._data, s = this.group, l = -e.get("startAngle") * ott;
      if (a.diff(o).add(function(c) {
        var f = a.getItemLayout(c);
        if (f) {
          var h = new sL(a, c, l);
          zt(h).dataIndex = c, s.add(h);
        }
      }).update(function(c, f) {
        var h = o.getItemGraphicEl(f), d = a.getItemLayout(c);
        if (!d) {
          h && Na(h, e, f);
          return;
        }
        h ? h.updateData(a, c, l) : h = new sL(a, c, l), s.add(h);
      }).remove(function(c) {
        var f = o.getItemGraphicEl(c);
        f && Na(f, e, c);
      }).execute(), !o) {
        var u = e.get("center");
        this.group.scaleX = 0.01, this.group.scaleY = 0.01, this.group.originX = dt(u[0], i.getWidth()), this.group.originY = dt(u[1], i.getHeight()), ze(this.group, {
          scaleX: 1,
          scaleY: 1
        }, e);
      }
      this._data = a, this.renderEdges(e, l);
    }, t.prototype.renderEdges = function(e, n) {
      var i = e.getData(), a = e.getEdgeData(), o = this._edgeData, s = this.group;
      a.diff(o).add(function(l) {
        var u = new att(i, a, l, n);
        zt(u).dataIndex = l, s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(i, a, l, n), s.add(c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        u && Na(u, e, l);
      }).execute(), this._edgeData = a;
    }, t.prototype.dispose = function() {
    }, t.type = "chord", t;
  }(Re)
), ltt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this.legendVisualProvider = new Oc(gt(this.getData, this), gt(this.getRawData, this));
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links);
    }, t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [];
      if (a && i) {
        var o = jb(a, i, this, !0, s);
        return o.data;
      }
      function s(l, u) {
        var c = ue.prototype.getModel;
        function f(d, p) {
          var g = c.call(this, d, p);
          return g.resolveParentPath = h, g;
        }
        u.wrapMethod("getItemModel", function(d) {
          return d.resolveParentPath = h, d.getModel = f, d;
        });
        function h(d) {
          if (d && (d[0] === "label" || d[1] === "label")) {
            var p = d.slice();
            return d[0] === "label" ? p[0] = "edgeLabel" : d[1] === "label" && (p[1] = "edgeLabel"), p;
          }
          return d;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getDataParams(e, i);
      if (i === "edge") {
        var o = this.getData(), s = o.graph.getEdgeByIndex(e), l = o.getName(s.node1.dataIndex), u = o.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), fr("nameValue", {
          name: c.join(" > "),
          value: a.value,
          noValue: a.value == null
        });
      }
      return fr("nameValue", {
        name: a.name,
        value: a.value,
        noValue: a.value == null
      });
    }, t.prototype.getDataParams = function(e, n) {
      var i = r.prototype.getDataParams.call(this, e, n);
      if (n === "node") {
        var a = this.getData(), o = this.getGraph().getNodeByIndex(e);
        if (i.name == null && (i.name = a.getName(e)), i.value == null) {
          var s = o.getLayout().value;
          i.value = s;
        }
      }
      return i;
    }, t.type = "series.chord", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "none",
      legendHoverLink: !0,
      colorBy: "data",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      center: ["50%", "50%"],
      radius: ["70%", "80%"],
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      minAngle: 0,
      padAngle: 3,
      itemStyle: {
        borderRadius: [0, 0, 5, 5]
      },
      lineStyle: {
        width: 0,
        color: "source",
        opacity: 0.2
      },
      label: {
        show: !0,
        position: "outside",
        distance: 5
      },
      emphasis: {
        focus: "adjacency",
        lineStyle: {
          opacity: 0.5
        }
      }
    }, t;
  }(ke)
), t_ = Math.PI / 180;
function utt(r, t) {
  r.eachSeriesByType("chord", function(e) {
    ctt(e, t);
  });
}
function ctt(r, t) {
  var e = r.getData(), n = e.graph, i = r.getEdgeData(), a = i.count();
  if (a) {
    var o = YN(r, t), s = o.cx, l = o.cy, u = o.r, c = o.r0, f = Math.max((r.get("padAngle") || 0) * t_, 0), h = Math.max((r.get("minAngle") || 0) * t_, 0), d = -r.get("startAngle") * t_, p = d + Math.PI * 2, g = r.get("clockwise"), v = g ? 1 : -1, m = [d, p];
    Qg(m, !g);
    var y = m[0], _ = m[1], x = _ - y, b = e.getSum("value") === 0 && i.getSum("value") === 0, S = [], w = 0;
    n.eachEdge(function(N) {
      var B = b ? 1 : N.getValue("value");
      b && (B > 0 || h) && (w += 2);
      var F = N.node1.dataIndex, G = N.node2.dataIndex;
      S[F] = (S[F] || 0) + B, S[G] = (S[G] || 0) + B;
    });
    var A = 0;
    if (n.eachNode(function(N) {
      var B = N.getValue("value");
      isNaN(B) || (S[N.dataIndex] = Math.max(B, S[N.dataIndex] || 0)), !b && (S[N.dataIndex] > 0 || h) && w++, A += S[N.dataIndex] || 0;
    }), !(w === 0 || A === 0)) {
      f * w >= Math.abs(x) && (f = Math.max(0, (Math.abs(x) - h * w) / w)), (f + h) * w >= Math.abs(x) && (h = (Math.abs(x) - f * w) / w);
      var T = (x - f * w * v) / A, M = 0, C = 0, R = 0;
      n.eachNode(function(N) {
        var B = S[N.dataIndex] || 0, F = T * (A ? B : 1) * v;
        Math.abs(F) < h ? M += h - Math.abs(F) : (C += Math.abs(F) - h, R += Math.abs(F)), N.setLayout({
          angle: F,
          value: B
        });
      });
      var E = !1;
      if (M > C) {
        var D = M / C;
        n.eachNode(function(N) {
          var B = N.getLayout().angle;
          Math.abs(B) >= h ? N.setLayout({
            angle: B * D,
            ratio: D
          }, !0) : N.setLayout({
            angle: h,
            ratio: h === 0 ? 1 : B / h
          }, !0);
        });
      } else
        n.eachNode(function(N) {
          if (!E) {
            var B = N.getLayout().angle, F = Math.min(B / R, 1), G = F * M;
            B - G < h && (E = !0);
          }
        });
      var I = M;
      n.eachNode(function(N) {
        if (!(I <= 0)) {
          var B = N.getLayout().angle;
          if (B > h && h > 0) {
            var F = E ? 1 : Math.min(B / R, 1), G = B - h, W = Math.min(G, Math.min(I, M * F));
            I -= W, N.setLayout({
              angle: B - W,
              ratio: (B - W) / B
            }, !0);
          } else
            h > 0 && N.setLayout({
              angle: h,
              ratio: B === 0 ? 1 : h / B
            }, !0);
        }
      });
      var P = y, O = [];
      n.eachNode(function(N) {
        var B = Math.max(N.getLayout().angle, h);
        N.setLayout({
          cx: s,
          cy: l,
          r0: c,
          r: u,
          startAngle: P,
          endAngle: P + B * v,
          clockwise: g
        }, !0), O[N.dataIndex] = P, P += (B + f) * v;
      }), n.eachEdge(function(N) {
        var B = b ? 1 : N.getValue("value"), F = T * (A ? B : 1) * v, G = N.node1.dataIndex, W = O[G] || 0, J = Math.abs((N.node1.getLayout().ratio || 1) * F), U = W + J * v, Y = [s + c * Math.cos(W), l + c * Math.sin(W)], at = [s + c * Math.cos(U), l + c * Math.sin(U)], st = N.node2.dataIndex, ut = O[st] || 0, lt = Math.abs((N.node2.getLayout().ratio || 1) * F), H = ut + lt * v, ct = [s + c * Math.cos(ut), l + c * Math.sin(ut)], ot = [s + c * Math.cos(H), l + c * Math.sin(H)];
        N.setLayout({
          s1: Y,
          s2: at,
          sStartAngle: W,
          sEndAngle: U,
          t1: ct,
          t2: ot,
          tStartAngle: ut,
          tEndAngle: H,
          cx: s,
          cy: l,
          r: c,
          value: B,
          clockwise: g
        }), O[G] = U, O[st] = H;
      });
    }
  }
}
function ftt(r) {
  r.registerChartView(stt), r.registerSeriesModel(ltt), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, utt), r.registerProcessor(Pc("chord"));
}
var htt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return r;
  }()
), dtt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "pointer", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new htt();
    }, t.prototype.buildPath = function(e, n) {
      var i = Math.cos, a = Math.sin, o = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2), c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, e.moveTo(u, c), e.lineTo(n.x + i(l) * s, n.y + a(l) * s), e.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o), e.lineTo(n.x - i(l) * s, n.y - a(l) * s), e.lineTo(u, c);
    }, t;
  }(ne)
);
function ptt(r, t) {
  var e = r.get("center"), n = t.getWidth(), i = t.getHeight(), a = Math.min(n, i), o = dt(e[0], t.getWidth()), s = dt(e[1], t.getHeight()), l = dt(r.get("radius"), a / 2);
  return {
    cx: o,
    cy: s,
    r: l
  };
}
function xp(r, t) {
  var e = r == null ? "" : r + "";
  return t && (pt(t) ? e = t.replace("{value}", e) : At(t) && (e = t(r))), e;
}
var vtt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this.group.removeAll();
      var a = e.get(["axisLine", "lineStyle", "color"]), o = ptt(e, i);
      this._renderMain(e, n, i, a, o), this._data = e.getData();
    }, t.prototype.dispose = function() {
    }, t.prototype._renderMain = function(e, n, i, a, o) {
      var s = this.group, l = e.get("clockwise"), u = -e.get("startAngle") / 180 * Math.PI, c = -e.get("endAngle") / 180 * Math.PI, f = e.getModel("axisLine"), h = f.get("roundCap"), d = h ? ag : jr, p = f.get("show"), g = f.getModel("lineStyle"), v = g.get("width"), m = [u, c];
      Qg(m, !l), u = m[0], c = m[1];
      for (var y = c - u, _ = u, x = [], b = 0; p && b < a.length; b++) {
        var S = Math.min(Math.max(a[b][0], 0), 1);
        c = u + y * S;
        var w = new d({
          shape: {
            startAngle: _,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r
          },
          silent: !0
        });
        w.setStyle({
          fill: a[b][1]
        }), w.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), x.push(w), _ = c;
      }
      x.reverse(), L(x, function(T) {
        return s.add(T);
      });
      var A = function(T) {
        if (T <= 0)
          return a[0][1];
        var M;
        for (M = 0; M < a.length; M++)
          if (a[M][0] >= T && (M === 0 ? 0 : a[M - 1][0]) < T)
            return a[M][1];
        return a[M - 1][1];
      };
      this._renderTicks(e, n, i, A, o, u, c, l, v), this._renderTitleAndDetail(e, n, i, A, o), this._renderAnchor(e, o), this._renderPointer(e, n, i, A, o, u, c, l, v);
    }, t.prototype._renderTicks = function(e, n, i, a, o, s, l, u, c) {
      for (var f = this.group, h = o.cx, d = o.cy, p = o.r, g = +e.get("min"), v = +e.get("max"), m = e.getModel("splitLine"), y = e.getModel("axisTick"), _ = e.getModel("axisLabel"), x = e.get("splitNumber"), b = y.get("splitNumber"), S = dt(m.get("length"), p), w = dt(y.get("length"), p), A = s, T = (l - s) / x, M = T / b, C = m.getModel("lineStyle").getLineStyle(), R = y.getModel("lineStyle").getLineStyle(), E = m.get("distance"), D, I, P = 0; P <= x; P++) {
        if (D = Math.cos(A), I = Math.sin(A), m.get("show")) {
          var O = E ? E + c : c, N = new lr({
            shape: {
              x1: D * (p - O) + h,
              y1: I * (p - O) + d,
              x2: D * (p - S - O) + h,
              y2: I * (p - S - O) + d
            },
            style: C,
            silent: !0
          });
          C.stroke === "auto" && N.setStyle({
            stroke: a(P / x)
          }), f.add(N);
        }
        if (_.get("show")) {
          var O = _.get("distance") + E, B = xp(sr(P / x * (v - g) + g), _.get("formatter")), F = a(P / x), G = D * (p - S - O) + h, W = I * (p - S - O) + d, J = _.get("rotate"), U = 0;
          J === "radial" ? (U = -A + 2 * Math.PI, U > Math.PI / 2 && (U += Math.PI)) : J === "tangential" ? U = -A - Math.PI / 2 : fe(J) && (U = J * Math.PI / 180), U === 0 ? f.add(new pe({
            style: Oe(_, {
              text: B,
              x: G,
              y: W,
              verticalAlign: I < -0.8 ? "top" : I > 0.8 ? "bottom" : "middle",
              align: D < -0.4 ? "left" : D > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: !0
          })) : f.add(new pe({
            style: Oe(_, {
              text: B,
              x: G,
              y: W,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: !0,
            originX: G,
            originY: W,
            rotation: U
          }));
        }
        if (y.get("show") && P !== x) {
          var O = y.get("distance");
          O = O ? O + c : c;
          for (var Y = 0; Y <= b; Y++) {
            D = Math.cos(A), I = Math.sin(A);
            var at = new lr({
              shape: {
                x1: D * (p - O) + h,
                y1: I * (p - O) + d,
                x2: D * (p - w - O) + h,
                y2: I * (p - w - O) + d
              },
              silent: !0,
              style: R
            });
            R.stroke === "auto" && at.setStyle({
              stroke: a((P + Y / b) / x)
            }), f.add(at), A += M;
          }
          A -= M;
        } else
          A += T;
      }
    }, t.prototype._renderPointer = function(e, n, i, a, o, s, l, u, c) {
      var f = this.group, h = this._data, d = this._progressEls, p = [], g = e.get(["pointer", "show"]), v = e.getModel("progress"), m = v.get("show"), y = e.getData(), _ = y.mapDimension("value"), x = +e.get("min"), b = +e.get("max"), S = [x, b], w = [s, l];
      function A(M, C) {
        var R = y.getItemModel(M), E = R.getModel("pointer"), D = dt(E.get("width"), o.r), I = dt(E.get("length"), o.r), P = e.get(["pointer", "icon"]), O = E.get("offsetCenter"), N = dt(O[0], o.r), B = dt(O[1], o.r), F = E.get("keepAspect"), G;
        return P ? G = hr(P, N - D / 2, B - I, D, I, null, F) : G = new dtt({
          shape: {
            angle: -Math.PI / 2,
            width: D,
            r: I,
            x: N,
            y: B
          }
        }), G.rotation = -(C + Math.PI / 2), G.x = o.cx, G.y = o.cy, G;
      }
      function T(M, C) {
        var R = v.get("roundCap"), E = R ? ag : jr, D = v.get("overlap"), I = D ? v.get("width") : c / y.count(), P = D ? o.r - I : o.r - (M + 1) * I, O = D ? o.r : o.r - M * I, N = new E({
          shape: {
            startAngle: s,
            endAngle: C,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: P,
            r: O
          }
        });
        return D && (N.z2 = Me(y.get(_, M), [x, b], [100, 0], !0)), N;
      }
      (m || g) && (y.diff(h).add(function(M) {
        var C = y.get(_, M);
        if (g) {
          var R = A(M, s);
          ze(R, {
            rotation: -((isNaN(+C) ? w[0] : Me(C, S, w, !0)) + Math.PI / 2)
          }, e), f.add(R), y.setItemGraphicEl(M, R);
        }
        if (m) {
          var E = T(M, s), D = v.get("clip");
          ze(E, {
            shape: {
              endAngle: Me(C, S, w, D)
            }
          }, e), f.add(E), Cx(e.seriesIndex, y.dataType, M, E), p[M] = E;
        }
      }).update(function(M, C) {
        var R = y.get(_, M);
        if (g) {
          var E = h.getItemGraphicEl(C), D = E ? E.rotation : s, I = A(M, D);
          I.rotation = D, ve(I, {
            rotation: -((isNaN(+R) ? w[0] : Me(R, S, w, !0)) + Math.PI / 2)
          }, e), f.add(I), y.setItemGraphicEl(M, I);
        }
        if (m) {
          var P = d[C], O = P ? P.shape.endAngle : s, N = T(M, O), B = v.get("clip");
          ve(N, {
            shape: {
              endAngle: Me(R, S, w, B)
            }
          }, e), f.add(N), Cx(e.seriesIndex, y.dataType, M, N), p[M] = N;
        }
      }).execute(), y.each(function(M) {
        var C = y.getItemModel(M), R = C.getModel("emphasis"), E = R.get("focus"), D = R.get("blurScope"), I = R.get("disabled");
        if (g) {
          var P = y.getItemGraphicEl(M), O = y.getItemVisual(M, "style"), N = O.fill;
          if (P instanceof Fr) {
            var B = P.style;
            P.useStyle(j({
              image: B.image,
              x: B.x,
              y: B.y,
              width: B.width,
              height: B.height
            }, O));
          } else
            P.useStyle(O), P.type !== "pointer" && P.setColor(N);
          P.setStyle(C.getModel(["pointer", "itemStyle"]).getItemStyle()), P.style.fill === "auto" && P.setStyle("fill", a(Me(y.get(_, M), S, [0, 1], !0))), P.z2EmphasisLift = 0, _r(P, C), He(P, E, D, I);
        }
        if (m) {
          var F = p[M];
          F.useStyle(y.getItemVisual(M, "style")), F.setStyle(C.getModel(["progress", "itemStyle"]).getItemStyle()), F.z2EmphasisLift = 0, _r(F, C), He(F, E, D, I);
        }
      }), this._progressEls = p);
    }, t.prototype._renderAnchor = function(e, n) {
      var i = e.getModel("anchor"), a = i.get("show");
      if (a) {
        var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = hr(s, n.cx - o / 2 + dt(l[0], n.r), n.cy - o / 2 + dt(l[1], n.r), o, o, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, t.prototype._renderTitleAndDetail = function(e, n, i, a, o) {
      var s = this, l = e.getData(), u = l.mapDimension("value"), c = +e.get("min"), f = +e.get("max"), h = new Ct(), d = [], p = [], g = e.isAnimationEnabled(), v = e.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(m) {
        d[m] = new pe({
          silent: !0
        }), p[m] = new pe({
          silent: !0
        });
      }).update(function(m, y) {
        d[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), _ = l.get(u, m), x = new Ct(), b = a(Me(_, [c, f], [0, 1], !0)), S = y.getModel("title");
        if (S.get("show")) {
          var w = S.get("offsetCenter"), A = o.cx + dt(w[0], o.r), T = o.cy + dt(w[1], o.r), M = d[m];
          M.attr({
            z2: v ? 0 : 2,
            style: Oe(S, {
              x: A,
              y: T,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: b
            })
          }), x.add(M);
        }
        var C = y.getModel("detail");
        if (C.get("show")) {
          var R = C.get("offsetCenter"), E = o.cx + dt(R[0], o.r), D = o.cy + dt(R[1], o.r), I = dt(C.get("width"), o.r), P = dt(C.get("height"), o.r), O = e.get(["progress", "show"]) ? l.getItemVisual(m, "style").fill : b, M = p[m], N = C.get("formatter");
          M.attr({
            z2: v ? 0 : 2,
            style: Oe(C, {
              x: E,
              y: D,
              text: xp(_, N),
              width: isNaN(I) ? null : I,
              height: isNaN(P) ? null : P,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: O
            })
          }), AN(M, {
            normal: C
          }, _, function(F) {
            return xp(F, N);
          }), g && EN(M, m, l, e, {
            getFormattedLabel: function(F, G, W, J, U, Y) {
              return xp(Y ? Y.interpolatedValue : _, N);
            }
          }), x.add(M);
        }
        h.add(x);
      }), this.group.add(h), this._titleEls = d, this._detailEls = p;
    }, t.type = "gauge", t;
  }(Re)
), gtt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "itemStyle", e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Nc(this, ["value"]);
    }, t.type = "series.gauge", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 
      min: 0,
      // 
      max: 100,
      // 10
      splitNumber: 10,
      // 
      axisLine: {
        // show
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, X.color.neutral10]],
          width: 10
        }
      },
      // 
      progress: {
        // show
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 
      splitLine: {
        // show
        show: !0,
        // length
        length: 10,
        distance: 10,
        // lineStylelineStyle
        lineStyle: {
          color: X.color.axisTick,
          width: 3,
          type: "solid"
        }
      },
      // 
      axisTick: {
        // show
        show: !0,
        // split
        splitNumber: 5,
        // length
        length: 6,
        distance: 10,
        // lineStyle
        lineStyle: {
          color: X.color.axisTickMinor,
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: X.color.axisLabel,
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: X.color.neutral00,
          borderWidth: 0,
          borderColor: X.color.theme[0]
        }
      },
      title: {
        show: !0,
        // x, ypx
        offsetCenter: [0, "20%"],
        // TEXTSTYLE
        color: X.color.secondary,
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: X.color.transparent,
        borderWidth: 0,
        borderColor: X.color.neutral40,
        width: 100,
        height: null,
        padding: [5, 10],
        // x, ypx
        offsetCenter: [0, "40%"],
        // formatter: null,
        // TEXTSTYLE
        color: X.color.primary,
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, t;
  }(ke)
);
function mtt(r) {
  r.registerChartView(vtt), r.registerSeriesModel(gtt);
}
var ytt = ["itemStyle", "opacity"], _tt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      var i = r.call(this) || this, a = i, o = new Gr(), s = new pe();
      return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(e, n, !0), i;
    }
    return t.prototype.updateData = function(e, n, i) {
      var a = this, o = e.hostModel, s = e.getItemModel(n), l = e.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(ytt);
      c = c ?? 1, i || oi(a), a.useStyle(e.getItemVisual(n, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, ze(a, {
        style: {
          opacity: c
        }
      }, o, n)) : ve(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, n), _r(a, s), this._updateLabel(e, n), He(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, n) {
      var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = e.hostModel, l = e.getItemModel(n), u = e.getItemLayout(n), c = u.label, f = e.getItemVisual(n, "style"), h = f.fill;
      Cr(
        // position will not be used in setLabelStyle
        o,
        xr(l),
        {
          labelFetcher: e.hostModel,
          labelDataIndex: n,
          defaultOpacity: f.opacity,
          defaultText: e.getName(n)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      );
      var d = l.getModel("label"), p = d.get("color"), g = p === "inherit" ? h : null;
      i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: g,
        outsideFill: g
      });
      var v = c.linePoints;
      a.setShape({
        points: v
      }), i.textGuideLineConfig = {
        anchor: v ? new Ot(v[0][0], v[0][1]) : null
      }, ve(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), Mb(i, Tb(l), {
        // Default use item visual color
        stroke: h
      });
    }, t;
  }(Jr)
), xtt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreLabelLineUpdate = !0, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new _tt(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        Na(u, e, l);
      }).execute(), this._data = a;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.prototype.dispose = function() {
    }, t.type = "funnel", t;
  }(Re)
), Stt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Oc(gt(this.getData, this), gt(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.getInitialData = function(e, n) {
      return Nc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(ib, this)
      });
    }, t.prototype._defaultLabelLine = function(e) {
      dl(e, "labelLine", ["show"]);
      var n = e.labelLine, i = e.emphasis.labelLine;
      n.show = n.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.prototype.getDataParams = function(e) {
      var n = this.getData(), i = r.prototype.getDataParams.call(this, e), a = n.mapDimension("value"), o = n.getSum(a);
      return i.percent = o ? +(n.get(a, e) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, t.type = "series.funnel", t.defaultOption = {
      coordinateSystemUsage: "box",
      // zlevel: 0,                  // 
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 65,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: Tooltip.formatter
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: ,
          width: 1
        }
      },
      itemStyle: {
        // color: ,
        borderColor: X.color.neutral00,
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      }
    }, t;
  }(ke)
);
function btt(r, t) {
  for (var e = r.mapDimension("value"), n = r.mapArray(e, function(l) {
    return l;
  }), i = [], a = t === "ascending", o = 0, s = r.count(); o < s; o++)
    i[o] = o;
  return At(t) ? i.sort(t) : t !== "none" && i.sort(function(l, u) {
    return a ? n[l] - n[u] : n[u] - n[l];
  }), i;
}
function wtt(r) {
  var t = r.hostModel, e = t.get("orient");
  r.each(function(n) {
    var i = r.getItemModel(n), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = r.getItemLayout(n), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", f, h, d, p;
    if (c)
      o === "insideLeft" ? (h = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, f = "left") : o === "insideRight" ? (h = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, f = "right") : (h = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, f = "center"), p = [[h, d], [h, d]];
    else {
      var g = void 0, v = void 0, m = void 0, y = void 0, _ = s.get("length");
      process.env.NODE_ENV !== "production" && (e === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), e === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), o === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - _, h = m - 5, f = "right") : o === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + _, h = m + 5, f = "left") : o === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - _, d = y - 5, f = "center") : o === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + _, d = y + 5, f = "center") : o === "rightTop" ? (g = e === "horizontal" ? u[3][0] : u[1][0], v = e === "horizontal" ? u[3][1] : u[1][1], e === "horizontal" ? (y = v - _, d = y - 5, f = "center") : (m = g + _, h = m + 5, f = "top")) : o === "rightBottom" ? (g = u[2][0], v = u[2][1], e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g + _, h = m + 5, f = "bottom")) : o === "leftTop" ? (g = u[0][0], v = e === "horizontal" ? u[0][1] : u[1][1], e === "horizontal" ? (y = v - _, d = y - 5, f = "center") : (m = g - _, h = m - 5, f = "right")) : o === "leftBottom" ? (g = e === "horizontal" ? u[1][0] : u[3][0], v = e === "horizontal" ? u[1][1] : u[2][1], e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g - _, h = m - 5, f = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g + _, h = m + 5, f = "left")), e === "horizontal" ? (m = g, h = m) : (y = v, d = y), p = [[g, v], [m, y]];
    }
    l.label = {
      linePoints: p,
      x: h,
      y: d,
      verticalAlign: "middle",
      textAlign: f,
      inside: c
    };
  });
}
function Mtt(r, t) {
  r.eachSeriesByType("funnel", function(e) {
    var n = e.getData(), i = n.mapDimension("value"), a = e.get("sort"), o = Sr(e, t), s = We(e.getBoxLayoutParams(), o.refContainer), l = e.get("orient"), u = s.width, c = s.height, f = btt(n, a), h = s.x, d = s.y, p = l === "horizontal" ? [dt(e.get("minSize"), c), dt(e.get("maxSize"), c)] : [dt(e.get("minSize"), u), dt(e.get("maxSize"), u)], g = n.getDataExtent(i), v = e.get("min"), m = e.get("max");
    v == null && (v = Math.min(g[0], 0)), m == null && (m = g[1]);
    var y = e.get("funnelAlign"), _ = e.get("gap"), x = l === "horizontal" ? u : c, b = (x - _ * (n.count() - 1)) / n.count(), S = function(I, P) {
      if (l === "horizontal") {
        var O = n.get(i, I) || 0, N = Me(O, [v, m], p, !0), B = void 0;
        switch (y) {
          case "top":
            B = d;
            break;
          case "center":
            B = d + (c - N) / 2;
            break;
          case "bottom":
            B = d + (c - N);
            break;
        }
        return [[P, B], [P, B + N]];
      }
      var F = n.get(i, I) || 0, G = Me(F, [v, m], p, !0), W;
      switch (y) {
        case "left":
          W = h;
          break;
        case "center":
          W = h + (u - G) / 2;
          break;
        case "right":
          W = h + u - G;
          break;
      }
      return [[W, P], [W + G, P]];
    };
    a === "ascending" && (b = -b, _ = -_, l === "horizontal" ? h += u : d += c, f = f.reverse());
    for (var w = 0; w < f.length; w++) {
      var A = f[w], T = f[w + 1], M = n.getItemModel(A);
      if (l === "horizontal") {
        var C = M.get(["itemStyle", "width"]);
        C == null ? C = b : (C = dt(C, u), a === "ascending" && (C = -C));
        var R = S(A, h), E = S(T, h + C);
        h += C + _, n.setItemLayout(A, {
          points: R.concat(E.slice().reverse())
        });
      } else {
        var D = M.get(["itemStyle", "height"]);
        D == null ? D = b : (D = dt(D, c), a === "ascending" && (D = -D));
        var R = S(A, d), E = S(T, d + D);
        d += D + _, n.setItemLayout(A, {
          points: R.concat(E.slice().reverse())
        });
      }
    }
    wtt(n);
  });
}
function Ttt(r) {
  r.registerChartView(xtt), r.registerSeriesModel(Stt), r.registerLayout(Mtt), r.registerProcessor(Pc("funnel"));
}
var Att = 0.3, Ett = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._dataGroup = new Ct(), e._initialized = !1, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, t.prototype.render = function(e, n, i, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = e.getData(), l = this._data, u = e.coordinateSystem, c = u.dimensions, f = cL(e);
      s.diff(l).add(h).update(d).remove(p).execute();
      function h(v) {
        var m = uL(s, o, v, c, u);
        e_(m, s, v, f);
      }
      function d(v, m) {
        var y = l.getItemGraphicEl(m), _ = _B(s, v, c, u);
        s.setItemGraphicEl(v, y), ve(y, {
          shape: {
            points: _
          }
        }, e, v), oi(y), e_(y, s, v, f);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        o.remove(m);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = Ctt(u, e, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(g);
      }
      this._data = s;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, t.prototype.incrementalRender = function(e, n, i) {
      for (var a = n.getData(), o = n.coordinateSystem, s = o.dimensions, l = cL(n), u = this._progressiveEls = [], c = e.start; c < e.end; c++) {
        var f = uL(a, this._dataGroup, c, s, o);
        f.incremental = !0, e_(f, a, c, l), u.push(f);
      }
    }, t.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, t.type = "parallel", t;
  }(Re)
);
function Ctt(r, t, e) {
  var n = r.model, i = r.getRect(), a = new te({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), o = n.get("layout") === "horizontal" ? "width" : "height";
  return a.setShape(o, 0), ze(a, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, t, e), a;
}
function _B(r, t, e, n) {
  for (var i = [], a = 0; a < e.length; a++) {
    var o = e[a], s = r.get(r.mapDimension(o), t);
    Dtt(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o));
  }
  return i;
}
function uL(r, t, e, n, i) {
  var a = _B(r, e, n, i), o = new Gr({
    shape: {
      points: a
    },
    // silent: true,
    z2: 10
  });
  return t.add(o), r.setItemGraphicEl(e, o), o;
}
function cL(r) {
  var t = r.get("smooth", !0);
  return t === !0 && (t = Att), t = Ha(t), kr(t) && (t = 0), {
    smooth: t
  };
}
function e_(r, t, e, n) {
  r.useStyle(t.getItemVisual(e, "style")), r.style.fill = null, r.setShape("smooth", n.smooth);
  var i = t.getItemModel(e), a = i.getModel("emphasis");
  _r(r, i, "lineStyle"), He(r, a.get("focus"), a.get("blurScope"), a.get("disabled"));
}
function Dtt(r, t) {
  return t === "category" ? r == null : r == null || isNaN(r);
}
var Ltt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Ja(null, this, {
        useEncodeDefaulter: gt(Rtt, null, this)
      });
    }, t.prototype.getRawIndicesByActiveState = function(e) {
      var n = this.coordinateSystem, i = this.getData(), a = [];
      return n.eachActiveState(i, function(o, s) {
        e === o && a.push(i.getRawIndex(s));
      }), a;
    }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, t;
  }(ke)
);
function Rtt(r) {
  var t = r.ecModel.getComponent("parallel", r.get("parallelIndex"));
  if (t) {
    var e = {};
    return L(t.dimensions, function(n) {
      var i = Itt(n);
      e[n] = i;
    }), e;
  }
}
function Itt(r) {
  return +r.replace("dim", "");
}
var Ptt = ["lineStyle", "opacity"], Ntt = {
  seriesType: "parallel",
  reset: function(r, t) {
    var e = r.coordinateSystem, n = {
      normal: r.get(["lineStyle", "opacity"]),
      active: r.get("activeOpacity"),
      inactive: r.get("inactiveOpacity")
    };
    return {
      progress: function(i, a) {
        e.eachActiveState(a, function(o, s) {
          var l = n[o];
          if (o === "normal" && a.hasItemOption) {
            var u = a.getItemModel(s).get(Ptt, !0);
            u != null && (l = u);
          }
          var c = a.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
function Ott(r) {
  ktt(r), Btt(r);
}
function ktt(r) {
  if (!r.parallel) {
    var t = !1;
    L(r.series, function(e) {
      e && e.type === "parallel" && (t = !0);
    }), t && (r.parallel = [{}]);
  }
}
function Btt(r) {
  var t = Ie(r.parallelAxis);
  L(t, function(e) {
    if (Lt(e)) {
      var n = e.parallelIndex || 0, i = Ie(r.parallel)[n];
      i && i.parallelAxisDefault && qt(e, i.parallelAxisDefault, !1);
    }
  });
}
var Vtt = 5, Ftt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this._model = e, this._api = i, this._handlers || (this._handlers = {}, L(ztt, function(a, o) {
        i.getZr().on(o, this._handlers[o] = gt(a, this));
      }, this)), Lc(this, "_throttledDispatchExpand", e.get("axisExpandRate"), "fixRate");
    }, t.prototype.dispose = function(e, n) {
      fh(this, "_throttledDispatchExpand"), L(this._handlers, function(i, a) {
        n.getZr().off(a, i);
      }), this._handlers = null;
    }, t.prototype._throttledDispatchExpand = function(e) {
      this._dispatchExpand(e);
    }, t.prototype._dispatchExpand = function(e) {
      e && this._api.dispatchAction(j({
        type: "parallelAxisExpand"
      }, e));
    }, t.type = "parallel", t;
  }(Ge)
), ztt = {
  mousedown: function(r) {
    r_(this, "click") && (this._mouseDownPoint = [r.offsetX, r.offsetY]);
  },
  mouseup: function(r) {
    var t = this._mouseDownPoint;
    if (r_(this, "click") && t) {
      var e = [r.offsetX, r.offsetY], n = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
      if (n > Vtt)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(r) {
    if (!(this._mouseDownPoint || !r_(this, "mousemove"))) {
      var t = this._model, e = t.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]), n = e.behavior;
      n === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
        axisExpandWindow: e.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: n === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function r_(r, t) {
  var e = r._model;
  return e.get("axisExpandable") && e.get("axisExpandTriggerOn") === t;
}
var Utt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      r.prototype.init.apply(this, arguments), this.mergeOption({});
    }, t.prototype.mergeOption = function(e) {
      var n = this.option;
      e && qt(n, e, !0), this._initDimensions();
    }, t.prototype.contains = function(e, n) {
      var i = e.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, t.prototype.setAxisExpand = function(e) {
      L(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(n) {
        e.hasOwnProperty(n) && (this.option[n] = e[n]);
      }, this);
    }, t.prototype._initDimensions = function() {
      var e = this.dimensions = [], n = this.parallelAxisIndex = [], i = Te(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      L(i, function(a) {
        e.push("dim" + a.get("dim")), n.push(a.componentIndex);
      });
    }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, t;
  }(re)
), Gtt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return t.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, t;
  }(Ei)
);
function Yo(r, t, e, n, i, a) {
  r = r || 0;
  var o = e[1] - e[0];
  if (i != null && (i = _u(i, [0, o])), a != null && (a = Math.max(a, i ?? 0)), n === "all") {
    var s = Math.abs(t[1] - t[0]);
    s = _u(s, [0, o]), i = a = _u(s, [i, a]), n = 0;
  }
  t[0] = _u(t[0], e), t[1] = _u(t[1], e);
  var l = n_(t, n);
  t[n] += r;
  var u = i || 0, c = e.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, t[n] = _u(t[n], c);
  var f;
  return f = n_(t, n), i != null && (f.sign !== l.sign || f.span < i) && (t[1 - n] = t[n] + l.sign * i), f = n_(t, n), a != null && f.span > a && (t[1 - n] = t[n] + f.sign * a), t;
}
function n_(r, t) {
  var e = r[t] - r[1 - t];
  return {
    span: Math.abs(e),
    sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1
  };
}
function _u(r, t) {
  return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, r));
}
var i_ = L, xB = Math.min, SB = Math.max, fL = Math.floor, Htt = Math.ceil, hL = sr, Wtt = Math.PI, Xtt = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "parallel", this._axesMap = wt(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, e, n);
    }
    return r.prototype._init = function(t, e, n) {
      var i = t.dimensions, a = t.parallelAxisIndex;
      i_(i, function(o, s) {
        var l = a[s], u = e.getComponent("parallelAxis", l), c = this._axesMap.set(o, new Gtt(o, vm(u), [0, 0], u.get("type"), l)), f = c.type === "category";
        c.onBand = f && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, r.prototype.update = function(t, e) {
      this._updateAxesFromSeries(this._model, t);
    }, r.prototype.containPoint = function(t) {
      var e = this._makeLayoutInfo(), n = e.axisBase, i = e.layoutBase, a = e.pixelDimIndex, o = t[1 - a], s = t[a];
      return o >= n && o <= n + e.axisLength && s >= i && s <= i + e.layoutLength;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype._updateAxesFromSeries = function(t, e) {
      e.eachSeries(function(n) {
        if (t.contains(n, e)) {
          var i = n.getData();
          i_(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(i, i.mapDimension(a)), lc(o.scale, o.model);
          }, this);
        }
      }, this);
    }, r.prototype.resize = function(t, e) {
      var n = Sr(t, e).refContainer;
      this._rect = We(t.getBoxLayoutParams(), n), this._layoutAxes();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._makeLayoutInfo = function() {
      var t = this._model, e = this._rect, n = ["x", "y"], i = ["width", "height"], a = t.get("layout"), o = a === "horizontal" ? 0 : 1, s = e[i[o]], l = [0, s], u = this.dimensions.length, c = Sp(t.get("axisExpandWidth"), l), f = Sp(t.get("axisExpandCount") || 0, [0, u]), h = t.get("axisExpandable") && u > 3 && u > f && f > 1 && c > 0 && s > 0, d = t.get("axisExpandWindow"), p;
      if (d)
        p = Sp(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = Sp(c * (f - 1), l);
        var g = t.get("axisExpandCenter") || fL(u / 2);
        d = [c * g - p / 2], d[1] = d[0] + p;
      }
      var v = (s - p) / (u - f);
      v < 3 && (v = 0);
      var m = [fL(hL(d[0] / c, 1)) + 1, Htt(hL(d[1] / c, 1)) - 1], y = v / c * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: e[n[o]],
        layoutLength: s,
        axisBase: e[n[1 - o]],
        axisLength: e[i[1 - o]],
        axisExpandable: h,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, r.prototype._layoutAxes = function() {
      var t = this._rect, e = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      e.each(function(o) {
        var s = [0, i.axisLength], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), i_(n, function(o, s) {
        var l = (i.axisExpandable ? $tt : Ytt)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: Wtt / 2,
          vertical: 0
        }, f = [u[a].x + t.x, u[a].y + t.y], h = c[a], d = Br();
        Ko(d, d, h), na(d, d, f), this._axesLayout[o] = {
          position: f,
          rotation: h,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, r.prototype.getAxis = function(t) {
      return this._axesMap.get(t);
    }, r.prototype.dataToPoint = function(t, e) {
      return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
    }, r.prototype.eachActiveState = function(t, e, n, i) {
      n == null && (n = 0), i == null && (i = t.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      L(o, function(v) {
        s.push(t.mapDimension(v)), l.push(a.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var f = void 0;
        if (!u)
          f = "normal";
        else {
          f = "active";
          for (var h = t.getValues(s, c), d = 0, p = o.length; d < p; d++) {
            var g = l[d].getActiveState(h[d]);
            if (g === "inactive") {
              f = "inactive";
              break;
            }
          }
        }
        e(f, c);
      }
    }, r.prototype.hasAxisBrushed = function() {
      for (var t = this.dimensions, e = this._axesMap, n = !1, i = 0, a = t.length; i < a; i++)
        e.get(t[i]).model.getActiveState() !== "normal" && (n = !0);
      return n;
    }, r.prototype.axisCoordToPoint = function(t, e) {
      var n = this._axesLayout[e];
      return _i([t, 0], n.transform);
    }, r.prototype.getAxisLayout = function(t) {
      return Dt(this._axesLayout[t]);
    }, r.prototype.getSlidedAxisExpandWindow = function(t) {
      var e = this._makeLayoutInfo(), n = e.pixelDimIndex, i = e.axisExpandWindow.slice(), a = i[1] - i[0], o = [0, e.axisExpandWidth * (e.axisCount - 1)];
      if (!this.containPoint(t))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = t[n] - e.layoutBase - e.axisExpandWindow0Pos, l, u = "slide", c = e.axisCollapseWidth, f = this._model.get("axisExpandSlideTriggerArea"), h = f[0] != null;
      if (c)
        h && c && s < a * f[0] ? (u = "jump", l = s - a * f[2]) : h && c && s > a * (1 - f[0]) ? (u = "jump", l = s - a * (1 - f[2])) : (l = s - a * f[1]) >= 0 && (l = s - a * (1 - f[1])) <= 0 && (l = 0), l *= e.axisExpandWidth / c, l ? Yo(l, i, o, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = o[1] * s / d;
        i = [SB(0, p - d / 2)], i[1] = xB(o[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, r;
  }()
);
function Sp(r, t) {
  return xB(SB(r, t[0]), t[1]);
}
function Ytt(r, t) {
  var e = t.layoutLength / (t.axisCount - 1);
  return {
    position: e * r,
    axisNameAvailableWidth: e,
    axisLabelShow: !0
  };
}
function $tt(r, t) {
  var e = t.layoutLength, n = t.axisExpandWidth, i = t.axisCount, a = t.axisCollapseWidth, o = t.winInnerIndices, s, l = a, u = !1, c;
  return r < o[0] ? (s = r * a, c = a) : r <= o[1] ? (s = t.axisExpandWindow0Pos + r * n - t.axisExpandWindow[0], l = n, u = !0) : (s = e - (i - 1 - r) * a, c = a), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function Ztt(r, t) {
  var e = [];
  return r.eachComponent("parallel", function(n, i) {
    var a = new Xtt(n, r, t);
    a.name = "parallel_" + i, a.resize(n, t), n.coordinateSystem = a, a.model = n, e.push(a);
  }), r.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "parallel") {
      var i = n.getReferringComponents("parallel", je).models[0];
      n.coordinateSystem = i.coordinateSystem;
    }
  }), e;
}
var qtt = {
  create: Ztt
}, NS = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.activeIntervals = [], e;
    }
    return t.prototype.getAreaSelectStyle = function() {
      return vl([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, t.prototype.setActiveIntervals = function(e) {
      var n = this.activeIntervals = Dt(e);
      if (n)
        for (var i = n.length - 1; i >= 0; i--)
          ri(n[i]);
    }, t.prototype.getActiveState = function(e) {
      var n = this.activeIntervals;
      if (!n.length)
        return "normal";
      if (e == null || isNaN(+e))
        return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= e && e <= i[1])
          return "active";
      } else
        for (var a = 0, o = n.length; a < o; a++)
          if (n[a][0] <= e && e <= n[a][1])
            return "active";
      return "inactive";
    }, t;
  }(re)
);
dr(NS, Wh);
var xl = !0, Th = Math.min, dc = Math.max, Ktt = Math.pow, jtt = 1e4, Jtt = 6, Qtt = 6, dL = "globalPan", tet = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, eet = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, pL = {
  brushStyle: {
    lineWidth: 2,
    stroke: X.color.backgroundTint,
    fill: X.color.borderTint
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, ret = 0, Jb = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, process.env.NODE_ENV !== "production" && St(e), n._zr = e, n.group = new Ct(), n._uid = "brushController_" + ret++, L(cet, function(i, a) {
        this._handlers[a] = gt(i, this);
      }, n), n;
    }
    return t.prototype.enableBrush = function(e) {
      return process.env.NODE_ENV !== "production" && St(this._mounted), this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this;
    }, t.prototype._doEnableBrush = function(e) {
      var n = this._zr;
      this._enableGlobalPan || Fj(n, dL, this._uid), L(this._handlers, function(i, a) {
        n.on(a, i);
      }), this._brushType = e.brushType, this._brushOption = qt(Dt(pL), e, !0);
    }, t.prototype._doDisableBrush = function() {
      var e = this._zr;
      zj(e, dL, this._uid), L(this._handlers, function(n, i) {
        e.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, t.prototype.setPanels = function(e) {
      if (e && e.length) {
        var n = this._panels = {};
        L(e, function(i) {
          n[i.panelId] = Dt(i);
        });
      } else
        this._panels = null;
      return this;
    }, t.prototype.mount = function(e) {
      e = e || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = e.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: e.x || 0,
        y: e.y || 0,
        rotation: e.rotation || 0,
        scaleX: e.scaleX || 1,
        scaleY: e.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, t.prototype.updateCovers = function(e) {
      process.env.NODE_ENV !== "production" && St(this._mounted), e = rt(e, function(h) {
        return qt(Dt(pL), h, !0);
      });
      var n = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new Ya(i, e, u, l).add(c).update(c).remove(f).execute(), this;
      function l(h, d) {
        return (h.id != null ? h.id : n + d) + "-" + h.brushType;
      }
      function u(h, d) {
        return l(h.__brushOption, d);
      }
      function c(h, d) {
        var p = e[h];
        if (d != null && i[d] === s)
          a[h] = i[d];
        else {
          var g = a[h] = d != null ? (i[d].__brushOption = p, i[d]) : wB(o, bB(o, p));
          Qb(o, g);
        }
      }
      function f(h) {
        i[h] !== s && o.group.remove(i[h]);
      }
    }, t.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), OS(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, t.prototype.dispose = function() {
      this.unmount(), this.off();
    }, t;
  }(si)
);
function bB(r, t) {
  var e = Mm[t.brushType].createCover(r, t);
  return e.__brushOption = t, TB(e, t), r.group.add(e), e;
}
function wB(r, t) {
  var e = tw(t);
  return e.endCreating && (e.endCreating(r, t), TB(t, t.__brushOption)), t;
}
function MB(r, t) {
  var e = t.__brushOption;
  tw(t).updateCoverShape(r, t, e.range, e);
}
function TB(r, t) {
  var e = t.z;
  e == null && (e = jtt), r.traverse(function(n) {
    n.z = e, n.z2 = e;
  });
}
function Qb(r, t) {
  tw(t).updateCommon(r, t), MB(r, t);
}
function tw(r) {
  return Mm[r.__brushOption.brushType];
}
function ew(r, t, e) {
  var n = r._panels;
  if (!n)
    return xl;
  var i, a = r._transform;
  return L(n, function(o) {
    o.isTargetByCursor(t, e, a) && (i = o);
  }), i;
}
function AB(r, t) {
  var e = r._panels;
  if (!e)
    return xl;
  var n = t.__brushOption.panelId;
  return n != null ? e[n] : xl;
}
function OS(r) {
  var t = r._covers, e = t.length;
  return L(t, function(n) {
    r.group.remove(n);
  }, r), t.length = 0, !!e;
}
function Sl(r, t) {
  var e = rt(r._covers, function(n) {
    var i = n.__brushOption, a = Dt(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: a
    };
  });
  r.trigger("brush", {
    areas: e,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick
  });
}
function net(r) {
  var t = r._track;
  if (!t.length)
    return !1;
  var e = t[t.length - 1], n = t[0], i = e[0] - n[0], a = e[1] - n[1], o = Ktt(i * i + a * a, 0.5);
  return o > Jtt;
}
function EB(r) {
  var t = r.length - 1;
  return t < 0 && (t = 0), [r[0], r[t]];
}
function CB(r, t, e, n) {
  var i = new Ct();
  return i.add(new te({
    name: "main",
    style: rw(e),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Yt(vL, r, t, i, ["n", "s", "w", "e"]),
    ondragend: Yt(Sl, t, {
      isEnd: !0
    })
  })), L(n, function(a) {
    i.add(new te({
      name: a.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Yt(vL, r, t, i, a),
      ondragend: Yt(Sl, t, {
        isEnd: !0
      })
    }));
  }), i;
}
function DB(r, t, e, n) {
  var i = n.brushStyle.lineWidth || 0, a = dc(i, Qtt), o = e[0][0], s = e[1][0], l = o - i / 2, u = s - i / 2, c = e[0][1], f = e[1][1], h = c - a + i / 2, d = f - a + i / 2, p = c - o, g = f - s, v = p + i, m = g + i;
  ba(r, t, "main", o, s, p, g), n.transformable && (ba(r, t, "w", l, u, a, m), ba(r, t, "e", h, u, a, m), ba(r, t, "n", l, u, v, a), ba(r, t, "s", l, d, v, a), ba(r, t, "nw", l, u, a, a), ba(r, t, "ne", h, u, a, a), ba(r, t, "sw", l, d, a, a), ba(r, t, "se", h, d, a, a));
}
function kS(r, t) {
  var e = t.__brushOption, n = e.transformable, i = t.childAt(0);
  i.useStyle(rw(e)), i.attr({
    silent: !n,
    cursor: n ? "move" : "default"
  }), L([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
    var o = t.childOfName(a.join("")), s = a.length === 1 ? BS(r, a[0]) : aet(r, a);
    o && o.attr({
      silent: !n,
      invisible: !n,
      cursor: n ? eet[s] + "-resize" : null
    });
  });
}
function ba(r, t, e, n, i, a, o) {
  var s = t.childOfName(e);
  s && s.setShape(set(nw(r, t, [[n, i], [n + a, i + o]])));
}
function rw(r) {
  return Bt({
    strokeNoScale: !0
  }, r.brushStyle);
}
function LB(r, t, e, n) {
  var i = [Th(r, e), Th(t, n)], a = [dc(r, e), dc(t, n)];
  return [
    [i[0], a[0]],
    [i[1], a[1]]
    // y range
  ];
}
function iet(r) {
  return sl(r.group);
}
function BS(r, t) {
  var e = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, n = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = om(e[t], iet(r));
  return n[i];
}
function aet(r, t) {
  var e = [BS(r, t[0]), BS(r, t[1])];
  return (e[0] === "e" || e[0] === "w") && e.reverse(), e.join("");
}
function vL(r, t, e, n, i, a) {
  var o = e.__brushOption, s = r.toRectRange(o.range), l = RB(t, i, a);
  L(n, function(u) {
    var c = tet[u];
    s[c[0]][c[1]] += l[c[0]];
  }), o.range = r.fromRectRange(LB(s[0][0], s[1][0], s[0][1], s[1][1])), Qb(t, e), Sl(t, {
    isEnd: !1
  });
}
function oet(r, t, e, n) {
  var i = t.__brushOption.range, a = RB(r, e, n);
  L(i, function(o) {
    o[0] += a[0], o[1] += a[1];
  }), Qb(r, t), Sl(r, {
    isEnd: !1
  });
}
function RB(r, t, e) {
  var n = r.group, i = n.transformCoordToLocal(t, e), a = n.transformCoordToLocal(0, 0);
  return [i[0] - a[0], i[1] - a[1]];
}
function nw(r, t, e) {
  var n = AB(r, t);
  return n && n !== xl ? n.clipPath(e, r._transform) : Dt(e);
}
function set(r) {
  var t = Th(r[0][0], r[1][0]), e = Th(r[0][1], r[1][1]), n = dc(r[0][0], r[1][0]), i = dc(r[0][1], r[1][1]);
  return {
    x: t,
    y: e,
    width: n - t,
    height: i - e
  };
}
function uet(r, t, e) {
  if (
    // Check active
    !(!r._brushType || fet(r, t.offsetX, t.offsetY))
  ) {
    var n = r._zr, i = r._covers, a = ew(r, t, e);
    if (!r._dragging)
      for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption;
        if (a && (a === xl || s.panelId === a.panelId) && Mm[s.brushType].contain(i[o], e[0], e[1]))
          return;
      }
    a && n.setCursorStyle("crosshair");
  }
}
function VS(r) {
  var t = r.event;
  t.preventDefault && t.preventDefault();
}
function FS(r, t, e) {
  return r.childOfName("main").contain(t, e);
}
function IB(r, t, e, n) {
  var i = r._creatingCover, a = r._creatingPanel, o = r._brushOption, s;
  if (r._track.push(e.slice()), net(r) || i) {
    if (a && !i) {
      o.brushMode === "single" && OS(r);
      var l = Dt(o);
      l.brushType = gL(l.brushType, a), l.panelId = a === xl ? null : a.panelId, i = r._creatingCover = bB(r, l), r._covers.push(i);
    }
    if (i) {
      var u = Mm[gL(r._brushType, a)], c = i.__brushOption;
      c.range = u.getCreatingRange(nw(r, i, r._track)), n && (wB(r, i), u.updateCommon(r, i)), MB(r, i), s = {
        isEnd: n
      };
    }
  } else
    n && o.brushMode === "single" && o.removeOnClick && ew(r, t, e) && OS(r) && (s = {
      isEnd: n,
      removeOnClick: !0
    });
  return s;
}
function gL(r, t) {
  return r === "auto" ? (process.env.NODE_ENV !== "production" && St(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : r;
}
var cet = {
  mousedown: function(r) {
    if (this._dragging)
      mL(this, r);
    else if (!r.target || !r.target.draggable) {
      VS(r);
      var t = this.group.transformCoordToLocal(r.offsetX, r.offsetY);
      this._creatingCover = null;
      var e = this._creatingPanel = ew(this, r, t);
      e && (this._dragging = !0, this._track = [t.slice()]);
    }
  },
  mousemove: function(r) {
    var t = r.offsetX, e = r.offsetY, n = this.group.transformCoordToLocal(t, e);
    if (uet(this, r, n), this._dragging) {
      VS(r);
      var i = IB(this, r, n, !1);
      i && Sl(this, i);
    }
  },
  mouseup: function(r) {
    mL(this, r);
  }
};
function mL(r, t) {
  if (r._dragging) {
    VS(t);
    var e = t.offsetX, n = t.offsetY, i = r.group.transformCoordToLocal(e, n), a = IB(r, t, i, !0);
    r._dragging = !1, r._track = [], r._creatingCover = null, a && Sl(r, a);
  }
}
function fet(r, t, e) {
  var n = r._zr;
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight();
}
var Mm = {
  lineX: yL(0),
  lineY: yL(1),
  rect: {
    createCover: function(r, t) {
      function e(n) {
        return n;
      }
      return CB({
        toRectRange: e,
        fromRectRange: e
      }, r, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(r) {
      var t = EB(r);
      return LB(t[1][0], t[1][1], t[0][0], t[0][1]);
    },
    updateCoverShape: function(r, t, e, n) {
      DB(r, t, e, n);
    },
    updateCommon: kS,
    contain: FS
  },
  polygon: {
    createCover: function(r, t) {
      var e = new Ct();
      return e.add(new Gr({
        name: "main",
        style: rw(t),
        silent: !0
      })), e;
    },
    getCreatingRange: function(r) {
      return r;
    },
    endCreating: function(r, t) {
      t.remove(t.childAt(0)), t.add(new Jr({
        name: "main",
        draggable: !0,
        drift: Yt(oet, r, t),
        ondragend: Yt(Sl, r, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(r, t, e, n) {
      t.childAt(0).setShape({
        points: nw(r, t, e)
      });
    },
    updateCommon: kS,
    contain: FS
  }
};
function yL(r) {
  return {
    createCover: function(t, e) {
      return CB({
        toRectRange: function(n) {
          var i = [n, [0, 100]];
          return r && i.reverse(), i;
        },
        fromRectRange: function(n) {
          return n[r];
        }
      }, t, e, [[["w"], ["e"]], [["n"], ["s"]]][r]);
    },
    getCreatingRange: function(t) {
      var e = EB(t), n = Th(e[0][r], e[1][r]), i = dc(e[0][r], e[1][r]);
      return [n, i];
    },
    updateCoverShape: function(t, e, n, i) {
      var a, o = AB(t, e);
      if (o !== xl && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r);
      else {
        var s = t._zr;
        a = [0, [s.getWidth(), s.getHeight()][1 - r]];
      }
      var l = [n, a];
      r && l.reverse(), DB(t, e, l, i);
    },
    updateCommon: kS,
    contain: FS
  };
}
function PB(r) {
  return r = iw(r), function(t) {
    return SN(t, r);
  };
}
function NB(r, t) {
  return r = iw(r), function(e) {
    var n = t ?? e, i = n ? r.width : r.height, a = n ? r.x : r.y;
    return [a, a + (i || 0)];
  };
}
function OB(r, t, e) {
  var n = iw(r);
  return function(i, a) {
    return n.contain(a[0], a[1]) && !z3(i, t, e);
  };
}
function iw(r) {
  return Vt.create(r);
}
var het = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      r.prototype.init.apply(this, arguments), (this._brushController = new Jb(n.getZr())).on("brush", gt(this._onBrush, this));
    }, t.prototype.render = function(e, n, i, a) {
      if (!det(e, n, a)) {
        this.axisModel = e, this.api = i, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!e.get("show")) {
          var s = vet(e, n), l = s.coordinateSystem, u = e.getAreaSelectStyle(), c = u.width, f = e.axis.dim, h = l.getAxisLayout(f), d = j({
            strokeContainThreshold: c
          }, h), p = new fn(e, i, d);
          p.build(), this._axisGroup.add(p.group), this._refreshBrushController(d, u, e, s, c, i), Vh(o, this._axisGroup, e);
        }
      }
    }, t.prototype._refreshBrushController = function(e, n, i, a, o, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), f = Vt.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      f.x -= c, f.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: e.rotation,
        x: e.position[0],
        y: e.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: PB(f),
        isTargetByCursor: OB(f, s, a),
        getLinearBrushOtherExtent: NB(f, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: !0
      }).updateCovers(pet(i));
    }, t.prototype._onBrush = function(e) {
      var n = e.areas, i = this.axisModel, a = i.axis, o = rt(n, function(s) {
        return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: o
      });
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.type = "parallelAxis", t;
  }(Ge)
);
function det(r, t, e) {
  return e && e.type === "axisAreaSelect" && t.findComponents({
    mainType: "parallelAxis",
    query: e
  })[0] === r;
}
function pet(r) {
  var t = r.axis;
  return rt(r.activeIntervals, function(e) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [t.dataToCoord(e[0], !0), t.dataToCoord(e[1], !0)]
    };
  });
}
function vet(r, t) {
  return t.getComponent("parallel", r.get("parallelIndex"));
}
var get = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function met(r) {
  r.registerAction(get, function(t, e) {
    e.eachComponent({
      mainType: "parallelAxis",
      query: t
    }, function(n) {
      n.axis.model.setActiveIntervals(t.intervals);
    });
  }), r.registerAction("parallelAxisExpand", function(t, e) {
    e.eachComponent({
      mainType: "parallel",
      query: t
    }, function(n) {
      n.setAxisExpand(t);
    });
  });
}
var yet = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function kB(r) {
  r.registerComponentView(Ftt), r.registerComponentModel(Utt), r.registerCoordinateSystem("parallel", qtt), r.registerPreprocessor(Ott), r.registerComponentModel(NS), r.registerComponentView(het), fc(r, "parallel", NS, yet), met(r);
}
function _et(r) {
  jt(kB), r.registerChartView(Ett), r.registerSeriesModel(Ltt), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Ntt);
}
var xet = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return r;
  }()
), bet = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new xet();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.extent;
      e.moveTo(n.x1, n.y1), e.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (e.lineTo(n.x2 + i, n.y2), e.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (e.lineTo(n.x2, n.y2 + i), e.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), e.closePath();
    }, t.prototype.highlight = function() {
      Wa(this);
    }, t.prototype.downplay = function() {
      Xa(this);
    }, t;
  }(ne)
), wet = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._mainGroup = new Ct(), e._focusAdjacencyDisabled = !1, e;
    }
    return t.prototype.init = function(e, n) {
      this._controller = new Pl(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = e.getGraph(), s = this._mainGroup, l = e.layoutInfo, u = l.width, c = l.height, f = e.getData(), h = e.getData("edge"), d = e.get("orient");
      this._model = e, s.removeAll(), s.x = l.x, s.y = l.y, this._updateViewCoordSys(e, i), U3(e, i, s, this._controller, this._controllerHost, null), o.eachEdge(function(p) {
        var g = new bet(), v = zt(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = e.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), _ = y.get("curveness"), x = p.node1.getLayout(), b = p.node1.getModel(), S = b.get("localX"), w = b.get("localY"), A = p.node2.getLayout(), T = p.node2.getModel(), M = T.get("localX"), C = T.get("localY"), R = p.getLayout(), E, D, I, P, O, N, B, F;
        g.shape.extent = Math.max(1, R.dy), g.shape.orient = d, d === "vertical" ? (E = (S != null ? S * u : x.x) + R.sy, D = (w != null ? w * c : x.y) + x.dy, I = (M != null ? M * u : A.x) + R.ty, P = C != null ? C * c : A.y, O = E, N = D * (1 - _) + P * _, B = I, F = D * _ + P * (1 - _)) : (E = (S != null ? S * u : x.x) + x.dx, D = (w != null ? w * c : x.y) + R.sy, I = M != null ? M * u : A.x, P = (C != null ? C * c : A.y) + R.ty, O = E * (1 - _) + I * _, N = D, B = E * _ + I * (1 - _), F = P), g.setShape({
          x1: E,
          y1: D,
          x2: I,
          y2: P,
          cpx1: O,
          cpy1: N,
          cpx2: B,
          cpy2: F
        }), g.useStyle(y.getItemStyle()), _L(g.style, d, p);
        var G = "" + m.get("value"), W = xr(m, "edgeLabel");
        Cr(g, W, {
          labelFetcher: {
            getFormattedLabel: function(Y, at, st, ut, lt, H) {
              return e.getFormattedLabel(
                Y,
                at,
                "edge",
                ut,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                un(lt, W.normal && W.normal.get("formatter"), G),
                H
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: G
        }), g.setTextConfig({
          position: "inside"
        });
        var J = m.getModel("emphasis");
        _r(g, m, "lineStyle", function(Y) {
          var at = Y.getItemStyle();
          return _L(at, d, p), at;
        }), s.add(g), h.setItemGraphicEl(p.dataIndex, g);
        var U = J.get("focus");
        He(g, U === "adjacency" ? p.getAdjacentDataIndices() : U === "trajectory" ? p.getTrajectoryDataIndices() : U, J.get("blurScope"), J.get("disabled"));
      }), o.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), _ = v.getModel("emphasis"), x = v.get(["itemStyle", "borderRadius"]) || 0, b = new te({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: x
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Cr(b, xr(v), {
          labelFetcher: {
            getFormattedLabel: function(w, A) {
              return e.getFormattedLabel(w, A, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), _r(b, v), s.add(b), f.setItemGraphicEl(p.dataIndex, b), zt(b).dataType = "node";
        var S = _.get("focus");
        He(b, S === "adjacency" ? p.getAdjacentDataIndices() : S === "trajectory" ? p.getTrajectoryDataIndices() : S, _.get("blurScope"), _.get("disabled"));
      }), f.eachItemGraphicEl(function(p, g) {
        var v = f.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: e.id,
            dataIndex: f.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && e.isAnimationEnabled() && s.setClipPath(Met(s.getBoundingRect(), e, function() {
        s.removeClipPath();
      })), this._data = e.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(e, n) {
      var i = e.layoutInfo, a = i.width, o = i.height, s = e.coordinateSystem = new Nl(null, {
        api: n,
        ecModel: e.ecModel
      });
      s.zoomLimit = e.get("scaleLimit"), s.setBoundingRect(0, 0, a, o), s.setCenter(e.get("center")), s.setZoom(e.get("zoom")), this._controllerHost.target.attr({
        x: s.x,
        y: s.y,
        scaleX: s.scaleX,
        scaleY: s.scaleY
      });
    }, t.type = "sankey", t;
  }(Re)
);
function _L(r, t, e) {
  switch (r.fill) {
    case "source":
      r.fill = e.node1.getVisual("color"), r.decal = e.node1.getVisual("style").decal;
      break;
    case "target":
      r.fill = e.node2.getVisual("color"), r.decal = e.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = e.node1.getVisual("color"), i = e.node2.getVisual("color");
      pt(n) && pt(i) && (r.fill = new Mc(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function Met(r, t, e) {
  var n = new te({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return ze(n, {
    shape: {
      width: r.width + 20
    }
  }, t, e), n;
}
var Tet = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], o = e.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new ue(o[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = jb(a, i, this, !0, c);
      return u.data;
      function c(f, h) {
        f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), h.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, _ = g.levelModels[y];
            _ && (d.parentModel = _);
          }
          return d;
        });
      }
    }, t.prototype.setNodePosition = function(e, n) {
      var i = this.option.data || this.option.nodes, a = i[e];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var o = this.getDataParams(e, i), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return fr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(e), f = c.getLayout().value, h = this.getDataParams(e, i).data.name;
        return fr("nameValue", {
          name: h != null ? h + "" : null,
          value: f,
          noValue: a(f)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(e, n) {
      var i = r.prototype.getDataParams.call(this, e, n);
      if (i.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(e), o = a.getLayout().value;
        i.value = o;
      }
      return i;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: X.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  }(ke)
);
function Aet(r, t) {
  r.eachSeriesByType("sankey", function(e) {
    var n = e.get("nodeWidth"), i = e.get("nodeGap"), a = Sr(e, t).refContainer, o = We(e.getBoxLayoutParams(), a);
    e.layoutInfo = o;
    var s = o.width, l = o.height, u = e.getGraph(), c = u.nodes, f = u.edges;
    Cet(c);
    var h = Te(c, function(v) {
      return v.getLayout().value === 0;
    }), d = h.length !== 0 ? 0 : e.get("layoutIterations"), p = e.get("orient"), g = e.get("nodeAlign");
    Eet(c, f, n, i, s, l, d, p, g);
  });
}
function Eet(r, t, e, n, i, a, o, s, l) {
  Det(r, t, e, i, a, s, l), Pet(r, t, a, i, n, o, s), Get(r, s);
}
function Cet(r) {
  L(r, function(t) {
    var e = Vo(t.outEdges, dg), n = Vo(t.inEdges, dg), i = t.getValue() || 0, a = Math.max(e, n, i);
    t.setLayout({
      value: a
    }, !0);
  });
}
function Det(r, t, e, n, i, a, o) {
  for (var s = [], l = [], u = [], c = [], f = 0, h = 0; h < t.length; h++)
    s[h] = 1;
  for (var h = 0; h < r.length; h++)
    l[h] = r[h].inEdges.length, l[h] === 0 && u.push(r[h]);
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
      m && v.depth > d && (d = v.depth), g.setLayout({
        depth: m ? v.depth : f
      }, !0), a === "vertical" ? g.setLayout({
        dy: e
      }, !0) : g.setLayout({
        dx: e
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var _ = g.outEdges[y], x = t.indexOf(_);
        s[x] = 0;
        var b = _.node2, S = r.indexOf(b);
        --l[S] === 0 && c.indexOf(b) < 0 && c.push(b);
      }
    }
    ++f, u = c, c = [];
  }
  for (var h = 0; h < s.length; h++)
    if (s[h] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var w = d > f - 1 ? d : f - 1;
  o && o !== "left" && Let(r, o, a, w);
  var A = a === "vertical" ? (i - e) / w : (n - e) / w;
  Iet(r, A, a);
}
function BB(r) {
  var t = r.hostGraph.data.getRawDataItem(r.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function Let(r, t, e, n) {
  if (t === "right") {
    for (var i = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      a = i, i = [], ++o;
    }
    L(r, function(f) {
      BB(f) || f.setLayout({
        depth: Math.max(0, n - f.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    t === "justify" && Ret(r, n);
}
function Ret(r, t) {
  L(r, function(e) {
    !BB(e) && !e.outEdges.length && e.setLayout({
      depth: t
    }, !0);
  });
}
function Iet(r, t, e) {
  L(r, function(n) {
    var i = n.getLayout().depth * t;
    e === "vertical" ? n.setLayout({
      y: i
    }, !0) : n.setLayout({
      x: i
    }, !0);
  });
}
function Pet(r, t, e, n, i, a, o) {
  var s = Net(r, o);
  Oet(s, t, e, n, i, o), a_(s, i, e, n, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, ket(s, l, o), a_(s, i, e, n, o), Uet(s, l, o), a_(s, i, e, n, o);
}
function Net(r, t) {
  var e = [], n = t === "vertical" ? "y" : "x", i = bx(r, function(a) {
    return a.getLayout()[n];
  });
  return i.keys.sort(function(a, o) {
    return a - o;
  }), L(i.keys, function(a) {
    e.push(i.buckets.get(a));
  }), e;
}
function Oet(r, t, e, n, i, a) {
  var o = 1 / 0;
  L(r, function(s) {
    var l = s.length, u = 0;
    L(s, function(f) {
      u += f.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * i) / u : (e - (l - 1) * i) / u;
    c < o && (o = c);
  }), L(r, function(s) {
    L(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), L(t, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function a_(r, t, e, n, i) {
  var a = i === "vertical" ? "x" : "y";
  L(r, function(o) {
    o.sort(function(g, v) {
      return g.getLayout()[a] - v.getLayout()[a];
    });
    for (var s, l, u, c = 0, f = o.length, h = i === "vertical" ? "dx" : "dy", d = 0; d < f; d++)
      l = o[d], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[h] + t;
    var p = i === "vertical" ? n : e;
    if (u = c - t - p, u > 0) {
      s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var d = f - 2; d >= 0; --d)
        l = o[d], u = l.getLayout()[a] + l.getLayout()[h] + t - c, u > 0 && (s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function ket(r, t, e) {
  L(r.slice().reverse(), function(n) {
    L(n, function(i) {
      if (i.outEdges.length) {
        var a = Vo(i.outEdges, Bet, e) / Vo(i.outEdges, dg);
        if (isNaN(a)) {
          var o = i.outEdges.length;
          a = o ? Vo(i.outEdges, Vet, e) / o : 0;
        }
        if (e === "vertical") {
          var s = i.getLayout().x + (a - $o(i, e)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - $o(i, e)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function Bet(r, t) {
  return $o(r.node2, t) * r.getValue();
}
function Vet(r, t) {
  return $o(r.node2, t);
}
function Fet(r, t) {
  return $o(r.node1, t) * r.getValue();
}
function zet(r, t) {
  return $o(r.node1, t);
}
function $o(r, t) {
  return t === "vertical" ? r.getLayout().x + r.getLayout().dx / 2 : r.getLayout().y + r.getLayout().dy / 2;
}
function dg(r) {
  return r.getValue();
}
function Vo(r, t, e) {
  for (var n = 0, i = r.length, a = -1; ++a < i; ) {
    var o = +t(r[a], e);
    isNaN(o) || (n += o);
  }
  return n;
}
function Uet(r, t, e) {
  L(r, function(n) {
    L(n, function(i) {
      if (i.inEdges.length) {
        var a = Vo(i.inEdges, Fet, e) / Vo(i.inEdges, dg);
        if (isNaN(a)) {
          var o = i.inEdges.length;
          a = o ? Vo(i.inEdges, zet, e) / o : 0;
        }
        if (e === "vertical") {
          var s = i.getLayout().x + (a - $o(i, e)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - $o(i, e)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function Get(r, t) {
  var e = t === "vertical" ? "x" : "y";
  L(r, function(n) {
    n.outEdges.sort(function(i, a) {
      return i.node2.getLayout()[e] - a.node2.getLayout()[e];
    }), n.inEdges.sort(function(i, a) {
      return i.node1.getLayout()[e] - a.node1.getLayout()[e];
    });
  }), L(r, function(n) {
    var i = 0, a = 0;
    L(n.outEdges, function(o) {
      o.setLayout({
        sy: i
      }, !0), i += o.getLayout().dy;
    }), L(n.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function Het(r) {
  r.eachSeriesByType("sankey", function(t) {
    var e = t.getGraph(), n = e.nodes, i = e.edges;
    if (n.length) {
      var a = 1 / 0, o = -1 / 0;
      L(n, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), L(n, function(s) {
        var l = new Tr({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && L(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function Wet(r) {
  r.registerChartView(wet), r.registerSeriesModel(Tet), r.registerLayout(Aet), r.registerVisual(Het), r.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), r.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(i) {
      var a = i.coordinateSystem, o = xm(a, t, i.get("scaleLimit"));
      i.setCenter(o.center), i.setZoom(o.zoom);
    });
  });
}
var VB = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype._hasEncodeRule = function(t) {
      var e = this.getEncode();
      return e && e.get(t) != null;
    }, r.prototype.getInitialData = function(t, e) {
      var n, i = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l;
      o === "category" ? (t.layout = "horizontal", n = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (t.layout = "vertical", n = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : t.layout = t.layout || "horizontal";
      var u = ["x", "y"], c = t.layout === "horizontal" ? 0 : 1, f = this._baseAxisDim = u[c], h = u[1 - c], d = [i, a], p = d[c].get("type"), g = d[1 - c].get("type"), v = t.data;
      if (v && l) {
        var m = [];
        L(v, function(x, b) {
          var S;
          et(x) ? (S = x.slice(), x.unshift(b)) : et(x.value) ? (S = j({}, x), S.value = S.value.slice(), x.value.unshift(b)) : S = x, m.push(S);
        }), t.data = m;
      }
      var y = this.defaultValueDimensions, _ = [{
        name: f,
        type: Kv(p),
        ordinalMeta: n,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: h,
        type: Kv(g),
        dimsDef: y.slice()
      }];
      return Nc(this, {
        coordDimensions: _,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Yt(QN, _, this)
      });
    }, r.prototype.getBaseAxis = function() {
      var t = this._baseAxisDim;
      return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
    }, r;
  }()
), FB = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], e.visualDrawType = "stroke", e;
    }
    return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: X.color.neutral00,
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: X.color.shadow
        }
      },
      animationDuration: 800
    }, t;
  }(ke)
);
dr(FB, VB, !0);
var Xet = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = e.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), f = xL(c, a, u, l, !0);
          a.setItemGraphicEl(u, f), o.add(f);
        }
      }).update(function(u, c) {
        var f = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(f);
          return;
        }
        var h = a.getItemLayout(u);
        f ? (oi(f), zB(h, f, a, u)) : f = xL(h, a, u, l), o.add(f), a.setItemGraphicEl(u, f);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, t.prototype.remove = function(e) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && n.remove(a);
      });
    }, t.type = "boxplot", t;
  }(Re)
), Yet = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), $et = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new Yet();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = 0;
      for (e.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)
        e.lineTo(i[a][0], i[a][1]);
      for (e.closePath(); a < i.length; a++)
        e.moveTo(i[a][0], i[a][1]), a++, e.lineTo(i[a][0], i[a][1]);
    }, t;
  }(ne)
);
function xL(r, t, e, n, i) {
  var a = r.ends, o = new $et({
    shape: {
      points: i ? Zet(a, n, r) : a
    }
  });
  return zB(r, o, t, e, i), o;
}
function zB(r, t, e, n, i) {
  var a = e.hostModel, o = El[i ? "initProps" : "updateProps"];
  o(t, {
    shape: {
      points: r.ends
    }
  }, a, n), t.useStyle(e.getItemVisual(n, "style")), t.style.strokeNoScale = !0, t.z2 = 100;
  var s = e.getItemModel(n), l = s.getModel("emphasis");
  _r(t, s), He(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function Zet(r, t, e) {
  return rt(r, function(n) {
    return n = n.slice(), n[t] = e.initBaseline, n;
  });
}
var Jf = L;
function qet(r) {
  var t = Ket(r);
  Jf(t, function(e) {
    var n = e.seriesModels;
    n.length && (jet(e), Jf(n, function(i, a) {
      Jet(i, e.boxOffsetList[a], e.boxWidthList[a]);
    }));
  });
}
function Ket(r) {
  var t = [], e = [];
  return r.eachSeriesByType("boxplot", function(n) {
    var i = n.getBaseAxis(), a = Zt(e, i);
    a < 0 && (a = e.length, e[a] = i, t[a] = {
      axis: i,
      seriesModels: []
    }), t[a].seriesModels.push(n);
  }), t;
}
function jet(r) {
  var t = r.axis, e = r.seriesModels, n = e.length, i = r.boxWidthList = [], a = r.boxOffsetList = [], o = [], s;
  if (t.type === "category")
    s = t.getBandWidth();
  else {
    var l = 0;
    Jf(e, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = t.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  Jf(e, function(p) {
    var g = p.get("boxWidth");
    et(g) || (g = [g, g]), o.push([dt(g[0], s) || 0, dt(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, f = c / n * 0.3, h = (c - f * (n - 1)) / n, d = h / 2 - c / 2;
  Jf(e, function(p, g) {
    a.push(d), d += f + h, i.push(Math.min(Math.max(h, o[g][0]), o[g][1]));
  });
}
function Jet(r, t, e) {
  var n = r.coordinateSystem, i = r.getData(), a = e / 2, o = r.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = i.mapDimension(l[o]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var f = 0; f < i.count(); f++) {
    var h = i.get(u, f), d = _(h, c[2], f), p = _(h, c[0], f), g = _(h, c[1], f), v = _(h, c[3], f), m = _(h, c[4], f), y = [];
    x(y, g, !1), x(y, v, !0), y.push(p, g, m, v), b(y, p), b(y, m), b(y, d), i.setItemLayout(f, {
      initBaseline: d[s],
      ends: y
    });
  }
  function _(S, w, A) {
    var T = i.get(w, A), M = [];
    M[o] = S, M[s] = T;
    var C;
    return isNaN(S) || isNaN(T) ? C = [NaN, NaN] : (C = n.dataToPoint(M), C[o] += t), C;
  }
  function x(S, w, A) {
    var T = w.slice(), M = w.slice();
    T[o] += a, M[o] -= a, A ? S.push(T, M) : S.push(M, T);
  }
  function b(S, w) {
    var A = w.slice(), T = w.slice();
    A[o] -= a, T[o] += a, S.push(A, T);
  }
}
function Qet(r, t) {
  t = t || {};
  for (var e = [], n = [], i = t.boundIQR, a = i === "none" || i === 0, o = 0; o < r.length; o++) {
    var s = ri(r[o].slice()), l = Iy(s, 0.25), u = Iy(s, 0.5), c = Iy(s, 0.75), f = s[0], h = s[s.length - 1], d = (i ?? 1.5) * (c - l), p = a ? f : Math.max(f, l - d), g = a ? h : Math.min(h, c + d), v = t.itemNameFormatter, m = At(v) ? v({
      value: o
    }) : pt(v) ? v.replace("{value}", o + "") : o + "";
    e.push([m, p, l, u, c, g]);
    for (var y = 0; y < s.length; y++) {
      var _ = s[y];
      if (_ < p || _ > g) {
        var x = [m, _];
        n.push(x);
      }
    }
  }
  return {
    boxData: e,
    outliers: n
  };
}
var trt = {
  type: "echarts:boxplot",
  transform: function(t) {
    var e = t.upstream;
    if (e.sourceFormat !== Vr) {
      var n = "";
      process.env.NODE_ENV !== "production" && (n = dn("source data is not applicable for this boxplot transform. Expect number[][].")), we(n);
    }
    var i = Qet(e.getRawData(), t.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function ert(r) {
  r.registerSeriesModel(FB), r.registerChartView(Xet), r.registerLayout(qet), r.registerTransform(trt);
}
var rrt = ["itemStyle", "borderColor"], nrt = ["itemStyle", "borderColor0"], irt = ["itemStyle", "borderColorDoji"], art = ["itemStyle", "color"], ort = ["itemStyle", "color0"];
function aw(r, t) {
  return t.get(r > 0 ? art : ort);
}
function ow(r, t) {
  return t.get(r === 0 ? irt : r > 0 ? rrt : nrt);
}
var srt = {
  seriesType: "candlestick",
  plan: Dc(),
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    if (!t.isSeriesFiltered(r)) {
      var e = r.pipelineContext.large;
      return !e && {
        progress: function(n, i) {
          for (var a; (a = n.next()) != null; ) {
            var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle();
            l.fill = aw(s, o), l.stroke = ow(s, o) || l.fill;
            var u = i.ensureUniqueItemVisual(a, "style");
            j(u, l);
          }
        }
      };
    }
  }
}, lrt = ["color", "borderColor"], urt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(e), this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e);
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this._clear(), this._updateDrawMode(e);
    }, t.prototype.incrementalRender = function(e, n, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(e, n) : this._incrementalRenderNormal(e, n);
    }, t.prototype.eachRendered = function(e) {
      jo(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var n = e.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(e) {
      var n = e.getData(), i = this._data, a = this.group, o = n.getLayout("isSimpleBox"), s = e.get("clip", !0), l = e.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var f = n.getItemLayout(c);
          if (s && SL(u, f))
            return;
          var h = o_(f, c, !0);
          ze(h, {
            shape: {
              points: f.ends
            }
          }, e, c), s_(h, n, c, o), a.add(h), n.setItemGraphicEl(c, h);
        }
      }).update(function(c, f) {
        var h = i.getItemGraphicEl(f);
        if (!n.hasValue(c)) {
          a.remove(h);
          return;
        }
        var d = n.getItemLayout(c);
        if (s && SL(u, d)) {
          a.remove(h);
          return;
        }
        h ? (ve(h, {
          shape: {
            points: d.ends
          }
        }, e, c), oi(h)) : h = o_(d), s_(h, n, c, o), a.add(h), n.setItemGraphicEl(c, h);
      }).remove(function(c) {
        var f = i.getItemGraphicEl(c);
        f && a.remove(f);
      }).execute(), this._data = n;
    }, t.prototype._renderLarge = function(e) {
      this._clear(), bL(e, this.group);
      var n = e.get("clip", !0) ? $h(e.coordinateSystem, !1, e) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, t.prototype._incrementalRenderNormal = function(e, n) {
      for (var i = n.getData(), a = i.getLayout("isSimpleBox"), o; (o = e.next()) != null; ) {
        var s = i.getItemLayout(o), l = o_(s);
        s_(l, i, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, t.prototype._incrementalRenderLarge = function(e, n) {
      bL(n, this.group, this._progressiveEls, !0);
    }, t.prototype.remove = function(e) {
      this._clear();
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "candlestick", t;
  }(Re)
), crt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), frt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new crt();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points;
      this.__simpleBox ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1])) : (e.moveTo(i[0][0], i[0][1]), e.lineTo(i[1][0], i[1][1]), e.lineTo(i[2][0], i[2][1]), e.lineTo(i[3][0], i[3][1]), e.closePath(), e.moveTo(i[4][0], i[4][1]), e.lineTo(i[5][0], i[5][1]), e.moveTo(i[6][0], i[6][1]), e.lineTo(i[7][0], i[7][1]));
    }, t;
  }(ne)
);
function o_(r, t, e) {
  var n = r.ends;
  return new frt({
    shape: {
      points: e ? hrt(n, r) : n
    },
    z2: 100
  });
}
function SL(r, t) {
  for (var e = !0, n = 0; n < t.ends.length; n++)
    if (r.contain(t.ends[n][0], t.ends[n][1])) {
      e = !1;
      break;
    }
  return e;
}
function s_(r, t, e, n) {
  var i = t.getItemModel(e);
  r.useStyle(t.getItemVisual(e, "style")), r.style.strokeNoScale = !0, r.__simpleBox = n, _r(r, i);
  var a = t.getItemLayout(e).sign;
  L(r.states, function(s, l) {
    var u = i.getModel(l), c = aw(a, u), f = ow(a, u) || c, h = s.style || (s.style = {});
    c && (h.fill = c), f && (h.stroke = f);
  });
  var o = i.getModel("emphasis");
  He(r, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function hrt(r, t) {
  return rt(r, function(e) {
    return e = e.slice(), e[1] = t.initBaseline, e;
  });
}
var drt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), l_ = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new drt();
    }, t.prototype.buildPath = function(e, n) {
      for (var i = n.points, a = 0; a < i.length; )
        if (this.__sign === i[a++]) {
          var o = i[a++];
          e.moveTo(o, i[a++]), e.lineTo(o, i[a++]);
        } else
          a += 3;
    }, t;
  }(ne)
);
function bL(r, t, e, n) {
  var i = r.getData(), a = i.getLayout("largePoints"), o = new l_({
    shape: {
      points: a
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  t.add(o);
  var s = new l_({
    shape: {
      points: a
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  t.add(s);
  var l = new l_({
    shape: {
      points: a
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  t.add(l), u_(1, o, r), u_(-1, s, r), u_(0, l, r), n && (o.incremental = !0, s.incremental = !0), e && e.push(o, s);
}
function u_(r, t, e, n) {
  var i = ow(r, e) || aw(r, e), a = e.getModel("itemStyle").getItemStyle(lrt);
  t.useStyle(a), t.style.fill = null, t.style.stroke = i;
}
var UB = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], e;
    }
    return t.prototype.getShadowDim = function() {
      return "open";
    }, t.prototype.brushSelector = function(e, n, i) {
      var a = n.getItemLayout(e);
      return a && i.rect(a.brushRect);
    }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, t;
  }(ke)
);
dr(UB, VB, !0);
function prt(r) {
  !r || !et(r.series) || L(r.series, function(t) {
    Lt(t) && t.type === "k" && (t.type = "candlestick");
  });
}
var vrt = {
  seriesType: "candlestick",
  plan: Dc(),
  reset: function(r) {
    var t = r.coordinateSystem, e = r.getData(), n = grt(r, e), i = 0, a = 1, o = ["x", "y"], s = e.getDimensionIndex(e.mapDimension(o[i])), l = rt(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e), u = l[0], c = l[1], f = l[2], h = l[3];
    if (e.setLayout({
      candleWidth: n,
      // The value is experimented visually.
      isSimpleBox: n <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: r.pipelineContext.large ? p : d
    };
    function d(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var _ = y.get(s, m), x = y.get(u, m), b = y.get(c, m), S = y.get(f, m), w = y.get(h, m), A = Math.min(x, b), T = Math.max(x, b), M = O(A, _), C = O(T, _), R = O(S, _), E = O(w, _), D = [];
        N(D, C, 0), N(D, M, 1), D.push(F(E), F(C), F(R), F(M));
        var I = v.getItemModel(m), P = !!I.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(m, {
          sign: wL(y, m, x, b, c, P),
          initBaseline: x > b ? C[a] : M[a],
          ends: D,
          brushRect: B(S, w, _)
        });
      }
      function O(G, W) {
        var J = [];
        return J[i] = W, J[a] = G, isNaN(W) || isNaN(G) ? [NaN, NaN] : t.dataToPoint(J);
      }
      function N(G, W, J) {
        var U = W.slice(), Y = W.slice();
        U[i] = Kp(U[i] + n / 2, 1, !1), Y[i] = Kp(Y[i] - n / 2, 1, !0), J ? G.push(U, Y) : G.push(Y, U);
      }
      function B(G, W, J) {
        var U = O(G, J), Y = O(W, J);
        return U[i] -= n / 2, Y[i] -= n / 2, {
          x: U[0],
          y: U[1],
          width: n,
          height: Y[1] - U[1]
        };
      }
      function F(G) {
        return G[i] = Kp(G[i], 1), G;
      }
    }
    function p(g, v) {
      for (var m = qi(g.count * 4), y = 0, _, x = [], b = [], S, w = v.getStore(), A = !!r.get(["itemStyle", "borderColorDoji"]); (S = g.next()) != null; ) {
        var T = w.get(s, S), M = w.get(u, S), C = w.get(c, S), R = w.get(f, S), E = w.get(h, S);
        if (isNaN(T) || isNaN(R) || isNaN(E)) {
          m[y++] = NaN, y += 3;
          continue;
        }
        m[y++] = wL(w, S, M, C, c, A), x[i] = T, x[a] = R, _ = t.dataToPoint(x, null, b), m[y++] = _ ? _[0] : NaN, m[y++] = _ ? _[1] : NaN, x[a] = E, _ = t.dataToPoint(x, null, b), m[y++] = _ ? _[1] : NaN;
      }
      v.setLayout("largePoints", m);
    }
  }
};
function wL(r, t, e, n, i, a) {
  var o;
  return e > n ? o = -1 : e < n ? o = 1 : o = a ? 0 : t > 0 ? r.get(i, t - 1) <= n ? 1 : -1 : 1, o;
}
function grt(r, t) {
  var e = r.getBaseAxis(), n, i = e.type === "category" ? e.getBandWidth() : (n = e.getExtent(), Math.abs(n[1] - n[0]) / t.count()), a = dt(bt(r.get("barMaxWidth"), i), i), o = dt(bt(r.get("barMinWidth"), 1), i), s = r.get("barWidth");
  return s != null ? dt(s, i) : Math.max(Math.min(i / 2, a), o);
}
function mrt(r) {
  r.registerChartView(urt), r.registerSeriesModel(UB), r.registerPreprocessor(prt), r.registerVisual(srt), r.registerLayout(vrt);
}
function ML(r, t) {
  var e = t.rippleEffectColor || t.color;
  r.eachChild(function(n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === "stroke" ? e : null,
        fill: t.brushType === "fill" ? e : null
      }
    });
  });
}
var yrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      var i = r.call(this) || this, a = new Xh(e, n), o = new Ct();
      return i.add(a), i.add(o), i.updateData(e, n), i;
    }
    return t.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, t.prototype.startEffectAnimation = function(e) {
      for (var n = e.symbolType, i = e.color, a = e.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = hr(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * e.period + e.effectOffset;
        l.animate("", !0).when(e.period, {
          scaleX: e.rippleScale / 2,
          scaleY: e.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(e.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      ML(o, e);
    }, t.prototype.updateEffectAnimation = function(e) {
      for (var n = this._effectCfg, i = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (n[s] !== e[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(e);
          return;
        }
      }
      ML(i, e);
    }, t.prototype.highlight = function() {
      Wa(this);
    }, t.prototype.downplay = function() {
      Xa(this);
    }, t.prototype.getSymbolType = function() {
      var e = this.childAt(0);
      return e && e.getSymbolType();
    }, t.prototype.updateData = function(e, n) {
      var i = this, a = e.hostModel;
      this.childAt(0).updateData(e, n);
      var o = this.childAt(1), s = e.getItemModel(n), l = e.getItemVisual(n, "symbol"), u = Rc(e.getItemVisual(n, "symbolSize")), c = e.getItemVisual(n, "style"), f = c && c.fill, h = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(v) {
        v.setStyle("fill", f);
      });
      var d = Ll(e.getItemVisual(n, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = e.getItemVisual(n, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = n / e.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = f, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, He(this, h.get("focus"), h.get("blurScope"), h.get("disabled"));
    }, t.prototype.fadeOut = function(e) {
      e && e();
    }, t;
  }(Ct)
), _rt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._symbolDraw = new Yh(yrt);
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(e)
      }), this.group.add(o.group);
    }, t.prototype._getClipShape = function(e) {
      var n = e.coordinateSystem, i = n && n.getArea && n.getArea();
      return e.get("clip", !0) ? i : null;
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData();
      this.group.dirty();
      var o = Zh("").reset(e, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, t.prototype._updateGroupTransform = function(e) {
      var n = e.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = BW(n.getRoamTransform()), this.group.decomposeTransform());
    }, t.prototype.remove = function(e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, t.type = "effectScatter", t;
  }(Re)
), xrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.point(n.getItemLayout(e));
    }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 
      symbolSize: 10
      // symbolSize * 2
      // symbolRotate: null,  // 
      // itemStyle: {
      //     opacity: 1
      // }
    }, t;
  }(ke)
);
function Srt(r) {
  r.registerChartView(_rt), r.registerSeriesModel(xrt), r.registerLayout(Zh("effectScatter"));
}
var GB = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a.add(a.createLine(e, n, i)), a._updateEffectSymbol(e, n), a;
    }
    return t.prototype.createLine = function(e, n, i) {
      return new qb(e, n, i);
    }, t.prototype._updateEffectSymbol = function(e, n) {
      var i = e.getItemModel(n), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      et(o) || (o = [o, o]);
      var l = e.getItemVisual(n, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = hr(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle(["color"])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(e, a, n));
    }, t.prototype._updateEffectAnimation = function(e, n, i) {
      var a = this.childAt(1);
      if (a) {
        var o = e.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), f = mr(n.get("delay"), function(d) {
          return d / e.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var h = void 0;
          At(f) ? h = f(i) : h = f, a.__t > 0 && (h = -s * a.__t), this._animateSymbol(a, s, h, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, t.prototype._animateSymbol = function(e, n, i, a, o) {
      if (n > 0) {
        e.__t = 0;
        var s = this, l = e.animate("", a).when(o ? n * 2 : n, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(e);
        });
        a || l.done(function() {
          s.remove(e);
        }), l.start();
      }
    }, t.prototype._getLineLength = function(e) {
      return So(e.__p1, e.__cp1) + So(e.__cp1, e.__p2);
    }, t.prototype._updateAnimationPoints = function(e, n) {
      e.__p1 = n[0], e.__p2 = n[1], e.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
    }, t.prototype.updateData = function(e, n, i) {
      this.childAt(0).updateData(e, n, i), this._updateEffectSymbol(e, n);
    }, t.prototype._updateSymbolPosition = function(e) {
      var n = e.__p1, i = e.__p2, a = e.__cp1, o = e.__t < 1 ? e.__t : 2 - e.__t, s = [e.x, e.y], l = s.slice(), u = Pr, c = ox;
      s[0] = u(n[0], a[0], i[0], o), s[1] = u(n[1], a[1], i[1], o);
      var f = e.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o), h = e.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o);
      e.rotation = -Math.atan2(h, f) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (e.__lastT !== void 0 && e.__lastT < e.__t ? (e.scaleY = So(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : e.__lastT === 1 ? e.scaleY = 2 * So(n, s) : e.scaleY = this._symbolScale[1]), e.__lastT = e.__t, e.ignore = !1, e.x = s[0], e.y = s[1];
    }, t.prototype.updateLayout = function(e, n) {
      this.childAt(0).updateLayout(e, n);
      var i = e.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(e, i, n);
    }, t;
  }(Ct)
), HB = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a._createPolyline(e, n, i), a;
    }
    return t.prototype._createPolyline = function(e, n, i) {
      var a = e.getItemLayout(n), o = new Gr({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(e, n, i);
    }, t.prototype.updateData = function(e, n, i) {
      var a = e.hostModel, o = this.childAt(0), s = {
        shape: {
          points: e.getItemLayout(n)
        }
      };
      ve(o, s, a, n), this._updateCommonStl(e, n, i);
    }, t.prototype._updateCommonStl = function(e, n, i) {
      var a = this.childAt(0), o = e.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || e.hasItemOption) {
        var f = o.getModel("emphasis");
        s = f.getModel("lineStyle").getLineStyle(), c = f.get("disabled"), l = f.get("focus"), u = f.get("blurScope");
      }
      a.useStyle(e.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var h = a.ensureState("emphasis");
      h.style = s, He(this, l, u, c);
    }, t.prototype.updateLayout = function(e, n) {
      var i = this.childAt(0);
      i.setShape("points", e.getItemLayout(n));
    }, t;
  }(Ct)
), brt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e._lastFrame = 0, e._lastFramePercent = 0, e;
    }
    return t.prototype.createLine = function(e, n, i) {
      return new HB(e, n, i);
    }, t.prototype._updateAnimationPoints = function(e, n) {
      this._points = n;
      for (var i = [0], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1], l = n[o];
        a += So(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++)
        i[o] /= a;
      this._offsets = i, this._length = a;
    }, t.prototype._getLineLength = function() {
      return this._length;
    }, t.prototype._updateSymbolPosition = function(e) {
      var n = e.__t < 1 ? e.__t : 2 - e.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= n); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > n); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]), f = i[l], h = i[l + 1];
        e.x = f[0] * (1 - c) + c * h[0], e.y = f[1] * (1 - c) + c * h[1];
        var d = e.__t < 1 ? h[0] - f[0] : f[0] - h[0], p = e.__t < 1 ? h[1] - f[1] : f[1] - h[1];
        e.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, e.ignore = !1;
      }
    }, t;
  }(GB)
), wrt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return r;
  }()
), Mrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.getDefaultStyle = function() {
      return {
        stroke: X.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new wrt();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.segs, a = n.curveness, o;
      if (n.polyline)
        for (o = this._off; o < i.length; ) {
          var s = i[o++];
          if (s > 0) {
            e.moveTo(i[o++], i[o++]);
            for (var l = 1; l < s; l++)
              e.lineTo(i[o++], i[o++]);
          }
        }
      else
        for (o = this._off; o < i.length; ) {
          var u = i[o++], c = i[o++], f = i[o++], h = i[o++];
          if (e.moveTo(u, c), a > 0) {
            var d = (u + f) / 2 - (c - h) * a, p = (c + h) / 2 - (f - u) * a;
            e.quadraticCurveTo(d, p, f, h);
          } else
            e.lineTo(f, h);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, t.prototype.findDataIndex = function(e, n) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++];
          if (c > 0)
            for (var f = a[u++], h = a[u++], d = 1; d < c; d++) {
              var p = a[u++], g = a[u++];
              if (yo(f, h, p, g, s, e, n))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var f = a[u++], h = a[u++], p = a[u++], g = a[u++];
          if (o > 0) {
            var v = (f + p) / 2 - (h - g) * o, m = (h + g) / 2 - (p - f) * o;
            if ($P(f, h, v, m, p, g, s, e, n))
              return l;
          } else if (yo(f, h, p, g, s, e, n))
            return l;
          l++;
        }
      return -1;
    }, t.prototype.contain = function(e, n) {
      var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
      if (e = i[0], n = i[1], a.contain(e, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(e, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var n = this.shape, i = n.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], f = i[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(f, o), l = Math.max(f, l);
        }
        e = this._rect = new Vt(a, o, s, l);
      }
      return e;
    }, t;
  }(ne)
), Trt = (
  /** @class */
  function() {
    function r() {
      this.group = new Ct();
    }
    return r.prototype.updateData = function(t) {
      this._clear();
      var e = this._create();
      e.setShape({
        segs: t.getLayout("linesPoints")
      }), this._setCommon(e, t);
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(t, e) {
      var n = this._newAdded[0], i = e.getLayout("linesPoints"), a = n && n.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, e), l.__startIndex = t.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, r.prototype._create = function() {
      var t = new Mrt({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(t), this.group.add(t), t;
    }, r.prototype._setCommon = function(t, e, n) {
      var i = e.hostModel;
      t.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), t.useStyle(i.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
      var a = e.getVisual("style");
      a && a.stroke && t.setStyle("stroke", a.stroke), t.setStyle("fill", null);
      var o = zt(t);
      o.seriesIndex = i.seriesIndex, t.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = t.hoverDataIdx;
        l > 0 && (o.dataIndex = l + t.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
), WB = {
  seriesType: "lines",
  plan: Dc(),
  reset: function(r) {
    var t = r.coordinateSystem;
    if (!t) {
      process.env.NODE_ENV !== "production" && ce("The lines series must have a coordinate system.");
      return;
    }
    var e = r.get("polyline"), n = r.pipelineContext.large;
    return {
      progress: function(i, a) {
        var o = [];
        if (n) {
          var s = void 0, l = i.end - i.start;
          if (e) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += r.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var f = 0, h = [], c = i.start; c < i.end; c++) {
            var d = r.getLineCoords(c, o);
            e && (s[f++] = d);
            for (var p = 0; p < d; p++)
              h = t.dataToPoint(o[p], !1, h), s[f++] = h[0], s[f++] = h[1];
          }
          a.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var g = a.getItemModel(c), d = r.getLineCoords(c, o), v = [];
            if (e)
              for (var m = 0; m < d; m++)
                v.push(t.dataToPoint(o[m]));
            else {
              v[0] = t.dataToPoint(o[0]), v[1] = t.dataToPoint(o[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y]);
            }
            a.setItemLayout(c, v);
          }
      }
    };
  }
}, Art = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._updateLineDraw(a, e), s = e.get("zlevel"), l = e.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(e) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var f = e.get("clip", !0) && $h(e.coordinateSystem, !1, e);
      f ? this.group.setClipPath(f) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      var a = e.getData(), o = this._updateLineDraw(a, e);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = !1;
    }, t.prototype.incrementalRender = function(e, n, i) {
      this._lineDraw.incrementalUpdate(e, n.getData()), this._finished = e.end === n.getData().count();
    }, t.prototype.eachRendered = function(e) {
      this._lineDraw && this._lineDraw.eachRendered(e);
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData(), o = e.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = WB.reset(e, n, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, t.prototype._updateLineDraw = function(e, n) {
      var i = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && a && l && console.warn("Large lines not support effect"), (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new Trt() : new Kb(o ? a ? brt : HB : a ? GB : qb), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, t.prototype._showEffect = function(e) {
      return !!e.get(["effect", "show"]);
    }, t.prototype._clearLayer = function(e) {
      var n = e.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
    }, t.prototype.remove = function(e, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, t.prototype.dispose = function(e, n) {
      this.remove(e, n);
    }, t.type = "lines", t;
  }(Re)
), Ert = typeof Uint32Array > "u" ? Array : Uint32Array, Crt = typeof Float64Array > "u" ? Array : Float64Array;
function TL(r) {
  var t = r.data;
  t && t[0] && t[0][0] && t[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), r.data = rt(t, function(e) {
    var n = [e[0].coord, e[1].coord], i = {
      coords: n
    };
    return e[0].name && (i.fromName = e[0].name), e[1].name && (i.toName = e[1].name), b1([i, e[0], e[1]]);
  }));
}
var Drt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.init = function(e) {
      e.data = e.data || [], TL(e);
      var n = this._processFlatCoordsArray(e.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (e.data = new Float32Array(n.count)), r.prototype.init.apply(this, arguments);
    }, t.prototype.mergeOption = function(e) {
      if (TL(e), e.data) {
        var n = this._processFlatCoordsArray(e.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (e.data = new Float32Array(n.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.appendData = function(e) {
      var n = this._processFlatCoordsArray(e.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = eh(this._flatCoords, n.flatCoords), this._flatCoordsOffset = eh(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), e.data = new Float32Array(n.count)), this.getRawData().appendData(e.data);
    }, t.prototype._getCoordsFromItemModel = function(e) {
      var n = this.getData().getItemModel(e), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, t.prototype.getLineCoordsCount = function(e) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[e * 2 + 1] : this._getCoordsFromItemModel(e).length;
    }, t.prototype.getLineCoords = function(e, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[e * 2], a = this._flatCoordsOffset[e * 2 + 1], o = 0; o < a; o++)
          n[o] = n[o] || [], n[o][0] = this._flatCoords[i + o * 2], n[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++)
          n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
        return s.length;
      }
    }, t.prototype._processFlatCoordsArray = function(e) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), fe(e[0])) {
        for (var i = e.length, a = new Ert(i), o = new Crt(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var f = e[c++];
          a[l++] = s + n, a[l++] = f;
          for (var h = 0; h < f; h++) {
            var d = e[c++], p = e[c++];
            if (o[s++] = d, o[s++] = p, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: e.length
      };
    }, t.prototype.getInitialData = function(e, n) {
      if (process.env.NODE_ENV !== "production") {
        var i = Cc.get(e.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + e.coordinateSystem);
      }
      var a = new cn(["value"], this);
      return a.hasItemOption = !1, a.initData(e.data, [], function(o, s, l, u) {
        if (o instanceof Array)
          return NaN;
        a.hasItemOption = !0;
        var c = o.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), a;
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = a.getItemModel(e), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), fr("nameValue", {
        name: c.join(" > ")
      });
    }, t.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, t.prototype.getZLevelKey = function() {
      var e = this.getModel("effect"), n = e.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : e.get("show") && n > 0 ? n + "" : "";
    }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: Tooltip.formatter
      },
      lineStyle: {
        opacity: 0.5
      }
    }, t;
  }(ke)
);
function bp(r) {
  return r instanceof Array || (r = [r, r]), r;
}
var Lrt = {
  seriesType: "lines",
  reset: function(r) {
    var t = bp(r.get("symbol")), e = bp(r.get("symbolSize")), n = r.getData();
    n.setVisual("fromSymbol", t && t[0]), n.setVisual("toSymbol", t && t[1]), n.setVisual("fromSymbolSize", e && e[0]), n.setVisual("toSymbolSize", e && e[1]);
    function i(a, o) {
      var s = a.getItemModel(o), l = bp(s.getShallow("symbol", !0)), u = bp(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
function Rrt(r) {
  r.registerChartView(Art), r.registerSeriesModel(Drt), r.registerLayout(WB), r.registerVisual(Lrt);
}
var Irt = 256, Prt = (
  /** @class */
  function() {
    function r() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var t = Si.createCanvas();
      this.canvas = t;
    }
    return r.prototype.update = function(t, e, n, i, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, f = this.canvas, h = f.getContext("2d"), d = t.length;
      f.width = e, f.height = n;
      for (var p = 0; p < d; ++p) {
        var g = t[p], v = g[0], m = g[1], y = g[2], _ = i(y);
        h.globalAlpha = _, h.drawImage(s, v - c, m - c);
      }
      if (!f.width || !f.height)
        return f;
      for (var x = h.getImageData(0, 0, f.width, f.height), b = x.data, S = 0, w = b.length, A = this.minOpacity, T = this.maxOpacity, M = T - A; S < w; ) {
        var _ = b[S + 3] / 256, C = Math.floor(_ * (Irt - 1)) * 4;
        if (_ > 0) {
          var R = o(_) ? l : u;
          _ > 0 && (_ = _ * M + A), b[S++] = R[C], b[S++] = R[C + 1], b[S++] = R[C + 2], b[S++] = R[C + 3] * _ * 256;
        } else
          S += 4;
      }
      return h.putImageData(x, 0, 0), f;
    }, r.prototype._getBrush = function() {
      var t = this._brushCanvas || (this._brushCanvas = Si.createCanvas()), e = this.pointSize + this.blurSize, n = e * 2;
      t.width = n, t.height = n;
      var i = t.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = X.color.neutral99, i.beginPath(), i.arc(-e, e, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), t;
    }, r.prototype._getGradient = function(t, e) {
      for (var n = this._gradientPixels, i = n[e] || (n[e] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
        t[e](s / 255, !0, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3];
      return i;
    }, r;
  }()
);
function Nrt(r, t, e) {
  var n = r[1] - r[0];
  t = rt(t, function(o) {
    return {
      interval: [(o.interval[0] - r[0]) / n, (o.interval[1] - r[0]) / n]
    };
  });
  var i = t.length, a = 0;
  return function(o) {
    var s;
    for (s = a; s < i; s++) {
      var l = t[s].interval;
      if (l[0] <= o && o <= l[1]) {
        a = s;
        break;
      }
    }
    if (s === i)
      for (s = a - 1; s >= 0; s--) {
        var l = t[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
    return s >= 0 && s < i && e[s];
  };
}
function Ort(r, t) {
  var e = r[1] - r[0];
  return t = [(t[0] - r[0]) / e, (t[1] - r[0]) / e], function(n) {
    return n >= t[0] && n <= t[1];
  };
}
function AL(r) {
  var t = r.dimensions;
  return t[0] === "lng" && t[1] === "lat";
}
var krt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a;
      if (n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === e && (a = s);
        });
      }), process.env.NODE_ENV !== "production" && !a)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var o = e.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" || o.type === "matrix" ? this._renderOnGridLike(e, i, 0, e.getData().count()) : AL(o) && this._renderOnGeo(o, e, a, i);
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this.group.removeAll();
    }, t.prototype.incrementalRender = function(e, n, i, a) {
      var o = n.coordinateSystem;
      o && (AL(o) ? this.render(n, i, a) : (this._progressiveEls = [], this._renderOnGridLike(n, a, e.start, e.end, !0)));
    }, t.prototype.eachRendered = function(e) {
      jo(this._progressiveEls || this.group, e);
    }, t.prototype._renderOnGridLike = function(e, n, i, a, o) {
      var s = e.coordinateSystem, l = Xo(s, "cartesian2d"), u = Xo(s, "matrix"), c, f, h, d;
      if (l) {
        var p = s.getAxis("x"), g = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(p.type === "category" && g.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(p.onBand && g.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        c = p.getBandWidth() + 0.5, f = g.getBandWidth() + 0.5, h = p.scale.getExtent(), d = g.scale.getExtent();
      }
      for (var v = this.group, m = e.getData(), y = e.getModel(["emphasis", "itemStyle"]).getItemStyle(), _ = e.getModel(["blur", "itemStyle"]).getItemStyle(), x = e.getModel(["select", "itemStyle"]).getItemStyle(), b = e.get(["itemStyle", "borderRadius"]), S = xr(e), w = e.getModel("emphasis"), A = w.get("focus"), T = w.get("blurScope"), M = w.get("disabled"), C = l || u ? [m.mapDimension("x"), m.mapDimension("y"), m.mapDimension("value")] : [m.mapDimension("time"), m.mapDimension("value")], R = i; R < a; R++) {
        var E = void 0, D = m.getItemVisual(R, "style");
        if (l) {
          var I = m.get(C[0], R), P = m.get(C[1], R);
          if (isNaN(m.get(C[2], R)) || isNaN(I) || isNaN(P) || I < h[0] || I > h[1] || P < d[0] || P > d[1])
            continue;
          var O = s.dataToPoint([I, P]);
          E = new te({
            shape: {
              x: O[0] - c / 2,
              y: O[1] - f / 2,
              width: c,
              height: f
            },
            style: D
          });
        } else if (u) {
          var N = s.dataToLayout([m.get(C[0], R), m.get(C[1], R)]).rect;
          if (kr(N.x))
            continue;
          E = new te({
            z2: 1,
            shape: N,
            style: D
          });
        } else {
          if (isNaN(m.get(C[1], R)))
            continue;
          var B = s.dataToLayout([m.get(C[0], R)]), N = B.contentRect || B.rect;
          if (kr(N.x) || kr(N.y))
            continue;
          E = new te({
            z2: 1,
            shape: N,
            style: D
          });
        }
        if (m.hasItemOption) {
          var F = m.getItemModel(R), G = F.getModel("emphasis");
          y = G.getModel("itemStyle").getItemStyle(), _ = F.getModel(["blur", "itemStyle"]).getItemStyle(), x = F.getModel(["select", "itemStyle"]).getItemStyle(), b = F.get(["itemStyle", "borderRadius"]), A = G.get("focus"), T = G.get("blurScope"), M = G.get("disabled"), S = xr(F);
        }
        E.shape.r = b;
        var W = e.getRawValue(R), J = "-";
        W && W[2] != null && (J = W[2] + ""), Cr(E, S, {
          labelFetcher: e,
          labelDataIndex: R,
          defaultOpacity: D.opacity,
          defaultText: J
        }), E.ensureState("emphasis").style = y, E.ensureState("blur").style = _, E.ensureState("select").style = x, He(E, A, T, M), E.incremental = o, o && (E.states.emphasis.hoverLayer = !0), v.add(E), m.setItemGraphicEl(R, E), this._progressiveEls && this._progressiveEls.push(E);
      }
    }, t.prototype._renderOnGeo = function(e, n, i, a) {
      var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new Prt();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = e.getViewRect().clone(), f = e.getRoamTransform();
      c.applyTransform(f);
      var h = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), g = Math.min(c.height + c.y, a.getHeight()), v = p - h, m = g - d, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], _ = l.mapArray(y, function(w, A, T) {
        var M = e.dataToPoint([w, A]);
        return M[0] -= h, M[1] -= d, M.push(T), M;
      }), x = i.getExtent(), b = i.type === "visualMap.continuous" ? Ort(x, i.option.range) : Nrt(x, i.getPieceList(), i.option.selected);
      u.update(_, v, m, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, b);
      var S = new Fr({
        style: {
          width: v,
          height: m,
          x: h,
          y: d,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(S);
    }, t.type = "heatmap", t;
  }(Re)
), Brt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Ja(null, this, {
        generateCoord: "value"
      });
    }, t.prototype.preventIncremental = function() {
      var e = Cc.get(this.get("coordinateSystem"));
      if (e && e.dimensions)
        return e.dimensions[0] === "lng" && e.dimensions[1] === "lat";
    }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      }
    }, t;
  }(ke)
);
function Vrt(r) {
  r.registerChartView(krt), r.registerSeriesModel(Brt);
}
var Frt = ["itemStyle", "borderWidth"], EL = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], c_ = new Ka(), zrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group, o = e.getData(), s = this._data, l = e.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), f = l.master.getRect(), h = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: e,
        coordSys: l,
        coordSysExtent: [[f.x, f.x + f.width], [f.y, f.y + f.height]],
        isHorizontal: c,
        valueDim: EL[+c],
        categoryDim: EL[1 - +c]
      };
      o.diff(s).add(function(p) {
        if (o.hasValue(p)) {
          var g = DL(o, p), v = CL(o, p, g, h), m = LL(o, h, v);
          o.setItemGraphicEl(p, m), a.add(m), IL(m, h, v);
        }
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        if (!o.hasValue(p)) {
          a.remove(v);
          return;
        }
        var m = DL(o, p), y = CL(o, p, m, h), _ = KB(o, y);
        v && _ !== v.__pictorialShapeStr && (a.remove(v), o.setItemGraphicEl(p, null), v = null), v ? $rt(v, h, y) : v = LL(o, h, y, !0), o.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, a.add(v), IL(v, h, y);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        g && RL(s, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var d = e.get("clip", !0) ? $h(e.coordinateSystem, !1, e) : null;
      return d ? a.setClipPath(d) : a.removeClipPath(), this._data = o, this.group;
    }, t.prototype.remove = function(e, n) {
      var i = this.group, a = this._data;
      e.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        RL(a, zt(o).dataIndex, e, o);
      }) : i.removeAll();
    }, t.type = "pictorialBar", t;
  }(Re)
);
function CL(r, t, e, n) {
  var i = r.getItemLayout(t), a = e.get("symbolRepeat"), o = e.get("symbolClip"), s = e.get("symbolPosition") || "start", l = e.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = e.get("symbolPatternSize") || 2, f = e.isAnimationEnabled(), h = {
    dataIndex: t,
    layout: i,
    itemModel: e,
    symbolType: r.getItemVisual(t, "symbol") || "circle",
    style: r.getItemVisual(t, "style"),
    symbolClip: o,
    symbolRepeat: a,
    symbolRepeatDirection: e.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: f ? e : null,
    hoverScale: f && e.get(["emphasis", "scale"]),
    z2: e.getShallow("z", !0) || 0
  };
  Urt(e, a, i, n, h), Grt(r, t, i, a, o, h.boundingLength, h.pxSign, c, n, h), Hrt(e, h.symbolScale, u, n, h);
  var d = h.symbolSize, p = Ll(e.get("symbolOffset"), d);
  return Wrt(e, d, i, a, o, p, s, h.valueLineWidth, h.boundingLength, h.repeatCutLength, n, h), h;
}
function Urt(r, t, e, n, i) {
  var a = n.valueDim, o = r.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(e[a.wh] <= 0), c;
  if (et(o)) {
    var f = [f_(s, o[0]) - l, f_(s, o[1]) - l];
    f[1] < f[0] && f.reverse(), c = f[u];
  } else
    o != null ? c = f_(s, o) - l : t ? c = n.coordSysExtent[a.index][u] - l : c = e[a.wh];
  i.boundingLength = c, t && (i.repeatCutLength = e[a.wh]);
  var h = a.xy === "x", d = s.inverse;
  i.pxSign = h && !d || !h && d ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
}
function f_(r, t) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(t)));
}
function Grt(r, t, e, n, i, a, o, s, l, u) {
  var c = l.valueDim, f = l.categoryDim, h = Math.abs(e[f.wh]), d = r.getItemVisual(t, "symbolSize"), p;
  et(d) ? p = d.slice() : d == null ? p = ["100%", "100%"] : p = [d, d], p[f.index] = dt(p[f.index], h), p[c.index] = dt(p[c.index], n ? h : Math.abs(a)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * o;
}
function Hrt(r, t, e, n, i) {
  var a = r.get(Frt) || 0;
  a && (c_.attr({
    scaleX: t[0],
    scaleY: t[1],
    rotation: e
  }), c_.updateTransform(), a /= c_.getLineScale(), a *= t[n.valueDim.index]), i.valueLineWidth = a || 0;
}
function Wrt(r, t, e, n, i, a, o, s, l, u, c, f) {
  var h = c.categoryDim, d = c.valueDim, p = f.pxSign, g = Math.max(t[d.index] + s, 0), v = g;
  if (n) {
    var m = Math.abs(l), y = mr(r.get("symbolMargin"), "15%") + "", _ = !1;
    y.lastIndexOf("!") === y.length - 1 && (_ = !0, y = y.slice(0, y.length - 1));
    var x = dt(y, t[d.index]), b = Math.max(g + x * 2, 0), S = _ ? 0 : x * 2, w = L1(n), A = w ? n : PL((m + S) / b), T = m - A * g;
    x = T / 2 / (_ ? A : Math.max(A - 1, 1)), b = g + x * 2, S = _ ? 0 : x * 2, !w && n !== "fixed" && (A = u ? PL((Math.abs(u) + S) / b) : 0), v = A * b - S, f.repeatTimes = A, f.symbolMargin = x;
  }
  var M = p * (v / 2), C = f.pathPosition = [];
  C[h.index] = e[h.wh] / 2, C[d.index] = o === "start" ? M : o === "end" ? l - M : l / 2, a && (C[0] += a[0], C[1] += a[1]);
  var R = f.bundlePosition = [];
  R[h.index] = e[h.xy], R[d.index] = e[d.xy];
  var E = f.barRectShape = j({}, e);
  E[d.wh] = p * Math.max(Math.abs(e[d.wh]), Math.abs(C[d.index] + M)), E[h.wh] = e[h.wh];
  var D = f.clipShape = {};
  D[h.xy] = -e[h.xy], D[h.wh] = c.ecSize[h.wh], D[d.xy] = 0, D[d.wh] = e[d.wh];
}
function XB(r) {
  var t = r.symbolPatternSize, e = hr(
    // Consider texture img, make a big size.
    r.symbolType,
    -t / 2,
    -t / 2,
    t,
    t
  );
  return e.attr({
    culling: !0
  }), e.type !== "image" && e.setStyle({
    strokeNoScale: !0
  }), e;
}
function YB(r, t, e, n) {
  var i = r.__pictorialBundle, a = e.symbolSize, o = e.valueLineWidth, s = e.pathPosition, l = t.valueDim, u = e.repeatTimes || 0, c = 0, f = a[t.valueDim.index] + o + e.symbolMargin * 2;
  for (sw(r, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? Zu(g, null, p(c), e, n) : Zu(g, null, {
      scaleX: 0,
      scaleY: 0
    }, e, n, function() {
      i.remove(g);
    }), c++;
  }); c < u; c++) {
    var h = XB(e);
    h.__pictorialAnimationIndex = c, h.__pictorialRepeatTimes = u, i.add(h);
    var d = p(c);
    Zu(h, {
      x: d.x,
      y: d.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: d.scaleX,
      scaleY: d.scaleY,
      rotation: d.rotation
    }, e, n);
  }
  function p(g) {
    var v = s.slice(), m = e.pxSign, y = g;
    return (e.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = f * (y - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: e.symbolScale[0],
      scaleY: e.symbolScale[1],
      rotation: e.rotation
    };
  }
}
function $B(r, t, e, n) {
  var i = r.__pictorialBundle, a = r.__pictorialMainPath;
  a ? Zu(a, null, {
    x: e.pathPosition[0],
    y: e.pathPosition[1],
    scaleX: e.symbolScale[0],
    scaleY: e.symbolScale[1],
    rotation: e.rotation
  }, e, n) : (a = r.__pictorialMainPath = XB(e), i.add(a), Zu(a, {
    x: e.pathPosition[0],
    y: e.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: e.rotation
  }, {
    scaleX: e.symbolScale[0],
    scaleY: e.symbolScale[1]
  }, e, n));
}
function ZB(r, t, e) {
  var n = j({}, t.barRectShape), i = r.__pictorialBarRect;
  i ? Zu(i, null, {
    shape: n
  }, t, e) : (i = r.__pictorialBarRect = new te({
    z2: 2,
    shape: n,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, r.add(i));
}
function qB(r, t, e, n) {
  if (e.symbolClip) {
    var i = r.__pictorialClipPath, a = j({}, e.clipShape), o = t.valueDim, s = e.animationModel, l = e.dataIndex;
    if (i)
      ve(i, {
        shape: a
      }, s, l);
    else {
      a[o.wh] = 0, i = new te({
        shape: a
      }), r.__pictorialBundle.setClipPath(i), r.__pictorialClipPath = i;
      var u = {};
      u[o.wh] = e.clipShape[o.wh], El[n ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function DL(r, t) {
  var e = r.getItemModel(t);
  return e.getAnimationDelayParams = Xrt, e.isAnimationEnabled = Yrt, e;
}
function Xrt(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes
  };
}
function Yrt() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function LL(r, t, e, n) {
  var i = new Ct(), a = new Ct();
  return i.add(a), i.__pictorialBundle = a, a.x = e.bundlePosition[0], a.y = e.bundlePosition[1], e.symbolRepeat ? YB(i, t, e) : $B(i, t, e), ZB(i, e, n), qB(i, t, e, n), i.__pictorialShapeStr = KB(r, e), i.__pictorialSymbolMeta = e, i;
}
function $rt(r, t, e) {
  var n = e.animationModel, i = e.dataIndex, a = r.__pictorialBundle;
  ve(a, {
    x: e.bundlePosition[0],
    y: e.bundlePosition[1]
  }, n, i), e.symbolRepeat ? YB(r, t, e, !0) : $B(r, t, e, !0), ZB(r, e, !0), qB(r, t, e, !0);
}
function RL(r, t, e, n) {
  var i = n.__pictorialBarRect;
  i && i.removeTextContent();
  var a = [];
  sw(n, function(o) {
    a.push(o);
  }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (e = null), L(a, function(o) {
    Ho(o, {
      scaleX: 0,
      scaleY: 0
    }, e, t, function() {
      n.parent && n.parent.remove(n);
    });
  }), r.setItemGraphicEl(t, null);
}
function KB(r, t) {
  return [r.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
}
function sw(r, t, e) {
  L(r.__pictorialBundle.children(), function(n) {
    n !== r.__pictorialBarRect && t.call(e, n);
  });
}
function Zu(r, t, e, n, i, a) {
  t && r.attr(t), n.symbolClip && !i ? e && r.attr(e) : e && El[i ? "updateProps" : "initProps"](r, e, n.animationModel, n.dataIndex, a);
}
function IL(r, t, e) {
  var n = e.dataIndex, i = e.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), f = a.get("blurScope"), h = a.get("scale");
  sw(r, function(g) {
    if (g instanceof Fr) {
      var v = g.style;
      g.useStyle(j({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, e.style));
    } else
      g.useStyle(e.style);
    var m = g.ensureState("emphasis");
    m.style = o, h && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = e.z2;
  });
  var d = t.valueDim.posDesc[+(e.boundingLength > 0)], p = r.__pictorialBarRect;
  p.ignoreClip = !0, Cr(p, xr(i), {
    labelFetcher: t.seriesModel,
    labelDataIndex: n,
    defaultText: cc(t.seriesModel.getData(), n),
    inheritColor: e.style.fill,
    defaultOpacity: e.style.opacity,
    defaultOutsidePosition: d
  }), He(r, c, f, a.get("disabled"));
}
function PL(r) {
  var t = Math.round(r);
  return Math.abs(r - t) < 1e-4 ? t : Math.ceil(r);
}
var Zrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e.defaultSymbol = "roundRect", e;
    }
    return t.prototype.getInitialData = function(e) {
      return e.stack = null, r.prototype.getInitialData.apply(this, arguments);
    }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = Jo(_h.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: X.color.primary
        }
      }
    }), t;
  }(_h)
);
function qrt(r) {
  r.registerChartView(zrt), r.registerSeriesModel(Zrt), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Yt(gk, "pictorialBar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, mk("pictorialBar"));
}
var Krt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._layers = [], e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this, s = this.group, l = e.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, f = u.boundaryGap;
      s.x = 0, s.y = c.y + f[0];
      function h(v) {
        return v.name;
      }
      var d = new Ya(this._layersSeries || [], l, h, h), p = [];
      d.add(gt(g, this, "add")).update(gt(g, this, "update")).remove(gt(g, this, "remove")).execute();
      function g(v, m, y) {
        var _ = o._layers;
        if (v === "remove") {
          s.remove(_[m]);
          return;
        }
        for (var x = [], b = [], S, w = l[m].indices, A = 0; A < w.length; A++) {
          var T = a.getItemLayout(w[A]), M = T.x, C = T.y0, R = T.y;
          x.push(M, C), b.push(M, C + R), S = a.getItemVisual(w[A], "style");
        }
        var E, D = a.getItemLayout(w[0]), I = e.getModel("label"), P = I.get("margin"), O = e.getModel("emphasis");
        if (v === "add") {
          var N = p[m] = new Ct();
          E = new s3({
            shape: {
              points: x,
              stackedOnPoints: b,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), N.add(E), s.add(N), e.isAnimationEnabled() && E.setClipPath(jrt(E.getBoundingRect(), e, function() {
            E.removeClipPath();
          }));
        } else {
          var N = _[y];
          E = N.childAt(0), s.add(N), p[m] = N, ve(E, {
            shape: {
              points: x,
              stackedOnPoints: b
            }
          }, e), oi(E);
        }
        Cr(E, xr(e), {
          labelDataIndex: w[A - 1],
          defaultText: a.getName(w[A - 1]),
          inheritColor: S.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), E.setTextConfig({
          position: null,
          local: !0
        });
        var B = E.getTextContent();
        B && (B.x = D.x - P, B.y = D.y0 + D.y / 2), E.useStyle(S), a.setItemGraphicEl(m, E), _r(E, e), He(E, O.get("focus"), O.get("blurScope"), O.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, t.type = "themeRiver", t;
  }(Re)
);
function jrt(r, t, e) {
  var n = new te({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return ze(n, {
    shape: {
      x: r.x - 50,
      width: r.width + 100,
      height: r.height + 20
    }
  }, t, e), n;
}
var h_ = 2, Jrt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Oc(gt(this.getData, this), gt(this.getRawData, this));
    }, t.prototype.fixData = function(e) {
      var n = e.length, i = {}, a = bx(e, function(h) {
        return i.hasOwnProperty(h[0] + "") || (i[h[0] + ""] = -1), h[2];
      }), o = [];
      a.buckets.each(function(h, d) {
        o.push({
          name: d,
          dataList: h
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var f = o[l].dataList[c][0] + "";
          i[f] = l;
        }
        for (var f in i)
          i.hasOwnProperty(f) && i[f] !== l && (i[f] = l, e[n] = [f, 0, u], n++);
      }
      return e;
    }, t.prototype.getInitialData = function(e, n) {
      for (var i = this.getReferringComponents("singleAxis", je).models[0], a = i.get("type"), o = Te(e.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = wt(), c = 0, f = 0; f < s.length; ++f)
        l.push(s[f][h_]), u.get(s[f][h_]) || (u.set(s[f][h_], c), c++);
      var h = Hh(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: Kv(a)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new cn(h, this);
      return d.initData(s), d;
    }, t.prototype.getLayerSeries = function() {
      for (var e = this.getData(), n = e.count(), i = [], a = 0; a < n; ++a)
        i[a] = a;
      var o = e.mapDimension("single"), s = bx(i, function(u) {
        return e.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(f, h) {
          return e.get(o, f) - e.get(o, h);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, t.prototype.getAxisTooltipData = function(e, n, i) {
      et(e) || (e = e ? [e] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var f = Number.MAX_VALUE, h = -1, d = o[c].indices.length, p = 0; p < d; ++p) {
          var g = a.get(e[0], o[c].indices[p]), v = Math.abs(g - n);
          v <= f && (u = g, f = v, h = o[c].indices[p]);
        }
        s.push(h);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = a.getName(e), s = a.get(a.mapDimension("value"), e);
      return fr("nameValue", {
        name: o,
        value: s
      });
    }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(ke)
);
function Qrt(r, t) {
  r.eachSeriesByType("themeRiver", function(e) {
    var n = e.getData(), i = e.coordinateSystem, a = {}, o = i.getRect();
    a.rect = o;
    var s = e.get("boundaryGap"), l = i.getAxis();
    if (a.boundaryGap = s, l.orient === "horizontal") {
      s[0] = dt(s[0], o.height), s[1] = dt(s[1], o.height);
      var u = o.height - s[0] - s[1];
      NL(n, e, u);
    } else {
      s[0] = dt(s[0], o.width), s[1] = dt(s[1], o.width);
      var c = o.width - s[0] - s[1];
      NL(n, e, c);
    }
    n.setLayout("layoutInfo", a);
  });
}
function NL(r, t, e) {
  if (r.count())
    for (var n = t.coordinateSystem, i = t.getLayerSeries(), a = r.mapDimension("single"), o = r.mapDimension("value"), s = rt(i, function(v) {
      return rt(v.indices, function(m) {
        var y = n.dataToPoint(r.get(a, m));
        return y[1] = r.get(o, m), y;
      });
    }), l = tnt(s), u = l.y0, c = e / l.max, f = i.length, h = i[0].indices.length, d, p = 0; p < h; ++p) {
      d = u[p] * c, r.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < f; ++g)
        d += s[g - 1][p][1] * c, r.setItemLayout(i[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: d,
          y: s[g][p][1] * c
        });
    }
}
function tnt(r) {
  for (var t = r.length, e = r[0].length, n = [], i = [], a = 0, o = 0; o < e; ++o) {
    for (var s = 0, l = 0; l < t; ++l)
      s += r[l][o][1];
    s > a && (a = s), n.push(s);
  }
  for (var u = 0; u < e; ++u)
    i[u] = (a - n[u]) / 2;
  a = 0;
  for (var c = 0; c < e; ++c) {
    var f = n[c] + i[c];
    f > a && (a = f);
  }
  return {
    y0: i,
    max: a
  };
}
function ent(r) {
  r.registerChartView(Krt), r.registerSeriesModel(Jrt), r.registerLayout(Qrt), r.registerProcessor(Pc("themeRiver"));
}
var rnt = 2, nnt = 4, OL = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      o.z2 = rnt, o.textConfig = {
        inside: !0
      }, zt(o).seriesIndex = n.seriesIndex;
      var s = new pe({
        z2: nnt,
        silent: e.getModel().get(["label", "silent"])
      });
      return o.setTextContent(s), o.updateData(!0, e, n, i, a), o;
    }
    return t.prototype.updateData = function(e, n, i, a, o) {
      this.node = n, n.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var s = this;
      zt(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), f = j({}, c);
      f.label = null;
      var h = n.getVisual("style");
      h.lineJoin = "bevel";
      var d = n.getVisual("decal");
      d && (h.decal = oc(d, o));
      var p = ji(l.getModel("itemStyle"), f, !0);
      j(f, p), L(pn, function(y) {
        var _ = s.ensureState(y), x = l.getModel([y, "itemStyle"]);
        _.style = x.getItemStyle();
        var b = ji(x, f);
        b && (_.shape = b);
      }), e ? (s.setShape(f), s.shape.r = c.r0, ze(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (ve(s, {
        shape: f
      }, i), oi(s)), s.useStyle(h), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var v = u.get("focus"), m = v === "relative" ? eh(n.getAncestorsIndices(), n.getDescendantIndices()) : v === "ancestor" ? n.getAncestorsIndices() : v === "descendant" ? n.getDescendantIndices() : v;
      He(this, m, u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e) {
      var n = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), f = this, h = f.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(s) < p);
      h.ignore = !g, L(oh, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([m, "label"]), _ = m === "normal", x = _ ? h : h.ensureState(m), b = e.getFormattedLabel(d, m);
        _ && (b = b || n.node.name), x.style = Oe(y, {}, null, m !== "normal", !0), b && (x.style.text = b);
        var S = y.get("show");
        S != null && !_ && (x.ignore = !S);
        var w = v(y, "position"), A = _ ? f : f.states[m], T = A.style.fill;
        A.textConfig = {
          outsideFill: y.get("color") === "inherit" ? T : null,
          inside: w !== "outside"
        };
        var M, C = v(y, "distance") || 0, R = v(y, "align"), E = v(y, "rotate"), D = Math.PI * 0.5, I = Math.PI * 1.5, P = Nn(E === "tangential" ? Math.PI / 2 - l : l), O = P > D && !ah(P - D) && P < I;
        w === "outside" ? (M = o.r + C, R = O ? "right" : "left") : !R || R === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? M = 0 : M = (o.r + o.r0) / 2, R = "center") : R === "left" ? (M = o.r0 + C, R = O ? "right" : "left") : R === "right" && (M = o.r - C, R = O ? "left" : "right"), x.style.align = R, x.style.verticalAlign = v(y, "verticalAlign") || "middle", x.x = M * u + o.cx, x.y = M * c + o.cy;
        var N = 0;
        E === "radial" ? N = Nn(-l) + (O ? Math.PI : 0) : E === "tangential" ? N = Nn(Math.PI / 2 - l) + (O ? Math.PI : 0) : fe(E) && (N = E * Math.PI / 180), x.rotation = Nn(N);
      });
      function v(m, y) {
        var _ = m.get(y);
        return _ ?? a.get(y);
      }
      h.dirtyStyle();
    }, t;
  }(jr)
), zS = "sunburstRootToNode", kL = "sunburstHighlight", int = "sunburstUnhighlight";
function ant(r) {
  r.registerAction({
    type: zS,
    update: "updateView"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, n);
    function n(i, a) {
      var o = Sh(t, [zS], i);
      if (o) {
        var s = i.getViewRoot();
        s && (t.direction = Wb(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node);
      }
    }
  }), r.registerAction({
    type: kL,
    update: "none"
  }, function(t, e, n) {
    t = j({}, t), e.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, i);
    function i(a) {
      var o = Sh(t, [kL], a);
      o && (t.dataIndex = o.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && or("sunburstHighlight", "highlight"), n.dispatchAction(j(t, {
      type: "highlight"
    }));
  }), r.registerAction({
    type: int,
    update: "updateView"
  }, function(t, e, n) {
    t = j({}, t), process.env.NODE_ENV !== "production" && or("sunburstUnhighlight", "downplay"), n.dispatchAction(j(t, {
      type: "downplay"
    }));
  });
}
var ont = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this;
      this.seriesModel = e, this.api = i, this.ecModel = n;
      var s = e.getData(), l = s.tree.root, u = e.getViewRoot(), c = this.group, f = e.get("renderLabelForZeroData"), h = [];
      u.eachNode(function(y) {
        h.push(y);
      });
      var d = this._oldChildren || [];
      p(h, d), m(l, u), this._initEvents(), this._oldChildren = h;
      function p(y, _) {
        if (y.length === 0 && _.length === 0)
          return;
        new Ya(_, y, x, x).add(b).update(b).remove(Yt(b, null)).execute();
        function x(S) {
          return S.getId();
        }
        function b(S, w) {
          var A = S == null ? null : y[S], T = w == null ? null : _[w];
          g(A, T);
        }
      }
      function g(y, _) {
        if (!f && y && !y.getValue() && (y = null), y !== l && _ !== l) {
          if (_ && _.piece)
            y ? (_.piece.updateData(!1, y, e, n, i), s.setItemGraphicEl(y.dataIndex, _.piece)) : v(_);
          else if (y) {
            var x = new OL(y, e, n, i);
            c.add(x), s.setItemGraphicEl(y.dataIndex, x);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, _) {
        _.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, y, e, n, i) : (o.virtualPiece = new OL(y, e, n, i), c.add(o.virtualPiece)), _.piece.off("click"), o.virtualPiece.on("click", function(x) {
          o._rootToNode(_.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, t.prototype._initEvents = function() {
      var e = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = !1, a = e.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!i && o.piece && o.piece === n.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode")
              e._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                Vv(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, t.prototype._rootToNode = function(e) {
      e !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: zS,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e
      });
    }, t.prototype.containPoint = function(e, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "sunburst", t;
  }(Re)
), snt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreStyleOnData = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = {
        name: e.name,
        children: e.data
      };
      jB(i);
      var a = this._levelModels = rt(e.levels || [], function(l) {
        return new ue(l, this, n);
      }, this), o = Hb.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var f = o.getNodeByDataIndex(c), h = a[f.depth];
          return h && (u.parentModel = h), u;
        });
      }
      return o.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treePathInfo = bm(i, this), n;
    }, t.prototype.getLevelModel = function(e) {
      return this._levelModels && this._levelModels[e.depth];
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!e || e !== n && !n.contains(e)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      eB(this);
    }, t.type = "series.sunburst", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, t;
  }(ke)
);
function jB(r) {
  var t = 0;
  L(r.children, function(n) {
    jB(n);
    var i = n.value;
    et(i) && (i = i[0]), t += i;
  });
  var e = r.value;
  et(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), et(r.value) ? r.value[0] = e : r.value = e;
}
var BL = Math.PI / 180;
function lnt(r, t, e) {
  t.eachSeriesByType(r, function(n) {
    var i = n.get("center"), a = n.get("radius");
    et(a) || (a = [0, a]), et(i) || (i = [i, i]);
    var o = e.getWidth(), s = e.getHeight(), l = Math.min(o, s), u = dt(i[0], o), c = dt(i[1], s), f = dt(a[0], l / 2), h = dt(a[1], l / 2), d = -n.get("startAngle") * BL, p = n.get("minAngle") * BL, g = n.getData().tree.root, v = n.getViewRoot(), m = v.depth, y = n.get("sort");
    y != null && JB(v, y);
    var _ = 0;
    L(v.children, function(P) {
      !isNaN(P.getValue()) && _++;
    });
    var x = v.getValue(), b = Math.PI / (x || _) * 2, S = v.depth > 0, w = v.height - (S ? -1 : 1), A = (h - f) / (w || 1), T = n.get("clockwise"), M = n.get("stillShowZeroSum"), C = T ? 1 : -1, R = function(P, O) {
      if (P) {
        var N = O;
        if (P !== g) {
          var B = P.getValue(), F = x === 0 && M ? b : B * b;
          F < p && (F = p), N = O + C * F;
          var G = P.depth - m - (S ? -1 : 1), W = f + A * G, J = f + A * (G + 1), U = n.getLevelModel(P);
          if (U) {
            var Y = U.get("r0", !0), at = U.get("r", !0), st = U.get("radius", !0);
            st != null && (Y = st[0], at = st[1]), Y != null && (W = dt(Y, l / 2)), at != null && (J = dt(at, l / 2));
          }
          P.setLayout({
            angle: F,
            startAngle: O,
            endAngle: N,
            clockwise: T,
            cx: u,
            cy: c,
            r0: W,
            r: J
          });
        }
        if (P.children && P.children.length) {
          var ut = 0;
          L(P.children, function(lt) {
            ut += R(lt, O + ut);
          });
        }
        return N - O;
      }
    };
    if (S) {
      var E = f, D = f + A, I = Math.PI * 2;
      g.setLayout({
        angle: I,
        startAngle: d,
        endAngle: d + I,
        clockwise: T,
        cx: u,
        cy: c,
        r0: E,
        r: D
      });
    }
    R(v, d);
  });
}
function JB(r, t) {
  var e = r.children || [];
  r.children = unt(e, t), e.length && L(r.children, function(n) {
    JB(n, t);
  });
}
function unt(r, t) {
  if (At(t)) {
    var e = rt(r, function(i, a) {
      var o = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return o;
          }
        },
        index: a
      };
    });
    return e.sort(function(i, a) {
      return t(i.params, a.params);
    }), rt(e, function(i) {
      return r[i.index];
    });
  } else {
    var n = t === "asc";
    return r.sort(function(i, a) {
      var o = (i.getValue() - a.getValue()) * (n ? 1 : -1);
      return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o;
    });
  }
}
function cnt(r) {
  var t = {};
  function e(n, i, a) {
    if (n.depth === 0)
      return X.color.neutral50;
    for (var o = n; o && o.depth > 1; )
      o = o.parentNode;
    var s = i.getColorFromPalette(o.name || o.dataIndex + "", t);
    return n.depth > 1 && pt(s) && (s = ux(s, (n.depth - 1) / (a - 1) * 0.5)), s;
  }
  r.eachSeriesByType("sunburst", function(n) {
    var i = n.getData(), a = i.tree;
    a.eachNode(function(o) {
      var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = e(o, n, a.root.height));
      var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
      j(u, l);
    });
  });
}
function fnt(r) {
  r.registerChartView(ont), r.registerSeriesModel(snt), r.registerLayout(Yt(lnt, "sunburst")), r.registerProcessor(Yt(Pc, "sunburst")), r.registerVisual(cnt), ant(r);
}
var VL = {
  color: "fill",
  borderColor: "stroke"
}, hnt = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, ka = ee(), dnt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, t.prototype.getInitialData = function(e, n) {
      return Ja(null, this);
    }, t.prototype.getDataParams = function(e, n, i) {
      var a = r.prototype.getDataParams.call(this, e, n);
      return i && (a.info = ka(i).info), a;
    }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, t;
  }(ke)
);
function pnt(r, t) {
  return t = t || [0, 0], rt(["x", "y"], function(e, n) {
    var i = this.getAxis(e), a = t[n], o = r[n] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o));
  }, this);
}
function vnt(r) {
  var t = r.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: gt(pnt, r)
    }
  };
}
function gnt(r, t) {
  return t = t || [0, 0], rt([0, 1], function(e) {
    var n = t[e], i = r[e] / 2, a = [], o = [];
    return a[e] = n - i, o[e] = n + i, a[1 - e] = o[1 - e] = t[1 - e], Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e]);
  }, this);
}
function mnt(r) {
  var t = r.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: r.getZoom()
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: gt(gnt, r)
    }
  };
}
function ynt(r, t) {
  var e = this.getAxis(), n = t instanceof Array ? t[0] : t, i = (r instanceof Array ? r[0] : r) / 2;
  return e.type === "category" ? e.getBandWidth() : Math.abs(e.dataToCoord(n - i) - e.dataToCoord(n + i));
}
function _nt(r) {
  var t = r.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: gt(ynt, r)
    }
  };
}
function xnt(r, t) {
  return t = t || [0, 0], rt(["Radius", "Angle"], function(e, n) {
    var i = "get" + e + "Axis", a = this[i](), o = t[n], s = r[n] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
    return e === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function Snt(r) {
  var t = r.getRadiusAxis(), e = r.getAngleAxis(), n = t.getExtent();
  return n[0] > n[1] && n.reverse(), {
    coordSys: {
      type: "polar",
      cx: r.cx,
      cy: r.cy,
      r: n[1],
      r0: n[0]
    },
    api: {
      coord: function(i) {
        var a = t.dataToRadius(i[0]), o = e.dataToAngle(i[1]), s = r.coordToPoint([a, o]);
        return s.push(a, o * Math.PI / 180), s;
      },
      size: gt(xnt, r)
    }
  };
}
function bnt(r) {
  var t = r.getRect(), e = r.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: e.start,
        end: e.end,
        weeks: e.weeks,
        dayCount: e.allDay
      }
    },
    api: {
      coord: function(n, i) {
        return r.dataToPoint(n, i);
      },
      layout: function(n, i) {
        return r.dataToLayout(n, i);
      }
    }
  };
}
function wnt(r) {
  var t = r.getRect();
  return {
    coordSys: {
      type: "matrix",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e, n) {
        return r.dataToPoint(e, n);
      },
      layout: function(e, n) {
        return r.dataToLayout(e, n);
      }
    }
  };
}
var FL = {};
function QB(r, t, e, n) {
  return r && (r.legacy || r.legacy !== !1 && !e && !n && t !== "tspan" && (t === "text" || _t(r, "text")));
}
function tV(r, t, e) {
  var n = r, i, a, o;
  if (t === "text")
    o = n;
  else {
    o = {}, _t(n, "text") && (o.text = n.text), _t(n, "rich") && (o.rich = n.rich), _t(n, "textFill") && (o.fill = n.textFill), _t(n, "textStroke") && (o.stroke = n.textStroke), _t(n, "fontFamily") && (o.fontFamily = n.fontFamily), _t(n, "fontSize") && (o.fontSize = n.fontSize), _t(n, "fontStyle") && (o.fontStyle = n.fontStyle), _t(n, "fontWeight") && (o.fontWeight = n.fontWeight), a = {
      type: "text",
      style: o,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = _t(n, "textPosition");
    e ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), _t(n, "textPosition") && (i.position = n.textPosition), _t(n, "textOffset") && (i.offset = n.textOffset), _t(n, "textRotation") && (i.rotation = n.textRotation), _t(n, "textDistance") && (i.distance = n.textDistance);
  }
  return zL(o, r), L(o.rich, function(l) {
    zL(l, l);
  }), {
    textConfig: i,
    textContent: a
  };
}
function zL(r, t) {
  t && (t.font = t.textFont || t.font, _t(t, "textStrokeWidth") && (r.lineWidth = t.textStrokeWidth), _t(t, "textAlign") && (r.align = t.textAlign), _t(t, "textVerticalAlign") && (r.verticalAlign = t.textVerticalAlign), _t(t, "textLineHeight") && (r.lineHeight = t.textLineHeight), _t(t, "textWidth") && (r.width = t.textWidth), _t(t, "textHeight") && (r.height = t.textHeight), _t(t, "textBackgroundColor") && (r.backgroundColor = t.textBackgroundColor), _t(t, "textPadding") && (r.padding = t.textPadding), _t(t, "textBorderColor") && (r.borderColor = t.textBorderColor), _t(t, "textBorderWidth") && (r.borderWidth = t.textBorderWidth), _t(t, "textBorderRadius") && (r.borderRadius = t.textBorderRadius), _t(t, "textBoxShadowColor") && (r.shadowColor = t.textBoxShadowColor), _t(t, "textBoxShadowBlur") && (r.shadowBlur = t.textBoxShadowBlur), _t(t, "textBoxShadowOffsetX") && (r.shadowOffsetX = t.textBoxShadowOffsetX), _t(t, "textBoxShadowOffsetY") && (r.shadowOffsetY = t.textBoxShadowOffsetY));
}
function UL(r, t, e) {
  var n = r;
  n.textPosition = n.textPosition || e.position || "inside", e.offset != null && (n.textOffset = e.offset), e.rotation != null && (n.textRotation = e.rotation), e.distance != null && (n.textDistance = e.distance);
  var i = n.textPosition.indexOf("inside") >= 0, a = r.fill || X.color.neutral99;
  GL(n, t);
  var o = n.textFill == null;
  return i ? o && (n.textFill = e.insideFill || X.color.neutral00, !n.textStroke && e.insideStroke && (n.textStroke = e.insideStroke), !n.textStroke && (n.textStroke = a), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (o && (n.textFill = r.fill || e.outsideFill || X.color.neutral00), !n.textStroke && e.outsideStroke && (n.textStroke = e.outsideStroke)), n.text = t.text, n.rich = t.rich, L(t.rich, function(s) {
    GL(s, s);
  }), n;
}
function GL(r, t) {
  t && (_t(t, "fill") && (r.textFill = t.fill), _t(t, "stroke") && (r.textStroke = t.fill), _t(t, "lineWidth") && (r.textStrokeWidth = t.lineWidth), _t(t, "font") && (r.font = t.font), _t(t, "fontStyle") && (r.fontStyle = t.fontStyle), _t(t, "fontWeight") && (r.fontWeight = t.fontWeight), _t(t, "fontSize") && (r.fontSize = t.fontSize), _t(t, "fontFamily") && (r.fontFamily = t.fontFamily), _t(t, "align") && (r.textAlign = t.align), _t(t, "verticalAlign") && (r.textVerticalAlign = t.verticalAlign), _t(t, "lineHeight") && (r.textLineHeight = t.lineHeight), _t(t, "width") && (r.textWidth = t.width), _t(t, "height") && (r.textHeight = t.height), _t(t, "backgroundColor") && (r.textBackgroundColor = t.backgroundColor), _t(t, "padding") && (r.textPadding = t.padding), _t(t, "borderColor") && (r.textBorderColor = t.borderColor), _t(t, "borderWidth") && (r.textBorderWidth = t.borderWidth), _t(t, "borderRadius") && (r.textBorderRadius = t.borderRadius), _t(t, "shadowColor") && (r.textBoxShadowColor = t.shadowColor), _t(t, "shadowBlur") && (r.textBoxShadowBlur = t.shadowBlur), _t(t, "shadowOffsetX") && (r.textBoxShadowOffsetX = t.shadowOffsetX), _t(t, "shadowOffsetY") && (r.textBoxShadowOffsetY = t.shadowOffsetY), _t(t, "textShadowColor") && (r.textShadowColor = t.textShadowColor), _t(t, "textShadowBlur") && (r.textShadowBlur = t.textShadowBlur), _t(t, "textShadowOffsetX") && (r.textShadowOffsetX = t.textShadowOffsetX), _t(t, "textShadowOffsetY") && (r.textShadowOffsetY = t.textShadowOffsetY));
}
function HL(r, t) {
  if (process.env.NODE_ENV !== "production") {
    var e = r + "^_^" + t;
    FL[e] || (console.warn('[ECharts] DEPRECATED: "' + r + '" has been deprecated. ' + t), FL[e] = !0);
  }
}
var eV = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, WL = se(eV), pg = ra(ia, function(r, t) {
  return r[t] = 1, r;
}, {}), XL = ia.join(", "), vg = ["", "style", "shape", "extra"], pc = ee();
function lw(r, t, e, n, i) {
  var a = r + "Animation", o = Tc(r, n, i) || {}, s = pc(t).userDuring;
  return o.duration > 0 && (o.during = s ? gt(Cnt, {
    el: t,
    userDuring: s
  }) : null, o.setToFinal = !0, o.scope = r), j(o, e[a]), o;
}
function iv(r, t, e, n) {
  n = n || {};
  var i = n.dataIndex, a = n.isInit, o = n.clearStyle, s = e.isAnimationEnabled(), l = pc(r), u = t.style;
  l.userDuring = t.during;
  var c = {}, f = {};
  if (Lnt(r, t, f), r.type === "compound")
    for (var h = r.shape.paths, d = t.shape.paths, p = 0; p < d.length; p++) {
      var g = d[p];
      d_("shape", g, h[p]);
    }
  else
    d_("shape", t, f), d_("extra", t, f);
  if (!a && s && (Dnt(r, t, c), YL("shape", r, t, c), YL("extra", r, t, c), Rnt(r, t, u, c)), f.style = u, Mnt(r, f, o), Ant(r, t), s)
    if (a) {
      var v = {};
      L(vg, function(y) {
        var _ = y ? t[y] : t;
        _ && _.enterFrom && (y && (v[y] = v[y] || {}), j(y ? v[y] : v, _.enterFrom));
      });
      var m = lw("enter", r, t, e, i);
      m.duration > 0 && r.animateFrom(v, m);
    } else
      Tnt(r, t, i || 0, e, c);
  rV(r, t), u ? r.dirty() : r.markRedraw();
}
function rV(r, t) {
  for (var e = pc(r).leaveToProps, n = 0; n < vg.length; n++) {
    var i = vg[n], a = i ? t[i] : t;
    a && a.leaveTo && (e || (e = pc(r).leaveToProps = {}), i && (e[i] = e[i] || {}), j(i ? e[i] : e, a.leaveTo));
  }
}
function Tm(r, t, e, n) {
  if (r) {
    var i = r.parent, a = pc(r).leaveToProps;
    if (a) {
      var o = lw("update", r, t, e, 0);
      o.done = function() {
        i && i.remove(r);
      }, r.animateTo(a, o);
    } else
      i && i.remove(r);
  }
}
function cl(r) {
  return r === "all";
}
function Mnt(r, t, e) {
  var n = t.style;
  if (!r.isGroup && n) {
    if (e) {
      r.useStyle({});
      for (var i = r.animators, a = 0; a < i.length; a++) {
        var o = i[a];
        o.targetName === "style" && o.changeTarget(r.style);
      }
    }
    r.setStyle(n);
  }
  t && (t.style = null, t && r.attr(t), t.style = n);
}
function Tnt(r, t, e, n, i) {
  if (i) {
    var a = lw("update", r, t, n, e);
    a.duration > 0 && r.animateFrom(i, a);
  }
}
function Ant(r, t) {
  _t(t, "silent") && (r.silent = t.silent), _t(t, "ignore") && (r.ignore = t.ignore), r instanceof ai && _t(t, "invisible") && (r.invisible = t.invisible), r instanceof ne && _t(t, "autoBatch") && (r.autoBatch = t.autoBatch);
}
var ki = {}, Ent = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(r, t) {
    return process.env.NODE_ENV !== "production" && St(_t(pg, r), "Only " + XL + " available in `setTransform`."), ki.el[r] = t, this;
  },
  getTransform: function(r) {
    return process.env.NODE_ENV !== "production" && St(_t(pg, r), "Only " + XL + " available in `getTransform`."), ki.el[r];
  },
  setShape: function(r, t) {
    process.env.NODE_ENV !== "production" && xu(r);
    var e = ki.el, n = e.shape || (e.shape = {});
    return n[r] = t, e.dirtyShape && e.dirtyShape(), this;
  },
  getShape: function(r) {
    process.env.NODE_ENV !== "production" && xu(r);
    var t = ki.el.shape;
    if (t)
      return t[r];
  },
  setStyle: function(r, t) {
    process.env.NODE_ENV !== "production" && xu(r);
    var e = ki.el, n = e.style;
    return n && (process.env.NODE_ENV !== "production" && kr(t) && Ye("style." + r + " must not be assigned with NaN."), n[r] = t, e.dirtyStyle && e.dirtyStyle()), this;
  },
  getStyle: function(r) {
    process.env.NODE_ENV !== "production" && xu(r);
    var t = ki.el.style;
    if (t)
      return t[r];
  },
  setExtra: function(r, t) {
    process.env.NODE_ENV !== "production" && xu(r);
    var e = ki.el.extra || (ki.el.extra = {});
    return e[r] = t, this;
  },
  getExtra: function(r) {
    process.env.NODE_ENV !== "production" && xu(r);
    var t = ki.el.extra;
    if (t)
      return t[r];
  }
};
function xu(r) {
  if (process.env.NODE_ENV !== "production" && (r === "transition" || r === "enterFrom" || r === "leaveTo"))
    throw new Error('key must not be "' + r + '"');
}
function Cnt() {
  var r = this, t = r.el;
  if (t) {
    var e = pc(t).userDuring, n = r.userDuring;
    if (e !== n) {
      r.el = r.userDuring = null;
      return;
    }
    ki.el = t, n(Ent);
  }
}
function YL(r, t, e, n) {
  var i = e[r];
  if (i) {
    var a = t[r], o;
    if (a) {
      var s = e.transition, l = i.transition;
      if (l)
        if (!o && (o = n[r] = {}), cl(l))
          j(o, a);
        else
          for (var u = Ie(l), c = 0; c < u.length; c++) {
            var f = u[c], h = a[f];
            o[f] = h;
          }
      else if (cl(s) || Zt(s, r) >= 0) {
        !o && (o = n[r] = {});
        for (var d = se(a), c = 0; c < d.length; c++) {
          var f = d[c], h = a[f];
          Int(i[f], h) && (o[f] = h);
        }
      }
    }
  }
}
function d_(r, t, e) {
  var n = t[r];
  if (n)
    for (var i = e[r] = {}, a = se(n), o = 0; o < a.length; o++) {
      var s = a[o];
      i[s] = Wf(n[s]);
    }
}
function Dnt(r, t, e) {
  for (var n = t.transition, i = cl(n) ? ia : Ie(n || []), a = 0; a < i.length; a++) {
    var o = i[a];
    if (!(o === "style" || o === "shape" || o === "extra")) {
      var s = r[o];
      process.env.NODE_ENV !== "production" && nV(o, "el.transition"), e[o] = s;
    }
  }
}
function Lnt(r, t, e) {
  for (var n = 0; n < WL.length; n++) {
    var i = WL[n], a = eV[i], o = t[i];
    o && (e[a[0]] = o[0], e[a[1]] = o[1]);
  }
  for (var n = 0; n < ia.length; n++) {
    var s = ia[n];
    t[s] != null && (e[s] = t[s]);
  }
}
function Rnt(r, t, e, n) {
  if (e) {
    var i = r.style, a;
    if (i) {
      var o = e.transition, s = t.transition;
      if (o && !cl(o)) {
        var l = Ie(o);
        !a && (a = n.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], f = i[c];
          a[c] = f;
        }
      } else if (r.getAnimationStyleProps && (cl(s) || cl(o) || Zt(s, "style") >= 0)) {
        var h = r.getAnimationStyleProps(), d = h ? h.style : null;
        if (d) {
          !a && (a = n.style = {});
          for (var p = se(e), u = 0; u < p.length; u++) {
            var c = p[u];
            if (d[c]) {
              var f = i[c];
              a[c] = f;
            }
          }
        }
      }
    }
  }
}
function Int(r, t) {
  return Kr(r) ? r !== t : r != null && isFinite(r);
}
var nV;
process.env.NODE_ENV !== "production" && (nV = function(r, t) {
  _t(pg, r) || Ye("Prop `" + r + "` is not a permitted in `" + t + "`. Only `" + se(pg).join("`, `") + "` are permitted.");
});
var iV = ee(), Pnt = ["percent", "easing", "shape", "style", "extra"];
function aV(r) {
  r.stopAnimation("keyframe"), r.attr(iV(r));
}
function gg(r, t, e) {
  if (!(!e.isAnimationEnabled() || !t)) {
    if (et(t)) {
      L(t, function(s) {
        gg(r, s, e);
      });
      return;
    }
    var n = t.keyframes, i = t.duration;
    if (e && i == null) {
      var a = Tc("enter", e, 0);
      i = a && a.duration;
    }
    if (!(!n || !i)) {
      var o = iV(r);
      L(vg, function(s) {
        if (!(s && !r[s])) {
          var l, u = !1;
          n.sort(function(c, f) {
            return c.percent - f.percent;
          }), L(n, function(c) {
            var f = r.animators, h = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!h) {
              var d = se(h);
              if (s || (d = Te(d, function(v) {
                return Zt(Pnt, v) < 0;
              })), !!d.length) {
                l || (l = r.animate(s, t.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < f.length; p++)
                  f[p] !== l && f[p].targetName === l.targetName && f[p].stopTracks(d);
                s && (o[s] = o[s] || {});
                var g = s ? o[s] : o;
                L(d, function(v) {
                  g[v] = ((s ? r[s] : r) || {})[v];
                }), l.whenWithKeys(i * c.percent, h, d, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || Ye("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(t.delay || 0).duration(i).start(t.easing));
        }
      });
    }
  }
}
var Ba = "emphasis", Co = "normal", uw = "blur", cw = "select", Zo = [Co, Ba, uw, cw], p_ = {
  normal: ["itemStyle"],
  emphasis: [Ba, "itemStyle"],
  blur: [uw, "itemStyle"],
  select: [cw, "itemStyle"]
}, v_ = {
  normal: ["label"],
  emphasis: [Ba, "label"],
  blur: [uw, "label"],
  select: [cw, "label"]
}, Nnt = ["x", "y"], Ont = "e\0\0", Xn = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, $L = {
  cartesian2d: vnt,
  geo: mnt,
  single: _nt,
  polar: Snt,
  calendar: bnt,
  matrix: wnt
};
function mg(r) {
  return r instanceof ne;
}
function US(r) {
  return r instanceof ai;
}
function knt(r, t) {
  t.copyTransform(r), US(t) && US(r) && (t.setStyle(r.style), t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t.invisible = r.invisible, t.ignore = r.ignore, mg(t) && mg(r) && t.setShape(r.shape));
}
var Bnt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._progressiveEls = null;
      var o = this._data, s = e.getData(), l = this.group, u = ZL(e, s, n, i);
      o || l.removeAll(), s.diff(o).add(function(f) {
        g_(i, null, f, u(f, a), e, l, s);
      }).remove(function(f) {
        var h = o.getItemGraphicEl(f);
        h && Tm(h, ka(h).option, e);
      }).update(function(f, h) {
        var d = o.getItemGraphicEl(h);
        g_(i, d, f, u(f, a), e, l, s);
      }).execute();
      var c = e.get("clip", !0) ? $h(e.coordinateSystem, !1, e) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this.group.removeAll(), this._data = null;
    }, t.prototype.incrementalRender = function(e, n, i, a, o) {
      var s = n.getData(), l = ZL(n, s, i, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = !0, d.ensureState("emphasis").hoverLayer = !0);
      }
      for (var f = e.start; f < e.end; f++) {
        var h = g_(null, null, f, l(f, o), n, this.group, s);
        h && (h.traverse(c), u.push(h));
      }
    }, t.prototype.eachRendered = function(e) {
      jo(this._progressiveEls || this.group, e);
    }, t.prototype.filterForExposedEvent = function(e, n, i, a) {
      var o = n.element;
      if (o == null || i.name === o)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === o)
          return !0;
      return !1;
    }, t.type = "custom", t;
  }(Re)
);
function fw(r) {
  var t = r.type, e;
  if (t === "path") {
    var n = r.shape, i = n.width != null && n.height != null ? {
      x: n.x || 0,
      y: n.y || 0,
      width: n.width,
      height: n.height
    } : null, a = lV(n);
    e = sh(a, null, i, n.layout || "center"), ka(e).customPathData = a;
  } else if (t === "image")
    e = new Fr({}), ka(e).customImagePath = r.style.image;
  else if (t === "text")
    e = new pe({});
  else if (t === "group")
    e = new Ct();
  else if (t === "compoundPath") {
    var n = r.shape;
    if (!n || !n.paths) {
      var o = "";
      process.env.NODE_ENV !== "production" && (o = "shape.paths must be specified in compoundPath"), we(o);
    }
    var s = rt(n.paths, function(c) {
      if (c.type === "path")
        return sh(c.shape.pathData, c, null);
      var f = Ov(c.type);
      if (!f) {
        var h = "";
        process.env.NODE_ENV !== "production" && (h = 'graphic type "' + t + '" can not be found.'), we(h);
      }
      return new f();
    });
    e = new am({
      shape: {
        paths: s
      }
    });
  } else {
    var l = Ov(t);
    if (!l) {
      var o = "";
      process.env.NODE_ENV !== "production" && (o = 'graphic type "' + t + '" can not be found.'), we(o);
    }
    e = new l();
  }
  return ka(e).customGraphicType = t, e.name = r.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e;
}
function hw(r, t, e, n, i, a, o) {
  aV(t);
  var s = i && i.normal.cfg;
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = Nnt);
  var l = n && n.style;
  if (l) {
    if (t.type === "text") {
      var u = l;
      _t(u, "textFill") && (u.fill = u.textFill), _t(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, f = mg(t) ? l.decal : null;
    r && f && (f.dirty = !0, c = oc(f, r)), l.__decalPattern = c;
  }
  if (US(t) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  iv(t, n, a, {
    dataIndex: e,
    isInit: o,
    clearStyle: !0
  }), gg(t, n.keyframeAnimation, a);
}
function oV(r, t, e, n, i) {
  var a = t.isGroup ? null : t, o = i && i[r].cfg;
  if (a) {
    var s = a.ensureState(r);
    if (n === !1) {
      var l = a.getState(r);
      l && (l.style = null);
    } else
      s.style = n || null;
    o && (s.textConfig = o), gl(a);
  }
}
function Vnt(r, t, e) {
  if (!r.isGroup) {
    var n = r, i = e.currentZ, a = e.currentZLevel;
    n.z = i, n.zlevel = a;
    var o = t.z2;
    o != null && (n.z2 = o || 0);
    for (var s = 0; s < Zo.length; s++)
      Fnt(n, t, Zo[s]);
  }
}
function Fnt(r, t, e) {
  var n = e === Co, i = n ? t : yg(t, e), a = i ? i.z2 : null, o;
  a != null && (o = n ? r : r.ensureState(e), o.z2 = a || 0);
}
function ZL(r, t, e, n) {
  var i = r.get("renderItem");
  if (typeof i == "string") {
    var a = ZY(i);
    a ? i = a : process.env.NODE_ENV !== "production" && console.warn("Custom series renderItem '" + i + `' not found.
                Call 'echarts.registerCustomSeries' to register it.`);
  }
  var o = r.coordinateSystem, s = {};
  o && (process.env.NODE_ENV !== "production" && (St(i, "series.render is required."), St(o.prepareCustoms || $L[o.type], "This coordSys does not support custom series.")), s = o.prepareCustoms ? o.prepareCustoms(o) : $L[o.type](o));
  for (var l = Bt({
    getWidth: n.getWidth,
    getHeight: n.getHeight,
    getZr: n.getZr,
    getDevicePixelRatio: n.getDevicePixelRatio,
    value: b,
    style: w,
    ordinalRawValue: S,
    styleEmphasis: A,
    visual: C,
    barLayout: R,
    currentSeriesIndices: E,
    font: D
  }, s.api || {}), u = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: r.id,
    seriesName: r.name,
    seriesIndex: r.seriesIndex,
    coordSys: s.coordSys,
    dataInsideLength: t.count(),
    encode: znt(r.getData()),
    itemPayload: r.get("itemPayload") || {}
  }, c, f, h = {}, d = {}, p = {}, g = {}, v = 0; v < Zo.length; v++) {
    var m = Zo[v];
    p[m] = r.getModel(p_[m]), g[m] = r.getModel(v_[m]);
  }
  function y(I) {
    return I === c ? f || (f = t.getItemModel(I)) : t.getItemModel(I);
  }
  function _(I, P) {
    return t.hasItemOption ? I === c ? h[P] || (h[P] = y(I).getModel(p_[P])) : y(I).getModel(p_[P]) : p[P];
  }
  function x(I, P) {
    return t.hasItemOption ? I === c ? d[P] || (d[P] = y(I).getModel(v_[P])) : y(I).getModel(v_[P]) : g[P];
  }
  return function(I, P) {
    return c = I, f = null, h = {}, d = {}, i && i(Bt({
      dataIndexInside: I,
      dataIndex: t.getRawIndex(I),
      // Can be used for optimization when zoom or roam.
      actionType: P ? P.type : null
    }, u), l);
  };
  function b(I, P) {
    return P == null && (P = c), t.getStore().get(t.getDimensionIndex(I || 0), P);
  }
  function S(I, P) {
    P == null && (P = c), I = I || 0;
    var O = t.getDimensionInfo(I);
    if (!O) {
      var N = t.getDimensionIndex(I);
      return N >= 0 ? t.getStore().get(N, P) : void 0;
    }
    var B = t.get(O.name, P), F = O && O.ordinalMeta;
    return F ? F.categories[B] : B;
  }
  function w(I, P) {
    process.env.NODE_ENV !== "production" && HL("api.style", "Please write literal style directly instead."), P == null && (P = c);
    var O = t.getItemVisual(P, "style"), N = O && O.fill, B = O && O.opacity, F = _(P, Co).getItemStyle();
    N != null && (F.fill = N), B != null && (F.opacity = B);
    var G = {
      inheritColor: pt(N) ? N : X.color.neutral99
    }, W = x(P, Co), J = Oe(W, null, G, !1, !0);
    J.text = W.getShallow("show") ? bt(r.getFormattedLabel(P, Co), cc(t, P)) : null;
    var U = kv(W, G, !1);
    return M(I, F), F = UL(F, J, U), I && T(F, I), F.legacy = !0, F;
  }
  function A(I, P) {
    process.env.NODE_ENV !== "production" && HL("api.styleEmphasis", "Please write literal style directly instead."), P == null && (P = c);
    var O = _(P, Ba).getItemStyle(), N = x(P, Ba), B = Oe(N, null, null, !0, !0);
    B.text = N.getShallow("show") ? un(r.getFormattedLabel(P, Ba), r.getFormattedLabel(P, Co), cc(t, P)) : null;
    var F = kv(N, null, !0);
    return M(I, O), O = UL(O, B, F), I && T(O, I), O.legacy = !0, O;
  }
  function T(I, P) {
    for (var O in P)
      _t(P, O) && (I[O] = P[O]);
  }
  function M(I, P) {
    I && (I.textFill && (P.textFill = I.textFill), I.textPosition && (P.textPosition = I.textPosition));
  }
  function C(I, P) {
    if (P == null && (P = c), _t(VL, I)) {
      var O = t.getItemVisual(P, "style");
      return O ? O[VL[I]] : null;
    }
    if (_t(hnt, I))
      return t.getItemVisual(P, I);
  }
  function R(I) {
    if (o.type === "cartesian2d") {
      var P = o.getBaseAxis();
      return Z$(Bt({
        axis: P
      }, I));
    }
  }
  function E() {
    return e.getCurrentSeriesIndices();
  }
  function D(I) {
    return Y1(I, e);
  }
}
function znt(r) {
  var t = {};
  return L(r.dimensions, function(e) {
    var n = r.getDimensionInfo(e);
    if (!n.isExtraCoord) {
      var i = n.coordDim, a = t[i] = t[i] || [];
      a[n.coordDimIndex] = r.getDimensionIndex(e);
    }
  }), t;
}
function g_(r, t, e, n, i, a, o) {
  if (!n) {
    a.remove(t);
    return;
  }
  var s = dw(r, t, e, n, i, a);
  return s && o.setItemGraphicEl(e, s), s && He(s, n.focus, n.blurScope, n.emphasisDisabled), s;
}
function dw(r, t, e, n, i, a) {
  process.env.NODE_ENV !== "production" && St(n, "should not have an null/undefined element setting");
  var o = -1, s = t;
  t && sV(t, n, i) && (o = Zt(a.childrenRef(), t), t = null);
  var l = !t, u = t;
  u ? u.clearStates() : (u = fw(n), s && knt(s, u)), n.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), n.tooltipDisabled && (u.tooltipDisabled = !0), Xn.normal.cfg = Xn.normal.conOpt = Xn.emphasis.cfg = Xn.emphasis.conOpt = Xn.blur.cfg = Xn.blur.conOpt = Xn.select.cfg = Xn.select.conOpt = null, Xn.isLegacy = !1, Gnt(u, e, n, i, l, Xn), Unt(u, e, n, i, l), hw(r, u, e, n, Xn, i, l), _t(n, "info") && (ka(u).info = n.info);
  for (var c = 0; c < Zo.length; c++) {
    var f = Zo[c];
    if (f !== Co) {
      var h = yg(n, f), d = pw(n, h, f);
      oV(f, u, h, d, Xn);
    }
  }
  return Vnt(u, n, i), n.type === "group" && Hnt(r, u, e, n, i), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
}
function sV(r, t, e) {
  var n = ka(r), i = t.type, a = t.shape, o = t.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    e.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && $nt(a) && lV(a) !== n.customPathData || i === "image" && _t(o, "image") && o.image !== n.customImagePath
  );
}
function Unt(r, t, e, n, i) {
  var a = e.clipPath;
  if (a === !1)
    r && r.getClipPath() && r.removeClipPath();
  else if (a) {
    var o = r.getClipPath();
    o && sV(o, a, n) && (o = null), o || (o = fw(a), process.env.NODE_ENV !== "production" && St(mg(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), r.setClipPath(o)), hw(null, o, t, a, null, n, i);
  }
}
function Gnt(r, t, e, n, i, a) {
  if (!(r.isGroup || r.type === "compoundPath")) {
    qL(e, null, a), qL(e, Ba, a);
    var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
    if (o != null || s != null || u != null || l != null) {
      var c = r.getTextContent();
      if (o === !1)
        c && r.removeTextContent();
      else {
        o = a.normal.conOpt = o || {
          type: "text"
        }, c ? c.clearStates() : (c = fw(o), r.setTextContent(c)), hw(null, c, t, o, null, n, i);
        for (var f = o && o.style, h = 0; h < Zo.length; h++) {
          var d = Zo[h];
          if (d !== Co) {
            var p = a[d].conOpt;
            oV(d, c, p, pw(o, p, d), null);
          }
        }
        f ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function qL(r, t, e) {
  var n = t ? yg(r, t) : r, i = t ? pw(r, n, Ba) : r.style, a = r.type, o = n ? n.textConfig : null, s = r.textContent, l = s ? t ? yg(s, t) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (e.isLegacy || QB(i, a, !!o, !!l))) {
    e.isLegacy = !0;
    var u = tV(i, a, !t);
    !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!t && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && St(c.type === "text", 'textContent.type must be "text"');
  }
  var f = t ? e[t] : e.normal;
  f.cfg = o, f.conOpt = l;
}
function yg(r, t) {
  return t ? r ? r[t] : null : r;
}
function pw(r, t, e) {
  var n = t && t.style;
  return n == null && e === Ba && r && (n = r.styleEmphasis), n;
}
function Hnt(r, t, e, n, i) {
  var a = n.children, o = a ? a.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === !1;
  if (!(!o && !l && !u)) {
    if (l) {
      Xnt({
        api: r,
        oldChildren: t.children() || [],
        newChildren: a || [],
        dataIndex: e,
        seriesModel: i,
        group: t
      });
      return;
    }
    u && t.removeAll();
    for (var c = 0; c < o; c++) {
      var f = a[c], h = t.childAt(c);
      f ? (f.ignore == null && (f.ignore = !1), dw(r, h, e, f, i, t)) : (process.env.NODE_ENV !== "production" && St(h, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), h.ignore = !0);
    }
    for (var d = t.childCount() - 1; d >= c; d--) {
      var p = t.childAt(d);
      Wnt(t, p, i);
    }
  }
}
function Wnt(r, t, e) {
  t && Tm(t, ka(r).option, e);
}
function Xnt(r) {
  new Ya(r.oldChildren, r.newChildren, KL, KL, r).add(jL).update(jL).remove(Ynt).execute();
}
function KL(r, t) {
  var e = r && r.name;
  return e ?? Ont + t;
}
function jL(r, t) {
  var e = this.context, n = r != null ? e.newChildren[r] : null, i = t != null ? e.oldChildren[t] : null;
  dw(e.api, i, e.dataIndex, n, e.seriesModel, e.group);
}
function Ynt(r) {
  var t = this.context, e = t.oldChildren[r];
  e && Tm(e, ka(e).option, t.seriesModel);
}
function lV(r) {
  return r && (r.pathData || r.d);
}
function $nt(r) {
  return r && (_t(r, "pathData") || _t(r, "d"));
}
function Znt(r) {
  r.registerChartView(Bnt), r.registerSeriesModel(dnt);
}
var Xs = ee(), JL = Dt, m_ = gt, vw = (
  /** @class */
  function() {
    function r() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return r.prototype.render = function(t, e, n, i) {
      var a = e.get("value"), o = e.get("status");
      if (this._axisModel = t, this._axisPointerModel = e, this._api = n, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, e, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var f = this._moveAnimation = this.determineAnimation(t, e);
        if (!s)
          s = this._group = new Ct(), this.createPointerEl(s, u, t, e), this.createLabelEl(s, u, t, e), n.getZr().add(s);
        else {
          var h = Yt(QL, e, f);
          this.updatePointerEl(s, u, h), this.updateLabelEl(s, u, h, e);
        }
        e2(s, e, !0), this._renderHandle(a);
      }
    }, r.prototype.remove = function(t) {
      this.clear(t);
    }, r.prototype.dispose = function(t) {
      this.clear(t);
    }, r.prototype.determineAnimation = function(t, e) {
      var n = e.get("animation"), i = t.axis, a = i.type === "category", o = e.get("snap");
      if (!o && !a)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s)
          return !0;
        if (o) {
          var l = kb(t).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, r.prototype.makeElOption = function(t, e, n, i, a) {
    }, r.prototype.createPointerEl = function(t, e, n, i) {
      var a = e.pointer;
      if (a) {
        var o = Xs(t).pointerEl = new El[a.type](JL(e.pointer));
        t.add(o);
      }
    }, r.prototype.createLabelEl = function(t, e, n, i) {
      if (e.label) {
        var a = Xs(t).labelEl = new pe(JL(e.label));
        t.add(a), t2(a, i);
      }
    }, r.prototype.updatePointerEl = function(t, e, n) {
      var i = Xs(t).pointerEl;
      i && e.pointer && (i.setStyle(e.pointer.style), n(i, {
        shape: e.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(t, e, n, i) {
      var a = Xs(t).labelEl;
      a && (a.setStyle(e.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: e.label.x,
        y: e.label.y
      }), t2(a, i));
    }, r.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var e = this._axisPointerModel, n = this._api.getZr(), i = this._handle, a = e.getModel("handle"), o = e.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = Fh(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Ga(u.event);
          },
          onmousedown: m_(this._onHandleDragMove, this, 0, 0),
          drift: m_(this._onHandleDragMove, this),
          ondragend: m_(this._onHandleDragEnd, this)
        }), n.add(i)), e2(i, e, !1), i.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        et(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Lc(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, r.prototype._moveHandleToValue = function(t, e) {
      QL(this._axisPointerModel, !e && this._moveAnimation, this._handle, y_(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(t, e) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var i = this.updateHandleTransform(y_(n), [t, e], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(y_(i)), Xs(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var e = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: e.cursorPoint[0],
          y: e.cursorPoint[1],
          tooltipOption: e.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var e = this._axisPointerModel.get("value");
        this._moveHandleToValue(e), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var e = t.getZr(), n = this._group, i = this._handle;
      e && n && (this._lastGraphicKey = null, n && e.remove(n), i && e.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), fh(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(t, e, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: e[n],
        height: e[1 - n]
      };
    }, r;
  }()
);
function QL(r, t, e, n) {
  uV(Xs(e).lastProp, n) || (Xs(e).lastProp = n, t ? ve(e, n, r) : (e.stopAnimation(), e.attr(n)));
}
function uV(r, t) {
  if (Lt(r) && Lt(t)) {
    var e = !0;
    return L(t, function(n, i) {
      e = e && uV(r[i], n);
    }), !!e;
  } else
    return r === t;
}
function t2(r, t) {
  r[t.get(["label", "show"]) ? "show" : "hide"]();
}
function y_(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0
  };
}
function e2(r, t, e) {
  var n = t.get("z"), i = t.get("zlevel");
  r && r.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), i != null && (a.zlevel = i), a.silent = e);
  });
}
function gw(r) {
  var t = r.get("type"), e = r.getModel(t + "Style"), n;
  return t === "line" ? (n = e.getLineStyle(), n.fill = null) : t === "shadow" && (n = e.getAreaStyle(), n.stroke = null), n;
}
function cV(r, t, e, n, i) {
  var a = e.get("value"), o = fV(a, t.axis, t.ecModel, e.get("seriesDataIndices"), {
    precision: e.get(["label", "precision"]),
    formatter: e.get(["label", "formatter"])
  }), s = e.getModel("label"), l = zh(s.get("padding") || 0), u = s.getFont(), c = Xg(o, u), f = i.position, h = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
  p === "right" && (f[0] -= h), p === "center" && (f[0] -= h / 2);
  var g = i.verticalAlign;
  g === "bottom" && (f[1] -= d), g === "middle" && (f[1] -= d / 2), qnt(f, h, d, n);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = t.get(["axisLine", "lineStyle", "color"])), r.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: f[0],
    y: f[1],
    style: Oe(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function qnt(r, t, e, n) {
  var i = n.getWidth(), a = n.getHeight();
  r[0] = Math.min(r[0] + t, i) - t, r[1] = Math.min(r[1] + e, a) - e, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
}
function fV(r, t, e, n, i) {
  r = t.scale.parse(r);
  var a = t.scale.getLabel({
    value: r
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), o = i.formatter;
  if (o) {
    var s = {
      value: jv(t, {
        value: r
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    L(n, function(l) {
      var u = e.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, f = u && u.getDataParams(c);
      f && s.seriesData.push(f);
    }), pt(o) ? a = o.replace("{value}", a) : At(o) && (a = o(s));
  }
  return a;
}
function mw(r, t, e) {
  var n = Br();
  return Ko(n, n, e.rotation), na(n, n, e.position), _i([r.dataToCoord(t), (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0)], n);
}
function hV(r, t, e, n, i, a) {
  var o = fn.innerTextLayout(e.rotation, 0, e.labelDirection);
  e.labelMargin = i.get(["label", "margin"]), cV(t, n, i, a, {
    position: mw(n.axis, r, e),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function yw(r, t, e) {
  return e = e || 0, {
    x1: r[e],
    y1: r[1 - e],
    x2: t[e],
    y2: t[1 - e]
  };
}
function dV(r, t, e) {
  return e = e || 0, {
    x: r[e],
    y: r[1 - e],
    width: t[e],
    height: t[1 - e]
  };
}
function r2(r, t, e, n, i, a) {
  return {
    cx: r,
    cy: t,
    r0: e,
    r: n,
    startAngle: i,
    endAngle: a,
    clockwise: !0
  };
}
var Knt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), c = n2(l, s).getOtherAxis(s).getGlobalExtent(), f = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var h = gw(a), d = jnt[u](s, f, c);
        d.style = h, e.graphicKey = d.type, e.pointer = d;
      }
      var p = sg(l.getRect(), i);
      hV(n, e, p, i, a, o);
    }, t.prototype.getHandleTransform = function(e, n, i) {
      var a = sg(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = mw(n.axis, e, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, n, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(!0), u = n2(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, f = [e.x, e.y];
      f[c] += n[c], f[c] = Math.min(l[1], f[c]), f[c] = Math.max(l[0], f[c]);
      var h = (u[1] + u[0]) / 2, d = [h, h];
      d[c] = f[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: f[0],
        y: f[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, t;
  }(vw)
);
function n2(r, t) {
  var e = {};
  return e[t.dim + "AxisIndex"] = t.index, r.getCartesian(e);
}
var jnt = {
  line: function(r, t, e) {
    var n = yw([t, e[0]], [t, e[1]], i2(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(r, t, e) {
    var n = Math.max(1, r.getBandWidth()), i = e[1] - e[0];
    return {
      type: "Rect",
      shape: dV([t - n / 2, e[0]], [n, i], i2(r))
    };
  }
};
function i2(r) {
  return r.dim === "x" ? 0 : 1;
}
var Jnt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: X.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: X.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: X.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: X.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: X.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  }(re)
), Ra = ee(), Qnt = L;
function pV(r, t, e) {
  if (!oe.node) {
    var n = t.getZr();
    Ra(n).records || (Ra(n).records = {}), tit(n, t);
    var i = Ra(n).records[r] || (Ra(n).records[r] = {});
    i.handler = e;
  }
}
function tit(r, t) {
  if (Ra(r).initialized)
    return;
  Ra(r).initialized = !0, e("click", Yt(a2, "click")), e("mousemove", Yt(a2, "mousemove")), e("globalout", rit);
  function e(n, i) {
    r.on(n, function(a) {
      var o = nit(t);
      Qnt(Ra(r).records, function(s) {
        s && i(s, a, o.dispatchAction);
      }), eit(o.pendings, t);
    });
  }
}
function eit(r, t) {
  var e = r.showTip.length, n = r.hideTip.length, i;
  e ? i = r.showTip[e - 1] : n && (i = r.hideTip[n - 1]), i && (i.dispatchAction = null, t.dispatchAction(i));
}
function rit(r, t, e) {
  r.handler("leave", null, e);
}
function a2(r, t, e, n) {
  t.handler(r, e, n);
}
function nit(r) {
  var t = {
    showTip: [],
    hideTip: []
  }, e = function(n) {
    var i = t[n.type];
    i ? i.push(n) : (n.dispatchAction = e, r.dispatchAction(n));
  };
  return {
    dispatchAction: e,
    pendings: t
  };
}
function GS(r, t) {
  if (!oe.node) {
    var e = t.getZr(), n = (Ra(e).records || {})[r];
    n && (Ra(e).records[r] = null);
  }
}
var iit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = n.getComponent("tooltip"), o = e.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      pV("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(e, n) {
      GS("axisPointer", n);
    }, t.prototype.dispose = function(e, n) {
      GS("axisPointer", n);
    }, t.type = "axisPointer", t;
  }(Ge)
);
function vV(r, t) {
  var e = [], n = r.seriesIndex, i;
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = i.getData(), o = pl(a, r);
  if (o == null || o < 0 || et(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    e = i.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), f = c.dim, h = u.dim, d = f === "x" || f === "radius" ? 1 : 0, p = a.mapDimension(h), g = [];
      g[d] = a.get(p, o), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), e = l.dataToPoint(g) || [];
    } else
      e = l.dataToPoint(a.getValues(rt(l.dimensions, function(m) {
        return a.mapDimension(m);
      }), o)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), e = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: e,
    el: s
  };
}
var o2 = ee();
function ait(r, t, e) {
  var n = r.currTrigger, i = [r.x, r.y], a = r, o = r.dispatchAction || gt(e.dispatchAction, e), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    av(i) && (i = vV({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = av(i), u = a.axesInfo, c = s.axesInfo, f = n === "leave" || av(i), h = {}, d = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: Yt(sit, d),
      showTooltip: Yt(lit, p)
    };
    L(s.coordSysMap, function(m, y) {
      var _ = l || m.containPoint(i);
      L(s.coordSysAxesInfo[y], function(x, b) {
        var S = x.axis, w = hit(u, x);
        if (!f && _ && (!u || w)) {
          var A = w && w.value;
          A == null && !l && (A = S.pointToData(i)), A != null && s2(x, A, g, !1, h);
        }
      });
    });
    var v = {};
    return L(c, function(m, y) {
      var _ = m.linkGroup;
      _ && !d[y] && L(_.axesInfo, function(x, b) {
        var S = d[b];
        if (x !== m && S) {
          var w = S.value;
          _.mapper && (w = m.axis.scale.parse(_.mapper(w, l2(x), l2(m)))), v[m.key] = w;
        }
      });
    }), L(v, function(m, y) {
      s2(c[y], m, g, !0, h);
    }), uit(d, c, h), cit(p, i, r, o), fit(c, o, e), h;
  }
}
function s2(r, t, e, n, i) {
  var a = r.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!r.involveSeries) {
      e.showPointer(r, t);
      return;
    }
    var o = oit(t, r), s = o.payloadBatch, l = o.snapToValue;
    s[0] && i.seriesIndex == null && j(i, s[0]), !n && r.snap && a.containData(l) && l != null && (t = l), e.showPointer(r, t, s), e.showTooltip(r, o, l);
  }
}
function oit(r, t) {
  var e = t.axis, n = e.dim, i = r, a = [], o = Number.MAX_VALUE, s = -1;
  return L(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), f, h;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(c, r, e);
      h = d.dataIndices, f = d.nestestValue;
    } else {
      if (h = l.indicesOfNearest(
        n,
        c[0],
        r,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        e.type === "category" ? 0.5 : null
      ), !h.length)
        return;
      f = l.getData().get(c[0], h[0]);
    }
    if (!(f == null || !isFinite(f))) {
      var p = r - f, g = Math.abs(p);
      g <= o && ((g < o || p >= 0 && s < 0) && (o = g, s = p, i = f, a.length = 0), L(h, function(v) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: i
  };
}
function sit(r, t, e, n) {
  r[t.key] = {
    value: e,
    payloadBatch: n
  };
}
function lit(r, t, e, n) {
  var i = e.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model, u = xh(l), c = r.map[u];
    c || (c = r.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, r.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function uit(r, t, e) {
  var n = e.axesInfo = [];
  L(t, function(i, a) {
    var o = i.axisPointerModel.option, s = r[a];
    s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && n.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: o.value
    });
  });
}
function cit(r, t, e, n) {
  if (av(t) || !r.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: e.tooltipOption,
    position: e.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: r.list
  });
}
function fit(r, t, e) {
  var n = e.getZr(), i = "axisPointerLastHighlights", a = o2(n)[i] || {}, o = o2(n)[i] = {};
  L(r, function(u, c) {
    var f = u.axisPointerModel.option;
    f.status === "show" && u.triggerEmphasis && L(f.seriesDataIndices, function(h) {
      var d = h.seriesIndex + " | " + h.dataIndex;
      o[d] = h;
    });
  });
  var s = [], l = [];
  L(a, function(u, c) {
    !o[c] && l.push(u);
  }), L(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && e.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && e.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function hit(r, t) {
  for (var e = 0; e < (r || []).length; e++) {
    var n = r[e];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function l2(r) {
  var t = r.axis.model, e = {}, n = e.axisDim = r.axis.dim;
  return e.axisIndex = e[n + "AxisIndex"] = t.componentIndex, e.axisName = e[n + "AxisName"] = t.name, e.axisId = e[n + "AxisId"] = t.id, e;
}
function av(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
}
function Kh(r) {
  Il.registerAxisPointerClass("CartesianAxisPointer", Knt), r.registerComponentModel(Jnt), r.registerComponentView(iit), r.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var e = t.axisPointer.link;
      e && !et(e) && (t.axisPointer.link = [e]);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
    t.getComponent("axisPointer").coordSysAxesInfo = hj(t, e);
  }), r.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, ait);
}
function dit(r) {
  jt(V3), jt(Kh);
}
var pit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), f = s.dataToCoord(n), h = a.get("type");
      if (h && h !== "none") {
        var d = gw(a), p = git[h](s, l, f, c);
        p.style = d, e.graphicKey = p.type, e.pointer = p;
      }
      var g = a.get(["label", "margin"]), v = vit(n, i, a, l, g);
      cV(e, i, a, o, v);
    }, t;
  }(vw)
);
function vit(r, t, e, n, i) {
  var a = t.axis, o = a.dataToCoord(r), s = n.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = n.getRadiusAxis().getExtent(), u, c, f;
  if (a.dim === "radius") {
    var h = Br();
    Ko(h, h, s), na(h, h, [n.cx, n.cy]), u = _i([o, -i], h);
    var d = t.getModel("axisLabel").get("rotate") || 0, p = fn.innerTextLayout(s, d * Math.PI / 180, -1);
    c = p.textAlign, f = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = n.coordToPoint([g + i, o]);
    var v = n.cx, m = n.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", f = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: f
  };
}
var git = {
  line: function(r, t, e, n) {
    return r.dim === "angle" ? {
      type: "Line",
      shape: yw(t.coordToPoint([n[0], e]), t.coordToPoint([n[1], e]))
    } : {
      type: "Circle",
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: e
      }
    };
  },
  shadow: function(r, t, e, n) {
    var i = Math.max(1, r.getBandWidth()), a = Math.PI / 180;
    return r.dim === "angle" ? {
      type: "Sector",
      shape: r2(
        t.cx,
        t.cy,
        n[0],
        n[1],
        // In ECharts y is negative if angle is positive
        (-e - i / 2) * a,
        (-e + i / 2) * a
      )
    } : {
      type: "Sector",
      shape: r2(t.cx, t.cy, e - i / 2, e + i / 2, 0, Math.PI * 2)
    };
  }
}, mit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.findAxisModel = function(e) {
      var n, i = this.ecModel;
      return i.eachComponent(e, function(a) {
        a.getCoordSysModel() === this && (n = a);
      }, this), n;
    }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, t;
  }(re)
), _w = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", je).models[0];
    }, t.type = "polarAxis", t;
  }(re)
);
dr(_w, Wh);
var yit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "angleAxis", t;
  }(_w)
), _it = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "radiusAxis", t;
  }(_w)
), xw = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      return r.call(this, "radius", e, n) || this;
    }
    return t.prototype.pointToData = function(e, n) {
      return this.polar.pointToData(e, n)[this.dim === "radius" ? 0 : 1];
    }, t;
  }(Ei)
);
xw.prototype.dataToRadius = Ei.prototype.dataToCoord;
xw.prototype.radiusToData = Ei.prototype.coordToData;
var xit = ee(), Sw = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n) {
      return r.call(this, "angle", e, n || [0, 360]) || this;
    }
    return t.prototype.pointToData = function(e, n) {
      return this.polar.pointToData(e, n)[this.dim === "radius" ? 0 : 1];
    }, t.prototype.calculateCategoryInterval = function() {
      var e = this, n = e.getLabelModel(), i = e.scale, a = i.getExtent(), o = i.count();
      if (a[1] - a[0] < 1)
        return 0;
      var s = a[0], l = e.dataToCoord(s + 1) - e.dataToCoord(s), u = Math.abs(l), c = Xg(s == null ? "" : s + "", n.getFont(), "center", "top"), f = Math.max(c.height, 7), h = f / u;
      isNaN(h) && (h = 1 / 0);
      var d = Math.max(0, Math.floor(h)), p = xit(e.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - o) <= 1 && g > d ? d = g : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, t;
  }(Ei)
);
Sw.prototype.dataToAngle = Ei.prototype.dataToCoord;
Sw.prototype.angleToData = Ei.prototype.coordToData;
var gV = ["radius", "angle"], Sit = (
  /** @class */
  function() {
    function r(t) {
      this.dimensions = gV, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new xw(), this._angleAxis = new Sw(), this.axisPointerEnabled = !0, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return r.prototype.containPoint = function(t) {
      var e = this.pointToCoord(t);
      return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
    }, r.prototype.containData = function(t) {
      return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
    }, r.prototype.getAxis = function(t) {
      var e = "_" + t + "Axis";
      return this[e];
    }, r.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, r.prototype.getAxesByScale = function(t) {
      var e = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === t && e.push(n), i.scale.type === t && e.push(i), e;
    }, r.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, r.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, r.prototype.getOtherAxis = function(t) {
      var e = this._angleAxis;
      return t === e ? this._radiusAxis : e;
    }, r.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, r.prototype.getTooltipAxes = function(t) {
      var e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
      return {
        baseAxes: [e],
        otherAxes: [this.getOtherAxis(e)]
      };
    }, r.prototype.dataToPoint = function(t, e, n) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)], n);
    }, r.prototype.pointToData = function(t, e, n) {
      n = n || [];
      var i = this.pointToCoord(t);
      return n[0] = this._radiusAxis.radiusToData(i[0], e), n[1] = this._angleAxis.angleToData(i[1], e), n;
    }, r.prototype.pointToCoord = function(t) {
      var e = t[0] - this.cx, n = t[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      i.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(e * e + n * n);
      e /= l, n /= l;
      for (var u = Math.atan2(-n, e) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; )
        u += c * 360;
      return [l, u];
    }, r.prototype.coordToPoint = function(t, e) {
      e = e || [];
      var n = t[0], i = t[1] / 180 * Math.PI;
      return e[0] = Math.cos(i) * n + this.cx, e[1] = -Math.sin(i) * n + this.cy, e;
    }, r.prototype.getArea = function() {
      var t = this.getAngleAxis(), e = this.getRadiusAxis(), n = e.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = t.getExtent(), a = Math.PI / 180, o = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: t.inverse,
        contain: function(s, l) {
          var u = s - this.cx, c = l - this.cy, f = u * u + c * c, h = this.r, d = this.r0;
          return h !== d && f - o <= h * h && f + o >= d * d;
        },
        // As the bounding box
        x: this.cx - n[1],
        y: this.cy - n[1],
        width: n[1] * 2,
        height: n[1] * 2
      };
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = u2(e);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = u2(e);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }()
);
function u2(r) {
  var t = r.seriesModel, e = r.polarModel;
  return e && e.coordinateSystem || t && t.coordinateSystem;
}
function bit(r, t, e) {
  var n = t.get("center"), i = Sr(t, e).refContainer;
  r.cx = dt(n[0], i.width) + i.x, r.cy = dt(n[1], i.height) + i.y;
  var a = r.getRadiusAxis(), o = Math.min(i.width, i.height) / 2, s = t.get("radius");
  s == null ? s = [0, "100%"] : et(s) || (s = [0, s]);
  var l = [dt(s[0], o), dt(s[1], o)];
  a.inverse ? a.setExtent(l[1], l[0]) : a.setExtent(l[0], l[1]);
}
function wit(r, t) {
  var e = this, n = e.getAngleAxis(), i = e.getRadiusAxis();
  if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), r.eachSeries(function(s) {
    if (s.coordinateSystem === e) {
      var l = s.getData();
      L(Jv(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), L(Jv(l, "angle"), function(u) {
        n.scale.unionExtentFromData(l, u);
      });
    }
  }), lc(n.scale, n.model), lc(i.scale, i.model), n.type === "category" && !n.onBand) {
    var a = n.getExtent(), o = 360 / n.scale.count();
    n.inverse ? a[1] += o : a[1] -= o, n.setExtent(a[0], a[1]);
  }
}
function Mit(r) {
  return r.mainType === "angleAxis";
}
function c2(r, t) {
  var e;
  if (r.type = t.get("type"), r.scale = vm(t), r.onBand = t.get("boundaryGap") && r.type === "category", r.inverse = t.get("inverse"), Mit(t)) {
    r.inverse = r.inverse !== t.get("clockwise");
    var n = t.get("startAngle"), i = (e = t.get("endAngle")) !== null && e !== void 0 ? e : n + (r.inverse ? -360 : 360);
    r.setExtent(n, i);
  }
  t.axis = r, r.model = t;
}
var Tit = {
  dimensions: gV,
  create: function(r, t) {
    var e = [];
    return r.eachComponent("polar", function(n, i) {
      var a = new Sit(i + "");
      a.update = wit;
      var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
      c2(o, l), c2(s, u), bit(a, n, t), e.push(a), n.coordinateSystem = a, a.model = n;
    }), r.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "polar") {
        var i = n.getReferringComponents("polar", je).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + mr(n.get("polarIndex"), n.get("polarId"), 0) + '" not found');
        n.coordinateSystem = i.coordinateSystem;
      }
    }), e;
  }
}, Ait = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function wp(r, t, e) {
  t[1] > t[0] && (t = t.slice().reverse());
  var n = r.coordToPoint([t[0], e]), i = r.coordToPoint([t[1], e]);
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1]
  };
}
function Mp(r) {
  var t = r.getRadiusAxis();
  return t.inverse ? 0 : 1;
}
function f2(r) {
  var t = r[0], e = r[r.length - 1];
  t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && r.pop();
}
var Eit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, n) {
      if (this.group.removeAll(), !!e.get("show")) {
        var i = e.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords({
          breakTicks: "none"
        }), l = i.getMinorTicksCoords(), u = rt(i.getViewLabels(), function(c) {
          c = Dt(c);
          var f = i.scale, h = f.type === "ordinal" ? f.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(h), c;
        });
        f2(u), f2(s), L(Ait, function(c) {
          e.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && Cit[c](this.group, e, a, s, l, o, u);
        }, this);
      }
    }, t.type = "angleAxis", t;
  }(Il)
), Cit = {
  axisLine: function(r, t, e, n, i, a) {
    var o = t.getModel(["axisLine", "lineStyle"]), s = e.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = Mp(e), f = c ? 0 : 1, h, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    a[f] === 0 ? h = new El[d]({
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: a[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }) : h = new kh({
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: a[c],
        r0: a[f]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }), h.style.fill = null, r.add(h);
  },
  axisTick: function(r, t, e, n, i, a) {
    var o = t.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[Mp(e)], u = rt(n, function(c) {
      return new lr({
        shape: wp(e, [l, l + s], c.coord)
      });
    });
    r.add(Qn(u, {
      style: Bt(o.getModel("lineStyle").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(r, t, e, n, i, a) {
    if (i.length) {
      for (var o = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[Mp(e)], c = [], f = 0; f < i.length; f++)
        for (var h = 0; h < i[f].length; h++)
          c.push(new lr({
            shape: wp(e, [u, u + l], i[f][h].coord)
          }));
      r.add(Qn(c, {
        style: Bt(s.getModel("lineStyle").getLineStyle(), Bt(o.getLineStyle(), {
          stroke: t.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(r, t, e, n, i, a, o) {
    var s = t.getCategories(!0), l = t.getModel("axisLabel"), u = l.get("margin"), c = t.get("triggerEvent");
    L(o, function(f, h) {
      var d = l, p = f.tickValue, g = a[Mp(e)], v = e.coordToPoint([g + u, f.coord]), m = e.cx, y = e.cy, _ = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", x = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
      if (s && s[p]) {
        var b = s[p];
        Lt(b) && b.textStyle && (d = new ue(b.textStyle, l, l.ecModel));
      }
      var S = new pe({
        silent: fn.isLabelSilent(t),
        style: Oe(d, {
          x: v[0],
          y: v[1],
          fill: d.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          text: f.formattedLabel,
          align: _,
          verticalAlign: x
        })
      });
      if (r.add(S), ja({
        el: S,
        componentModel: t,
        itemName: f.formattedLabel,
        formatterParamsExtra: {
          isTruncated: function() {
            return S.isTruncated;
          },
          value: f.rawLabel,
          tickIndex: h
        }
      }), c) {
        var w = fn.makeAxisEventDataBase(t);
        w.targetType = "axisLabel", w.value = f.rawLabel, zt(S).eventData = w;
      }
    }, this);
  },
  splitLine: function(r, t, e, n, i, a) {
    var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], f = 0; f < n.length; f++) {
      var h = u++ % l.length;
      c[h] = c[h] || [], c[h].push(new lr({
        shape: wp(e, a, n[f].coord)
      }));
    }
    for (var f = 0; f < c.length; f++)
      r.add(Qn(c[f], {
        style: Bt({
          stroke: l[f % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: t.get("z")
      }));
  },
  minorSplitLine: function(r, t, e, n, i, a) {
    if (i.length) {
      for (var o = t.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new lr({
            shape: wp(e, a, i[u][c].coord)
          }));
      r.add(Qn(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: t.get("z")
      }));
    }
  },
  splitArea: function(r, t, e, n, i, a) {
    if (n.length) {
      var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], f = Math.PI / 180, h = -n[0].coord * f, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = t.get("clockwise"), v = 1, m = n.length; v <= m; v++) {
        var y = v === m ? n[0].coord : n[v].coord, _ = u++ % l.length;
        c[_] = c[_] || [], c[_].push(new jr({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r0: d,
            r: p,
            startAngle: h,
            endAngle: -y * f,
            clockwise: g
          },
          silent: !0
        })), h = -y * f;
      }
      for (var v = 0; v < c.length; v++)
        r.add(Qn(c[v], {
          style: Bt({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
}, Dit = ["splitLine", "splitArea", "minorSplitLine"], Lit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this.group.removeAll(), !!e.get("show")) {
        var a = this._axisGroup, o = this._axisGroup = new Ct();
        this.group.add(o);
        var s = e.axis, l = s.polar, u = l.getAngleAxis(), c = s.getTicksCoords(), f = s.getMinorTicksCoords(), h = u.getExtent()[0], d = s.getExtent(), p = Iit(l, e, h), g = new fn(e, i, p);
        g.build(), o.add(g.group), Vh(a, o, e), L(Dit, function(v) {
          e.get([v, "show"]) && !s.scale.isBlank() && Rit[v](this.group, e, l, h, d, c, f);
        }, this);
      }
    }, t.type = "radiusAxis", t;
  }(Il)
), Rit = {
  splitLine: function(r, t, e, n, i, a) {
    var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, c = e.getAngleAxis(), f = Math.PI / 180, h = c.getExtent(), d = Math.abs(h[1] - h[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var p = [], g = 0; g < a.length; g++) {
      var v = u++ % l.length;
      p[v] = p[v] || [], p[v].push(new El[d]({
        shape: {
          cx: e.cx,
          cy: e.cy,
          // ensure circle radius >= 0
          r: Math.max(a[g].coord, 0),
          startAngle: -h[0] * f,
          endAngle: -h[1] * f,
          clockwise: c.inverse
        }
      }));
    }
    for (var g = 0; g < p.length; g++)
      r.add(Qn(p[g], {
        style: Bt({
          stroke: l[g % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(r, t, e, n, i, a, o) {
    if (o.length) {
      for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++)
        for (var f = 0; f < o[c].length; f++)
          u.push(new Ka({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: o[c][f].coord
            }
          }));
      r.add(Qn(u, {
        style: Bt({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(r, t, e, n, i, a) {
    if (a.length) {
      var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], f = a[0].coord, h = 1; h < a.length; h++) {
        var d = u++ % l.length;
        c[d] = c[d] || [], c[d].push(new jr({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r0: f,
            r: a[h].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), f = a[h].coord;
      }
      for (var h = 0; h < c.length; h++)
        r.add(Qn(c[h], {
          style: Bt({
            fill: l[h % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function Iit(r, t, e) {
  return {
    position: [r.cx, r.cy],
    rotation: e / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
function mV(r) {
  return r.get("stack") || "__ec_stack_" + r.seriesIndex;
}
function yV(r, t) {
  return t.dim + r.model.componentIndex;
}
function Pit(r, t, e) {
  var n = {}, i = Nit(Te(t.getSeriesByType(r), function(a) {
    return !t.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
  }));
  t.eachSeriesByType(r, function(a) {
    if (a.coordinateSystem.type === "polar") {
      var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = yV(s, l), c = mV(a), f = i[u][c], h = f.offset, d = f.width, p = s.getOtherAxis(l), g = a.coordinateSystem.cx, v = a.coordinateSystem.cy, m = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
      n[c] = n[c] || [];
      for (var _ = o.mapDimension(p.dim), x = o.mapDimension(l.dim), b = Wo(
        o,
        _
        /* , baseDim */
      ), S = l.dim !== "radius" || !a.get("roundCap", !0), w = p.model, A = w.get("startValue"), T = p.dataToCoord(A || 0), M = 0, C = o.count(); M < C; M++) {
        var R = o.get(_, M), E = o.get(x, M), D = R >= 0 ? "p" : "n", I = T;
        b && (n[c][E] || (n[c][E] = {
          p: T,
          n: T
          // Negative stack
        }), I = n[c][E][D]);
        var P = void 0, O = void 0, N = void 0, B = void 0;
        if (p.dim === "radius") {
          var F = p.dataToCoord(R) - T, G = l.dataToCoord(E);
          Math.abs(F) < m && (F = (F < 0 ? -1 : 1) * m), P = I, O = I + F, N = G - h, B = N - d, b && (n[c][E][D] = O);
        } else {
          var W = p.dataToCoord(R, S) - T, J = l.dataToCoord(E);
          Math.abs(W) < y && (W = (W < 0 ? -1 : 1) * y), P = J + h, O = P + d, N = I, B = I + W, b && (n[c][E][D] = B);
        }
        o.setItemLayout(M, {
          cx: g,
          cy: v,
          r0: P,
          r: O,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -N * Math.PI / 180,
          endAngle: -B * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: N >= B
        });
      }
    }
  });
}
function Nit(r) {
  var t = {};
  L(r, function(n, i) {
    var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = yV(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), f = t[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, h = f.stacks;
    t[l] = f;
    var d = mV(n);
    h[d] || f.autoWidthCount++, h[d] = h[d] || {
      width: 0,
      maxWidth: 0
    };
    var p = dt(n.get("barWidth"), c), g = dt(n.get("barMaxWidth"), c), v = n.get("barGap"), m = n.get("barCategoryGap");
    p && !h[d].width && (p = Math.min(f.remainedWidth, p), h[d].width = p, f.remainedWidth -= p), g && (h[d].maxWidth = g), v != null && (f.gap = v), m != null && (f.categoryGap = m);
  });
  var e = {};
  return L(t, function(n, i) {
    e[i] = {};
    var a = n.stacks, o = n.bandWidth, s = dt(n.categoryGap, o), l = dt(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, f = (u - s) / (c + (c - 1) * l);
    f = Math.max(f, 0), L(a, function(g, v) {
      var m = g.maxWidth;
      m && m < f && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
    }), f = (u - s) / (c + (c - 1) * l), f = Math.max(f, 0);
    var h = 0, d;
    L(a, function(g, v) {
      g.width || (g.width = f), d = g, h += g.width * (1 + l);
    }), d && (h -= d.width * l);
    var p = -h / 2;
    L(a, function(g, v) {
      e[i][v] = e[i][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), e;
}
var Oit = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, kit = {
  splitNumber: 5
}, Bit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "polar", t;
  }(Ge)
);
function Vit(r) {
  jt(Kh), Il.registerAxisPointerClass("PolarAxisPointer", pit), r.registerCoordinateSystem("polar", Tit), r.registerComponentModel(mit), r.registerComponentView(Bit), fc(r, "angle", yit, Oit), fc(r, "radius", _it, kit), r.registerComponentView(Eit), r.registerComponentView(Lit), r.registerLayout(Yt(Pit, "bar"));
}
function HS(r, t) {
  t = t || {};
  var e = r.coordinateSystem, n = r.axis, i = {}, a = n.position, o = n.orient, s = e.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[o];
  var f = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = f[a], r.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), mr(t.labelInside, r.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var h = r.get(["axisLabel", "rotate"]);
  return i.labelRotate = a === "top" ? -h : h, i.z2 = 1, i;
}
var Fit = ["splitArea", "splitLine", "breakArea"], zit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "SingleAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Ct();
      var l = HS(e), u = new fn(e, i, l);
      u.build(), o.add(this._axisGroup), o.add(u.group), L(Fit, function(c) {
        e.get([c, "show"]) && Uit[c](this, this.group, this._axisGroup, e, i);
      }, this), Vh(s, this._axisGroup, e), r.prototype.render.call(this, e, n, i, a);
    }, t.prototype.remove = function() {
      O3(this);
    }, t.type = "singleAxis", t;
  }(Il)
), Uit = {
  splitLine: function(r, t, e, n, i) {
    var a = n.axis;
    if (!a.scale.isBlank()) {
      var o = n.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color");
      l = l instanceof Array ? l : [l];
      for (var u = s.get("width"), c = n.coordinateSystem.getRect(), f = a.isHorizontal(), h = [], d = 0, p = a.getTicksCoords({
        tickModel: o,
        breakTicks: "none",
        pruneByBreak: "preserve_extent_bound"
      }), g = [], v = [], m = 0; m < p.length; ++m) {
        var y = a.toGlobalCoord(p[m].coord);
        f ? (g[0] = y, g[1] = c.y, v[0] = y, v[1] = c.y + c.height) : (g[0] = c.x, g[1] = y, v[0] = c.x + c.width, v[1] = y);
        var _ = new lr({
          shape: {
            x1: g[0],
            y1: g[1],
            x2: v[0],
            y2: v[1]
          },
          silent: !0
        });
        ic(_.shape, u);
        var x = d++ % l.length;
        h[x] = h[x] || [], h[x].push(_);
      }
      for (var b = s.getLineStyle(["color"]), m = 0; m < h.length; ++m)
        t.add(Qn(h[m], {
          style: Bt({
            stroke: l[m % l.length]
          }, b),
          silent: !0
        }));
    }
  },
  splitArea: function(r, t, e, n, i) {
    N3(r, e, n, n);
  },
  breakArea: function(r, t, e, n, i) {
    var a = qh(), o = n.axis.scale;
    a && o.type !== "ordinal" && a.rectCoordBuildBreakAxis(t, r, n, n.coordinateSystem.getRect(), i);
  }
}, ov = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getCoordSysModel = function() {
      return this;
    }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      },
      jitter: 0,
      jitterOverlap: !0,
      jitterMargin: 2
    }, t;
  }(re)
);
dr(ov, Wh.prototype);
var Git = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.pointToData = function(e, n) {
      return this.coordinateSystem.pointToData(e)[0];
    }, t;
  }(Ei)
), _V = ["single"], Hit = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "single", this.dimension = "single", this.dimensions = _V, this.axisPointerEnabled = !0, this.model = t, this._init(t, e, n);
    }
    return r.prototype._init = function(t, e, n) {
      var i = this.dimension, a = new Git(i, vm(t), [0, 0], t.get("type"), t.get("position")), o = a.type === "category";
      a.onBand = o && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), t.axis = a, a.model = t, a.coordinateSystem = this, this._axis = a;
    }, r.prototype.update = function(t, e) {
      t.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          L(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), lc(this._axis.scale, this._axis.model);
        }
      }, this);
    }, r.prototype.resize = function(t, e) {
      var n = Sr(t, e).refContainer;
      this._rect = We(t.getBoxLayoutParams(), n), this._adjustAxis();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._adjustAxis = function() {
      var t = this._rect, e = this._axis, n = e.isHorizontal(), i = n ? [0, t.width] : [0, t.height], a = e.inverse ? 1 : 0;
      e.setExtent(i[a], i[1 - a]), this._updateAxisTransform(e, n ? t.x : t.y);
    }, r.prototype._updateAxisTransform = function(t, e) {
      var n = t.getExtent(), i = n[0] + n[1], a = t.isHorizontal();
      t.toGlobalCoord = a ? function(o) {
        return o + e;
      } : function(o) {
        return i - o + e;
      }, t.toLocalCoord = a ? function(o) {
        return o - e;
      } : function(o) {
        return i - o + e;
      };
    }, r.prototype.getAxis = function() {
      return this._axis;
    }, r.prototype.getBaseAxis = function() {
      return this._axis;
    }, r.prototype.getAxes = function() {
      return [this._axis];
    }, r.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, r.prototype.containPoint = function(t) {
      var e = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : n.contain(n.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
    }, r.prototype.pointToData = function(t, e, n) {
      n = n || [];
      var i = this.getAxis();
      return n[0] = i.coordToData(i.toLocalCoord(t[i.orient === "horizontal" ? 0 : 1])), n;
    }, r.prototype.dataToPoint = function(t, e, n) {
      var i = this.getAxis(), a = this.getRect();
      n = n || [];
      var o = i.orient === "horizontal" ? 0 : 1;
      return t instanceof Array && (t = t[0]), n[o] = i.toGlobalCoord(i.dataToCoord(+t)), n[1 - o] = o === 0 ? a.y + a.height / 2 : a.x + a.width / 2, n;
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = h2(e);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = h2(e);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }()
);
function h2(r) {
  var t = r.seriesModel, e = r.singleAxisModel;
  return e && e.coordinateSystem || t && t.coordinateSystem;
}
function Wit(r, t) {
  var e = [];
  return r.eachComponent("singleAxis", function(n, i) {
    var a = new Hit(n, r, t);
    a.name = "single_" + i, a.resize(n, t), n.coordinateSystem = a, e.push(a);
  }), r.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "singleAxis") {
      var i = n.getReferringComponents("singleAxis", je).models[0];
      n.coordinateSystem = i && i.coordinateSystem;
    }
  }), e;
}
var Xit = {
  create: Wit,
  dimensions: _V
}, d2 = ["x", "y"], Yit = ["width", "height"], $it = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis, l = s.coordinateSystem, u = __(l, 1 - _g(s)), c = l.dataToPoint(n)[0], f = a.get("type");
      if (f && f !== "none") {
        var h = gw(a), d = Zit[f](s, c, u);
        d.style = h, e.graphicKey = d.type, e.pointer = d;
      }
      var p = HS(i);
      hV(n, e, p, i, a, o);
    }, t.prototype.getHandleTransform = function(e, n, i) {
      var a = HS(n, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = mw(n.axis, e, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, n, i, a) {
      var o = i.axis, s = o.coordinateSystem, l = _g(o), u = __(s, l), c = [e.x, e.y];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var f = __(s, 1 - l), h = (f[1] + f[0]) / 2, d = [h, h];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, t;
  }(vw)
), Zit = {
  line: function(r, t, e) {
    var n = yw([t, e[0]], [t, e[1]], _g(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(r, t, e) {
    var n = r.getBandWidth(), i = e[1] - e[0];
    return {
      type: "Rect",
      shape: dV([t - n / 2, e[0]], [n, i], _g(r))
    };
  }
};
function _g(r) {
  return r.isHorizontal() ? 0 : 1;
}
function __(r, t) {
  var e = r.getRect();
  return [e[d2[t]], e[d2[t]] + e[Yit[t]]];
}
var qit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "single", t;
  }(Ge)
);
function Kit(r) {
  jt(Kh), Il.registerAxisPointerClass("SingleAxisPointer", $it), r.registerComponentView(qit), r.registerComponentView(zit), r.registerComponentModel(ov), fc(r, "single", ov, ov.defaultOption), r.registerCoordinateSystem("single", Xit);
}
var jit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n, i) {
      var a = Cl(e);
      r.prototype.init.apply(this, arguments), p2(e, a);
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), p2(this.option, e);
    }, t.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, t.type = "calendar", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      // TODO: theoretically, the z of the calendar should be lower
      // than series, but we don't want the series to be displayed
      // on top of the borders like month split line. To align with
      // the effect of previous versions, we set the z to 2 for now
      // until better solution is found.
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: X.color.axisLine,
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: X.color.neutral00,
        borderWidth: 1,
        borderColor: X.color.neutral10
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: X.size.s,
        color: X.color.secondary
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: X.size.s,
        // center or left
        align: "center",
        formatter: null,
        color: X.color.secondary
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: X.size.xl,
        formatter: null,
        color: X.color.quaternary,
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, t;
  }(re)
);
function p2(r, t) {
  var e = r.cellSize, n;
  et(e) ? n = e : n = r.cellSize = [e, e], n.length === 1 && (n[1] = n[0]);
  var i = rt([0, 1], function(a) {
    return L9(t, a) && (n[a] = "auto"), n[a] != null && n[a] !== "auto";
  });
  sa(r, t, {
    type: "box",
    ignoreSize: i
  });
}
var Jit = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group;
      a.removeAll();
      var o = e.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(e, s, a), this._renderLines(e, s, l, a), this._renderYearText(e, s, l, a), this._renderMonthText(e, u, l, a), this._renderWeekText(e, u, s, l, a);
    }, t.prototype._renderDayRect = function(e, n, i) {
      for (var a = e.coordinateSystem, o = e.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = n.start.time; u <= n.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToCalendarLayout([u], !1).tl, f = new te({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        i.add(f);
      }
    }, t.prototype._renderLines = function(e, n, i, a) {
      var o = this, s = e.coordinateSystem, l = e.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = e.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var f = n.start, h = 0; f.time <= n.end.time; h++) {
        p(f.formatedDate), h === 0 && (f = s.getDateInfo(n.start.y + "-" + n.start.m));
        var d = f.date;
        d.setMonth(d.getMonth() + 1), f = s.getDateInfo(d);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)), o._firstDayPoints.push(s.dataToCalendarLayout([g], !1).tl);
        var v = o._getLinePointsOfOneWeek(e, g, i);
        o._tlpoints.push(v[0]), o._blpoints.push(v[v.length - 1]), u && o._drawSplitline(v, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a);
    }, t.prototype._getEdgesPoints = function(e, n, i) {
      var a = [e[0].slice(), e[e.length - 1].slice()], o = i === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - n / 2, a[1][o] = a[1][o] + n / 2, a;
    }, t.prototype._drawSplitline = function(e, n, i) {
      var a = new Gr({
        z2: 20,
        shape: {
          points: e
        },
        style: n
      });
      i.add(a);
    }, t.prototype._getLinePointsOfOneWeek = function(e, n, i) {
      for (var a = e.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToCalendarLayout([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, t.prototype._formatterLabel = function(e, n) {
      return pt(e) && e ? M9(e, n) : At(e) ? e(n) : n.nameMap;
    }, t.prototype._yearTextPositionControl = function(e, n, i, a, o) {
      var s = n[0], l = n[1], u = ["center", "bottom"];
      a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, t.prototype._renderYearText = function(e, n, i, a) {
      var o = e.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, f = (u[0][1] + u[1][1]) / 2, h = i === "horizontal" ? 0 : 1, d = {
          top: [c, u[h][1]],
          bottom: [c, u[1 - h][1]],
          left: [u[1 - h][0], f],
          right: [u[h][0], f]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var g = o.get("formatter"), v = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new pe({
          z2: 30,
          style: Oe(o, {
            text: m
          }),
          silent: o.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y);
      }
    }, t.prototype._monthTextPositionControl = function(e, n, i, a, o) {
      var s = "left", l = "top", u = e[0], c = e[1];
      return i === "horizontal" ? (c = c + o, n && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, n && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderMonthText = function(e, n, i, a) {
      var o = e.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), f = [this._tlpoints, this._blpoints];
        (!s || pt(s)) && (s && (n = Vx(s) || n), s = n.get(["time", "monthAbbr"]) || []);
        var h = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = o.get("silent"), v = 0; v < f[h].length - 1; v++) {
          var m = f[h][v].slice(), y = this._firstDayOfMonth[v];
          if (p) {
            var _ = this._firstDayPoints[v];
            m[d] = (_[d] + f[0][v + 1][d]) / 2;
          }
          var x = o.get("formatter"), b = s[+y.m - 1], S = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: b
          }, w = this._formatterLabel(x, S), A = new pe({
            z2: 30,
            style: j(Oe(o, {
              text: w
            }), this._monthTextPositionControl(m, p, i, u, l)),
            silent: g
          });
          a.add(A);
        }
      }
    }, t.prototype._weekTextPositionControl = function(e, n, i, a, o) {
      var s = "center", l = "middle", u = e[0], c = e[1], f = i === "start";
      return n === "horizontal" ? (u = u + a + (f ? 1 : -1) * o[0] / 2, s = f ? "right" : "left") : (c = c + a + (f ? 1 : -1) * o[1] / 2, l = f ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderWeekText = function(e, n, i, a, o) {
      var s = e.getModel("dayLabel");
      if (s.get("show")) {
        var l = e.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), f = s.get("margin"), h = l.getFirstDayOfWeek();
        if (!c || pt(c)) {
          c && (n = Vx(c) || n);
          var d = n.get(["time", "dayOfWeekShort"]);
          c = d || rt(n.get(["time", "dayOfWeekAbbr"]), function(S) {
            return S[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        f = dt(f, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, f = -f);
        for (var v = s.get("silent"), m = 0; m < 7; m++) {
          var y = l.getNextNDay(p, m), _ = l.dataToCalendarLayout([y.time], !1).center, x = m;
          x = Math.abs((m + h) % 7);
          var b = new pe({
            z2: 30,
            style: j(Oe(s, {
              text: c[x]
            }), this._weekTextPositionControl(_, a, u, f, g)),
            silent: v
          });
          o.add(b);
        }
      }
    }, t.type = "calendar", t;
  }(Ge)
), x_ = 864e5, Qit = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "calendar", this.dimensions = r.dimensions, this.getDimensionsInfo = r.getDimensionsInfo, this._model = t, this._update(e, n);
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, r.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.getCellWidth = function() {
      return this._sw;
    }, r.prototype.getCellHeight = function() {
      return this._sh;
    }, r.prototype.getOrient = function() {
      return this._orient;
    }, r.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, r.prototype.getDateInfo = function(t) {
      t = Al(t);
      var e = t.getFullYear(), n = t.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, a = t.getDate(), o = a < 10 ? "0" + a : "" + a, s = t.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: e + "",
        m: i,
        d: o,
        day: s,
        time: t.getTime(),
        formatedDate: e + "-" + i + "-" + o,
        date: t
      };
    }, r.prototype.getNextNDay = function(t, e) {
      return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t));
    }, r.prototype._update = function(t, e) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [n, 7] : [7, n];
      L([0, 1], function(f) {
        c(a, f) && (o[i[f]] = a[f] * s[f]);
      });
      var l = {
        width: e.getWidth(),
        height: e.getHeight()
      }, u = this._rect = We(o, l);
      L([0, 1], function(f) {
        c(a, f) || (a[f] = u[i[f]] / s[f]);
      });
      function c(f, h) {
        return f[h] != null && f[h] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, r.prototype.dataToPoint = function(t, e, n) {
      n = n || [], et(t) && (t = t[0]), e == null && (e = !0);
      var i = this.getDateInfo(t), a = this._rangeInfo, o = i.formatedDate;
      if (e && !(i.time >= a.start.time && i.time < a.end.time + x_))
        return n[0] = n[1] = NaN, n;
      var s = i.day, l = this._getRangeInfo([a.start.time, o]).nthWeek;
      return this._orient === "vertical" ? (n[0] = this._rect.x + s * this._sw + this._sw / 2, n[1] = this._rect.y + l * this._sh + this._sh / 2) : (n[0] = this._rect.x + l * this._sw + this._sw / 2, n[1] = this._rect.y + s * this._sh + this._sh / 2), n;
    }, r.prototype.pointToData = function(t) {
      var e = this.pointToDate(t);
      return e && e.time;
    }, r.prototype.dataToLayout = function(t, e, n) {
      n = n || {};
      var i = n.rect = n.rect || {}, a = n.contentRect = n.contentRect || {}, o = this.dataToPoint(t, e);
      return i.x = o[0] - this._sw / 2, i.y = o[1] - this._sh / 2, i.width = this._sw, i.height = this._sh, Vt.copy(a, i), ml(a, this._lineWidth / 2, !0, !0), n;
    }, r.prototype.dataToCalendarLayout = function(t, e) {
      var n = this.dataToPoint(t, e);
      return {
        center: n,
        tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
        tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
        br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
        bl: [n[0] - this._sw / 2, n[1] + this._sh / 2]
      };
    }, r.prototype.pointToDate = function(t) {
      var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, n = Math.floor((t[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, e - 1, i) : this._getDateByWeeksAndDay(e, n - 1, i);
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = S_(e);
      return i === this ? i.dataToPoint(n) : null;
    }, r.prototype.convertToLayout = function(t, e, n) {
      var i = S_(e);
      return i === this ? i.dataToLayout(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = S_(e);
      return i === this ? i.pointToData(n) : null;
    }, r.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, r.prototype._initRangeOption = function() {
      var t = this._model.get("range"), e;
      if (et(t) && t.length === 1 && (t = t[0]), et(t))
        e = t;
      else {
        var n = t.toString();
        if (/^\d{4}$/.test(n) && (e = [n + "-01-01", n + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          e = [i.formatedDate, o.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (e = [n, n]);
      }
      if (!e)
        return process.env.NODE_ENV !== "production" && mi("Invalid date range."), t;
      var s = this._getRangeInfo(e);
      return s.start.time > s.end.time && e.reverse(), e;
    }, r.prototype._getRangeInfo = function(t) {
      var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], n;
      e[0].time > e[1].time && (n = !0, e.reverse());
      var i = Math.floor(e[1].time / x_) - Math.floor(e[0].time / x_) + 1, a = new Date(e[0].time), o = a.getDate(), s = e[1].date.getDate();
      a.setDate(o + i - 1);
      var l = a.getDate();
      if (l !== s)
        for (var u = a.getTime() - e[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0; )
          i -= u, a.setDate(l - u);
      var c = Math.floor((i + e[0].day + 6) / 7), f = n ? -c + 1 : c - 1;
      return n && e.reverse(), {
        range: [e[0].formatedDate, e[1].formatedDate],
        start: e[0],
        end: e[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: f,
        fweek: e[0].day,
        lweek: e[1].day
      };
    }, r.prototype._getDateByWeeksAndDay = function(t, e, n) {
      var i = this._getRangeInfo(n);
      if (t > i.weeks || t === 0 && e < i.fweek || t === i.weeks && e > i.lweek)
        return null;
      var a = (t - 1) * 7 - i.fweek + e, o = new Date(i.start.time);
      return o.setDate(+i.start.d + a), this.getDateInfo(o);
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("calendar", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachComponent(function(i, a) {
        Uh({
          targetModel: a,
          coordSysType: "calendar",
          coordSysProvider: HN
        });
      }), n;
    }, r.dimensions = ["time", "value"], r;
  }()
);
function S_(r) {
  var t = r.calendarModel, e = r.seriesModel, n = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
  return n;
}
function tat(r) {
  r.registerComponentModel(jit), r.registerComponentView(Jit), r.registerCoordinateSystem("calendar", Qit);
}
var Ea = {
  level: 1,
  leaf: 2,
  nonLeaf: 3
}, Va = {
  // No clamp, be falsy, equals to null/undefined. It means if the input part is
  // null/undefined/NaN/outOfBoundary, the result part is NaN, rather than clamp to
  // the boundary of the matrix.
  none: 0,
  // Clamp, where null/undefined/NaN/outOfBoundary can be used to cover the entire row/column.
  all: 1,
  body: 2,
  corner: 3
};
function WS(r, t, e) {
  var n = t[Wt[e]].getCell(r);
  return !n && fe(r) && r < 0 && (n = t[Wt[1 - e]].getUnitLayoutInfo(e, Math.round(r))), n;
}
function xV(r) {
  var t = r || [];
  return t[0] = t[0] || [], t[1] = t[1] || [], t[0][0] = t[0][1] = t[1][0] = t[1][1] = NaN, t;
}
function SV(r, t, e, n, i) {
  v2(r[0], t, i, e, n, 0), v2(r[1], t, i, e, n, 1);
}
function v2(r, t, e, n, i, a) {
  r[0] = 1 / 0, r[1] = -1 / 0;
  var o = n[a], s = et(o) ? o : [o], l = s.length, u = !!e;
  if (l >= 1 ? (g2(r, t, s, u, i, a, 0), l > 1 && g2(r, t, s, u, i, a, l - 1)) : (process.env.NODE_ENV !== "production" && t && t.push('Should be like [["x1", "x2"], ["y1", "y2"]], or ["x1", "y1"], rather than empty.'), r[0] = r[1] = NaN), u) {
    var c = -i[Wt[1 - a]].getLocatorCount(a), f = i[Wt[a]].getLocatorCount(a) - 1;
    e === Va.body ? c = er(0, c) : e === Va.corner && (f = Bn(-1, f)), f < c && (c = f = NaN), kr(r[0]) && (r[0] = c), kr(r[1]) && (r[1] = f), r[0] = er(Bn(r[0], f), c), r[1] = er(Bn(r[1], f), c);
  }
}
function g2(r, t, e, n, i, a, o) {
  var s = WS(e[o], i, a);
  if (!s) {
    process.env.NODE_ENV !== "production" && !n && t && t.push("Can not find cell by coord[" + a + "][" + o + "]."), r[0] = r[1] = NaN;
    return;
  }
  var l = s.id[Wt[a]], u = l, c = iat(s);
  c && (u += c.span[Wt[a]] - 1), r[0] = Bn(r[0], l, u), r[1] = er(r[1], l, u);
}
function Tp(r, t) {
  return kr(r[t][0]) || kr(r[t][1]);
}
function m2(r, t, e, n) {
  t = t || eat;
  for (var i = 0; i < n; i++)
    t[i] = !1;
  for (; ; ) {
    for (var a = !1, i = 0; i < n; i++) {
      var o = e[i];
      !t[i] && o.cellMergeOwner && rat(r, o.locatorRange) && (t[i] = !0, a = !0);
    }
    if (!a)
      break;
  }
}
var eat = [];
function rat(r, t) {
  return !y2(r[0], t[0]) || !y2(r[1], t[1]) ? !1 : (r[0][0] = Bn(r[0][0], t[0][0]), r[0][1] = er(r[0][1], t[0][1]), r[1][0] = Bn(r[1][0], t[1][0]), r[1][1] = er(r[1][1], t[1][1]), !0);
}
function y2(r, t) {
  return r[1] >= t[0] && r[0] <= t[1];
}
function _2(r, t) {
  r.id.set(t[0][0], t[1][0]), r.span.set(t[0][1] - r.id.x + 1, t[1][1] - r.id.y + 1);
}
function nat(r, t) {
  r[0][0] = t[0][0], r[0][1] = t[0][1], r[1][0] = t[1][0], r[1][1] = t[1][1];
}
function x2(r, t, e, n) {
  var i = WS(t[n][0], e, n), a = WS(t[n][1], e, n);
  r[Wt[n]] = r[cr[n]] = NaN, i && a && (r[Wt[n]] = i.xy, r[cr[n]] = a.xy + a.wh - i.xy);
}
function yf(r, t, e, n) {
  return r[Wt[t]] = e, r[Wt[1 - t]] = n, r;
}
function iat(r) {
  return r && (r.type === Ea.leaf || r.type === Ea.nonLeaf) ? r : null;
}
function xg() {
  return {
    x: NaN,
    y: NaN,
    width: NaN,
    height: NaN
  };
}
var S2 = (
  /** @class */
  function() {
    function r(t, e) {
      this._cells = [], this._levels = [], this.dim = t, this.dimIdx = t === "x" ? 0 : 1, this._model = e, this._uniqueValueGen = aat(t);
      var n = e.get("data", !0);
      n != null && !et(n) && (process.env.NODE_ENV !== "production" && ce("Illegal echarts option - matrix." + this.dim + ".data must be an array if specified."), n = []), n ? this._initByDimModelData(n) : this._initBySeriesData();
    }
    return r.prototype._initByDimModelData = function(t) {
      var e = this, n = e._cells, i = e._levels, a = [], o = 0;
      e._leavesCount = s(t, 0, 0), l();
      return;
      function s(u, c, f) {
        var h = 0;
        return u && L(u, function(d, p) {
          var g = !1, v;
          pt(d) ? v = {
            value: d
          } : Lt(d) ? (v = d, d.value != null && !pt(d.value) && (g = !0, v = {
            value: null
          })) : (v = {
            value: null
          }, d != null && (g = !0)), g && process.env.NODE_ENV !== "production" && ce("Illegal echarts option - matrix." + e.dim + ".data[" + p + "] must be `string | {value: string}`.");
          var m = {
            type: Ea.nonLeaf,
            ordinal: NaN,
            level: f,
            firstLeafLocator: c,
            id: new Ot(),
            span: yf(new Ot(), e.dimIdx, 1, 1),
            option: v,
            xy: NaN,
            wh: NaN,
            dim: e,
            rect: xg()
          };
          o++, (a[c] || (a[c] = [])).push(m), i[f] || (i[f] = {
            type: Ea.level,
            xy: NaN,
            wh: NaN,
            option: null,
            id: new Ot(),
            dim: e
          });
          var y = s(v.children, c, f + 1), _ = Math.max(1, y);
          m.span[Wt[e.dimIdx]] = _, h += _, c += _;
        }), h;
      }
      function l() {
        for (var u = []; n.length < o; )
          for (var c = 0; c < a.length; c++) {
            var f = a[c].pop();
            if (f) {
              f.ordinal = u.length;
              var h = f.option.value;
              u.push(h), n.push(f), e._uniqueValueGen.calcDupBase(h);
            }
          }
        e._uniqueValueGen.ensureValueUnique(u, n);
        var d = e._ordinalMeta = new vh({
          categories: u,
          needCollect: !1,
          deduplication: !1
        });
        e._scale = new sc({
          ordinalMeta: d
        });
        for (var p = 0; p < e._leavesCount; p++) {
          var g = e._cells[p];
          g.type = Ea.leaf, g.span[Wt[1 - e.dimIdx]] = e._levels.length - g.level;
        }
        e._initCellsId(), e._initLevelIdOptions();
      }
    }, r.prototype._initBySeriesData = function() {
      var t = this;
      t._leavesCount = 0, t._levels = [{
        type: Ea.level,
        xy: NaN,
        wh: NaN,
        option: null,
        id: new Ot(),
        dim: t
      }], t._initLevelIdOptions();
      var e = t._ordinalMeta = new vh({
        needCollect: !0,
        deduplication: !0,
        onCollect: function(n, i) {
          var a = t._cells[i] = {
            type: Ea.leaf,
            ordinal: i,
            level: 0,
            firstLeafLocator: i,
            id: new Ot(),
            span: yf(new Ot(), t.dimIdx, 1, 1),
            // Theoretically `value` is from `dataset` or `series.data`, so it may be any type.
            // Do not restrict this case for user's convenience, and here simply convert it to
            // string for display.
            option: {
              value: n + ""
            },
            xy: NaN,
            wh: NaN,
            dim: t,
            rect: xg()
          };
          t._leavesCount++, t._setCellId(a);
        }
      });
      t._scale = new sc({
        ordinalMeta: e
      });
    }, r.prototype._setCellId = function(t) {
      var e = this._levels.length, n = this.dimIdx;
      yf(t.id, n, t.firstLeafLocator, t.level - e);
    }, r.prototype._initCellsId = function() {
      var t = this._levels.length, e = this.dimIdx;
      L(this._cells, function(n) {
        yf(n.id, e, n.firstLeafLocator, n.level - t);
      });
    }, r.prototype._initLevelIdOptions = function() {
      var t = this._levels.length, e = this.dimIdx, n = this._model.get("levels", !0);
      n = et(n) ? n : [], L(this._levels, function(i, a) {
        yf(i.id, e, 0, a - t), i.option = n[a];
      });
    }, r.prototype.shouldShow = function() {
      return !!this._model.getShallow("show", !0);
    }, r.prototype.resetLayoutIterator = function(t, e, n, i) {
      if (t = t || new ko(), e === this.dimIdx) {
        var a = this._leavesCount, o = n != null ? Math.max(0, n) : 0;
        i = i != null ? Math.min(i, a) : a, t.reset(this._cells, o, o + i);
      } else {
        var a = this._levels.length, o = n != null ? Math.max(0, n + a) : 0;
        i = i != null ? Math.min(i, a) : a, t.reset(this._levels, o, o + i);
      }
      return t;
    }, r.prototype.resetCellIterator = function(t) {
      return (t || new ko()).reset(this._cells, 0);
    }, r.prototype.resetLevelIterator = function(t) {
      return (t || new ko()).reset(this._levels, 0);
    }, r.prototype.getLayout = function(t, e, n) {
      var i = this.getUnitLayoutInfo(e, n);
      t[Wt[e]] = i ? i.xy : NaN, t[cr[e]] = i ? i.wh : NaN;
    }, r.prototype.getUnitLayoutInfo = function(t, e) {
      return t === this.dimIdx ? e < this._leavesCount ? this._cells[e] : void 0 : this._levels[e + this._levels.length];
    }, r.prototype.getCell = function(t) {
      var e = this._scale.parse(t);
      return kr(e) ? void 0 : this._cells[e];
    }, r.prototype.getLocatorCount = function(t) {
      return t === this.dimIdx ? this._leavesCount : this._levels.length;
    }, r.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, r;
  }()
);
function aat(r) {
  var t = r.toUpperCase(), e = new RegExp("^" + t + "([0-9]+)$"), n = 0;
  function i(s) {
    var l;
    s != null && (l = s.match(e)) && (n = er(n, +l[1] + 1));
  }
  function a() {
    return "" + t + n++;
  }
  function o(s, l) {
    for (var u = wt(), c = 0; c < s.length; c++) {
      var f = s[c];
      (f == null || u.get(f) != null) && (s[c] = f = a(), l[c].option = Bt({
        value: f
      }, l[c].option)), u.set(f, !0);
    }
  }
  return {
    calcDupBase: i,
    ensureValueUnique: o
  };
}
var b2 = (
  /** @class */
  function() {
    function r(t, e, n) {
      this._model = e, this._dims = n, this._kind = t, this._cellMergeOwnerList = [];
    }
    return r.prototype._ensureCellMap = function() {
      var t = this, e = t._cellMap;
      return e || (e = t._cellMap = wt(), n()), e;
      function n() {
        var a = [], o = t._model.getShallow("data");
        o && !et(o) && (process.env.NODE_ENV !== "production" && ce("matrix." + o + ".data must be an array if specified."), o = null), L(o, function(p, g) {
          if (!Lt(p) || !et(p.coord)) {
            process.env.NODE_ENV !== "production" && ce("Illegal matrix." + t._kind + ".data[" + g + "], must be a {coord: [...], ...}");
            return;
          }
          var v = xV([]), m = null;
          if (process.env.NODE_ENV !== "production" && (m = []), SV(v, m, p.coord, t._dims, p.coordClamp ? Va[t._kind] : Va.none), Tp(v, 0) || Tp(v, 1)) {
            process.env.NODE_ENV !== "production" && ce("Can not determine cells by option matrix." + t._kind + ".data[" + g + "]: " + ("" + m.join(" ")));
            return;
          }
          var y = p && p.mergeCells, _ = {
            id: new Ot(),
            span: new Ot(),
            locatorRange: v,
            option: p,
            cellMergeOwner: y
          };
          _2(_, v), a.push(_);
        });
        for (var s = [], l = 0; l < a.length; l++) {
          var u = a[l];
          if (u.cellMergeOwner) {
            var c = u.locatorRange;
            m2(c, s, a, l);
            for (var f = 0; f < l; f++)
              s[f] && (a[f].cellMergeOwner = !1);
            if (c[0][0] !== u.id.x || c[1][0] !== u.id.y) {
              u.cellMergeOwner = !1;
              var h = j({}, u.option);
              h.coord = null;
              var d = {
                id: new Ot(),
                span: new Ot(),
                locatorRange: c,
                option: h,
                cellMergeOwner: !0
              };
              _2(d, c), a.push(d);
            }
          }
        }
        L(a, function(p) {
          var g = i(p.id.x, p.id.y);
          if (p.cellMergeOwner && (g.cellMergeOwner = !0, g.span = p.span, g.locatorRange = p.locatorRange, g.spanRect = xg(), t._cellMergeOwnerList.push(g)), !(!p.cellMergeOwner && !p.option))
            for (var v = 0; v < p.span.y; v++)
              for (var m = 0; m < p.span.x; m++) {
                var y = i(p.id.x + m, p.id.y + v);
                y.option = p.option, p.cellMergeOwner && (y.inSpanOf = g);
              }
        });
      }
      function i(a, o) {
        var s = w2(a, o), l = e.get(s);
        return l || (l = e.set(s, {
          id: new Ot(a, o),
          option: null,
          inSpanOf: null,
          span: null,
          spanRect: null,
          locatorRange: null,
          cellMergeOwner: !1
        })), l;
      }
    }, r.prototype.getCell = function(t) {
      return this._ensureCellMap().get(w2(t[0], t[1]));
    }, r.prototype.travelExistingCells = function(t) {
      this._ensureCellMap().each(t);
    }, r.prototype.expandRangeByCellMerge = function(t) {
      if (!Tp(t, 0) && !Tp(t, 1) && t[0][0] === t[0][1] && t[1][0] === t[1][1]) {
        b_[0] = t[0][0], b_[1] = t[1][0];
        var e = this.getCell(b_), n = e && e.inSpanOf;
        if (n) {
          nat(t, n.locatorRange);
          return;
        }
      }
      var i = this._cellMergeOwnerList;
      m2(t, null, i, i.length);
    }, r;
  }()
), b_ = [];
function w2(r, t) {
  return r + "|" + t;
}
var bw = {
  show: !0,
  color: X.color.secondary,
  // overflow: 'truncate',
  overflow: "break",
  lineOverflow: "truncate",
  padding: [2, 3, 2, 3],
  // Prefer to use `padding`, rather than distance.
  distance: 0
};
function ww(r) {
  return {
    color: "none",
    borderWidth: 1,
    borderColor: r ? "none" : X.color.borderTint
  };
}
var M2 = {
  show: !0,
  label: bw,
  itemStyle: ww(!1),
  silent: void 0,
  dividerLineStyle: {
    width: 1,
    color: X.color.border
  }
}, oat = {
  label: bw,
  itemStyle: ww(!1),
  silent: void 0
}, sat = {
  label: bw,
  itemStyle: ww(!0),
  silent: void 0
}, lat = {
  // As a most basic coord sys, `z` should be lower than
  // other series and coord sys, such as, grid.
  z: -50,
  left: "10%",
  top: "10%",
  right: "10%",
  bottom: "10%",
  x: M2,
  y: M2,
  body: oat,
  corner: sat,
  backgroundStyle: {
    color: "none",
    borderColor: X.color.axisLine,
    borderWidth: 1
  }
}, uat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      var e = this._dimModels = {
        // Do not use matrixModel as the parent model, for preventing from cascade-fetching options to it.
        x: new T2(this.get("x", !0) || {}),
        y: new T2(this.get("y", !0) || {})
      };
      e.x.option.type = e.y.option.type = "category";
      var n = e.x.dim = new S2("x", e.x), i = e.y.dim = new S2("y", e.y), a = {
        x: n,
        y: i
      };
      this._body = new b2("body", new ue(this.getShallow("body")), a), this._corner = new b2("corner", new ue(this.getShallow("corner")), a);
    }, t.prototype.getDimensionModel = function(e) {
      return this._dimModels[e];
    }, t.prototype.getBody = function() {
      return this._body;
    }, t.prototype.getCorner = function() {
      return this._corner;
    }, t.type = "matrix", t.layoutMode = "box", t.defaultOption = lat, t;
  }(re)
), T2 = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getOrdinalMeta = function() {
      return this.dim.getOrdinalMeta();
    }, t;
  }(ue)
), Ap = Math.round, cat = 0, fat = 99, hat = {
  normal: 25,
  special: 100
}, dat = {
  normal: 50,
  special: 125
}, pat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n) {
      this.group.removeAll();
      var i = this.group, a = e.coordinateSystem, o = a.getRect(), s = e.getDimensionModel("x"), l = e.getDimensionModel("y"), u = s.dim, c = l.dim;
      vat(i, e, n), gat(i, e, u, c, n);
      var f = e.getShallow("borderZ2", !0), h = bt(f, fat), d = h - 1, p = e.getModel("backgroundStyle").getItemStyle(["borderWidth"]);
      p.lineWidth = 0;
      var g = e.getModel("backgroundStyle").getItemStyle(["color", "decal", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]);
      g.fill = "none";
      var v = XS(o.clone(), p, cat), m = XS(o.clone(), g, h);
      v.silent = !0, m.silent = !0, i.add(v), i.add(m);
      var y = u.getUnitLayoutInfo(0, 0), _ = c.getUnitLayoutInfo(1, 0);
      y && _ && (u.shouldShow() && i.add(A2({
        x1: o.x,
        y1: _.xy,
        x2: o.x + o.width,
        y2: _.xy
      }, s.getModel("dividerLineStyle").getLineStyle(), d)), c.shouldShow() && i.add(A2({
        x1: y.xy,
        y1: o.y,
        x2: y.xy,
        y2: o.y + o.height
      }, l.getModel("dividerLineStyle").getLineStyle(), d)));
    }, t.type = "matrix", t;
  }(Ge)
);
function vat(r, t, e) {
  n(0), n(1);
  function n(i) {
    var a = t.getDimensionModel(Wt[i]), o = a.dim;
    if (o.shouldShow())
      for (var s = a.getModel("itemStyle"), l = a.getModel("label"), u = t.getShallow("tooltip", !0), c = [], f = o.resetCellIterator(); f.next(); ) {
        var h = f.item, d = {};
        Vt.copy(d, h.rect), M1(c, h.id.x, h.id.y), bV(c, t, r, e, h.option, s, l, a, d, h.option.value, dat, u);
      }
  }
}
function gat(r, t, e, n, i) {
  a("body", t.getBody(), e, n), e.shouldShow() && n.shouldShow() && a("corner", t.getCorner(), n, e);
  function a(o, s, l, u) {
    var c = new ue(t.getShallow(o, !0)), f = c.getModel("itemStyle"), h = c.getModel("label"), d = new ko(), p = new ko(), g = [], v = t.getShallow("tooltip", !0);
    for (u.resetLayoutIterator(p, 1); p.next(); )
      for (l.resetLayoutIterator(d, 0); d.next(); ) {
        var m = d.item, y = p.item;
        M1(g, m.id.x, y.id.y);
        var _ = s.getCell(g);
        if (!(_ && _.inSpanOf && _.inSpanOf !== _)) {
          var x = {};
          _ && _.span ? Vt.copy(x, _.spanRect) : (m.dim.getLayout(x, 0, g[0]), y.dim.getLayout(x, 1, g[1]));
          var b = _ ? _.option : null;
          bV(g, t, r, i, b, f, h, c, x, b ? b.value : null, hat, v);
        }
      }
  }
}
function bV(r, t, e, n, i, a, o, s, l, u, c, f) {
  var h;
  Ep.option = i ? i.itemStyle : null, Ep.parentModel = a, Su.option = i, Su.parentModel = s;
  var d = bt(Su.getShallow("z2"), i && i.itemStyle ? c.special : c.normal), p = f && f.show, g = XS(l, Ep.getItemStyle(), d);
  e.add(g);
  var v = Su.get("cursor");
  v != null && g.attr("cursor", v);
  var m;
  if (u != null) {
    var y = u + "";
    if (bu.option = i ? i.label : null, bu.parentModel = o, bu.ecModel = n, Cr(
      g,
      // Currently do not support other states (`emphasis`, `select`, `blur`)
      {
        normal: bu
      },
      {
        defaultText: y,
        autoOverflowArea: !0,
        // By default based on boundingRect. But boundingRect contains borderWidth,
        // and borderWidth is half outside the cell. Thus specific `layoutRect` explicitly.
        layoutRect: Dt(g.shape)
      }
    ), m = g.getTextContent(), m) {
      m.z2 = d + 1;
      var _ = m.style;
      if (_ && _.overflow && _.overflow !== "none" && _.lineOverflow) {
        var x = {};
        Vt.copy(x, l), ml(x, (((h = g.style) === null || h === void 0 ? void 0 : h.lineWidth) || 0) / 2, !0, !0), g.updateInnerText(), m.getLocalTransform(Cp), bi(Cp, Cp), Vt.applyTransform(x, x, Cp), m.setClipPath(new te({
          shape: x
        }));
      }
    }
    ja({
      el: g,
      componentModel: t,
      itemName: y,
      itemTooltipOption: f,
      formatterParamsExtra: {
        xyLocator: r.slice()
      }
    });
  }
  if (m) {
    var b = bu.get("silent");
    b == null && (b = !p), m.silent = b, m.ignoreHostSilent = !0;
  }
  var S = Su.get("silent");
  S == null && (S = // If no background color in cell, set `rect.silent: false` will cause that only
  // the border response to mouse hovering, which is probably weird.
  !g.style || g.style.fill === "none" || !g.style.fill), g.silent = S, Py(Su), Py(Ep), Py(bu);
}
var Su = new ue(), Ep = new ue(), bu = new ue(), Cp = [];
function XS(r, t, e) {
  var n = t.lineWidth;
  if (n) {
    var i = r.x + r.width, a = r.y + r.height;
    r.x = On(r.x, n, !0), r.y = On(r.y, n, !0), r.width = On(i, n, !0) - r.x, r.height = On(a, n, !0) - r.y;
  }
  return new te({
    shape: r,
    style: t,
    z2: e
  });
}
function A2(r, t, e) {
  var n = t.lineWidth;
  return n && (Ap(r.x1 * 2) === Ap(r.x2 * 2) && (r.x1 = r.x2 = On(r.x1, n, !0)), Ap(r.y1 * 2) === Ap(r.y2 * 2) && (r.y1 = r.y2 = On(r.y1, n, !0))), new lr({
    shape: r,
    style: t,
    silent: !0,
    z2: e
  });
}
var mat = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dimensions = r.dimensions, this.type = "matrix", this._model = t;
      var i = this._dimModels = {
        x: t.getDimensionModel("x"),
        y: t.getDimensionModel("y")
      };
      this._dims = {
        x: i.x.dim,
        y: i.y.dim
      }, this._resize(t, n);
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "x",
        type: "ordinal"
      }, {
        name: "y",
        type: "ordinal"
      }, {
        name: "value"
      }];
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("matrix", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachComponent(function(i, a) {
        Uh({
          targetModel: a,
          coordSysType: "matrix",
          coordSysProvider: HN
        });
      }), n;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._resize = function(t, e) {
      var n = this._dims, i = this._dimModels, a = this._rect = We(t.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
      });
      E2(i, n, a, 0), E2(i, n, a, 1), C2(0, n), C2(1, n), D2(this._model.getBody(), n), D2(this._model.getCorner(), n);
    }, r.prototype.dataToPoint = function(t, e, n) {
      return n = n || [], this.dataToLayout(t, e, _f), n[0] = _f.rect.x + _f.rect.width / 2, n[1] = _f.rect.y + _f.rect.height / 2, n;
    }, r.prototype.dataToLayout = function(t, e, n) {
      var i = this._dims;
      n = n || {};
      var a = n.rect = n.rect || {};
      a.x = a.y = a.width = a.height = NaN;
      var o = n.matrixXYLocatorRange = xV(n.matrixXYLocatorRange);
      return et(t) ? (SV(o, null, t, i, bt(e && e.clamp, Va.none)), (!e || !e.ignoreMergeCells) && ((!e || e.clamp !== Va.corner) && this._model.getBody().expandRangeByCellMerge(o), (!e || e.clamp !== Va.body) && this._model.getCorner().expandRangeByCellMerge(o)), x2(a, o, i, 0), x2(a, o, i, 1), n) : (process.env.NODE_ENV !== "production" && ce("Input data must be an array in `convertToLayout`, `convertToPixel`"), n);
    }, r.prototype.pointToData = function(t, e, n) {
      var i = this._dims;
      return L2(Ni, 0, i, t, e && e.clamp), L2(Ni, 1, i, t, e && e.clamp), n = n || [], n[0] = n[1] = NaN, Ni.y === Ur.inCorner && Ni.x === Ur.inBody ? R2(Ni, n, 0, i) : Ni.x === Ur.inCorner && Ni.y === Ur.inBody ? R2(Ni, n, 1, i) : (I2(Ni, n, 0, i), I2(Ni, n, 1, i)), n;
    }, r.prototype.convertToPixel = function(t, e, n, i) {
      var a = M_(e);
      return a === this ? a.dataToPoint(n, i) : void 0;
    }, r.prototype.convertToLayout = function(t, e, n, i) {
      var a = M_(e);
      return a === this ? a.dataToLayout(n, i) : void 0;
    }, r.prototype.convertFromPixel = function(t, e, n, i) {
      var a = M_(e);
      return a === this ? a.pointToData(n, i) : void 0;
    }, r.prototype.containPoint = function(t) {
      return this._rect.contain(t[0], t[1]);
    }, r.dimensions = ["x", "y", "value"], r;
  }()
), _f = {
  rect: xg()
}, Dp = new ko(), w_ = new ko();
function E2(r, t, e, n) {
  for (var i = 1 - n, a = t[Wt[n]], o = t[Wt[i]], s = o.shouldShow(), l = a.resetCellIterator(); l.next(); )
    l.item.wh = l.item.xy = NaN;
  for (var u = o.resetLayoutIterator(null, n); u.next(); )
    u.item.wh = u.item.xy = NaN;
  for (var c = e[cr[n]], f = a.getLocatorCount(n) + o.getLocatorCount(n), h = new ue(), d = o.resetLevelIterator(); d.next(); )
    h.option = d.item.option, h.parentModel = r[Wt[i]], v(d.item, s ? h.get("levelSize") : 0);
  for (var p = new ue(), g = a.resetCellIterator(); g.next(); )
    g.item.type === Ea.leaf && (p.option = g.item.option, p.parentModel = void 0, v(g.item, p.get("size")));
  function v(w, A) {
    var T = yat(A, n, e);
    kr(T) || (w.wh = YS(T, c), c = YS(c - w.wh), f--);
  }
  var m = f ? c / f : 0, y = !f && c >= 1, _ = e[Wt[n]], x = a.getLocatorCount(n) - 1, b = new ko();
  for (o.resetLayoutIterator(b, n); b.next(); )
    S(b.item);
  for (a.resetLayoutIterator(b, n); b.next(); )
    S(b.item);
  function S(w) {
    kr(w.wh) && (w.wh = m), w.xy = _, w.id[Wt[n]] === x && !y && (w.wh = e[Wt[n]] + e[cr[n]] - w.xy), _ += w.wh;
  }
}
function C2(r, t) {
  for (var e = t[Wt[r]].resetCellIterator(); e.next(); ) {
    var n = e.item;
    Sg(n.rect, r, n.id, n.span, t), Sg(n.rect, 1 - r, n.id, n.span, t), n.type === Ea.nonLeaf && (n.xy = n.rect[Wt[r]], n.wh = n.rect[cr[r]]);
  }
}
function D2(r, t) {
  r.travelExistingCells(function(e) {
    var n = e.span;
    if (n) {
      var i = e.spanRect, a = e.id;
      Sg(i, 0, a, n, t), Sg(i, 1, a, n, t);
    }
  });
}
function Sg(r, t, e, n, i) {
  r[cr[t]] = 0;
  var a = e[Wt[t]], o = a < 0 ? i[Wt[1 - t]] : i[Wt[t]], s = o.getUnitLayoutInfo(t, e[Wt[t]]);
  if (r[Wt[t]] = s.xy, r[cr[t]] = s.wh, n[Wt[t]] > 1) {
    var l = o.getUnitLayoutInfo(t, e[Wt[t]] + n[Wt[t]] - 1);
    r[cr[t]] = l.xy + l.wh - s.xy;
  }
}
function yat(r, t, e) {
  var n = Lv(r, e[cr[t]]);
  return YS(n, e[cr[t]]);
}
function YS(r, t) {
  return Math.max(Math.min(r, bt(t, 1 / 0)), 0);
}
function M_(r) {
  var t = r.matrixModel, e = r.seriesModel, n = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
  return n;
}
var Ur = {
  inBody: 1,
  inCorner: 2,
  outside: 3
}, Ni = {
  x: null,
  y: null,
  point: []
};
function L2(r, t, e, n, i) {
  var a = e[Wt[t]], o = e[Wt[1 - t]], s = a.getUnitLayoutInfo(t, a.getLocatorCount(t) - 1), l = a.getUnitLayoutInfo(t, 0), u = o.getUnitLayoutInfo(t, -o.getLocatorCount(t)), c = o.shouldShow() ? o.getUnitLayoutInfo(t, -1) : null, f = r.point[t] = n[t];
  if (!l && !c) {
    r[Wt[t]] = Ur.outside;
    return;
  }
  if (i === Va.body) {
    l ? (r[Wt[t]] = Ur.inBody, f = Bn(s.xy + s.wh, er(l.xy, f)), r.point[t] = f) : r[Wt[t]] = Ur.outside;
    return;
  } else if (i === Va.corner) {
    c ? (r[Wt[t]] = Ur.inCorner, f = Bn(c.xy + c.wh, er(u.xy, f)), r.point[t] = f) : r[Wt[t]] = Ur.outside;
    return;
  }
  var h = l ? l.xy : c ? c.xy + c.wh : NaN, d = u ? u.xy : h, p = s ? s.xy + s.wh : h;
  if (f < d) {
    if (!i) {
      r[Wt[t]] = Ur.outside;
      return;
    }
    f = d;
  } else if (f > p) {
    if (!i) {
      r[Wt[t]] = Ur.outside;
      return;
    }
    f = p;
  }
  r.point[t] = f, r[Wt[t]] = h <= f && f <= p ? Ur.inBody : d <= f && f <= h ? Ur.inCorner : Ur.outside;
}
function R2(r, t, e, n) {
  var i = 1 - e;
  if (r[Wt[e]] !== Ur.outside)
    for (n[Wt[e]].resetCellIterator(w_); w_.next(); ) {
      var a = w_.item;
      if (P2(r.point[e], a.rect, e) && P2(r.point[i], a.rect, i)) {
        t[e] = a.ordinal, t[i] = a.id[Wt[i]];
        return;
      }
    }
}
function I2(r, t, e, n) {
  if (r[Wt[e]] !== Ur.outside) {
    var i = r[Wt[e]] === Ur.inCorner ? n[Wt[1 - e]] : n[Wt[e]];
    for (i.resetLayoutIterator(Dp, e); Dp.next(); )
      if (_at(r.point[e], Dp.item)) {
        t[e] = Dp.item.id[Wt[e]];
        return;
      }
  }
}
function _at(r, t) {
  return t.xy <= r && r <= t.xy + t.wh;
}
function P2(r, t, e) {
  return t[Wt[e]] <= r && r <= t[Wt[e]] + t[cr[e]];
}
function xat(r) {
  r.registerComponentModel(uat), r.registerComponentView(pat), r.registerCoordinateSystem("matrix", mat);
}
function Sat(r, t) {
  var e = r.existing;
  if (t.id = r.keyInfo.id, !t.type && e && (t.type = e.type), t.parentId == null) {
    var n = t.parentOption;
    n ? t.parentId = n.id : e && (t.parentId = e.parentId);
  }
  t.parentOption = null;
}
function N2(r, t) {
  var e;
  return L(t, function(n) {
    r[n] != null && r[n] !== "auto" && (e = !0);
  }), e;
}
function bat(r, t, e) {
  var n = j({}, e), i = r[t], a = e.$action || "merge";
  if (a === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var o = e.type;
        St(!o || i.type === o, 'Please set $action: "replace" to change `type`');
      }
      qt(i, n, !0), sa(i, n, {
        ignoreSize: !0
      }), ZN(e, i), Lp(e, i), Lp(e, i, "shape"), Lp(e, i, "style"), Lp(e, i, "extra"), e.clipPath = i.clipPath;
    } else
      r[t] = n;
  else
    a === "replace" ? r[t] = n : a === "remove" && i && (r[t] = null);
}
var wV = ["transition", "enterFrom", "leaveTo"], wat = wV.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function Lp(r, t, e) {
  if (e && (!r[e] && t[e] && (r[e] = {}), r = r[e], t = t[e]), !(!r || !t))
    for (var n = e ? wV : wat, i = 0; i < n.length; i++) {
      var a = n[i];
      r[a] == null && t[a] != null && (r[a] = t[a]);
    }
}
function Mat(r, t) {
  if (r && (r.hv = t.hv = [
    // Rigid body, don't care about `width`.
    N2(t, ["left", "right"]),
    // Rigid body, don't care about `height`.
    N2(t, ["top", "bottom"])
  ], r.type === "group")) {
    var e = r, n = t;
    e.width == null && (e.width = n.width = 0), e.height == null && (e.height = n.height = 0);
  }
}
var Tat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventAutoZ = !0, e;
    }
    return t.prototype.mergeOption = function(e, n) {
      var i = this.option.elements;
      this.option.elements = null, r.prototype.mergeOption.call(this, e, n), this.option.elements = i;
    }, t.prototype.optionUpdated = function(e, n) {
      var i = this.option, a = (n ? i : e).elements, o = i.elements = n ? [] : i.elements, s = [];
      this._flatten(a, s, null);
      var l = BP(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      L(l, function(c, f) {
        var h = c.newOption;
        process.env.NODE_ENV !== "production" && St(Lt(h) || c.existing, "Empty graphic option definition"), h && (u.push(h), Sat(c, h), bat(o, f, h), Mat(o[f], h));
      }, this), i.elements = Te(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, t.prototype._flatten = function(e, n, i) {
      L(e, function(a) {
        if (a) {
          i && (a.parentOption = i), n.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, n, a), delete a.children;
        }
      }, this);
    }, t.prototype.useElOptionsToUpdate = function() {
      var e = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, e;
    }, t.type = "graphic", t.defaultOption = {
      elements: []
      // parentId: null
    }, t;
  }(re)
), O2 = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Ct,
  image: Fr,
  text: pe
}, Kn = ee(), Aat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._elMap = wt();
    }, t.prototype.render = function(e, n, i) {
      e !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = e, this._updateElements(e), this._relocate(e, i);
    }, t.prototype._updateElements = function(e) {
      var n = e.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, a = this.group, o = e.get("z"), s = e.get("zlevel");
        L(n, function(l) {
          var u = yr(l.id, null), c = u != null ? i.get(u) : null, f = yr(l.parentId, null), h = f != null ? i.get(f) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && QB(p, d, !!v, !!g)) {
            var m = tV(p, d, !0);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = Eat(l);
          process.env.NODE_ENV !== "production" && c && St(h === c.parent, "Changing parent is not supported.");
          var _ = l.$action || "merge", x = _ === "merge", b = _ === "replace";
          if (x) {
            var S = !c, w = c;
            S ? w = k2(u, h, l.type, i) : (w && (Kn(w).isNew = !1), aV(w)), w && (iv(w, y, e, {
              isInit: S
            }), B2(w, l, o, s));
          } else if (b) {
            sv(c, l, i, e);
            var A = k2(u, h, l.type, i);
            A && (iv(A, y, e, {
              isInit: !0
            }), B2(A, l, o, s));
          } else
            _ === "remove" && (rV(c, l), sv(c, l, i, e));
          var T = i.get(u);
          if (T && g)
            if (x) {
              var M = T.getTextContent();
              M ? M.attr(g) : T.setTextContent(new pe(g));
            } else
              b && T.setTextContent(new pe(g));
          if (T) {
            var C = l.clipPath;
            if (C) {
              var R = C.type, E = void 0, S = !1;
              if (x) {
                var D = T.getClipPath();
                S = !D || Kn(D).type !== R, E = S ? $S(R) : D;
              } else
                b && (S = !0, E = $S(R));
              T.setClipPath(E), iv(E, C, e, {
                isInit: S
              }), gg(E, C.keyframeAnimation, e);
            }
            var I = Kn(T);
            T.setTextConfig(v), I.option = l, Cat(T, e, l), ja({
              el: T,
              componentModel: e,
              itemName: T.name,
              itemTooltipOption: l.tooltip
            }), gg(T, l.keyframeAnimation, e);
          }
        });
      }
    }, t.prototype._relocate = function(e, n) {
      for (var i = e.option.elements, a = this.group, o = this._elMap, s = n.getWidth(), l = n.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var f = i[c], h = yr(f.id, null), d = h != null ? o.get(h) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === a, v = Kn(d), m = Kn(p);
          v.width = dt(v.option.width, g ? s : m.width) || 0, v.height = dt(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var f = i[c], h = yr(f.id, null), d = h != null ? o.get(h) : null;
        if (d) {
          var p = d.parent, m = Kn(p), y = p === a ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, _ = {}, x = cm(d, f, y, null, {
            hv: f.hv,
            boundingMode: f.bounding
          }, _);
          if (!Kn(d).isNew && x) {
            for (var b = f.transition, S = {}, w = 0; w < u.length; w++) {
              var A = u[w], T = _[A];
              b && (cl(b) || Zt(b, A) >= 0) ? S[A] = T : d[A] = T;
            }
            ve(d, S, e, 0);
          } else
            d.attr(_);
        }
      }
    }, t.prototype._clear = function() {
      var e = this, n = this._elMap;
      n.each(function(i) {
        sv(i, Kn(i).option, n, e._lastGraphicModel);
      }), this._elMap = wt();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "graphic", t;
  }(Ge)
);
function $S(r) {
  process.env.NODE_ENV !== "production" && St(r, "graphic type MUST be set");
  var t = _t(O2, r) ? O2[r] : Ov(r);
  process.env.NODE_ENV !== "production" && St(t, "graphic type " + r + " can not be found");
  var e = new t({});
  return Kn(e).type = r, e;
}
function k2(r, t, e, n) {
  var i = $S(e);
  return t.add(i), n.set(r, i), Kn(i).id = r, Kn(i).isNew = !0, i;
}
function sv(r, t, e, n) {
  var i = r && r.parent;
  i && (r.type === "group" && r.traverse(function(a) {
    sv(a, t, e, n);
  }), Tm(r, t, n), e.removeKey(Kn(r).id));
}
function B2(r, t, e, n) {
  r.isGroup || L([
    ["cursor", ai.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", n || 0],
    ["z", e || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var a = i[0];
    _t(t, a) ? r[a] = bt(t[a], i[1]) : r[a] == null && (r[a] = i[1]);
  }), L(se(t), function(i) {
    if (i.indexOf("on") === 0) {
      var a = t[i];
      r[i] = At(a) ? a : null;
    }
  }), _t(t, "draggable") && (r.draggable = t.draggable), t.name != null && (r.name = t.name), t.id != null && (r.id = t.id);
}
function Eat(r) {
  return r = j({}, r), L(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(WN), function(t) {
    delete r[t];
  }), r;
}
function Cat(r, t, e) {
  var n = zt(r).eventData;
  !r.silent && !r.ignore && !n && (n = zt(r).eventData = {
    componentType: "graphic",
    componentIndex: t.componentIndex,
    name: r.name
  }), n && (n.info = e.info);
}
function Dat(r) {
  r.registerComponentModel(Tat), r.registerComponentView(Aat), r.registerPreprocessor(function(t) {
    var e = t.graphic;
    et(e) ? !e[0] || !e[0].elements ? t.graphic = [{
      elements: e
    }] : t.graphic = [t.graphic[0]] : e && !e.elements && (t.graphic = [{
      elements: [e]
    }]);
  });
}
var V2 = ["x", "y", "radius", "angle", "single"], Lat = ["cartesian2d", "polar", "singleAxis"];
function Rat(r) {
  var t = r.get("coordinateSystem");
  return Zt(Lat, t) >= 0;
}
function Do(r) {
  return process.env.NODE_ENV !== "production" && St(r), r + "Axis";
}
function Iat(r, t) {
  var e = wt(), n = [], i = wt();
  r.eachComponent({
    mainType: "dataZoom",
    query: t
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var a;
  do
    a = !1, r.eachComponent("dataZoom", o);
  while (a);
  function o(c) {
    !i.get(c.uid) && l(c) && (s(c), a = !0);
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c);
  }
  function l(c) {
    var f = !1;
    return c.eachTargetAxis(function(h, d) {
      var p = e.get(h);
      p && p[d] && (f = !0);
    }), f;
  }
  function u(c) {
    c.eachTargetAxis(function(f, h) {
      (e.get(f) || e.set(f, []))[h] = !0;
    });
  }
  return n;
}
function MV(r) {
  var t = r.ecModel, e = {
    infoList: [],
    infoMap: wt()
  };
  return r.eachTargetAxis(function(n, i) {
    var a = t.getComponent(Do(n), i);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = e.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, e.infoList.push(l), e.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), e;
}
var T_ = (
  /** @class */
  function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(t) {
      this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0);
    }, r;
  }()
), Ah = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._autoThrottle = !0, e._noTarget = !0, e._rangePropMode = ["percent", "percent"], e;
    }
    return t.prototype.init = function(e, n, i) {
      var a = F2(e);
      this.settledOption = a, this.mergeDefaultAndTheme(e, i), this._doInit(a);
    }, t.prototype.mergeOption = function(e) {
      var n = F2(e);
      qt(this.option, e, !0), qt(this.settledOption, n, !0), this._doInit(n);
    }, t.prototype._doInit = function(e) {
      var n = this.option;
      this._setDefaultThrottle(e), this._updateRangeUse(e);
      var i = this.settledOption;
      L([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (n[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, t.prototype._resetTarget = function() {
      var e = this.get("orient", !0), n = this._targetAxisInfoMap = wt(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = e || this._makeAutoOrientByTargetAxis() : (this._orient = e || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, t.prototype._fillSpecifiedTargetAxis = function(e) {
      var n = !1;
      return L(V2, function(i) {
        var a = this.getReferringComponents(Do(i), a6);
        if (a.specified) {
          n = !0;
          var o = new T_();
          L(a.models, function(s) {
            o.add(s.componentIndex);
          }), e.set(i, o);
        }
      }, this), n;
    }, t.prototype._fillAutoTargetAxisByOrient = function(e, n) {
      var i = this.ecModel, a = !0;
      if (a) {
        var o = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var f = u[0];
        if (f) {
          var h = new T_();
          if (h.add(f.componentIndex), e.set(c, h), a = !1, c === "x" || c === "y") {
            var d = f.getReferringComponents("grid", je).models[0];
            d && L(u, function(p) {
              f.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", je).models[0] && h.add(p.componentIndex);
            });
          }
        }
      }
      a && L(V2, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: Do(u),
            filter: function(h) {
              return h.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var f = new T_();
            f.add(c[0].componentIndex), e.set(u, f), a = !1;
          }
        }
      }, this);
    }, t.prototype._makeAutoOrientByTargetAxis = function() {
      var e;
      return this.eachTargetAxis(function(n) {
        !e && (e = n);
      }, this), e === "y" ? "vertical" : "horizontal";
    }, t.prototype._setDefaultThrottle = function(e) {
      if (e.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, t.prototype._updateRangeUse = function(e) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      L([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = e[a[0]] != null, l = e[a[1]] != null;
        s && !l ? n[o] = "percent" : !s && l ? n[o] = "value" : i ? n[o] = i[o] : s && (n[o] = "percent");
      });
    }, t.prototype.noTarget = function() {
      return this._noTarget;
    }, t.prototype.getFirstTargetAxisModel = function() {
      var e;
      return this.eachTargetAxis(function(n, i) {
        e == null && (e = this.ecModel.getComponent(Do(n), i));
      }, this), e;
    }, t.prototype.eachTargetAxis = function(e, n) {
      this._targetAxisInfoMap.each(function(i, a) {
        L(i.indexList, function(o) {
          e.call(n, a, o);
        });
      });
    }, t.prototype.getAxisProxy = function(e, n) {
      var i = this.getAxisModel(e, n);
      if (i)
        return i.__dzAxisProxy;
    }, t.prototype.getAxisModel = function(e, n) {
      process.env.NODE_ENV !== "production" && St(e && n != null);
      var i = this._targetAxisInfoMap.get(e);
      if (i && i.indexMap[n])
        return this.ecModel.getComponent(Do(e), n);
    }, t.prototype.setRawRange = function(e) {
      var n = this.option, i = this.settledOption;
      L([["start", "startValue"], ["end", "endValue"]], function(a) {
        (e[a[0]] != null || e[a[1]] != null) && (n[a[0]] = i[a[0]] = e[a[0]], n[a[1]] = i[a[1]] = e[a[1]]);
      }, this), this._updateRangeUse(e);
    }, t.prototype.setCalculatedRange = function(e) {
      var n = this.option;
      L(["start", "startValue", "end", "endValue"], function(i) {
        n[i] = e[i];
      });
    }, t.prototype.getPercentRange = function() {
      var e = this.findRepresentativeAxisProxy();
      if (e)
        return e.getDataPercentWindow();
    }, t.prototype.getValueRange = function(e, n) {
      if (e == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(e, n).getDataValueWindow();
    }, t.prototype.findRepresentativeAxisProxy = function(e) {
      if (e)
        return e.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++)
        for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          n || (n = u);
        }
      return n;
    }, t.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, t.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && St(this._orient), this._orient;
    }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, t;
  }(re)
);
function F2(r) {
  var t = {};
  return L(["start", "end", "startValue", "endValue", "throttle"], function(e) {
    r.hasOwnProperty(e) && (t[e] = r[e]);
  }), t;
}
var Pat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(Ah)
), Mw = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.dataZoomModel = e, this.ecModel = n, this.api = i;
    }, t.type = "dataZoom", t;
  }(Ge)
), Nat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(Mw)
), Lu = L, z2 = ri, Oat = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this._dimName = t, this._axisIndex = e, this.ecModel = i, this._dataZoomModel = n;
    }
    return r.prototype.hostedBy = function(t) {
      return this._dataZoomModel === t;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var t = [];
      return this.ecModel.eachSeries(function(e) {
        if (Rat(e)) {
          var n = Do(this._dimName), i = e.getReferringComponents(n, je).models[0];
          i && this._axisIndex === i.componentIndex && t.push(e);
        }
      }, this), t;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return Dt(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(t) {
      var e = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      Lu(["start", "end"], function(h, d) {
        var p = t[h], g = t[h + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), g = i.parse(Me(p, o, e))) : (u = !0, g = g == null ? e[d] : i.parse(g), p = Me(g, e, o)), l[d] = g == null || isNaN(g) ? e[d] : g, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), z2(l), z2(s);
      var c = this._minMaxSpan;
      u ? f(l, s, e, o, !1) : f(s, l, o, e, !0);
      function f(h, d, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        Yo(0, h, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++)
          d[y] = Me(h[y], p, g, !0), v && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(t) {
      if (t === this._dataZoomModel) {
        var e = this.getTargetSeriesModels();
        this._dataExtent = kat(this, this._dimName, e), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(t.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(t, e) {
      if (t !== this._dataZoomModel)
        return;
      var n = this._dimName, i = this.getTargetSeriesModels(), a = t.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      Lu(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (a === "weakFilter") {
            var f = u.getStore(), h = rt(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = f.get(h[m], d), _ = !isNaN(y), x = y < o[0], b = y > o[1];
                if (_ && !x && !b)
                  return !0;
                _ && (v = !0), x && (p = !0), b && (g = !0);
              }
              return v && p && g;
            });
          } else
            Lu(c, function(d) {
              if (a === "empty")
                l.setData(u = u.map(d, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[d] = o, u.selectRange(p);
              }
            });
          Lu(c, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var t = this._minMaxSpan = {}, e = this._dataZoomModel, n = this._dataExtent;
      Lu(["min", "max"], function(i) {
        var a = e.get(i + "Span"), o = e.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Me(n[0] + o, n, [0, 100], !0) : a != null && (o = Me(a, [0, 100], n, !0) - n[0]), t[i + "Span"] = a, t[i + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var t = this.getAxisModel(), e = this._percentWindow, n = this._valueWindow;
      if (e) {
        var i = DP(n, [0, 500]);
        i = Math.min(i, 20);
        var a = t.axis.scale.rawExtentInfo;
        e[0] !== 0 && a.setDeterminedMinMax("min", +n[0].toFixed(i)), e[1] !== 100 && a.setDeterminedMinMax("max", +n[1].toFixed(i)), a.freeze();
      }
    }, r;
  }()
);
function kat(r, t, e) {
  var n = [1 / 0, -1 / 0];
  Lu(e, function(o) {
    dZ(n, o.getData(), t);
  });
  var i = r.getAxisModel(), a = bk(i.axis.scale, i, n).calculate();
  return [a.min, a.max];
}
var Bat = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(r) {
    function t(i) {
      r.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = r.getComponent(Do(o), s);
          i(o, s, l, a);
        });
      });
    }
    t(function(i, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var e = [];
    t(function(i, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new Oat(i, a, s, r), e.push(o.__dzAxisProxy));
    });
    var n = wt();
    return L(e, function(i) {
      L(i.getTargetSeriesModels(), function(a) {
        n.set(a.uid, a);
      });
    }), n;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(r, t) {
    r.eachComponent("dataZoom", function(e) {
      e.eachTargetAxis(function(n, i) {
        e.getAxisProxy(n, i).reset(e);
      }), e.eachTargetAxis(function(n, i) {
        e.getAxisProxy(n, i).filterData(e, t);
      });
    }), r.eachComponent("dataZoom", function(e) {
      var n = e.findRepresentativeAxisProxy();
      if (n) {
        var i = n.getDataPercentWindow(), a = n.getDataValueWindow();
        e.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
function Vat(r) {
  r.registerAction("dataZoom", function(t, e) {
    var n = Iat(e, t);
    L(n, function(i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue
      });
    });
  });
}
var U2 = !1;
function Tw(r) {
  U2 || (U2 = !0, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, Bat), Vat(r), r.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function Fat(r) {
  r.registerComponentModel(Pat), r.registerComponentView(Nat), Tw(r);
}
var Jn = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), TV = {};
function Ru(r, t) {
  TV[r] = t;
}
function AV(r) {
  return TV[r];
}
var zat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      r.prototype.optionUpdated.apply(this, arguments);
      var e = this.ecModel;
      L(this.option.feature, function(n, i) {
        var a = AV(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)), qt(n, a.defaultOption));
      });
    }, t.type = "toolbox", t.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, t.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: X.color.border,
      borderRadius: 0,
      borderWidth: 0,
      padding: X.size.m,
      itemSize: 15,
      itemGap: X.size.s,
      showTitle: !0,
      iconStyle: {
        borderColor: X.color.accent50,
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: X.color.accent50
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, t;
  }(re)
);
function EV(r, t) {
  var e = zh(t.get("padding")), n = t.getItemStyle(["color", "opacity"]);
  n.fill = t.get("backgroundColor");
  var i = new te({
    shape: {
      x: r.x - e[3],
      y: r.y - e[0],
      width: r.width + e[1] + e[3],
      height: r.height + e[0] + e[2],
      r: t.get("borderRadius")
    },
    style: n,
    silent: !0,
    z2: -1
  });
  return i;
}
var Uat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this.group;
      if (o.removeAll(), !e.get("show"))
        return;
      var s = +e.get("itemSize"), l = e.get("orient") === "vertical", u = e.get("feature") || {}, c = this._features || (this._features = {}), f = [];
      L(u, function(y, _) {
        f.push(_);
      }), new Ya(this._featureNames || [], f).add(h).update(h).remove(Yt(h, null)).execute(), this._featureNames = f;
      function h(y, _) {
        var x = f[y], b = f[_], S = u[x], w = new ue(S, e, e.ecModel), A;
        if (a && a.newTitle != null && a.featureName === x && (S.title = a.newTitle), x && !b) {
          if (Gat(x))
            A = {
              onclick: w.option.onclick,
              featureName: x
            };
          else {
            var T = AV(x);
            if (!T)
              return;
            A = new T();
          }
          c[x] = A;
        } else if (A = c[b], !A)
          return;
        A.uid = Ec("toolbox-feature"), A.model = w, A.ecModel = n, A.api = i;
        var M = A instanceof Jn;
        if (!x && b) {
          M && A.dispose && A.dispose(n, i);
          return;
        }
        if (!w.get("show") || M && A.unusable) {
          M && A.remove && A.remove(n, i);
          return;
        }
        d(w, A, x), w.setIconStatus = function(C, R) {
          var E = this.option, D = this.iconPaths;
          E.iconStatus = E.iconStatus || {}, E.iconStatus[C] = R, D[C] && (R === "emphasis" ? Wa : Xa)(D[C]);
        }, A instanceof Jn && A.render && A.render(w, n, i, a);
      }
      function d(y, _, x) {
        var b = y.getModel("iconStyle"), S = y.getModel(["emphasis", "iconStyle"]), w = _ instanceof Jn && _.getIcons ? _.getIcons() : y.get("icon"), A = y.get("title") || {}, T, M;
        pt(w) ? (T = {}, T[x] = w) : T = w, pt(A) ? (M = {}, M[x] = A) : M = A;
        var C = y.iconPaths = {};
        L(T, function(R, E) {
          var D = Fh(R, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          D.setStyle(b.getItemStyle());
          var I = D.ensureState("emphasis");
          I.style = S.getItemStyle();
          var P = new pe({
            style: {
              text: M[E],
              align: S.get("textAlign"),
              borderRadius: S.get("textBorderRadius"),
              padding: S.get("textPadding"),
              fill: null,
              font: Y1({
                fontStyle: S.get("textFontStyle"),
                fontFamily: S.get("textFontFamily"),
                fontSize: S.get("textFontSize"),
                fontWeight: S.get("textFontWeight")
              }, n)
            },
            ignore: !0
          });
          D.setTextContent(P), ja({
            el: D,
            componentModel: e,
            itemName: E,
            formatterParamsExtra: {
              title: M[E]
            }
          }), D.__title = M[E], D.on("mouseover", function() {
            var O = S.getItemStyle(), N = l ? e.get("right") == null && e.get("left") !== "right" ? "right" : "left" : e.get("bottom") == null && e.get("top") !== "bottom" ? "bottom" : "top";
            P.setStyle({
              fill: S.get("textFill") || O.fill || O.stroke || X.color.neutral99,
              backgroundColor: S.get("textBackgroundColor")
            }), D.setTextConfig({
              position: S.get("textPosition") || N
            }), P.ignore = !e.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            y.get(["iconStatus", E]) !== "emphasis" && i.leaveEmphasis(this), P.hide();
          }), (y.get(["iconStatus", E]) === "emphasis" ? Wa : Xa)(D), o.add(D), D.on("click", gt(_.onclick, _, n, i, E)), C[E] = D;
        });
      }
      var p = Sr(e, i).refContainer, g = e.getBoxLayoutParams(), v = e.get("padding"), m = We(g, p, v);
      ll(e.get("orient"), o, e.get("itemGap"), m.width, m.height), cm(o, g, p, v), o.add(EV(o.getBoundingRect(), e)), l || o.eachChild(function(y) {
        var _ = y.__title, x = y.ensureState("emphasis"), b = x.textConfig || (x.textConfig = {}), S = y.getTextContent(), w = S && S.ensureState("emphasis");
        if (w && !At(w) && _) {
          var A = w.style || (w.style = {}), T = Xg(_, pe.makeFont(A)), M = y.x + o.x, C = y.y + o.y + s, R = !1;
          C + T.height > i.getHeight() && (b.position = "top", R = !0);
          var E = R ? -5 - T.height : s + 10;
          M + T.width / 2 > i.getWidth() ? (b.position = ["100%", E], A.align = "right") : M - T.width / 2 < 0 && (b.position = [0, E], A.align = "left");
        }
      });
    }, t.prototype.updateView = function(e, n, i, a) {
      L(this._features, function(o) {
        o instanceof Jn && o.updateView && o.updateView(o.model, n, i, a);
      });
    }, t.prototype.remove = function(e, n) {
      L(this._features, function(i) {
        i instanceof Jn && i.remove && i.remove(e, n);
      }), this.group.removeAll();
    }, t.prototype.dispose = function(e, n) {
      L(this._features, function(i) {
        i instanceof Jn && i.dispose && i.dispose(e, n);
      });
    }, t.type = "toolbox", t;
  }(Ge)
);
function Gat(r) {
  return r.indexOf("my") === 0;
}
var Hat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      var i = this.model, a = i.get("name") || e.get("title.0.text") || "echarts", o = n.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", !0) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || e.get("backgroundColor") || X.color.neutral00,
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = oe.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var f = new MouseEvent("click", {
          // some micro front-end framework window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(f);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var h = l.split(","), d = h[0].indexOf("base64") > -1, p = o ? decodeURIComponent(h[1]) : h[1];
        d && (p = window.atob(p));
        var g = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v);
          var y = new Blob([m]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var _ = document.createElement("iframe");
          document.body.appendChild(_);
          var x = _.contentWindow, b = x.document;
          b.open("image/svg+xml", "replace"), b.write(p), b.close(), x.focus(), b.execCommand("SaveAs", !0, g), document.body.removeChild(_);
        }
      } else {
        var S = i.get("lang"), w = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (S && S[0] || "") + '" /></body>', A = window.open();
        A.document.write(w), A.document.title = a;
      }
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: e.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: X.color.neutral00,
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: e.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return n;
    }, t;
  }(Jn)
), G2 = "__ec_magicType_stack__", Wat = [["line", "bar"], ["stack"]], Xat = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getIcons = function() {
      var e = this.model, n = e.get("icon"), i = {};
      return L(e.get("type"), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: e.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, t.prototype.onclick = function(e, n, i) {
      var a = this.model, o = a.get(["seriesIndex", i]);
      if (H2[i]) {
        var s = {
          series: []
        }, l = function(f) {
          var h = f.subType, d = f.id, p = H2[i](h, d, f, a);
          p && (Bt(p, f.option), s.series.push(p));
          var g = f.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", _ = f.getReferringComponents(y, je).models[0], x = _.componentIndex;
              s[y] = s[y] || [];
              for (var b = 0; b <= x; b++)
                s[y][x] = s[y][x] || {};
              s[y][x].boundaryGap = i === "bar";
            }
          }
        };
        L(Wat, function(f) {
          Zt(f, i) >= 0 && L(f, function(h) {
            a.setIconStatus(h, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), e.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = qt({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, t;
  }(Jn)
), H2 = {
  line: function(r, t, e, n) {
    if (r === "bar")
      return qt({
        id: t,
        type: "line",
        // Preserve data related option
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, n.get(["option", "line"]) || {}, !0);
  },
  bar: function(r, t, e, n) {
    if (r === "line")
      return qt({
        id: t,
        type: "bar",
        // Preserve data related option
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, n.get(["option", "bar"]) || {}, !0);
  },
  stack: function(r, t, e, n) {
    var i = e.get("stack") === G2;
    if (r === "line" || r === "bar")
      return n.setIconStatus("stack", i ? "normal" : "emphasis"), qt({
        id: t,
        stack: i ? "" : G2
      }, n.get(["option", "stack"]) || {}, !0);
  }
};
fa({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(r, t) {
  t.mergeOption(r.newOption);
});
var Am = new Array(60).join("-"), vc = "	";
function Yat(r) {
  var t = {}, e = [], n = [];
  return r.eachRawSeries(function(i) {
    var a = i.coordinateSystem;
    if (a && (a.type === "cartesian2d" || a.type === "polar")) {
      var o = a.getBaseAxis();
      if (o.type === "category") {
        var s = o.dim + "_" + o.index;
        t[s] || (t[s] = {
          categoryAxis: o,
          valueAxis: a.getOtherAxis(o),
          series: []
        }, n.push({
          axisDim: o.dim,
          axisIndex: o.index
        })), t[s].series.push(i);
      } else
        e.push(i);
    } else
      e.push(i);
  }), {
    seriesGroupByCategoryAxis: t,
    other: e,
    meta: n
  };
}
function $at(r) {
  var t = [];
  return L(r, function(e, n) {
    var i = e.categoryAxis, a = e.valueAxis, o = a.dim, s = [" "].concat(rt(e.series, function(d) {
      return d.name;
    })), l = [i.model.getCategories()];
    L(e.series, function(d) {
      var p = d.getRawData();
      l.push(d.getRawData().mapArray(p.mapDimension(o), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(vc)], c = 0; c < l[0].length; c++) {
      for (var f = [], h = 0; h < l.length; h++)
        f.push(l[h][c]);
      u.push(f.join(vc));
    }
    t.push(u.join(`
`));
  }), t.join(`

` + Am + `

`);
}
function Zat(r) {
  return rt(r, function(t) {
    var e = t.getRawData(), n = [t.name], i = [];
    return e.each(e.dimensions, function() {
      for (var a = arguments.length, o = arguments[a - 1], s = e.getName(o), l = 0; l < a - 1; l++)
        i[l] = arguments[l];
      n.push((s ? s + vc : "") + i.join(vc));
    }), n.join(`
`);
  }).join(`

` + Am + `

`);
}
function qat(r) {
  var t = Yat(r);
  return {
    value: Te([$at(t.seriesGroupByCategoryAxis), Zat(t.other)], function(e) {
      return !!e.replace(/[\n\t\s]/g, "");
    }).join(`

` + Am + `

`),
    meta: t.meta
  };
}
function bg(r) {
  return r.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Kat(r) {
  var t = r.slice(0, r.indexOf(`
`));
  if (t.indexOf(vc) >= 0)
    return !0;
}
var ZS = new RegExp("[" + vc + "]+", "g");
function jat(r) {
  for (var t = r.split(/\n+/g), e = bg(t.shift()).split(ZS), n = [], i = rt(e, function(l) {
    return {
      name: l,
      data: []
    };
  }), a = 0; a < t.length; a++) {
    var o = bg(t[a]).split(ZS);
    n.push(o.shift());
    for (var s = 0; s < o.length; s++)
      i[s] && (i[s].data[a] = o[s]);
  }
  return {
    series: i,
    categories: n
  };
}
function Jat(r) {
  for (var t = r.split(/\n+/g), e = bg(t.shift()), n = [], i = 0; i < t.length; i++) {
    var a = bg(t[i]);
    if (a) {
      var o = a.split(ZS), s = "", l = void 0, u = !1;
      isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), n[i] = {
        name: s,
        value: []
      }, l = n[i].value) : l = n[i] = [];
      for (var c = 0; c < o.length; c++)
        l.push(+o[c]);
      l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
    }
  }
  return {
    name: e,
    data: n
  };
}
function Qat(r, t) {
  var e = r.split(new RegExp(`
*` + Am + `
*`, "g")), n = {
    series: []
  };
  return L(e, function(i, a) {
    if (Kat(i)) {
      var o = jat(i), s = t[a], l = s.axisDim + "Axis";
      s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
        data: o.categories
      }, n.series = n.series.concat(o.series));
    } else {
      var o = Jat(i);
      n.series.push(o);
    }
  }), n;
}
var tot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || X.color.neutral00;
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var f = a.get("optionToContent"), h = a.get("contentToOption"), d = qat(e);
      if (At(f)) {
        var p = f(n.getOption());
        pt(p) ? u.innerHTML = p : hl(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var v = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", _ = document.createElement("div"), x = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var b = this;
      function S() {
        i.removeChild(o), b._dom = null;
      }
      nx(_, "click", S), nx(x, "click", function() {
        if (h == null && f != null || h != null && f == null) {
          process.env.NODE_ENV !== "production" && Ye("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), S();
          return;
        }
        var w;
        try {
          At(h) ? w = h(u, n.getOption()) : w = Qat(c.value, v);
        } catch (A) {
          throw S(), new Error("Data view format error " + A);
        }
        w && n.dispatchAction({
          type: "changeDataView",
          newOption: w
        }), S();
      }), _.innerHTML = l[1], x.innerHTML = l[2], x.style.cssText = _.style.cssText = y, !a.get("readOnly") && m.appendChild(x), m.appendChild(_), o.appendChild(s), o.appendChild(u), o.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o;
    }, t.prototype.remove = function(e, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, t.prototype.dispose = function(e, n) {
      this.remove(e, n);
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: e.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: e.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: X.color.background,
        textColor: X.color.primary,
        textareaColor: X.color.background,
        textareaBorderColor: X.color.border,
        buttonColor: X.color.accent50,
        buttonTextColor: X.color.neutral00
      };
      return n;
    }, t;
  }(Jn)
);
function eot(r, t) {
  return rt(r, function(e, n) {
    var i = t && t[n];
    if (Lt(i) && !et(i)) {
      var a = Lt(e) && !et(e);
      a || (e = {
        value: e
      });
      var o = i.name != null && e.name == null;
      return e = Bt(e, i), o && delete e.name, e;
    } else
      return e;
  });
}
fa({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(r, t) {
  var e = [];
  L(r.newOption.series, function(n) {
    var i = t.getSeriesByName(n.name)[0];
    if (!i)
      e.push(j({
        // Default is scatter
        type: "scatter"
      }, n));
    else {
      var a = i.get("data");
      e.push({
        name: n.name,
        data: eot(n.data, a)
      });
    }
  }), t.mergeOption(Bt({
    series: e
  }, r.newOption));
});
var CV = L, DV = ee();
function rot(r, t) {
  var e = Aw(r);
  CV(t, function(n, i) {
    for (var a = e.length - 1; a >= 0; a--) {
      var o = e[a];
      if (o[i])
        break;
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        e[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), e.push(t);
}
function not(r) {
  var t = Aw(r), e = t[t.length - 1];
  t.length > 1 && t.pop();
  var n = {};
  return CV(e, function(i, a) {
    for (var o = t.length - 1; o >= 0; o--)
      if (i = t[o][a], i) {
        n[a] = i;
        break;
      }
  }), n;
}
function iot(r) {
  DV(r).snapshots = null;
}
function aot(r) {
  return Aw(r).length;
}
function Aw(r) {
  var t = DV(r);
  return t.snapshots || (t.snapshots = [{}]), t.snapshots;
}
var oot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      iot(e), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: e.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return n;
    }, t;
  }(Jn)
);
fa({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(r, t) {
  t.resetOption("recreate");
});
var sot = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], Ew = (
  /** @class */
  function() {
    function r(t, e, n) {
      var i = this;
      this._targetInfoList = [];
      var a = W2(e, t);
      L(lot, function(o, s) {
        (!n || !n.include || Zt(n.include, s) >= 0) && o(a, i._targetInfoList);
      });
    }
    return r.prototype.setOutputRanges = function(t, e) {
      return this.matchOutputRanges(t, e, function(n, i, a) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var o = A_[n.brushType](0, a, i);
          n.__rangeOffset = {
            offset: Z2[n.brushType](o.values, n.range, [1, 1]),
            xyMinMax: o.xyMinMax
          };
        }
      }), t;
    }, r.prototype.matchOutputRanges = function(t, e, n) {
      L(t, function(i) {
        var a = this.findTargetInfo(i, e);
        a && a !== !0 && L(a.coordSyses, function(o) {
          var s = A_[i.brushType](1, o, i.range, !0);
          n(i, s.values, o, e);
        });
      }, this);
    }, r.prototype.setInputRanges = function(t, e) {
      L(t, function(n) {
        var i = this.findTargetInfo(n, e);
        if (process.env.NODE_ENV !== "production" && (St(!i || i === !0 || n.coordRange, "coordRange must be specified when coord index specified."), St(!i || i !== !0 || n.range, "range must be specified in global brush.")), n.range = n.range || [], i && i !== !0) {
          n.panelId = i.panelId;
          var a = A_[n.brushType](0, i.coordSys, n.coordRange), o = n.__rangeOffset;
          n.range = o ? Z2[n.brushType](a.values, o.offset, uot(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, r.prototype.makePanelOpts = function(t, e) {
      return rt(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: e ? e(n) : null,
          clipPath: PB(i),
          isTargetByCursor: OB(i, t, n.coordSysModel),
          getLinearBrushOtherExtent: NB(i)
        };
      });
    }, r.prototype.controlSeries = function(t, e, n) {
      var i = this.findTargetInfo(t, n);
      return i === !0 || i && Zt(i.coordSyses, e.coordinateSystem) >= 0;
    }, r.prototype.findTargetInfo = function(t, e) {
      for (var n = this._targetInfoList, i = W2(e, t), a = 0; a < n.length; a++) {
        var o = n[a], s = t.panelId;
        if (s) {
          if (o.panelId === s)
            return o;
        } else
          for (var l = 0; l < X2.length; l++)
            if (X2[l](i, o))
              return o;
      }
      return !0;
    }, r;
  }()
);
function qS(r) {
  return r[0] > r[1] && r.reverse(), r;
}
function W2(r, t) {
  return Xu(r, t, {
    includeMainTypes: sot
  });
}
var lot = {
  grid: function(r, t) {
    var e = r.xAxisModels, n = r.yAxisModels, i = r.gridModels, a = wt(), o = {}, s = {};
    !e && !n && !i || (L(e, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), o[u.id] = !0;
    }), L(n, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), s[u.id] = !0;
    }), L(i, function(l) {
      a.set(l.id, l), o[l.id] = !0, s[l.id] = !0;
    }), a.each(function(l) {
      var u = l.coordinateSystem, c = [];
      L(u.getCartesians(), function(f, h) {
        (Zt(e, f.getAxis("x").model) >= 0 || Zt(n, f.getAxis("y").model) >= 0) && c.push(f);
      }), t.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: Y2.grid,
        xAxisDeclared: o[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(r, t) {
    L(r.geoModels, function(e) {
      var n = e.coordinateSystem;
      t.push({
        panelId: "geo--" + e.id,
        geoModel: e,
        coordSysModel: e,
        coordSys: n,
        coordSyses: [n],
        getPanelRect: Y2.geo
      });
    });
  }
}, X2 = [
  // grid
  function(r, t) {
    var e = r.xAxisModel, n = r.yAxisModel, i = r.gridModel;
    return !i && e && (i = e.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === t.gridModel;
  },
  // geo
  function(r, t) {
    var e = r.geoModel;
    return e && e === t.geoModel;
  }
], Y2 = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var r = this.coordSys, t = r.getBoundingRect().clone();
    return t.applyTransform(sl(r)), t;
  }
}, A_ = {
  lineX: Yt($2, 0),
  lineY: Yt($2, 1),
  rect: function(r, t, e, n) {
    var i = r ? t.pointToData([e[0][0], e[1][0]], n) : t.dataToPoint([e[0][0], e[1][0]], n), a = r ? t.pointToData([e[0][1], e[1][1]], n) : t.dataToPoint([e[0][1], e[1][1]], n), o = [qS([i[0], a[0]]), qS([i[1], a[1]])];
    return {
      values: o,
      xyMinMax: o
    };
  },
  polygon: function(r, t, e, n) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = rt(e, function(o) {
      var s = r ? t.pointToData(o, n) : t.dataToPoint(o, n);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: a,
      xyMinMax: i
    };
  }
};
function $2(r, t, e, n) {
  process.env.NODE_ENV !== "production" && St(e.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = e.getAxis(["x", "y"][r]), a = qS(rt([0, 1], function(s) {
    return t ? i.coordToData(i.toLocalCoord(n[s]), !0) : i.toGlobalCoord(i.dataToCoord(n[s]));
  })), o = [];
  return o[r] = a, o[1 - r] = [NaN, NaN], {
    values: a,
    xyMinMax: o
  };
}
var Z2 = {
  lineX: Yt(q2, 0),
  lineY: Yt(q2, 1),
  rect: function(r, t, e) {
    return [[r[0][0] - e[0] * t[0][0], r[0][1] - e[0] * t[0][1]], [r[1][0] - e[1] * t[1][0], r[1][1] - e[1] * t[1][1]]];
  },
  polygon: function(r, t, e) {
    return rt(r, function(n, i) {
      return [n[0] - e[0] * t[i][0], n[1] - e[1] * t[i][1]];
    });
  }
};
function q2(r, t, e, n) {
  return [t[0] - n[r] * e[0], t[1] - n[r] * e[1]];
}
function uot(r, t) {
  var e = K2(r), n = K2(t), i = [e[0] / n[0], e[1] / n[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function K2(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN];
}
var KS = L, cot = t6("toolbox-dataZoom_"), fot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._brushController || (this._brushController = new Jb(i.getZr()), this._brushController.on("brush", gt(this._onBrush, this)).mount()), pot(e, n, this, a, i), dot(e, n);
    }, t.prototype.onclick = function(e, n, i) {
      hot[i].call(this);
    }, t.prototype.remove = function(e, n) {
      this._brushController && this._brushController.unmount();
    }, t.prototype.dispose = function(e, n) {
      this._brushController && this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var n = e.areas;
      if (!e.isEnd || !n.length)
        return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new Ew(Cw(this.model), a, {
        include: ["grid"]
      });
      o.matchOutputRanges(n, a, function(u, c, f) {
        if (f.type === "cartesian2d") {
          var h = u.brushType;
          h === "rect" ? (s("x", f, c[0]), s("y", f, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[h], f, c);
        }
      }), rot(a, i), this._dispatchZoomAction(i);
      function s(u, c, f) {
        var h = c.getAxis(u), d = h.model, p = l(u, d, a), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (f = Yo(0, f.slice(), h.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: f[0],
          endValue: f[1]
        });
      }
      function l(u, c, f) {
        var h;
        return f.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (h = d);
        }), h;
      }
    }, t.prototype._dispatchZoomAction = function(e) {
      var n = [];
      KS(e, function(i, a) {
        n.push(Dt(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: e.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: X.color.backgroundTint
        }
      };
      return n;
    }, t;
  }(Jn)
), hot = {
  zoom: function() {
    var r = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: r
    });
  },
  back: function() {
    this._dispatchZoomAction(not(this.ecModel));
  }
};
function Cw(r) {
  var t = {
    xAxisIndex: r.get("xAxisIndex", !0),
    yAxisIndex: r.get("yAxisIndex", !0),
    xAxisId: r.get("xAxisId", !0),
    yAxisId: r.get("yAxisId", !0)
  };
  return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
}
function dot(r, t) {
  r.setIconStatus("back", aot(t) > 1 ? "emphasis" : "normal");
}
function pot(r, t, e, n, i) {
  var a = e._isZoomActive;
  n && n.type === "takeGlobalCursor" && (a = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : !1), e._isZoomActive = a, r.setIconStatus("zoom", a ? "emphasis" : "normal");
  var o = new Ew(Cw(r), t, {
    include: ["grid"]
  }), s = o.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  e._brushController.setPanels(s).enableBrush(a && s.length ? {
    brushType: "auto",
    brushStyle: r.getModel("brushStyle").getItemStyle()
  } : !1);
}
B9("dataZoom", function(r) {
  var t = r.getComponent("toolbox", 0), e = ["feature", "dataZoom"];
  if (!t || t.get(e) == null)
    return;
  var n = t.getModel(e), i = [], a = Cw(n), o = Xu(r, a);
  KS(o.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), KS(o.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var f = l.componentIndex, h = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: n.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: cot + u + f
    };
    h[c] = f, i.push(h);
  }
  return i;
});
function vot(r) {
  r.registerComponentModel(zat), r.registerComponentView(Uat), Ru("saveAsImage", Hat), Ru("magicType", Xat), Ru("dataView", tot), Ru("dataZoom", fot), Ru("restore", oot), jt(Fat);
}
var got = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: X.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: X.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: X.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: X.color.tertiary,
        fontSize: 14
      }
    }, t;
  }(re)
);
function LV(r) {
  var t = r.get("confine");
  return t != null ? !!t : r.get("renderMode") === "richText";
}
function RV(r) {
  if (oe.domSupported) {
    for (var t = document.documentElement.style, e = 0, n = r.length; e < n; e++)
      if (r[e] in t)
        return r[e];
  }
}
var IV = RV(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), mot = RV(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function PV(r, t) {
  if (!r)
    return t;
  t = zN(t, !0);
  var e = r.indexOf(t);
  return r = e === -1 ? t : "-" + r.slice(0, e) + "-" + t, r.toLowerCase();
}
function yot(r, t) {
  var e = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
  return e ? e[t] : null;
}
var _ot = PV(mot, "transition"), Dw = PV(IV, "transform"), xot = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (oe.transform3dSupported ? "will-change:transform;" : "");
function Sot(r) {
  return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
}
function bot(r, t, e) {
  if (!pt(e) || e === "inside")
    return "";
  var n = r.get("backgroundColor"), i = r.get("borderWidth");
  t = _l(t);
  var a = Sot(e), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = Dw + ":", u;
  Zt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, f = o + i, h = f * Math.abs(Math.cos(c)) + f * Math.abs(Math.sin(c)), d = Math.round(((h - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (h - f) / 2) * 100) / 100;
  s += ";" + a + ":-" + d + "px";
  var p = t + " solid " + i + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function wot(r, t, e) {
  var n = "cubic-bezier(0.23,1,0.32,1)", i = "", a = "";
  return e && (i = " " + r / 2 + "s " + n, a = "opacity" + i + ",visibility" + i), t || (i = " " + r + "s " + n, a += (a.length ? "," : "") + (oe.transformSupported ? "" + Dw + i : ",left" + i + ",top" + i)), _ot + ":" + a;
}
function j2(r, t, e) {
  var n = r.toFixed(0) + "px", i = t.toFixed(0) + "px";
  if (!oe.transformSupported)
    return e ? "top:" + i + ";left:" + n + ";" : [["top", i], ["left", n]];
  var a = oe.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + i + (a ? ",0" : "") + ")";
  return e ? "top:0;left:0;" + Dw + ":" + o + ";" : [["top", 0], ["left", 0], [IV, o]];
}
function Mot(r) {
  var t = [], e = r.get("fontSize"), n = r.getTextColor();
  n && t.push("color:" + n), t.push("font:" + r.getFont());
  var i = bt(r.get("lineHeight"), Math.round(e * 3 / 2));
  e && t.push("line-height:" + i + "px");
  var a = r.get("textShadowColor"), o = r.get("textShadowBlur") || 0, s = r.get("textShadowOffsetX") || 0, l = r.get("textShadowOffsetY") || 0;
  return a && o && t.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), L(["decoration", "align"], function(u) {
    var c = r.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function Tot(r, t, e, n) {
  var i = [], a = r.get("transitionDuration"), o = r.get("backgroundColor"), s = r.get("shadowBlur"), l = r.get("shadowColor"), u = r.get("shadowOffsetX"), c = r.get("shadowOffsetY"), f = r.getModel("textStyle"), h = TO(r, "html"), d = u + "px " + c + "px " + s + "px " + l;
  return i.push("box-shadow:" + d), t && a > 0 && i.push(wot(a, e, n)), o && i.push("background-color:" + o), L(["width", "color", "radius"], function(p) {
    var g = "border-" + p, v = zN(g), m = r.get(v);
    m != null && i.push(g + ":" + m + (p === "color" ? "" : "px"));
  }), i.push(Mot(f)), h != null && i.push("padding:" + zh(h).join("px ") + "px"), i.join(";") + ";";
}
function J2(r, t, e, n, i) {
  var a = t && t.painter;
  if (e) {
    var o = a && a.getViewportRoot();
    o && TW(r, o, e, n, i);
  } else {
    r[0] = n, r[1] = i;
    var s = a && a.getViewportRootOffset();
    s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
  }
  r[2] = r[0] / t.getWidth(), r[3] = r[1] / t.getHeight();
}
var Aot = (
  /** @class */
  function() {
    function r(t, e) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, oe.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var i = this._zr = t.getZr(), a = e.appendTo, o = a && (pt(a) ? document.querySelector(a) : hl(a) ? a : At(a) && a(t.getDom()));
      J2(this._styleCoord, i, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(n), this._api = t, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          $n(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(t) {
      if (!this._container) {
        var e = this._api.getDom(), n = yot(e, "position"), i = e.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, r.prototype.show = function(t, e) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, a = this._styleCoord;
      n.innerHTML ? i.cssText = xot + Tot(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + j2(a[0], a[1], !0) + ("border-color:" + _l(e) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, r.prototype.setContent = function(t, e, n, i, a) {
      var o = this.el;
      if (t == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (pt(a) && n.get("trigger") === "item" && !LV(n) && (s = bot(n, i, a)), pt(t))
        o.innerHTML = t + s;
      else if (t) {
        o.innerHTML = "", et(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          hl(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, r.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, r.prototype.moveTo = function(t, e) {
      if (this.el) {
        var n = this._styleCoord;
        if (J2(n, this._zr, this._container, t, e), n[0] != null && n[1] != null) {
          var i = this.el.style, a = j2(n[0], n[1]);
          L(a, function(o) {
            i[o[0]] = o[1];
          });
        }
      }
    }, r.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var t = this, e = this.el.style;
      this._enableDisplayTransition ? (e.visibility = "hidden", e.opacity = "0") : e.display = "none", oe.transform3dSupported && (e.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, r.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(gt(this.hide, this), t)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      AW(t && t.painter && t.painter.getViewportRoot(), this._container);
      var e = this.el;
      if (e) {
        e.onmouseenter = e.onmousemove = e.onmouseleave = null;
        var n = e.parentNode;
        n && n.removeChild(e);
      }
      this.el = this._container = null;
    }, r;
  }()
), Eot = (
  /** @class */
  function() {
    function r(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), tR(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return r.prototype.update = function(t) {
      var e = t.get("alwaysShowContent");
      e && this._moveIfResized(), this._alwaysShowContent = e;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, r.prototype.setContent = function(t, e, n, i, a) {
      var o = this;
      Lt(t) && we(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new pe({
        style: {
          rich: e.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: TO(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), L(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = n.get(u);
      }), L(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, r.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, r.prototype.getSize = function() {
      var t = this.el, e = this.el.getBoundingRect(), n = Q2(t.style);
      return [e.width + n.left + n.right, e.height + n.top + n.bottom];
    }, r.prototype.moveTo = function(t, e) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        tR(i, this._zr, t, e), t = i[0], e = i[1];
        var a = n.style, o = mo(a.borderWidth || 0), s = Q2(a);
        n.x = t + o + s.left, n.y = e + o + s.top, n.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, r.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(gt(this.hide, this), t)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }()
);
function mo(r) {
  return Math.max(0, r);
}
function Q2(r) {
  var t = mo(r.shadowBlur || 0), e = mo(r.shadowOffsetX || 0), n = mo(r.shadowOffsetY || 0);
  return {
    left: mo(t - e),
    right: mo(t + e),
    top: mo(t - n),
    bottom: mo(t + n)
  };
}
function tR(r, t, e, n) {
  r[0] = e, r[1] = n, r[2] = r[0] / t.getWidth(), r[3] = r[1] / t.getHeight();
}
var Cot = new te({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), Dot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      if (!(oe.node || !n.getDom())) {
        var i = e.getComponent("tooltip"), a = this._renderMode = s6(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new Eot(n) : new Aot(n, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(e, n, i) {
      if (!(oe.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = e, this._ecModel = n, this._api = i;
        var a = this._tooltipContent;
        a.update(e), a.setEnterable(e.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && e.get("transitionDuration") ? Lc(this, "_updatePosition", 50, "fixRate") : fh(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var e = this._tooltipModel, n = e.get("triggerOn");
      pV("itemTooltip", this._api, gt(function(i, a, o) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, t.prototype._keepShow = function() {
      var e = this._tooltipModel, n = this._ecModel, i = this._api, a = e.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(e, n, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(e, n, i, a) {
      if (!(a.from === this.uid || oe.node || !i.getDom())) {
        var o = eR(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = Pot(a, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = Cot;
          c.x = a.x, c.y = a.y, c.update(), zt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(e, n, i, a))
            return;
          var f = vV(a, n), h = f.point[0], d = f.point[1];
          h != null && d != null && this._tryShow({
            offsetX: h,
            offsetY: d,
            target: f.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else
          a.x != null && a.y != null && (i.dispatchAction({
            type: "updateAxisPointer",
            x: a.x,
            y: a.y
          }), this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            target: i.getZr().findHover(a.x, a.y).target
          }, o));
      }
    }, t.prototype.manuallyHideTip = function(e, n, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(eR(a, i));
    }, t.prototype._manuallyAxisShowTip = function(e, n, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), f = xf([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (f.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(e, n) {
      var i = e.target, a = this._tooltipModel;
      if (a) {
        this._lastX = e.offsetX, this._lastY = e.offsetY;
        var o = e.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, e);
        else if (i) {
          var s = zt(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          Qs(i, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (zt(c).dataIndex != null ? l = c : zt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(e, l, n) : u ? this._showComponentItemTooltip(e, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(e, n) {
      var i = e.get("showDelay");
      n = gt(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, t.prototype._showAxisTooltip = function(e, n) {
      var i = this._ecModel, a = this._tooltipModel, o = [n.offsetX, n.offsetY], s = xf([n.tooltipOption], a), l = this._renderMode, u = [], c = fr("section", {
        blocks: [],
        noHeader: !0
      }), f = [], h = new o0();
      L(e, function(y) {
        L(y.dataByAxis, function(_) {
          var x = i.getComponent(_.axisDim + "Axis", _.axisIndex), b = _.value;
          if (!(!x || b == null)) {
            var S = fV(b, x.axis, i, _.seriesDataIndices, _.valueLabelOpt), w = fr("section", {
              header: S,
              noHeader: !ei(S),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(w), L(_.seriesDataIndices, function(A) {
              var T = i.getSeriesByIndex(A.seriesIndex), M = A.dataIndexInside, C = T.getDataParams(M);
              if (!(C.dataIndex < 0)) {
                C.axisDim = _.axisDim, C.axisIndex = _.axisIndex, C.axisType = _.axisType, C.axisId = _.axisId, C.axisValue = jv(x.axis, {
                  value: b
                }), C.axisValueLabel = S, C.marker = h.makeTooltipMarker("item", _l(C.color), l);
                var R = dE(T.formatTooltip(M, !0, null)), E = R.frag;
                if (E) {
                  var D = xf([T], a).get("valueFormatter");
                  w.blocks.push(D ? j({
                    valueFormatter: D
                  }, E) : E);
                }
                R.text && f.push(R.text), u.push(C);
              }
            });
          }
        });
      }), c.blocks.reverse(), f.reverse();
      var d = n.position, p = s.get("order"), g = _E(c, h, l, p, i.get("useUTC"), s.get("textStyle"));
      g && f.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = f.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(e, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", o[0], o[1], d, null, h);
      });
    }, t.prototype._showSeriesItemTooltip = function(e, n, i) {
      var a = this._ecModel, o = zt(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, f = o.dataType, h = u.getData(f), d = this._renderMode, p = e.positionDefault, g = xf([h.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, f), y = new o0();
        m.marker = y.makeTooltipMarker("item", _l(m.color), d);
        var _ = dE(u.formatTooltip(c, !1, f)), x = g.get("order"), b = g.get("valueFormatter"), S = _.frag, w = S ? _E(b ? j({
          valueFormatter: b
        }, S) : S, y, d, x, a.get("useUTC"), g.get("textStyle")) : _.text, A = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, w, m, A, e.offsetX, e.offsetY, e.position, e.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: h.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(e, n, i) {
      var a = this._renderMode === "html", o = zt(n), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (pt(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = Dt(l), l.content = sn(l.content));
      var f = [l], h = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      h && f.push(h), f.push({
        formatter: l.content
      });
      var d = e.positionDefault, p = xf(f, this._tooltipModel, d ? {
        position: d
      } : null), g = p.get("content"), v = Math.random() + "", m = new o0();
      this._showOrMove(p, function() {
        var y = Dt(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, v, e.offsetX, e.offsetY, e.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(e, n, i, a, o, s, l, u, c) {
      if (this._ticket = "", !(!e.get("showContent") || !e.get("show"))) {
        var f = this._tooltipContent;
        f.setEnterable(e.get("enterable"));
        var h = e.get("formatter");
        l = l || e.get("position");
        var d = n, p = this._getNearestPoint([o, s], i, e.get("trigger"), e.get("borderColor"), e.get("defaultBorderColor", !0)), g = p.color;
        if (h)
          if (pt(h)) {
            var v = e.ecModel.get("useUTC"), m = et(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            d = h, y && (d = um(m.axisValue, d, v)), d = UN(d, i, !0);
          } else if (At(h)) {
            var _ = gt(function(x, b) {
              x === this._ticket && (f.setContent(b, c, e, g, l), this._updatePosition(e, l, o, s, f, i, u));
            }, this);
            this._ticket = a, d = h(i, a, _);
          } else
            d = h;
        f.setContent(d, c, e, g, l), f.show(e, g), this._updatePosition(e, l, o, s, f, i, u);
      }
    }, t.prototype._getNearestPoint = function(e, n, i, a, o) {
      if (i === "axis" || et(n))
        return {
          color: a || o
        };
      if (!et(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(e, n, i, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || e.get("position");
      var f = o.getSize(), h = e.get("align"), d = e.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), At(n) && (n = n([i, a], s, o.el, p, {
        viewSize: [u, c],
        contentSize: f.slice()
      })), et(n))
        i = dt(n[0], u), a = dt(n[1], c);
      else if (Lt(n)) {
        var g = n;
        g.width = f[0], g.height = f[1];
        var v = We(g, {
          width: u,
          height: c
        });
        i = v.x, a = v.y, h = null, d = null;
      } else if (pt(n) && l) {
        var m = Iot(n, p, f, e.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = Lot(i, a, o, u, c, h ? null : 20, d ? null : 20);
        i = m[0], a = m[1];
      }
      if (h && (i -= rR(h) ? f[0] / 2 : h === "right" ? f[0] : 0), d && (a -= rR(d) ? f[1] / 2 : d === "bottom" ? f[1] : 0), LV(e)) {
        var m = Rot(i, a, o, u, c);
        i = m[0], a = m[1];
      }
      o.moveTo(i, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(e, n) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === e.length;
      return o && L(i, function(s, l) {
        var u = s.dataByAxis || [], c = e[l] || {}, f = c.dataByAxis || [];
        o = o && u.length === f.length, o && L(u, function(h, d) {
          var p = f[d] || {}, g = h.seriesDataIndices || [], v = p.seriesDataIndices || [];
          o = o && h.value === p.value && h.axisType === p.axisType && h.axisId === p.axisId && g.length === v.length, o && L(g, function(m, y) {
            var _ = v[y];
            o = o && m.seriesIndex === _.seriesIndex && m.dataIndex === _.dataIndex;
          }), a && L(h.seriesDataIndices, function(m) {
            var y = m.seriesIndex, _ = n[y], x = a[y];
            _ && x && x.data !== _.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = e, this._cbParamsList = n, !!o;
    }, t.prototype._hide = function(e) {
      this._lastDataByCoordSys = null, e({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(e, n) {
      oe.node || !n.getDom() || (fh(this, "_updatePosition"), this._tooltipContent.dispose(), GS("itemTooltip", n));
    }, t.type = "tooltip", t;
  }(Ge)
);
function xf(r, t, e) {
  var n = t.ecModel, i;
  e ? (i = new ue(e, n, n), i = new ue(t.option, i, n)) : i = t;
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a];
    o && (o instanceof ue && (o = o.get("tooltip", !0)), pt(o) && (o = {
      formatter: o
    }), o && (i = new ue(o, i, n)));
  }
  return i;
}
function eR(r, t) {
  return r.dispatchAction || gt(t.dispatchAction, t);
}
function Lot(r, t, e, n, i, a, o) {
  var s = e.getSize(), l = s[0], u = s[1];
  return a != null && (r + l + a + 2 > n ? r -= l + a : r += a), o != null && (t + u + o > i ? t -= u + o : t += o), [r, t];
}
function Rot(r, t, e, n, i) {
  var a = e.getSize(), o = a[0], s = a[1];
  return r = Math.min(r + o, n) - o, t = Math.min(t + s, i) - s, r = Math.max(r, 0), t = Math.max(t, 0), [r, t];
}
function Iot(r, t, e, n) {
  var i = e[0], a = e[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (r) {
    case "inside":
      s = t.x + u / 2 - i / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      s = t.x + u / 2 - i / 2, l = t.y - a - o;
      break;
    case "bottom":
      s = t.x + u / 2 - i / 2, l = t.y + c + o;
      break;
    case "left":
      s = t.x - i - o, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      s = t.x + u + o, l = t.y + c / 2 - a / 2;
  }
  return [s, l];
}
function rR(r) {
  return r === "center" || r === "middle";
}
function Pot(r, t, e) {
  var n = I1(r).queryOptionMap, i = n.keys()[0];
  if (!(!i || i === "series")) {
    var a = bc(t, i, n.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = e.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = zt(u).tooltipConfig;
        if (c && c.name === r.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
function Not(r) {
  jt(Kh), r.registerComponentModel(got), r.registerComponentView(Dot), r.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, rr), r.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, rr);
}
var Oot = ["rect", "polygon", "keep", "clear"];
function kot(r, t) {
  var e = Ie(r ? r.brush : []);
  if (e.length) {
    var n = [];
    L(e, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (n = n.concat(u));
    });
    var i = r && r.toolbox;
    et(i) && (i = i[0]), i || (i = {
      feature: {}
    }, r.toolbox = [i]);
    var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
    s.push.apply(s, n), Bot(s), t && !s.length && s.push.apply(s, Oot);
  }
}
function Bot(r) {
  var t = {};
  L(r, function(e) {
    t[e] = 1;
  }), r.length = 0, L(t, function(e, n) {
    r.push(n);
  });
}
var nR = L;
function iR(r) {
  if (r) {
    for (var t in r)
      if (r.hasOwnProperty(t))
        return !0;
  }
}
function jS(r, t, e) {
  var n = {};
  return nR(t, function(a) {
    var o = n[a] = i();
    nR(r[a], function(s, l) {
      if (Tr.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        e && e(u, a), o[l] = new Tr(u), l === "opacity" && (u = Dt(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Tr(u));
      }
    });
  }), n;
  function i() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function NV(r, t, e) {
  var n;
  L(e, function(i) {
    t.hasOwnProperty(i) && iR(t[i]) && (n = !0);
  }), n && L(e, function(i) {
    t.hasOwnProperty(i) && iR(t[i]) ? r[i] = Dt(t[i]) : delete r[i];
  });
}
function Vot(r, t, e, n, i, a) {
  var o = {};
  L(r, function(f) {
    var h = Tr.prepareVisualTypes(t[f]);
    o[f] = h;
  });
  var s;
  function l(f) {
    return hb(e, s, f);
  }
  function u(f, h) {
    OO(e, s, f, h);
  }
  e.each(c);
  function c(f, h) {
    s = f;
    var d = e.getRawDataItem(s);
    if (!(d && d.visualMap === !1))
      for (var p = n.call(i, f), g = t[p], v = o[p], m = 0, y = v.length; m < y; m++) {
        var _ = v[m];
        g[_] && g[_].applyVisual(f, l, u);
      }
  }
}
function Fot(r, t, e, n) {
  var i = {};
  return L(r, function(a) {
    var o = Tr.prepareVisualTypes(t[a]);
    i[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      n != null && (l = s.getDimensionIndex(n));
      function u(b) {
        return hb(s, f, b);
      }
      function c(b, S) {
        OO(s, f, b, S);
      }
      for (var f, h = s.getStore(); (f = o.next()) != null; ) {
        var d = s.getRawDataItem(f);
        if (!(d && d.visualMap === !1))
          for (var p = n != null ? h.get(l, f) : f, g = e(p), v = t[g], m = i[g], y = 0, _ = m.length; y < _; y++) {
            var x = m[y];
            v[x] && v[x].applyVisual(p, u, c);
          }
      }
    }
  };
}
function zot(r) {
  var t = r.brushType, e = {
    point: function(n) {
      return aR[t].point(n, e, r);
    },
    rect: function(n) {
      return aR[t].rect(n, e, r);
    }
  };
  return e;
}
var aR = {
  lineX: oR(0),
  lineY: oR(1),
  rect: {
    point: function(r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]);
    },
    rect: function(r, t, e) {
      return r && e.boundingRect.intersect(r);
    }
  },
  polygon: {
    point: function(r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]) && Hs(e.range, r[0], r[1]);
    },
    rect: function(r, t, e) {
      var n = e.range;
      if (!r || n.length <= 1)
        return !1;
      var i = r.x, a = r.y, o = r.width, s = r.height, l = n[0];
      if (Hs(n, i, a) || Hs(n, i + o, a) || Hs(n, i, a + s) || Hs(n, i + o, a + s) || Vt.create(r).contain(l[0], l[1]) || Rf(i, a, i + o, a, n) || Rf(i, a, i, a + s, n) || Rf(i + o, a, i + o, a + s, n) || Rf(i, a + s, i + o, a + s, n))
        return !0;
    }
  }
};
function oR(r) {
  var t = ["x", "y"], e = ["width", "height"];
  return {
    point: function(n, i, a) {
      if (n) {
        var o = a.range, s = n[r];
        return Sf(s, o);
      }
    },
    rect: function(n, i, a) {
      if (n) {
        var o = a.range, s = [n[t[r]], n[t[r]] + n[e[r]]];
        return s[1] < s[0] && s.reverse(), Sf(s[0], o) || Sf(s[1], o) || Sf(o[0], s) || Sf(o[1], s);
      }
    }
  };
}
function Sf(r, t) {
  return t[0] <= r && r <= t[1];
}
var sR = ["inBrush", "outOfBrush"], E_ = "__ecBrushSelect", JS = "__ecInBrushSelectEvent";
function OV(r) {
  r.eachComponent({
    mainType: "brush"
  }, function(t) {
    var e = t.brushTargetManager = new Ew(t.option, r);
    e.setInputRanges(t.areas, r);
  });
}
function Uot(r, t, e) {
  var n = [], i, a;
  r.eachComponent({
    mainType: "brush"
  }, function(o) {
    e && e.type === "takeGlobalCursor" && o.setBrushOption(e.key === "brush" ? e.brushOption : {
      brushType: !1
    });
  }), OV(r), r.eachComponent({
    mainType: "brush"
  }, function(o, s) {
    var l = {
      brushId: o.id,
      brushIndex: s,
      brushName: o.name,
      areas: Dt(o.areas),
      selected: []
    };
    n.push(l);
    var u = o.option, c = u.brushLink, f = [], h = [], d = [], p = !1;
    s || (i = u.throttleType, a = u.throttleDelay);
    var g = rt(o.areas, function(b) {
      var S = Xot[b.brushType], w = Bt({
        boundingRect: S ? S(b) : void 0
      }, b);
      return w.selectors = zot(w), w;
    }), v = jS(o.option, sR, function(b) {
      b.mappingMethod = "fixed";
    });
    et(c) && L(c, function(b) {
      f[b] = 1;
    });
    function m(b) {
      return c === "all" || !!f[b];
    }
    function y(b) {
      return !!b.length;
    }
    r.eachSeries(function(b, S) {
      var w = d[S] = [];
      b.subType === "parallel" ? _(b, S) : x(b, S, w);
    });
    function _(b, S) {
      var w = b.coordinateSystem;
      p = p || w.hasAxisBrushed(), m(S) && w.eachActiveState(b.getData(), function(A, T) {
        A === "active" && (h[T] = 1);
      });
    }
    function x(b, S, w) {
      if (!(!b.brushSelector || Wot(o, S)) && (L(g, function(T) {
        o.brushTargetManager.controlSeries(T, b, r) && w.push(T), p = p || y(w);
      }), m(S) && y(w))) {
        var A = b.getData();
        A.each(function(T) {
          lR(b, w, A, T) && (h[T] = 1);
        });
      }
    }
    r.eachSeries(function(b, S) {
      var w = {
        seriesId: b.id,
        seriesIndex: S,
        seriesName: b.name,
        dataIndex: []
      };
      l.selected.push(w);
      var A = d[S], T = b.getData(), M = m(S) ? function(C) {
        return h[C] ? (w.dataIndex.push(T.getRawIndex(C)), "inBrush") : "outOfBrush";
      } : function(C) {
        return lR(b, A, T, C) ? (w.dataIndex.push(T.getRawIndex(C)), "inBrush") : "outOfBrush";
      };
      (m(S) ? p : y(A)) && Vot(sR, v, T, M);
    });
  }), Got(t, i, a, n, e);
}
function Got(r, t, e, n, i) {
  if (i) {
    var a = r.getZr();
    if (!a[JS]) {
      a[E_] || (a[E_] = Hot);
      var o = Lc(a, E_, e, t);
      o(r, n);
    }
  }
}
function Hot(r, t) {
  if (!r.isDisposed()) {
    var e = r.getZr();
    e[JS] = !0, r.dispatchAction({
      type: "brushSelect",
      batch: t
    }), e[JS] = !1;
  }
}
function lR(r, t, e, n) {
  for (var i = 0, a = t.length; i < a; i++) {
    var o = t[i];
    if (r.brushSelector(n, e, o.selectors, o))
      return !0;
  }
}
function Wot(r, t) {
  var e = r.option.seriesIndex;
  return e != null && e !== "all" && (et(e) ? Zt(e, t) < 0 : t !== e);
}
var Xot = {
  rect: function(r) {
    return uR(r.range);
  },
  polygon: function(r) {
    for (var t, e = r.range, n = 0, i = e.length; n < i; n++) {
      t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var a = e[n];
      a[0] < t[0][0] && (t[0][0] = a[0]), a[0] > t[0][1] && (t[0][1] = a[0]), a[1] < t[1][0] && (t[1][0] = a[1]), a[1] > t[1][1] && (t[1][1] = a[1]);
    }
    return t && uR(t);
  }
};
function uR(r) {
  return new Vt(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0]);
}
var Yot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      this.ecModel = e, this.api = n, this.model, (this._brushController = new Jb(n.getZr())).on("brush", gt(this._onBrush, this)).mount();
    }, t.prototype.render = function(e, n, i, a) {
      this.model = e, this._updateController(e, n, i, a);
    }, t.prototype.updateTransform = function(e, n, i, a) {
      OV(n), this._updateController(e, n, i, a);
    }, t.prototype.updateVisual = function(e, n, i, a) {
      this.updateTransform(e, n, i, a);
    }, t.prototype.updateView = function(e, n, i, a) {
      this._updateController(e, n, i, a);
    }, t.prototype._updateController = function(e, n, i, a) {
      (!a || a.$from !== e.id) && this._brushController.setPanels(e.brushTargetManager.makePanelOpts(i)).enableBrush(e.brushOption).updateCovers(e.areas.slice());
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel);
      (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: Dt(i),
        $from: n
      }), e.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: Dt(i),
        $from: n
      });
    }, t.type = "brush", t;
  }(Ge)
), $ot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.areas = [], e.brushOption = {}, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      var i = this.option;
      !n && NV(i, e, ["inBrush", "outOfBrush"]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: this.option.defaultOutOfBrushColor
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, t.prototype.setAreas = function(e) {
      process.env.NODE_ENV !== "production" && (St(et(e)), L(e, function(n) {
        St(n.brushType, "Illegal areas");
      })), e && (this.areas = rt(e, function(n) {
        return cR(this.option, n);
      }, this));
    }, t.prototype.setBrushOption = function(e) {
      this.brushOption = cR(this.option, e), this.brushType = this.brushOption.brushType;
    }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: X.color.backgroundTint,
        borderColor: X.color.borderTint
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4,
      defaultOutOfBrushColor: X.color.disabled
    }, t;
  }(re)
);
function cR(r, t) {
  return qt({
    brushType: r.brushType,
    brushMode: r.brushMode,
    transformable: r.transformable,
    brushStyle: new ue(r.brushStyle).getItemStyle(),
    removeOnClick: r.removeOnClick,
    z: r.z
  }, t, !0);
}
var Zot = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], qot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i) {
      var a, o, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, L(e.get("type", !0), function(l) {
        e.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, t.prototype.updateView = function(e, n, i) {
      this.render(e, n, i);
    }, t.prototype.getIcons = function() {
      var e = this.model, n = e.get("icon", !0), i = {};
      return L(e.get("type", !0), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, t.prototype.onclick = function(e, n, i) {
      var a = this._brushType, o = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? !1 : i,
          brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        type: Zot.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: e.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return n;
    }, t;
  }(Jn)
);
function Kot(r) {
  r.registerComponentView(Yot), r.registerComponentModel($ot), r.registerPreprocessor(kot), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Uot), r.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(t, e) {
    e.eachComponent({
      mainType: "brush",
      query: t
    }, function(n) {
      n.setAreas(t.areas);
    });
  }), r.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, rr), r.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, rr), Ru("brush", qot);
}
var jot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, e;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: X.size.m,
      backgroundColor: X.color.transparent,
      borderColor: X.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: X.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: X.color.quaternary
      }
    }, t;
  }(re)
), Jot = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this.group.removeAll(), !!e.get("show")) {
        var a = this.group, o = e.getModel("textStyle"), s = e.getModel("subtextStyle"), l = e.get("textAlign"), u = bt(e.get("textBaseline"), e.get("textVerticalAlign")), c = new pe({
          style: Oe(o, {
            text: e.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), f = c.getBoundingRect(), h = e.get("subtext"), d = new pe({
          style: Oe(s, {
            text: h,
            fill: s.getTextColor(),
            y: f.height + e.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = e.get("link"), g = e.get("sublink"), v = e.get("triggerEvent", !0);
        c.silent = !p && !v, d.silent = !g && !v, p && c.on("click", function() {
          Vv(p, "_" + e.get("target"));
        }), g && d.on("click", function() {
          Vv(g, "_" + e.get("subtarget"));
        }), zt(c).eventData = zt(d).eventData = v ? {
          componentType: "title",
          componentIndex: e.componentIndex
        } : null, a.add(c), h && a.add(d);
        var m = a.getBoundingRect(), y = e.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var _ = Sr(e, i), x = We(y, _.refContainer, e.get("padding"));
        l || (l = e.get("left") || e.get("right"), l === "middle" && (l = "center"), l === "right" ? x.x += x.width : l === "center" && (x.x += x.width / 2)), u || (u = e.get("top") || e.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? x.y += x.height : u === "middle" && (x.y += x.height / 2), u = u || "top"), a.x = x.x, a.y = x.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), d.setStyle(b), m = a.getBoundingRect();
        var S = x.margin, w = e.getItemStyle(["color", "opacity"]);
        w.fill = e.get("backgroundColor");
        var A = new te({
          shape: {
            x: m.x - S[3],
            y: m.y - S[0],
            width: m.width + S[1] + S[3],
            height: m.height + S[0] + S[2],
            r: e.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(A);
      }
    }, t.type = "title", t;
  }(Ge)
);
function Qot(r) {
  r.registerComponentModel(jot), r.registerComponentView(Jot);
}
var fR = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = "box", e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i), this._initData();
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this._initData();
    }, t.prototype.setCurrentIndex = function(e) {
      e == null && (e = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? e = (e % n + n) % n : (e >= n && (e = n - 1), e < 0 && (e = 0)), this.option.currentIndex = e;
    }, t.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, t.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, t.prototype.setPlayState = function(e) {
      this.option.autoPlay = !!e;
    }, t.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, t.prototype._initData = function() {
      var e = this.option, n = e.data || [], i = e.axisType, a = this._names = [], o;
      i === "category" ? (o = [], L(n, function(u, c) {
        var f = yr(Sc(u), ""), h;
        Lt(u) ? (h = Dt(u), h.value = c) : h = c, o.push(h), a.push(f);
      })) : o = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new cn([{
        name: "value",
        type: s
      }], this);
      l.initData(o, a);
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, t.type = "timeline", t.defaultOption = {
      // zlevel: 0,                  // 
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: X.size.m,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: X.color.secondary
      },
      data: []
    }, t;
  }(re)
), kV = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline.slider", t.defaultOption = Jo(fR.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: X.color.border,
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: X.color.accent10
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // TEXTSTYLE
        color: X.color.tertiary
      },
      itemStyle: {
        color: X.color.accent20,
        borderWidth: 0
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: X.color.accent50,
        borderColor: X.color.accent50,
        borderWidth: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        shadowColor: "rgba(0, 0, 0, 0)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10.6699C11.5 9.90014 12.3333 9.41887 13 9.80371L20.5 14.1338C21.1667 14.5187 21.1667 15.4813 20.5 15.8662L13 20.1963C12.3333 20.5811 11.5 20.0999 11.5 19.3301V10.6699Z",
        stopIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10C12.3284 10 13 10.6716 13 11.5V18.5C13 19.3284 12.3284 20 11.5 20C10.6716 20 10 19.3284 10 18.5V11.5C10 10.6716 10.6716 10 11.5 10ZM18.5 10C19.3284 10 20 10.6716 20 11.5V18.5C20 19.3284 19.3284 20 18.5 20C17.6716 20 17 19.3284 17 18.5V11.5C17 10.6716 17.6716 10 18.5 10Z",
        // eslint-disable-next-line max-len
        nextIcon: "path://M0.838834 18.7383C0.253048 18.1525 0.253048 17.2028 0.838834 16.617L7.55635 9.89949L0.838834 3.18198C0.253048 2.59619 0.253048 1.64645 0.838834 1.06066C1.42462 0.474874 2.37437 0.474874 2.96015 1.06066L10.7383 8.83883L10.8412 8.95277C11.2897 9.50267 11.2897 10.2963 10.8412 10.8462L10.7383 10.9602L2.96015 18.7383C2.37437 19.3241 1.42462 19.3241 0.838834 18.7383Z",
        // eslint-disable-next-line max-len
        prevIcon: "path://M10.9602 1.06066C11.5459 1.64645 11.5459 2.59619 10.9602 3.18198L4.24264 9.89949L10.9602 16.617C11.5459 17.2028 11.5459 18.1525 10.9602 18.7383C10.3744 19.3241 9.42462 19.3241 8.83883 18.7383L1.06066 10.9602L0.957771 10.8462C0.509245 10.2963 0.509245 9.50267 0.957771 8.95277L1.06066 8.83883L8.83883 1.06066C9.42462 0.474874 10.3744 0.474874 10.9602 1.06066Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: X.color.accent50,
        borderColor: X.color.accent50,
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          // TEXTSTYLE
          color: X.color.accent60
        },
        itemStyle: {
          color: X.color.accent60,
          borderColor: X.color.accent60
        },
        controlStyle: {
          color: X.color.accent70,
          borderColor: X.color.accent70
        }
      },
      progress: {
        lineStyle: {
          color: X.color.accent30
        },
        itemStyle: {
          color: X.color.accent40
        }
      },
      data: []
    }), t;
  }(fR)
);
dr(kV, hm.prototype);
var tst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline", t;
  }(Ge)
), est = (
  /** @class */
  function(r) {
    $(t, r);
    function t(e, n, i, a) {
      var o = r.call(this, e, n, i) || this;
      return o.type = a || "value", o;
    }
    return t.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, t.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, t;
  }(Ei)
), C_ = Math.PI, hR = ee(), rst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      this.api = n;
    }, t.prototype.render = function(e, n, i) {
      if (this.model = e, this.api = i, this.ecModel = n, this.group.removeAll(), e.get("show", !0)) {
        var a = this._layout(e, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, e);
        e.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return fr("nameValue", {
            noName: !0,
            value: c
          });
        }, L(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](a, o, l, e);
        }, this), this._renderAxisLabel(a, s, l, e), this._position(a, e);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, t.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._clearTimer();
    }, t.prototype._layout = function(e, n) {
      var i = e.get(["label", "position"]), a = e.get("orient"), o = ist(e, n), s;
      i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < n.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < n.getWidth() / 2 ? "+" : "-" : pt(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: C_ / 2
      }, f = a === "vertical" ? o.height : o.width, h = e.getModel("controlStyle"), d = h.get("show", !0), p = d ? h.get("itemSize") : 0, g = d ? h.get("itemGap") : 0, v = p + g, m = e.get(["label", "rotate"]) || 0;
      m = m * C_ / 180;
      var y, _, x, b = h.get("position", !0), S = d && h.get("showPlayBtn", !0), w = d && h.get("showPrevBtn", !0), A = d && h.get("showNextBtn", !0), T = 0, M = f;
      b === "left" || b === "bottom" ? (S && (y = [0, 0], T += v), w && (_ = [T, 0], T += v), A && (x = [M - p, 0], M -= v)) : (S && (y = [M - p, 0], M -= v), w && (_ = [0, 0], T += v), A && (x = [M - p, 0], M -= v));
      var C = [T, M];
      return e.get("inverse") && C.reverse(), {
        viewRect: o,
        mainLength: f,
        orient: a,
        rotation: c[a],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: e.get(["label", "align"]) || l[a],
        labelBaseline: e.get(["label", "verticalAlign"]) || e.get(["label", "baseline"]) || u[a],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: _,
        nextBtnPosition: x,
        axisExtent: C,
        controlSize: p,
        controlGap: g
      };
    }, t.prototype._position = function(e, n) {
      var i = this._mainGroup, a = this._labelGroup, o = e.viewRect;
      if (e.orient === "vertical") {
        var s = Br(), l = o.x, u = o.y + o.height;
        na(s, s, [-l, -u]), Ko(s, s, -C_ / 2), na(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
      }
      var c = y(o), f = y(i.getBoundingRect()), h = y(a.getBoundingRect()), d = [i.x, i.y], p = [a.x, a.y];
      p[0] = d[0] = c[0][0];
      var g = e.labelPosOpt;
      if (g == null || pt(g)) {
        var v = g === "+" ? 0 : 1;
        _(d, f, c, 1, v), _(p, h, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        _(d, f, c, 1, v), p[1] = d[1] + g;
      }
      i.setPosition(d), a.setPosition(p), i.rotation = a.rotation = e.rotation, m(i), m(a);
      function m(x) {
        x.originX = c[0][0] - x.x, x.originY = c[1][0] - x.y;
      }
      function y(x) {
        return [[x.x, x.x + x.width], [x.y, x.y + x.height]];
      }
      function _(x, b, S, w, A) {
        x[w] += S[w][A] - b[w][A];
      }
    }, t.prototype._createAxis = function(e, n) {
      var i = n.getData(), a = n.get("axisType"), o = nst(n, a);
      o.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new est("value", o, e.axisExtent, a);
      return l.model = n, l;
    }, t.prototype._createGroup = function(e) {
      var n = this[e] = new Ct();
      return this.group.add(n), n;
    }, t.prototype._renderAxisLine = function(e, n, i, a) {
      var o = i.getExtent();
      if (a.get(["lineStyle", "show"])) {
        var s = new lr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: j({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new lr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: Bt({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(l);
      }
    }, t.prototype._renderAxisTick = function(e, n, i, a) {
      var o = this, s = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], L(l, function(u) {
        var c = i.dataToCoord(u.value), f = s.getItemModel(u.value), h = f.getModel("itemStyle"), d = f.getModel(["emphasis", "itemStyle"]), p = f.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: gt(o._changeTimeline, o, u.value)
        }, v = dR(f, h, n, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), ol(v);
        var m = zt(v);
        f.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = a) : m.dataIndex = m.dataModel = null, o._tickSymbols.push(v);
      });
    }, t.prototype._renderAxisLabel = function(e, n, i, a) {
      var o = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], L(u, function(c) {
          var f = c.tickValue, h = l.getItemModel(f), d = h.getModel("label"), p = h.getModel(["emphasis", "label"]), g = h.getModel(["progress", "label"]), v = i.dataToCoord(c.tickValue), m = new pe({
            x: v,
            y: 0,
            rotation: e.labelRotation - e.rotation,
            onclick: gt(o._changeTimeline, o, f),
            silent: !1,
            style: Oe(d, {
              text: c.formattedLabel,
              align: e.labelAlign,
              verticalAlign: e.labelBaseline
            })
          });
          m.ensureState("emphasis").style = Oe(p), m.ensureState("progress").style = Oe(g), n.add(m), ol(m), hR(m).dataIndex = f, o._tickLabels.push(m);
        });
      }
    }, t.prototype._renderControl = function(e, n, i, a) {
      var o = e.controlSize, s = e.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = a.getPlayState(), f = a.get("inverse", !0);
      h(e.nextBtnPosition, "next", gt(this._changeTimeline, this, f ? "-" : "+")), h(e.prevBtnPosition, "prev", gt(this._changeTimeline, this, f ? "+" : "-")), h(e.playPosition, c ? "stop" : "play", gt(this._handlePlayClick, this, !c), !0);
      function h(d, p, g, v) {
        if (d) {
          var m = wi(bt(a.get(["controlStyle", p + "BtnSize"]), o), o), y = [0, -m / 2, m, m], _ = ast(a, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          _.ensureState("emphasis").style = u, n.add(_), ol(_);
        }
      }
    }, t.prototype._renderCurrentPointer = function(e, n, i, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(f) {
          f.draggable = !0, f.drift = gt(u._handlePointerDrag, u), f.ondragend = gt(u._handlePointerDragend, u), pR(f, u._progressLine, s, i, a, !0);
        },
        onUpdate: function(f) {
          pR(f, u._progressLine, s, i, a);
        }
      };
      this._currentPointer = dR(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, t.prototype._handlePlayClick = function(e) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: e,
        from: this.uid
      });
    }, t.prototype._handlePointerDrag = function(e, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, t.prototype._handlePointerDragend = function(e) {
      this._pointerChangeTimeline([e.offsetX, e.offsetY], !0);
    }, t.prototype._pointerChangeTimeline = function(e, n) {
      var i = this._toAxisCoord(e)[0], a = this._axis, o = ri(a.getExtent().slice());
      i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, t.prototype._doPlayStop = function() {
      var e = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = e.model;
        e._changeTimeline(n.getCurrentIndex() + (n.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, t.prototype._toAxisCoord = function(e) {
      var n = this._mainGroup.getLocalTransform();
      return _i(e, n, !0);
    }, t.prototype._findNearestTick = function(e) {
      var n = this.model.getData(), i = 1 / 0, a, o = this._axis;
      return n.each(["value"], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - e);
        c < i && (i = c, a = l);
      }), a;
    }, t.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, t.prototype._changeTimeline = function(e) {
      var n = this.model.getCurrentIndex();
      e === "+" ? e = n + 1 : e === "-" && (e = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: e,
        from: this.uid
      });
    }, t.prototype._updateTicksStatus = function() {
      var e = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n)
        for (var a = 0; a < n.length; a++)
          n && n[a] && n[a].toggleState("progress", a < e);
      if (i)
        for (var a = 0; a < i.length; a++)
          i && i[a] && i[a].toggleState("progress", hR(i[a]).dataIndex <= e);
    }, t.type = "timeline.slider", t;
  }(tst)
);
function nst(r, t) {
  if (t = t || r.get("type"), t)
    switch (t) {
      case "category":
        return new sc({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new bb({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new $a();
    }
}
function ist(r, t) {
  return We(r.getBoxLayoutParams(), Sr(r, t).refContainer, r.get("padding"));
}
function ast(r, t, e, n) {
  var i = n.style, a = Fh(r.get(["controlStyle", t]), n || {}, new Vt(e[0], e[1], e[2], e[3]));
  return i && a.setStyle(i), a;
}
function dR(r, t, e, n, i, a) {
  var o = t.get("color");
  if (i)
    i.setColor(o), e.add(i), a && a.onUpdate(i);
  else {
    var s = r.get("symbol");
    i = hr(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", !0), e.add(i), a && a.onCreate(i);
  }
  var l = t.getItemStyle(["color"]);
  i.setStyle(l), n = qt({
    rectHover: !0,
    z2: 100
  }, n, !0);
  var u = Rc(r.get("symbolSize"));
  n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
  var c = Ll(r.get("symbolOffset"), u);
  c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
  var f = r.get("symbolRotate");
  return n.rotation = (f || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
}
function pR(r, t, e, n, i, a) {
  if (!r.dragging) {
    var o = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", e));
    if (a || !o.get("animation", !0))
      r.attr({
        x: s,
        y: 0
      }), t && t.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: o.get("animationDuration", !0),
        easing: o.get("animationEasing", !0)
      };
      r.stopAnimation(null, !0), r.animateTo({
        x: s,
        y: 0
      }, l), t && t.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
function ost(r) {
  r.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(t, e, n) {
    var i = e.getComponent("timeline");
    return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), n.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: t.from
    }))), e.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), Bt({
      currentIndex: i.option.currentIndex
    }, t);
  }), r.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(t, e) {
    var n = e.getComponent("timeline");
    n && t.playState != null && n.setPlayState(t.playState);
  });
}
function sst(r) {
  var t = r && r.timeline;
  et(t) || (t = t ? [t] : []), L(t, function(e) {
    e && lst(e);
  });
}
function lst(r) {
  var t = r.type, e = {
    number: "value",
    time: "time"
  };
  if (e[t] && (r.axisType = e[t], delete r.type), vR(r), Ys(r, "controlPosition")) {
    var n = r.controlStyle || (r.controlStyle = {});
    Ys(n, "position") || (n.position = r.controlPosition), n.position === "none" && !Ys(n, "show") && (n.show = !1, delete n.position), delete r.controlPosition;
  }
  L(r.data || [], function(i) {
    Lt(i) && !et(i) && (!Ys(i, "value") && Ys(i, "name") && (i.value = i.name), vR(i));
  });
}
function vR(r) {
  var t = r.itemStyle || (r.itemStyle = {}), e = t.emphasis || (t.emphasis = {}), n = r.label || r.label || {}, i = n.normal || (n.normal = {}), a = {
    normal: 1,
    emphasis: 1
  };
  L(n, function(o, s) {
    !a[s] && !Ys(i, s) && (i[s] = o);
  }), e.label && !Ys(n, "emphasis") && (n.emphasis = e.label, delete e.label);
}
function Ys(r, t) {
  return r.hasOwnProperty(t);
}
function ust(r) {
  r.registerComponentModel(kV), r.registerComponentView(rst), r.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), ost(r), r.registerPreprocessor(sst);
}
function Lw(r, t) {
  if (!r)
    return !1;
  for (var e = et(r) ? r : [r], n = 0; n < e.length; n++)
    if (e[n] && e[n][t])
      return !0;
  return !1;
}
function Rp(r) {
  dl(r, "label", ["show"]);
}
var Ip = ee(), ua = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.createdBySelf = !1, e.preventAutoZ = !0, e;
    }
    return t.prototype.init = function(e, n, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, !1, !0);
    }, t.prototype.isAnimationEnabled = function() {
      if (oe.node)
        return !1;
      var e = this.__hostSeries;
      return this.getShallow("animation") && e && e.isAnimationEnabled();
    }, t.prototype.mergeOption = function(e, n) {
      this._mergeOption(e, n, !1, !1);
    }, t.prototype._mergeOption = function(e, n, i, a) {
      var o = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = Ip(s)[o];
        if (!l || !l.data) {
          Ip(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, n, !0) : (a && Rp(l), L(l.data, function(c) {
          c instanceof Array ? (Rp(c[0]), Rp(c[1])) : Rp(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), j(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), Ip(s)[o] = u;
      }, this);
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
      return fr("section", {
        header: this.name,
        blocks: [fr("nameValue", {
          name: s,
          value: o,
          noName: !s,
          noValue: o == null
        })]
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.setData = function(e) {
      this._data = e;
    }, t.prototype.getDataParams = function(e, n) {
      var i = hm.prototype.getDataParams.call(this, e, n), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, t.getMarkerModelFromSeries = function(e, n) {
      return Ip(e)[n];
    }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
  }(re)
);
dr(ua, hm.prototype);
var cst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markPoint", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(ua)
);
function QS(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)));
}
function fst(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y));
}
function Pp(r, t, e, n, i, a, o) {
  var s = [], l = Wo(
    t,
    i
    /* , otherDataDim */
  ), u = l ? t.getCalculationInfo("stackResultDimension") : i, c = wg(t, u, r), f = t.hostModel, h = f.indicesOfNearest(e, u, c)[0];
  s[a] = t.get(n, h), s[o] = t.get(u, h);
  var d = t.get(i, h), p = $i(t.get(i, h));
  return p = Math.min(p, 20), p >= 0 && (s[o] = +s[o].toFixed(p)), [s, d];
}
var Np = {
  min: Yt(Pp, "min"),
  max: Yt(Pp, "max"),
  average: Yt(Pp, "average"),
  median: Yt(Pp, "median")
};
function Eh(r, t) {
  if (t) {
    var e = r.getData(), n = r.coordinateSystem, i = n && n.dimensions;
    if (!fst(t) && !et(t.coord) && et(i)) {
      var a = BV(t, e, n, r);
      if (t = Dt(t), t.type && Np[t.type] && a.baseAxis && a.valueAxis) {
        var o = Zt(i, a.baseAxis.dim), s = Zt(i, a.valueAxis.dim), l = Np[t.type](e, a.valueAxis.dim, a.baseDataDim, a.valueDataDim, o, s);
        t.coord = l[0], t.value = l[1];
      } else
        t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
    }
    if (t.coord == null || !et(i)) {
      t.coord = [];
      var u = r.getBaseAxis();
      if (u && t.type && Np[t.type]) {
        var c = n.getOtherAxis(u);
        c && (t.value = wg(e, e.mapDimension(c.dim), t.type));
      }
    } else
      for (var f = t.coord, h = 0; h < 2; h++)
        Np[f[h]] && (f[h] = wg(e, e.mapDimension(i[h]), f[h]));
    return t;
  }
}
function BV(r, t, e, n) {
  var i = {};
  return r.valueIndex != null || r.valueDim != null ? (i.valueDataDim = r.valueIndex != null ? t.getDimension(r.valueIndex) : r.valueDim, i.valueAxis = e.getAxis(hst(n, i.valueDataDim)), i.baseAxis = e.getOtherAxis(i.valueAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = e.getOtherAxis(i.baseAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim), i.valueDataDim = t.mapDimension(i.valueAxis.dim)), i;
}
function hst(r, t) {
  var e = r.getData().getDimensionInfo(t);
  return e && e.coordDim;
}
function Ch(r, t) {
  return r && r.containData && t.coord && !QS(t) ? r.containData(t.coord) : !0;
}
function dst(r, t, e) {
  return r && r.containZone && t.coord && e.coord && !QS(t) && !QS(e) ? r.containZone(t.coord, e.coord) : !0;
}
function VV(r, t) {
  return r ? function(e, n, i, a) {
    var o = a < 2 ? e.coord && e.coord[a] : e.value;
    return Bo(o, t[a]);
  } : function(e, n, i, a) {
    return Bo(e.value, t[a]);
  };
}
function wg(r, t, e) {
  if (e === "average") {
    var n = 0, i = 0;
    return r.each(t, function(a, o) {
      isNaN(a) || (n += a, i++);
    }), n / i;
  } else
    return e === "median" ? r.getMedian(t) : r.getDataExtent(t)[e === "max" ? 1 : 0];
}
var D_ = ee(), Rw = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this.markerGroupMap = wt();
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        D_(s).keep = !1;
      }), n.eachSeries(function(s) {
        var l = ua.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, n, i);
      }), o.each(function(s) {
        !D_(s).keep && a.group.remove(s.group);
      }), pst(n, o, this.type);
    }, t.prototype.markKeep = function(e) {
      D_(e).keep = !0;
    }, t.prototype.toggleBlurSeries = function(e, n) {
      var i = this;
      L(e, function(a) {
        var o = ua.getMarkerModelFromSeries(a, i.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? rN(l) : z1(l));
          });
        }
      });
    }, t.type = "marker", t;
  }(Ge)
);
function pst(r, t, e) {
  r.eachSeries(function(n) {
    var i = ua.getMarkerModelFromSeries(n, e), a = t.get(n.id);
    if (i && a && a.group) {
      var o = yl(i), s = o.z, l = o.zlevel;
      sm(a.group, s, l);
    }
  });
}
function gR(r, t, e) {
  var n = t.coordinateSystem, i = e.getWidth(), a = e.getHeight(), o = n && n.getArea && n.getArea();
  r.each(function(s) {
    var l = r.getItemModel(s), u = l.get("relativeTo") === "coordinate", c = u ? o ? o.width : 0 : i, f = u ? o ? o.height : 0 : a, h = u && o ? o.x : 0, d = u && o ? o.y : 0, p, g = dt(l.get("x"), c) + h, v = dt(l.get("y"), f) + d;
    if (!isNaN(g) && !isNaN(v))
      p = [g, v];
    else if (t.getMarkerPosition)
      p = t.getMarkerPosition(r.getValues(r.dimensions, s));
    else if (n) {
      var m = r.get(n.dimensions[0], s), y = r.get(n.dimensions[1], s);
      p = n.dataToPoint([m, y]);
    }
    isNaN(g) || (p[0] = g), isNaN(v) || (p[1] = v), r.setItemLayout(s, p);
  });
}
var vst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = ua.getMarkerModelFromSeries(a, "markPoint");
        o && (gR(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Yh()), f = gst(o, e, n);
      n.setData(f), gR(n.getData(), e, a), f.each(function(h) {
        var d = f.getItemModel(h), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (At(p) || At(g) || At(v) || At(m)) {
          var _ = n.getRawValue(h), x = n.getDataParams(h);
          At(p) && (p = p(_, x)), At(g) && (g = g(_, x)), At(v) && (v = v(_, x)), At(m) && (m = m(_, x));
        }
        var b = d.getModel("itemStyle").getItemStyle(), S = d.get("z2"), w = Gh(l, "color");
        b.fill || (b.fill = w), f.setItemVisual(h, {
          z2: bt(S, 0),
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: b
        });
      }), c.updateData(f), this.group.add(c.group), f.eachItemGraphicEl(function(h) {
        h.traverse(function(d) {
          zt(d).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markPoint", t;
  }(Rw)
);
function gst(r, t, e) {
  var n;
  r ? n = rt(r && r.dimensions, function(s) {
    var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
    return j(j({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new cn(n, e), a = rt(e.get("data"), Yt(Eh, t));
  r && (a = Te(a, Yt(Ch, r)));
  var o = VV(!!r, n);
  return i.initData(a, null, o), i;
}
function mst(r) {
  r.registerComponentModel(cst), r.registerComponentView(vst), r.registerPreprocessor(function(t) {
    Lw(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
  });
}
var yst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markLine", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, t;
  }(ua)
), Op = ee(), _st = function(r, t, e, n) {
  var i = r.getData(), a;
  if (et(n))
    a = n;
  else {
    var o = n.type;
    if (o === "min" || o === "max" || o === "average" || o === "median" || n.xAxis != null || n.yAxis != null) {
      var s = void 0, l = void 0;
      if (n.yAxis != null || n.xAxis != null)
        s = t.getAxis(n.yAxis != null ? "y" : "x"), l = mr(n.yAxis, n.xAxis);
      else {
        var u = BV(n, i, t, r);
        s = u.valueAxis;
        var c = ck(i, u.valueDataDim);
        l = wg(i, c, o);
      }
      var f = s.dim === "x" ? 0 : 1, h = 1 - f, d = Dt(n), p = {
        coord: []
      };
      d.type = null, d.coord = [], d.coord[h] = -1 / 0, p.coord[h] = 1 / 0;
      var g = e.get("precision");
      g >= 0 && fe(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[f] = p.coord[f] = l, a = [d, p, {
        type: o,
        valueIndex: n.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && mi("Invalid markLine data."), a = [];
  }
  var v = [Eh(r, a[0]), Eh(r, a[1]), j({}, a[2])];
  return v[2].type = v[2].type || null, qt(v[2], v[0]), qt(v[2], v[1]), v;
};
function Mg(r) {
  return !isNaN(r) && !isFinite(r);
}
function mR(r, t, e, n) {
  var i = 1 - r, a = n.dimensions[r];
  return Mg(t[i]) && Mg(e[i]) && t[r] === e[r] && n.getAxis(a).containData(t[r]);
}
function xst(r, t) {
  if (r.type === "cartesian2d") {
    var e = t[0].coord, n = t[1].coord;
    if (e && n && (mR(1, e, n, r) || mR(0, e, n, r)))
      return !0;
  }
  return Ch(r, t[0]) && Ch(r, t[1]);
}
function L_(r, t, e, n, i) {
  var a = n.coordinateSystem, o = r.getItemModel(t), s, l = dt(o.get("x"), i.getWidth()), u = dt(o.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(r.getValues(r.dimensions, t));
    else {
      var c = a.dimensions, f = r.get(c[0], t), h = r.get(c[1], t);
      s = a.dataToPoint([f, h]);
    }
    if (Xo(a, "cartesian2d")) {
      var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
      Mg(r.get(c[0], t)) ? s[0] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]) : Mg(r.get(c[1], t)) && (s[1] = p.toGlobalCoord(p.getExtent()[e ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  r.setItemLayout(t, s);
}
var Sst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = ua.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = Op(o).from, u = Op(o).to;
          l.each(function(c) {
            L_(l, c, !0, a, i), L_(u, c, !1, a, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Kb());
      this.group.add(c.group);
      var f = bst(o, e, n), h = f.from, d = f.to, p = f.line;
      Op(n).from = h, Op(n).to = d, n.setData(p);
      var g = n.get("symbol"), v = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      et(g) || (g = [g, g]), et(v) || (v = [v, v]), et(m) || (m = [m, m]), et(y) || (y = [y, y]), f.from.each(function(x) {
        _(h, x, !0), _(d, x, !1);
      }), p.each(function(x) {
        var b = p.getItemModel(x), S = b.getModel("lineStyle").getLineStyle();
        p.setItemLayout(x, [h.getItemLayout(x), d.getItemLayout(x)]);
        var w = b.get("z2");
        S.stroke == null && (S.stroke = h.getItemVisual(x, "style").fill), p.setItemVisual(x, {
          z2: bt(w, 0),
          fromSymbolKeepAspect: h.getItemVisual(x, "symbolKeepAspect"),
          fromSymbolOffset: h.getItemVisual(x, "symbolOffset"),
          fromSymbolRotate: h.getItemVisual(x, "symbolRotate"),
          fromSymbolSize: h.getItemVisual(x, "symbolSize"),
          fromSymbol: h.getItemVisual(x, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(x, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(x, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(x, "symbolRotate"),
          toSymbolSize: d.getItemVisual(x, "symbolSize"),
          toSymbol: d.getItemVisual(x, "symbol"),
          style: S
        });
      }), c.updateData(p), f.line.eachItemGraphicEl(function(x) {
        zt(x).dataModel = n, x.traverse(function(b) {
          zt(b).dataModel = n;
        });
      });
      function _(x, b, S) {
        var w = x.getItemModel(b);
        L_(x, b, S, e, a);
        var A = w.getModel("itemStyle").getItemStyle();
        A.fill == null && (A.fill = Gh(l, "color")), x.setItemVisual(b, {
          symbolKeepAspect: w.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: bt(w.get("symbolOffset", !0), y[S ? 0 : 1]),
          symbolRotate: bt(w.get("symbolRotate", !0), m[S ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: bt(w.get("symbolSize"), v[S ? 0 : 1]),
          symbol: bt(w.get("symbol", !0), g[S ? 0 : 1]),
          style: A
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markLine", t;
  }(Rw)
);
function bst(r, t, e) {
  var n;
  r ? n = rt(r && r.dimensions, function(u) {
    var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
    return j(j({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new cn(n, e), a = new cn(n, e), o = new cn([], e), s = rt(e.get("data"), Yt(_st, t, r, e));
  r && (s = Te(s, Yt(xst, r)));
  var l = VV(!!r, n);
  return i.initData(rt(s, function(u) {
    return u[0];
  }), null, l), a.initData(rt(s, function(u) {
    return u[1];
  }), null, l), o.initData(rt(s, function(u) {
    return u[2];
  })), o.hasItemOption = !0, {
    from: i,
    to: a,
    line: o
  };
}
function wst(r) {
  r.registerComponentModel(yst), r.registerComponentView(Sst), r.registerPreprocessor(function(t) {
    Lw(t.series, "markLine") && (t.markLine = t.markLine || {});
  });
}
var Mst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markArea", t.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, t;
  }(ua)
), kp = ee(), Tst = function(r, t, e, n) {
  var i = n[0], a = n[1];
  if (!(!i || !a)) {
    var o = Eh(r, i), s = Eh(r, a), l = o.coord, u = s.coord;
    l[0] = mr(l[0], -1 / 0), l[1] = mr(l[1], -1 / 0), u[0] = mr(u[0], 1 / 0), u[1] = mr(u[1], 1 / 0);
    var c = b1([{}, o, s]);
    return c.coord = [o.coord, s.coord], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function Tg(r) {
  return !isNaN(r) && !isFinite(r);
}
function yR(r, t, e, n) {
  var i = 1 - r;
  return Tg(t[i]) && Tg(e[i]);
}
function Ast(r, t) {
  var e = t.coord[0], n = t.coord[1], i = {
    coord: e,
    x: t.x0,
    y: t.y0
  }, a = {
    coord: n,
    x: t.x1,
    y: t.y1
  };
  return Xo(r, "cartesian2d") ? e && n && (yR(1, e, n) || yR(0, e, n)) ? !0 : dst(r, i, a) : Ch(r, i) || Ch(r, a);
}
function _R(r, t, e, n, i) {
  var a = n.coordinateSystem, o = r.getItemModel(t), s, l = dt(o.get(e[0]), i.getWidth()), u = dt(o.get(e[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition) {
      var c = r.getValues(["x0", "y0"], t), f = r.getValues(["x1", "y1"], t), h = a.clampData(c), d = a.clampData(f), p = [];
      e[0] === "x0" ? p[0] = h[0] > d[0] ? f[0] : c[0] : p[0] = h[0] > d[0] ? c[0] : f[0], e[1] === "y0" ? p[1] = h[1] > d[1] ? f[1] : c[1] : p[1] = h[1] > d[1] ? c[1] : f[1], s = n.getMarkerPosition(p, e, !0);
    } else {
      var g = r.get(e[0], t), v = r.get(e[1], t), m = [g, v];
      a.clampData && a.clampData(m, m), s = a.dataToPoint(m, !0);
    }
    if (Xo(a, "cartesian2d")) {
      var y = a.getAxis("x"), _ = a.getAxis("y"), g = r.get(e[0], t), v = r.get(e[1], t);
      Tg(g) ? s[0] = y.toGlobalCoord(y.getExtent()[e[0] === "x0" ? 0 : 1]) : Tg(v) && (s[1] = _.toGlobalCoord(_.getExtent()[e[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var xR = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], Est = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = ua.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = rt(xR, function(f) {
              return _R(s, l, f, a, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Ct()
      });
      this.group.add(c.group), this.markKeep(c);
      var f = Cst(o, e, n);
      n.setData(f), f.each(function(h) {
        var d = rt(xR, function(M) {
          return _R(f, h, M, e, a);
        }), p = o.getAxis("x").scale, g = o.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [p.parse(f.get("x0", h)), p.parse(f.get("x1", h))], _ = [g.parse(f.get("y0", h)), g.parse(f.get("y1", h))];
        ri(y), ri(_);
        var x = !(v[0] > y[1] || v[1] < y[0] || m[0] > _[1] || m[1] < _[0]), b = !x;
        f.setItemLayout(h, {
          points: d,
          allClipped: b
        });
        var S = f.getItemModel(h), w = S.getModel("itemStyle").getItemStyle(), A = S.get("z2"), T = Gh(l, "color");
        w.fill || (w.fill = T, pt(w.fill) && (w.fill = Mv(w.fill, 0.4))), w.stroke || (w.stroke = T), f.setItemVisual(h, "style", w), f.setItemVisual(h, "z2", bt(A, 0));
      }), f.diff(kp(c).data).add(function(h) {
        var d = f.getItemLayout(h), p = f.getItemVisual(h, "z2");
        if (!d.allClipped) {
          var g = new Jr({
            z2: bt(p, 0),
            shape: {
              points: d.points
            }
          });
          f.setItemGraphicEl(h, g), c.group.add(g);
        }
      }).update(function(h, d) {
        var p = kp(c).data.getItemGraphicEl(d), g = f.getItemLayout(h), v = f.getItemVisual(h, "z2");
        g.allClipped ? p && c.group.remove(p) : (p ? ve(p, {
          z2: bt(v, 0),
          shape: {
            points: g.points
          }
        }, n, h) : p = new Jr({
          shape: {
            points: g.points
          }
        }), f.setItemGraphicEl(h, p), c.group.add(p));
      }).remove(function(h) {
        var d = kp(c).data.getItemGraphicEl(h);
        c.group.remove(d);
      }).execute(), f.eachItemGraphicEl(function(h, d) {
        var p = f.getItemModel(d), g = f.getItemVisual(d, "style");
        h.useStyle(f.getItemVisual(d, "style")), Cr(h, xr(p), {
          labelFetcher: n,
          labelDataIndex: d,
          defaultText: f.getName(d) || "",
          inheritColor: pt(g.fill) ? Mv(g.fill, 1) : X.color.neutral99
        }), _r(h, p), He(h, null, null, p.get(["emphasis", "disabled"])), zt(h).dataModel = n;
      }), kp(c).data = f, c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markArea", t;
  }(Rw)
);
function Cst(r, t, e) {
  var n, i, a = ["x0", "y0", "x1", "y1"];
  if (r) {
    var o = rt(r && r.dimensions, function(u) {
      var c = t.getData(), f = c.getDimensionInfo(c.mapDimension(u)) || {};
      return j(j({}, f), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = rt(a, function(u, c) {
      return {
        name: u,
        type: o[c % 2].type
      };
    }), n = new cn(i, e);
  } else
    i = [{
      name: "value",
      type: "float"
    }], n = new cn(i, e);
  var s = rt(e.get("data"), Yt(Tst, t, r, e));
  r && (s = Te(s, Yt(Ast, r)));
  var l = r ? function(u, c, f, h) {
    var d = u.coord[Math.floor(h / 2)][h % 2];
    return Bo(d, i[h]);
  } : function(u, c, f, h) {
    return Bo(u.value, i[h]);
  };
  return n.initData(s, null, l), n.hasItemOption = !0, n;
}
function Dst(r) {
  r.registerComponentModel(Mst), r.registerComponentView(Est), r.registerPreprocessor(function(t) {
    Lw(t.series, "markArea") && (t.markArea = t.markArea || {});
  });
}
var Lst = function(r, t) {
  if (t === "all")
    return {
      type: "all",
      title: r.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (t === "inverse")
    return {
      type: "inverse",
      title: r.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, t1 = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i), e.selected = e.selected || {}, this._updateSelector(e);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), this._updateSelector(e);
    }, t.prototype._updateSelector = function(e) {
      var n = e.selector, i = this.ecModel;
      n === !0 && (n = e.selector = ["all", "inverse"]), et(n) && L(n, function(a, o) {
        pt(a) && (a = {
          type: a
        }), n[o] = qt(a, Lst(i, a.type));
      });
    }, t.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var e = this._data;
      if (e[0] && this.get("selectedMode") === "single") {
        for (var n = !1, i = 0; i < e.length; i++) {
          var a = e[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), n = !0;
            break;
          }
        }
        !n && this.select(e[0].get("name"));
      }
    }, t.prototype._updateData = function(e) {
      var n = [], i = [];
      e.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var f = l.legendVisualProvider, h = f.getAllNames();
          e.isSeriesFiltered(l) || (i = i.concat(h)), h.length ? n = n.concat(h) : c = !0;
        } else
          c = !0;
        c && R1(l) && n.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || n, o = wt(), s = rt(a, function(l) {
        return (pt(l) || fe(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new ue(l, this, this.ecModel));
      }, this);
      this._data = Te(s, function(l) {
        return !!l;
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.select = function(e) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        L(a, function(o) {
          n[o.get("name")] = !1;
        });
      }
      n[e] = !0;
    }, t.prototype.unSelect = function(e) {
      this.get("selectedMode") !== "single" && (this.option.selected[e] = !1);
    }, t.prototype.toggleSelected = function(e) {
      var n = this.option.selected;
      n.hasOwnProperty(e) || (n[e] = !0), this[n[e] ? "unSelect" : "select"](e);
    }, t.prototype.allSelect = function() {
      var e = this._data, n = this.option.selected;
      L(e, function(i) {
        n[i.get("name", !0)] = !0;
      });
    }, t.prototype.inverseSelect = function() {
      var e = this._data, n = this.option.selected;
      L(e, function(i) {
        var a = i.get("name", !0);
        n.hasOwnProperty(a) || (n[a] = !0), n[a] = !n[a];
      });
    }, t.prototype.isSelected = function(e) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(e) && !n[e]) && Zt(this._availableNames, e) >= 0;
    }, t.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      // top: 0,
      bottom: X.size.m,
      align: "auto",
      backgroundColor: X.color.transparent,
      borderColor: X.color.border,
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 8,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: X.color.disabled,
      inactiveBorderColor: X.color.disabled,
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: X.color.disabled,
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: X.color.secondary
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: X.color.tertiary,
        borderWidth: 1,
        borderColor: X.color.border
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: X.color.quaternary
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      },
      triggerEvent: !1
    }, t;
  }(re)
), wu = Yt, e1 = L, Bp = Ct, FV = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = !1, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._contentGroup = new Bp()), this.group.add(this._selectorGroup = new Bp()), this._isFirstRender = !0;
    }, t.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, t.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, t.prototype.render = function(e, n, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!e.get("show", !0)) {
        var o = e.get("align"), s = e.get("orient");
        (!o || o === "auto") && (o = e.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = e.get("selector", !0), u = e.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, e, n, i, l, s, u);
        var c = Sr(e, i).refContainer, f = e.getBoxLayoutParams(), h = e.get("padding"), d = We(f, c, h), p = this.layoutInner(e, o, d, a, l, u), g = We(Bt({
          width: p.width,
          height: p.height
        }, f), c, h);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = EV(
          p,
          // FXIME: most itemStyle options does not work in background because inherit is not handled yet.
          e
        ));
      }
    }, t.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, t.prototype.renderInner = function(e, n, i, a, o, s, l) {
      var u = this.getContentGroup(), c = wt(), f = n.get("selectedMode"), h = n.get("triggerEvent"), d = [];
      i.eachRawSeries(function(p) {
        !p.get("legendHoverLink") && d.push(p.id);
      }), e1(n.getData(), function(p, g) {
        var v = this, m = p.get("name");
        if (!this.newlineDisabled && (m === "" || m === `
`)) {
          var y = new Bp();
          y.newline = !0, u.add(y);
          return;
        }
        var _ = i.getSeriesByName(m)[0];
        if (!c.get(m)) {
          if (_) {
            var x = _.getData(), b = x.getVisual("legendLineStyle") || {}, S = x.getVisual("legendIcon"), w = x.getVisual("style"), A = this._createItem(_, m, g, p, n, e, b, w, S, f, a);
            A.on("click", wu(SR, m, null, a, d)).on("mouseover", wu(r1, _.name, null, a, d)).on("mouseout", wu(n1, _.name, null, a, d)), i.ssr && A.eachChild(function(T) {
              var M = zt(T);
              M.seriesIndex = _.seriesIndex, M.dataIndex = g, M.ssrType = "legend";
            }), h && A.eachChild(function(T) {
              v.packEventData(T, n, _, g, m);
            }), c.set(m, !0);
          } else
            i.eachRawSeries(function(T) {
              var M = this;
              if (!c.get(m) && T.legendVisualProvider) {
                var C = T.legendVisualProvider;
                if (!C.containName(m))
                  return;
                var R = C.indexOfName(m), E = C.getItemVisual(R, "style"), D = C.getItemVisual(R, "legendIcon"), I = wn(E.fill);
                I && I[3] === 0 && (I[3] = 0.2, E = j(j({}, E), {
                  fill: Qi(I, "rgba")
                }));
                var P = this._createItem(T, m, g, p, n, e, {}, E, D, f, a);
                P.on("click", wu(SR, null, m, a, d)).on("mouseover", wu(r1, null, m, a, d)).on("mouseout", wu(n1, null, m, a, d)), i.ssr && P.eachChild(function(O) {
                  var N = zt(O);
                  N.seriesIndex = T.seriesIndex, N.dataIndex = g, N.ssrType = "legend";
                }), h && P.eachChild(function(O) {
                  M.packEventData(O, n, T, g, m);
                }), c.set(m, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(m) || console.warn(m + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), o && this._createSelector(o, n, a, s, l);
    }, t.prototype.packEventData = function(e, n, i, a, o) {
      var s = {
        componentType: "legend",
        componentIndex: n.componentIndex,
        dataIndex: a,
        value: o,
        seriesIndex: i.seriesIndex
      };
      zt(e).eventData = s;
    }, t.prototype._createSelector = function(e, n, i, a, o) {
      var s = this.getSelectorGroup();
      e1(e, function(u) {
        var c = u.type, f = new pe({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: n.id
            });
          }
        });
        s.add(f);
        var h = n.getModel("selectorLabel"), d = n.getModel(["emphasis", "selectorLabel"]);
        Cr(f, {
          normal: h,
          emphasis: d
        }, {
          defaultText: u.title
        }), ol(f);
      });
    }, t.prototype._createItem = function(e, n, i, a, o, s, l, u, c, f, h) {
      var d = e.visualDrawType, p = o.get("itemWidth"), g = o.get("itemHeight"), v = o.isSelected(n), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), _ = a.get("icon");
      c = _ || c || "roundRect";
      var x = Rst(c, a, l, u, d, v, h), b = new Bp(), S = a.getModel("textStyle");
      if (At(e.getLegendIcon) && (!_ || _ === "inherit"))
        b.add(e.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: m,
          itemStyle: x.itemStyle,
          lineStyle: x.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var w = _ === "inherit" && e.getData().getVisual("symbol") ? m === "inherit" ? e.getData().getVisual("symbolRotate") : m : 0;
        b.add(Ist({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: w,
          itemStyle: x.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var A = s === "left" ? p + 5 : -5, T = s, M = o.get("formatter"), C = n;
      pt(M) && M ? C = M.replace("{name}", n ?? "") : At(M) && (C = M(n));
      var R = v ? S.getTextColor() : a.get("inactiveColor");
      b.add(new pe({
        style: Oe(S, {
          text: C,
          x: A,
          y: g / 2,
          fill: R,
          align: T,
          verticalAlign: "middle"
        }, {
          inheritColor: R
        })
      }));
      var E = new te({
        shape: b.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), D = a.getModel("tooltip");
      return D.get("show") && ja({
        el: E,
        componentModel: o,
        itemName: n,
        itemTooltipOption: D.option
      }), b.add(E), b.eachChild(function(I) {
        I.silent = !0;
      }), E.silent = !f, this.getContentGroup().add(b), ol(b), b.__legendDataIndex = i, b;
    }, t.prototype.layoutInner = function(e, n, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      ll(e.get("orient"), l, e.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), f = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        ll(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          e.get("selectorItemGap", !0)
        );
        var h = u.getBoundingRect(), d = [-h.x, -h.y], p = e.get("selectorButtonGap", !0), g = e.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? d[g] += c[v] + p : f[g] += h[v] + p, d[1 - g] += c[m] / 2 - h[m] / 2, u.x = d[0], u.y = d[1], l.x = f[0], l.y = f[1];
        var _ = {
          x: 0,
          y: 0
        };
        return _[v] = c[v] + p + h[v], _[m] = Math.max(c[m], h[m]), _[y] = Math.min(0, h[y] + d[1 - g]), _;
      } else
        return l.x = f[0], l.y = f[1], this.group.getBoundingRect();
    }, t.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, t.type = "legend.plain", t;
  }(Ge)
);
function Rst(r, t, e, n, i, a, o) {
  function s(v, m) {
    v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), e1(v, function(y, _) {
      v[_] === "inherit" && (v[_] = m[_]);
    });
  }
  var l = t.getModel("itemStyle"), u = l.getItemStyle(), c = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", f = l.getShallow("decal");
  u.decal = !f || f === "inherit" ? n.decal : oc(f, o), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : e).opacity), s(u, n);
  var h = t.getModel("lineStyle"), d = h.getLineStyle();
  if (s(d, e), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), d.stroke === "auto" && (d.stroke = n.fill), !a) {
    var p = t.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? n.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), d.stroke = h.get("inactiveColor"), d.lineWidth = h.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: d
  };
}
function Ist(r) {
  var t = r.icon || "roundRect", e = hr(t, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
  return e.setStyle(r.itemStyle), e.rotation = (r.iconRotate || 0) * Math.PI / 180, e.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), t.indexOf("empty") > -1 && (e.style.stroke = e.style.fill, e.style.fill = X.color.neutral00, e.style.lineWidth = 2), e;
}
function SR(r, t, e, n) {
  n1(r, t, e, n), e.dispatchAction({
    type: "legendToggleSelect",
    name: r ?? t
  }), r1(r, t, e, n);
}
function zV(r) {
  for (var t = r.getZr().storage.getDisplayList(), e, n = 0, i = t.length; n < i && !(e = t[n].states.emphasis); )
    n++;
  return e && e.hoverLayer;
}
function r1(r, t, e, n) {
  zV(e) || e.dispatchAction({
    type: "highlight",
    seriesName: r,
    name: t,
    excludeSeriesId: n
  });
}
function n1(r, t, e, n) {
  zV(e) || e.dispatchAction({
    type: "downplay",
    seriesName: r,
    name: t,
    excludeSeriesId: n
  });
}
function Pst(r) {
  var t = r.findComponents({
    mainType: "legend"
  });
  t && t.length && r.filterSeries(function(e) {
    for (var n = 0; n < t.length; n++)
      if (!t[n].isSelected(e.name))
        return !1;
    return !0;
  });
}
function bf(r, t, e) {
  var n = r === "allSelect" || r === "inverseSelect", i = {}, a = [];
  e.eachComponent({
    mainType: "legend",
    query: t
  }, function(s) {
    n ? s[r]() : s[r](t.name), bR(s, i), a.push(s.componentIndex);
  });
  var o = {};
  return e.eachComponent("legend", function(s) {
    L(i, function(l, u) {
      s[l ? "select" : "unSelect"](u);
    }), bR(s, o);
  }), n ? {
    selected: o,
    // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
    legendIndex: a
  } : {
    name: t.name,
    selected: o
  };
}
function bR(r, t) {
  var e = t || {};
  return L(r.getData(), function(n) {
    var i = n.get("name");
    if (!(i === `
` || i === "")) {
      var a = r.isSelected(i);
      _t(e, i) ? e[i] = e[i] && a : e[i] = a;
    }
  }), e;
}
function Nst(r) {
  r.registerAction("legendToggleSelect", "legendselectchanged", Yt(bf, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Yt(bf, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Yt(bf, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Yt(bf, "select")), r.registerAction("legendUnSelect", "legendunselected", Yt(bf, "unSelect"));
}
function UV(r) {
  r.registerComponentModel(t1), r.registerComponentView(FV), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, Pst), r.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), Nst(r);
}
var Ost = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.setScrollDataIndex = function(e) {
      this.option.scrollDataIndex = e;
    }, t.prototype.init = function(e, n, i) {
      var a = Cl(e);
      r.prototype.init.call(this, e, n, i), wR(this, e, a);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), wR(this, this.option, e);
    }, t.type = "legend.scroll", t.defaultOption = Jo(t1.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: X.color.accent50,
      pageIconInactiveColor: X.color.accent10,
      pageIconSize: 15,
      pageTextStyle: {
        color: X.color.tertiary
      },
      animationDurationUpdate: 800
    }), t;
  }(t1)
);
function wR(r, t, e) {
  var n = r.getOrient(), i = [1, 1];
  i[n.index] = 0, sa(t, e, {
    type: "box",
    ignoreSize: !!i
  });
}
var MR = Ct, R_ = ["width", "height"], I_ = ["x", "y"], kst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = !0, e._currentIndex = 0, e;
    }
    return t.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new MR()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new MR());
    }, t.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, t.prototype.renderInner = function(e, n, i, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, e, n, i, a, o, s, l);
      var c = this._controllerGroup, f = n.get("pageIconSize", !0), h = et(f) ? f : [f, f];
      p("pagePrev", 0);
      var d = n.getModel("pageTextStyle");
      c.add(new pe({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = Fh(n.get("pageIcons", !0)[n.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: gt(u._pageGo, u, m, n, a)
        }, {
          x: -h[0] / 2,
          y: -h[1] / 2,
          width: h[0],
          height: h[1]
        });
        y.name = g, c.add(y);
      }
    }, t.prototype.layoutInner = function(e, n, i, a, o, s) {
      var l = this.getSelectorGroup(), u = e.getOrient().index, c = R_[u], f = I_[u], h = R_[1 - u], d = I_[1 - u];
      o && ll(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        e.get("selectorItemGap", !0)
      );
      var p = e.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], m = Dt(i);
      o && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(e, a, m, u, c, h, d, f);
      if (o) {
        if (s === "end")
          v[u] += y[c] + p;
        else {
          var _ = g[c] + p;
          v[u] -= _, y[f] -= _;
        }
        y[c] += g[c] + p, v[1 - u] += y[d] + y[h] / 2 - g[h] / 2, y[h] = Math.max(y[h], g[h]), y[d] = Math.min(y[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, t.prototype._layoutContentAndController = function(e, n, i, a, o, s, l, u) {
      var c = this.getContentGroup(), f = this._containerGroup, h = this._controllerGroup;
      ll(e.get("orient"), c, e.get("itemGap"), a ? i.width : null, a ? null : i.height), ll(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        h,
        e.get("pageButtonItemGap", !0)
      );
      var d = c.getBoundingRect(), p = h.getBoundingRect(), g = this._showController = d[o] > i[o], v = [-d.x, -d.y];
      n || (v[a] = c[u]);
      var m = [0, 0], y = [-p.x, -p.y], _ = bt(e.get("pageButtonGap", !0), e.get("itemGap", !0));
      if (g) {
        var x = e.get("pageButtonPosition", !0);
        x === "end" ? y[a] += i[o] - p[o] : m[a] += p[o] + _;
      }
      y[1 - a] += d[s] / 2 - p[s] / 2, c.setPosition(v), f.setPosition(m), h.setPosition(y);
      var b = {
        x: 0,
        y: 0
      };
      if (b[o] = g ? i[o] : d[o], b[s] = Math.max(d[s], p[s]), b[l] = Math.min(0, p[l] + y[1 - a]), f.__rectSize = i[o], g) {
        var S = {
          x: 0,
          y: 0
        };
        S[o] = Math.max(i[o] - p[o] - _, 0), S[s] = b[s], f.setClipPath(new te({
          shape: S
        })), f.__rectSize = S[o];
      } else
        h.eachChild(function(A) {
          A.attr({
            invisible: !0,
            silent: !0
          });
        });
      var w = this._getPageInfo(e);
      return w.pageIndex != null && ve(
        c,
        {
          x: w.contentPosition[0],
          y: w.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? e : null
      ), this._updatePageInfoView(e, w), b;
    }, t.prototype._pageGo = function(e, n, i) {
      var a = this._getPageInfo(n)[e];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: n.id
      });
    }, t.prototype._updatePageInfoView = function(e, n) {
      var i = this._controllerGroup;
      L(["pagePrev", "pageNext"], function(c) {
        var f = c + "DataIndex", h = n[f] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", h ? e.get("pageIconColor", !0) : e.get("pageIconInactiveColor", !0)), d.cursor = h ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = e.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      a && o && a.setStyle("text", pt(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, t.prototype._getPageInfo = function(e) {
      var n = e.get("scrollDataIndex", !0), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = e.getOrient().index, s = R_[o], l = I_[o], u = this._findTargetItemIndex(n), c = i.children(), f = c[u], h = c.length, d = h ? 1 : 0, p = {
        contentPosition: [i.x, i.y],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!f)
        return p;
      var g = x(f);
      p.contentPosition[o] = -g.s;
      for (var v = u + 1, m = g, y = g, _ = null; v <= h; ++v)
        _ = x(c[v]), // Half of the last item is out of the window.
        (!_ && y.e > m.s + a || _ && !b(_, m.s)) && (y.i > m.i ? m = y : m = _, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = _;
      for (var v = u - 1, m = g, y = g, _ = null; v >= -1; --v)
        _ = x(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!_ || !b(y, _.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = _;
      return p;
      function x(S) {
        if (S) {
          var w = S.getBoundingRect(), A = w[l] + S[l];
          return {
            s: A,
            e: A + w[s],
            i: S.__legendDataIndex
          };
        }
      }
      function b(S, w) {
        return S.e >= w && S.s <= w + a;
      }
    }, t.prototype._findTargetItemIndex = function(e) {
      if (!this._showController)
        return 0;
      var n, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === e && (n = s);
      }), n ?? a;
    }, t.type = "legend.scroll", t;
  }(FV)
);
function Bst(r) {
  r.registerAction("legendScroll", "legendscroll", function(t, e) {
    var n = t.scrollDataIndex;
    n != null && e.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: t
    }, function(i) {
      i.setScrollDataIndex(n);
    });
  });
}
function Vst(r) {
  jt(UV), r.registerComponentModel(Ost), r.registerComponentView(kst), Bst(r);
}
function Fst(r) {
  jt(UV), jt(Vst);
}
var zst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.inside", t.defaultOption = Jo(Ah.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), t;
  }(Ah)
), Iw = ee();
function Ust(r, t, e) {
  Iw(r).coordSysRecordMap.each(function(n) {
    var i = n.dataZoomInfoMap.get(t.uid);
    i && (i.getRange = e);
  });
}
function Gst(r, t) {
  for (var e = Iw(r).coordSysRecordMap, n = e.keys(), i = 0; i < n.length; i++) {
    var a = n[i], o = e.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = t.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || GV(e, o));
    }
  }
}
function GV(r, t) {
  if (t) {
    r.removeKey(t.model.uid);
    var e = t.controller;
    e && e.dispose();
  }
}
function Hst(r, t) {
  var e = {
    model: t,
    containsPoint: Yt(Xst, t),
    dispatchAction: Yt(Wst, r),
    dataZoomInfoMap: null,
    controller: null
  }, n = e.controller = new Pl(r.getZr());
  return L(["pan", "zoom", "scrollMove"], function(i) {
    n.on(i, function(a) {
      var o = [];
      e.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && e.dispatchAction(o);
    });
  }), e;
}
function Wst(r, t) {
  r.isDisposed() || r.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: t
  });
}
function Xst(r, t, e, n) {
  return r.coordinateSystem.containPoint([e, n]);
}
function Yst(r, t, e) {
  var n, i = "type_", a = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, o = !0;
  return r.each(function(s) {
    var l = s.model, u = l.get("disabled", !0) ? !1 : l.get("zoomLock", !0) ? "move" : !0;
    a[i + u] > a[i + n] && (n = u), o = o && l.get("preventDefaultMouseMove", !0);
  }), {
    controlType: n,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!o,
      api: e,
      zInfo: {
        component: t.model
      },
      triggerInfo: {
        roamTrigger: null,
        isInSelf: t.containsPoint
      }
    }
  };
}
function $st(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(t, e) {
    var n = Iw(e), i = n.coordSysRecordMap || (n.coordSysRecordMap = wt());
    i.each(function(a) {
      a.dataZoomInfoMap = null;
    }), t.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = MV(a);
      L(o.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, Hst(e, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = wt());
        c.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), i.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        GV(i, a);
        return;
      }
      var c = Yst(l, a, e);
      o.enable(c.controlType, c.opt), Lc(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var Zst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataZoom.inside", e;
    }
    return t.prototype.render = function(e, n, i) {
      if (r.prototype.render.apply(this, arguments), e.noTarget()) {
        this._clear();
        return;
      }
      this.range = e.getPercentRange(), Ust(i, e, {
        pan: gt(P_.pan, this),
        zoom: gt(P_.zoom, this),
        scrollMove: gt(P_.scrollMove, this)
      });
    }, t.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      Gst(this.api, this.dataZoomModel), this.range = null;
    }, t.type = "dataZoom.inside", t;
  }(Mw)
), P_ = {
  zoom: function(r, t, e, n) {
    var i = this.range, a = i.slice(), o = r.axisModels[0];
    if (o) {
      var s = N_[t](null, [n.originX, n.originY], o, e, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / n.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Yo(0, a, [0, 100], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1])
        return a;
    }
  },
  pan: TR(function(r, t, e, n, i, a) {
    var o = N_[n]([a.oldX, a.oldY], [a.newX, a.newY], t, i, e);
    return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: TR(function(r, t, e, n, i, a) {
    var o = N_[n]([0, 0], [a.scrollDelta, a.scrollDelta], t, i, e);
    return o.signal * (r[1] - r[0]) * a.scrollDelta;
  })
};
function TR(r) {
  return function(t, e, n, i) {
    var a = this.range, o = a.slice(), s = t.axisModels[0];
    if (s) {
      var l = r(o, s, t, e, n, i);
      if (Yo(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var N_ = {
  grid: function(r, t, e, n, i) {
    var a = e.axis, o = {}, s = i.model.coordinateSystem.getRect();
    return r = r || [0, 0], a.dim === "x" ? (o.pixel = t[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(r, t, e, n, i) {
    var a = e.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return r = r ? s.pointToCoord(r) : [0, 0], t = s.pointToCoord(t), e.mainType === "radiusAxis" ? (o.pixel = t[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(r, t, e, n, i) {
    var a = e.axis, o = i.model.coordinateSystem.getRect(), s = {};
    return r = r || [0, 0], a.orient === "horizontal" ? (s.pixel = t[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
function HV(r) {
  Tw(r), r.registerComponentModel(zst), r.registerComponentView(Zst), $st(r);
}
var qst = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = Jo(Ah.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: X.color.accent10,
      borderRadius: 0,
      backgroundColor: X.color.transparent,
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: X.color.accent30,
          width: 0.5
        },
        areaStyle: {
          color: X.color.accent20,
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: X.color.accent40,
          width: 0.5
        },
        areaStyle: {
          color: X.color.accent20,
          opacity: 0.3
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: X.color.neutral00,
        borderColor: X.color.accent20
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: X.color.accent40,
        opacity: 0.5
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: X.color.tertiary
      },
      brushSelect: !0,
      brushStyle: {
        color: X.color.accent30,
        opacity: 0.3
      },
      emphasis: {
        handleLabel: {
          show: !0
        },
        handleStyle: {
          borderColor: X.color.accent40
        },
        moveHandleStyle: {
          opacity: 0.8
        }
      },
      defaultLocationEdgeGap: 15
    }), t;
  }(Ah)
), wf = te, Kst = 1, O_ = 30, jst = 7, Mf = "horizontal", AR = "vertical", Jst = 5, Qst = ["line", "bar", "candlestick", "scatter"], tlt = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, elt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._displayables = {}, e;
    }
    return t.prototype.init = function(e, n) {
      this.api = n, this._onBrush = gt(this._onBrush, this), this._onBrushEnd = gt(this._onBrushEnd, this);
    }, t.prototype.render = function(e, n, i, a) {
      if (r.prototype.render.apply(this, arguments), Lc(this, "_dispatchZoomAction", e.get("throttle"), "fixRate"), this._orient = e.getOrient(), e.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (e.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, t.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      fh(this, "_dispatchZoomAction");
      var e = this.api.getZr();
      e.off("mousemove", this._onBrush), e.off("mouseup", this._onBrushEnd);
    }, t.prototype._buildView = function() {
      var e = this.group;
      e.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new Ct();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), e.add(n), this._positionGroup();
    }, t.prototype._resetLocation = function() {
      var e = this.dataZoomModel, n = this.api, i = e.get("brushSelect"), a = i ? jst : 0, o = Sr(e, n).refContainer, s = this._findCoordRect(), l = e.get("defaultLocationEdgeGap", !0) || 0, u = this._orient === Mf ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: o.width - s.x - s.width,
        top: o.height - O_ - l - a,
        width: s.width,
        height: O_
      } : {
        right: l,
        top: s.y,
        width: O_,
        height: s.height
      }, c = Cl(e.option);
      L(["right", "top", "width", "height"], function(h) {
        c[h] === "ph" && (c[h] = u[h]);
      });
      var f = We(c, o);
      this._location = {
        x: f.x,
        y: f.y
      }, this._size = [f.width, f.height], this._orient === AR && this._size.reverse();
    }, t.prototype._positionGroup = function() {
      var e = this.group, n = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === Mf && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === Mf && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === AR && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = e.getBoundingRect([s]);
      e.x = n.x - u.x, e.y = n.y - u.y, e.markRedraw();
    }, t.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, t.prototype._renderBackground = function() {
      var e = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, a = e.get("brushSelect");
      i.add(new wf({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: e.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new wf({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: gt(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, t.prototype._renderDataShadow = function() {
      var e = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !e)
        return;
      var n = this._size, i = this._shadowSize || [], a = e.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var f = o.getDataExtent(e.thisDim), h = o.getDataExtent(l), d = (h[1] - h[0]) * 0.3;
        h = [h[0] - d, h[1] + d];
        var p = [0, n[1]], g = [0, n[0]], v = [[n[0], 0], [0, 0]], m = [], y = g[1] / Math.max(1, o.count() - 1), _ = n[0] / (f[1] - f[0]), x = e.thisAxis.type === "time", b = -y, S = Math.round(o.count() / n[0]), w;
        o.each([e.thisDim, l], function(R, E, D) {
          if (S > 0 && D % S) {
            x || (b += y);
            return;
          }
          b = x ? (+R - f[0]) * _ : b + y;
          var I = E == null || isNaN(E) || E === "", P = I ? 0 : Me(E, h, p, !0);
          I && !w && D ? (v.push([v[v.length - 1][0], 0]), m.push([m[m.length - 1][0], 0])) : !I && w && (v.push([b, 0]), m.push([b, 0])), I || (v.push([b, P]), m.push([b, P])), w = I;
        }), u = this._shadowPolygonPts = v, c = this._shadowPolylinePts = m;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [n[0], n[1]];
      var A = this.dataZoomModel;
      function T(R) {
        var E = A.getModel(R ? "selectedDataBackground" : "dataBackground"), D = new Ct(), I = new Jr({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: E.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), P = new Gr({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: E.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return D.add(I), D.add(P), D;
      }
      for (var M = 0; M < 3; M++) {
        var C = T(M === 1);
        this._displayables.sliderGroup.add(C), this._displayables.dataShadowSegs.push(C);
      }
    }, t.prototype._prepareDataShadowInfo = function() {
      var e = this.dataZoomModel, n = e.get("showDataShadow");
      if (n !== !1) {
        var i, a = this.ecModel;
        return e.eachTargetAxis(function(o, s) {
          var l = e.getAxisProxy(o, s).getTargetSeriesModels();
          L(l, function(u) {
            if (!i && !(n !== !0 && Zt(Qst, u.get("type")) < 0)) {
              var c = a.getComponent(Do(o), s).axis, f = rlt(o), h, d = u.coordinateSystem;
              f != null && d.getOtherAxis && (h = d.getOtherAxis(c).inverse), f = u.getData().mapDimension(f);
              var p = u.getData().mapDimension(o);
              i = {
                thisAxis: c,
                series: u,
                thisDim: p,
                otherDim: f,
                otherAxisInverse: h
              };
            }
          }, this);
        }, this), i;
      }
    }, t.prototype._renderHandle = function() {
      var e = this.group, n = this._displayables, i = n.handles = [null, null], a = n.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, f = l.get("brushSelect"), h = n.filler = new wf({
        silent: f,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(h), o.add(new wf({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: Kst,
          fill: X.color.transparent
        }
      })), L([0, 1], function(_) {
        var x = l.get("handleIcon");
        !Hv[x] && x.indexOf("path://") < 0 && x.indexOf("image://") < 0 && (x = "path://" + x, process.env.NODE_ENV !== "production" && aa("handleIcon now needs 'path://' prefix when using a path string"));
        var b = hr(x, -1, 0, 2, 2, null, !0);
        b.attr({
          cursor: nlt(this._orient),
          draggable: !0,
          drift: gt(this._onDragMove, this, _),
          ondragend: gt(this._onDragEnd, this),
          onmouseover: gt(this._showDataInfo, this, !0),
          onmouseout: gt(this._showDataInfo, this, !1),
          z2: 5
        });
        var S = b.getBoundingRect(), w = l.get("handleSize");
        this._handleHeight = dt(w, this._size[1]), this._handleWidth = S.width / S.height * this._handleHeight, b.setStyle(l.getModel("handleStyle").getItemStyle()), b.style.strokeNoScale = !0, b.rectHover = !0, b.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), ol(b);
        var A = l.get("handleColor");
        A != null && (b.style.fill = A), o.add(i[_] = b);
        var T = l.getModel("textStyle"), M = l.get("handleLabel") || {}, C = M.show || !1;
        e.add(a[_] = new pe({
          silent: !0,
          invisible: !C,
          style: Oe(T, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: T.getTextColor(),
            font: T.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = h;
      if (f) {
        var p = dt(l.get("moveHandleSize"), s[1]), g = n.moveHandle = new te({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = n.moveHandleIcon = hr(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, X.color.neutral00, !0);
        m.silent = !0, m.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        d = n.moveZone = new te({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), o.add(g), o.add(m), o.add(d);
      }
      d.attr({
        draggable: !0,
        cursor: "default",
        drift: gt(this._onDragMove, this, "all"),
        ondragstart: gt(this._showDataInfo, this, !0),
        ondragend: gt(this._onDragEnd, this),
        onmouseover: gt(this._showDataInfo, this, !0),
        onmouseout: gt(this._showDataInfo, this, !1)
      });
    }, t.prototype._resetInterval = function() {
      var e = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [Me(e[0], [0, 100], n, !0), Me(e[1], [0, 100], n, !0)];
    }, t.prototype._updateInterval = function(e, n) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Yo(n, a, o, i.get("zoomLock") ? "all" : e, s.minSpan != null ? Me(s.minSpan, l, o, !0) : null, s.maxSpan != null ? Me(s.maxSpan, l, o, !0) : null);
      var u = this._range, c = this._range = ri([Me(a[0], o, l, !0), Me(a[1], o, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, t.prototype._updateView = function(e) {
      var n = this._displayables, i = this._handleEnds, a = ri(i.slice()), o = this._size;
      L([0, 1], function(d) {
        var p = n.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[d] + (d ? -1 : 1),
          y: o[1] / 2 - g / 2
        });
      }, this), n.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0; c < l.length; c++) {
        var f = l[c], h = f.getClipPath();
        h || (h = new te(), f.setClipPath(h)), h.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(e);
    }, t.prototype._updateDataInfo = function(e) {
      var n = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = ["", ""];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, f = e ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(f[0], u), this._formatLabel(f[1], u)];
        }
      }
      var h = ri(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = sl(i.handles[p].parent, this.group), v = om(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + Jst, y = _i([h[p] + (p === 0 ? -m : m), this._size[1] / 2], g);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === Mf ? "middle" : v,
          align: o === Mf ? v : "center",
          text: s[p]
        });
      }
    }, t.prototype._formatLabel = function(e, n) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = n.getPixelPrecision());
      var s = e == null || isNaN(e) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(e)
      }) : e.toFixed(Math.min(o, 20));
      return At(a) ? a(e, s) : pt(a) ? a.replace("{value}", s) : s;
    }, t.prototype._showDataInfo = function(e) {
      var n = this.dataZoomModel.get("handleLabel") || {}, i = n.show || !1, a = this.dataZoomModel.getModel(["emphasis", "handleLabel"]), o = a.get("show") || !1, s = e || this._dragging ? o : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !s), u[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, t.prototype._onDragMove = function(e, n, i, a) {
      this._dragging = !0, Ga(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = _i([n, i], o, !0), l = this._updateInterval(e, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, t.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var e = this.dataZoomModel.get("realtime");
      !e && this._dispatchZoomAction(!1);
    }, t.prototype._onClickPanel = function(e) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, t.prototype._onBrushStart = function(e) {
      var n = e.offsetX, i = e.offsetY;
      this._brushStart = new Ot(n, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, t.prototype._onBrushEnd = function(e) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = !1, !!n) {
          n.attr("ignore", !0);
          var i = n.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100], l = this._handleEnds = [i.x, i.x + i.width], u = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
            Yo(0, l, o, 0, u.minSpan != null ? Me(u.minSpan, s, o, !0) : null, u.maxSpan != null ? Me(u.maxSpan, s, o, !0) : null), this._range = ri([Me(l[0], o, s, !0), Me(l[1], o, s, !0)]), this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, t.prototype._onBrush = function(e) {
      this._brushing && (Ga(e.event), this._updateBrushRect(e.offsetX, e.offsetY));
    }, t.prototype._updateBrushRect = function(e, n) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new wf({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(e, n), c = l.transformCoordToLocal(s.x, s.y), f = this._size;
      u[0] = Math.max(Math.min(f[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: f[1]
      });
    }, t.prototype._dispatchZoomAction = function(e) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: e ? tlt : null,
        start: n[0],
        end: n[1]
      });
    }, t.prototype._findCoordRect = function() {
      var e, n = MV(this.dataZoomModel).infoList;
      if (!e && n.length) {
        var i = n[0].model.coordinateSystem;
        e = i.getRect && i.getRect();
      }
      if (!e) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        e = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return e;
    }, t.type = "dataZoom.slider", t;
  }(Mw)
);
function rlt(r) {
  var t = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return t[r];
}
function nlt(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
function WV(r) {
  r.registerComponentModel(qst), r.registerComponentView(elt), Tw(r);
}
function ilt(r) {
  jt(HV), jt(WV);
}
var XV = {
  /**
   * @public
   */
  get: function(r, t, e) {
    var n = Dt((alt[r] || {})[t]);
    return e && et(n) ? n[n.length - 1] : n;
  }
}, alt = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: [X.color.transparent]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, ER = Tr.mapVisual, olt = Tr.eachVisual, slt = et, CR = L, llt = ri, ult = Me, Ag = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.stateList = ["inRange", "outOfRange"], e.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], e.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, e.dataBound = [-1 / 0, 1 / 0], e.targetVisuals = {}, e.controllerVisuals = {}, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.optionUpdated = function(e, n) {
      var i = this.option;
      !n && NV(i, e, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, t.prototype.resetVisual = function(e) {
      var n = this.stateList;
      e = gt(e, this), this.controllerVisuals = jS(this.option.controller, n, e), this.targetVisuals = jS(this.option.target, n, e);
    }, t.prototype.getItemSymbol = function() {
      return null;
    }, t.prototype.getTargetSeriesIndices = function() {
      var e = this.option.seriesId, n = this.option.seriesIndex;
      n == null && e == null && (n = "all");
      var i = bc(this.ecModel, "series", {
        index: n,
        id: e
      }, {
        useDefault: !1,
        enableAll: !0,
        enableNone: !1
      }).models;
      return rt(i, function(a) {
        return a.componentIndex;
      });
    }, t.prototype.eachTargetSeries = function(e, n) {
      L(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && e.call(n, a);
      }, this);
    }, t.prototype.isTargetSeries = function(e) {
      var n = !1;
      return this.eachTargetSeries(function(i) {
        i === e && (n = !0);
      }), n;
    }, t.prototype.formatValueText = function(e, n, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || ["<", ">"], et(e) && (e = e.slice(), u = !0);
      var c = n ? e : u ? [f(e[0]), f(e[1])] : f(e);
      if (pt(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (At(l))
        return u ? l(e[0], e[1]) : l(e);
      if (u)
        return e[0] === s[0] ? i[0] + " " + c[1] : e[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function f(h) {
        return h === s[0] ? "min" : h === s[1] ? "max" : (+h).toFixed(Math.min(o, 20));
      }
    }, t.prototype.resetExtent = function() {
      var e = this.option, n = llt([e.min, e.max]);
      this._dataExtent = n;
    }, t.prototype.getDataDimensionIndex = function(e) {
      var n = this.option.dimension;
      if (n != null)
        return e.getDimensionIndex(n);
      for (var i = e.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = e.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, t.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, t.prototype.completeVisualOption = function() {
      var e = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, a = n.target || (n.target = {}), o = n.controller || (n.controller = {});
      qt(a, i), qt(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(f) {
        slt(n.color) && !f.inRange && (f.inRange = {
          color: n.color.slice().reverse()
        }), f.inRange = f.inRange || {
          color: e.get("gradientColor")
        };
      }
      function u(f, h, d) {
        var p = f[h], g = f[d];
        p && !g && (g = f[d] = {}, CR(p, function(v, m) {
          if (Tr.isValidType(m)) {
            var y = XV.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(f) {
        var h = (f.inRange || {}).symbol || (f.outOfRange || {}).symbol, d = (f.inRange || {}).symbolSize || (f.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        CR(this.stateList, function(m) {
          var y = this.itemSize, _ = f[m];
          _ || (_ = f[m] = {
            color: s ? p : [p]
          }), _.symbol == null && (_.symbol = h && Dt(h) || (s ? v : [v])), _.symbolSize == null && (_.symbolSize = d && Dt(d) || (s ? y[0] : [y[0], y[0]])), _.symbol = ER(_.symbol, function(S) {
            return S === "none" ? v : S;
          });
          var x = _.symbolSize;
          if (x != null) {
            var b = -1 / 0;
            olt(x, function(S) {
              S > b && (b = S);
            }), _.symbolSize = ER(x, function(S) {
              return ult(S, [0, b], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, t.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, t.prototype.isCategory = function() {
      return !!this.option.categories;
    }, t.prototype.setSelected = function(e) {
    }, t.prototype.getSelected = function() {
      return null;
    }, t.prototype.getValueState = function(e) {
      return null;
    }, t.prototype.getVisualMeta = function(e) {
      return null;
    }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      // seriesIndex: 'all',
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: X.color.transparent,
      borderColor: X.color.borderTint,
      contentColor: X.color.theme[0],
      inactiveColor: X.color.disabled,
      borderWidth: 0,
      padding: X.size.m,
      // css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: X.color.secondary
        // 
      }
    }, t;
  }(re)
), DR = [20, 140], clt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, t.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var e = this.itemSize;
      (e[0] == null || isNaN(e[0])) && (e[0] = DR[0]), (e[1] == null || isNaN(e[1])) && (e[1] = DR[1]);
    }, t.prototype._resetRange = function() {
      var e = this.getExtent(), n = this.option.range;
      !n || n.auto ? (e.auto = 1, this.option.range = e) : et(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], e[0]), n[1] = Math.min(n[1], e[1]));
    }, t.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), L(this.stateList, function(e) {
        var n = this.option.controller[e].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, t.prototype.setSelected = function(e) {
      this.option.range = e.slice(), this._resetRange();
    }, t.prototype.getSelected = function() {
      var e = this.getExtent(), n = ri((this.get("range") || []).slice());
      return n[0] > e[1] && (n[0] = e[1]), n[1] > e[1] && (n[1] = e[1]), n[0] < e[0] && (n[0] = e[0]), n[1] < e[0] && (n[1] = e[0]), n;
    }, t.prototype.getValueState = function(e) {
      var n = this.option.range, i = this.getExtent(), a = bt(this.option.unboundedRange, !0);
      return (a && n[0] <= i[0] || n[0] <= e) && (a && n[1] >= i[1] || e <= n[1]) ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          e[0] <= s && s <= e[1] && a.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), n;
    }, t.prototype.getVisualMeta = function(e) {
      var n = LR(this, "outOfRange", this.getExtent()), i = LR(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: e(d, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++)
        n[l] < i[s] && o(n[l], "outOfRange");
      for (var f = 1; s < u; s++, f = 0)
        f && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var f = 1; l < c; l++)
        (!i.length || i[i.length - 1] < n[l]) && (f && (a.length && o(a[a.length - 1].value, "outOfRange"), f = 0), o(n[l], "outOfRange"));
      var h = a.length;
      return {
        stops: a,
        outerColors: [h ? a[0].color : "transparent", h ? a[h - 1].color : "transparent"]
      };
    }, t.type = "visualMap.continuous", t.defaultOption = Jo(Ag.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: X.color.neutral00,
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: X.color.neutral00,
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: X.color.shadow
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: tokens.color.shadow
      //     }
      // }
    }), t;
  }(Ag)
);
function LR(r, t, e) {
  if (e[0] === e[1])
    return e.slice();
  for (var n = 200, i = (e[1] - e[0]) / n, a = e[0], o = [], s = 0; s <= n && a < e[1]; s++)
    o.push(a), a += i;
  return o.push(e[1]), o;
}
var YV = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, e;
    }
    return t.prototype.init = function(e, n) {
      this.ecModel = e, this.api = n;
    }, t.prototype.render = function(e, n, i, a) {
      if (this.visualMapModel = e, e.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(e, n, i, a);
    }, t.prototype.renderBackground = function(e) {
      var n = this.visualMapModel, i = zh(n.get("padding") || 0), a = e.getBoundingRect();
      e.add(new te({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, t.prototype.getControllerVisual = function(e, n, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (n === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var f = o.controllerVisuals[a || o.getValueState(e)], h = Tr.prepareVisualTypes(f);
      return L(h, function(d) {
        var p = f[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = f.__alphaForOpacity), Tr.dependsOn(d, n) && p && p.applyVisual(e, u, c);
      }), s[n];
    }, t.prototype.positionGroup = function(e) {
      var n = this.visualMapModel, i = this.api, a = Sr(n, i).refContainer;
      cm(e, n.getBoxLayoutParams(), a);
    }, t.prototype.doRender = function(e, n, i, a) {
    }, t.type = "visualMap", t;
  }(Ge)
), RR = [["left", "right", "width"], ["top", "bottom", "height"]];
function $V(r, t, e) {
  var n = r.option, i = n.align;
  if (i != null && i !== "auto")
    return i;
  for (var a = {
    width: t.getWidth(),
    height: t.getHeight()
  }, o = n.orient === "horizontal" ? 1 : 0, s = RR[o], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[RR[1 - o][c]] = l[c], u[s[c]] = c === 2 ? e[0] : n[s[c]];
  var f = [["x", "width", 3], ["y", "height", 0]][o], h = We(u, a, n.padding);
  return s[(h.margin[f[2]] || 0) + h[f[0]] + h[f[1]] * 0.5 < a[f[1]] * 0.5 ? 0 : 1];
}
function lv(r, t) {
  return L(r || [], function(e) {
    e.dataIndex != null && (e.dataIndexInside = e.dataIndex, e.dataIndex = null), e.highlightKey = "visualMap" + (t ? t.componentIndex : "");
  }), r;
}
var Bi = Me, flt = L, IR = Math.min, k_ = Math.max, hlt = 12, dlt = 6, plt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._shapes = {}, e._dataInterval = [], e._handleEnds = [], e._hoverLinkDataIndices = [], e;
    }
    return t.prototype.init = function(e, n) {
      r.prototype.init.call(this, e, n), this._hoverLinkFromSeriesMouseOver = gt(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = gt(this._hideIndicator, this);
    }, t.prototype.doRender = function(e, n, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, t.prototype._buildView = function() {
      this.group.removeAll();
      var e = this.visualMapModel, n = this.group;
      this._orient = e.get("orient"), this._useHandle = e.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = e.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, t.prototype._renderEndsText = function(e, n, i) {
      if (n) {
        var a = n[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), f = this._applyTransform(i === 0 ? "bottom" : "top", u), h = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new pe({
          style: Oe(d, {
            x: c[0],
            y: c[1],
            verticalAlign: d.get("verticalAlign") || (h === "horizontal" ? "middle" : f),
            align: d.get("align") || (h === "horizontal" ? f : "center"),
            text: a
          })
        }));
      }
    }, t.prototype._renderBar = function(e) {
      var n = this.visualMapModel, i = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, l = $V(n, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new Ct();
      u.add(c), c.add(i.outOfRange = PR()), c.add(i.inRange = PR(null, s ? OR(this._orient) : null, gt(this._dragHandle, this, "all", !1), gt(this._dragHandle, this, "all", !0))), c.setClipPath(new te({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var f = n.textStyleModel.getTextRect(""), h = k_(f.width, f.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, a, h, o), this._createHandle(n, u, 1, a, h, o)), this._createIndicator(n, u, a, h, o), e.add(u);
    }, t.prototype._createHandle = function(e, n, i, a, o, s) {
      var l = gt(this._dragHandle, this, i, !1), u = gt(this._dragHandle, this, i, !0), c = wi(e.get("handleSize"), a[0]), f = hr(e.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), h = OR(this._orient);
      f.attr({
        cursor: h,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Ga(m.event);
        }
      }), f.x = a[0] / 2, f.useStyle(e.getModel("handleStyle").getItemStyle()), f.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), f.style.lineWidth *= 2, f.ensureState("emphasis").style = e.getModel(["emphasis", "handleStyle"]).getItemStyle(), js(f, !0), n.add(f);
      var d = this.visualMapModel.textStyleModel, p = new pe({
        cursor: h,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          Ga(m.event);
        },
        ondragend: u,
        style: Oe(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[i] = f, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, t.prototype._createIndicator = function(e, n, i, a, o) {
      var s = wi(e.get("indicatorSize"), i[0]), l = hr(e.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = e.getModel("indicatorStyle").getItemStyle();
      if (l instanceof Fr) {
        var c = l.style;
        l.useStyle(j({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      n.add(l);
      var f = this.visualMapModel.textStyleModel, h = new pe({
        silent: !0,
        invisible: !0,
        style: Oe(f, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(h);
      var d = [(o === "horizontal" ? a / 2 : dlt) + i[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = h, p.indicatorLabelPoint = d, this._firstShowIndicator = !0;
    }, t.prototype._dragHandle = function(e, n, i, a) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var o = this._applyTransform([i, a], this._shapes.mainGroup, !0);
          this._updateInterval(e, o[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : NR(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[e], !1);
      }
    }, t.prototype._resetInterval = function() {
      var e = this.visualMapModel, n = this._dataInterval = e.getSelected(), i = e.getExtent(), a = [0, e.itemSize[1]];
      this._handleEnds = [Bi(n[0], i, a, !0), Bi(n[1], i, a, !0)];
    }, t.prototype._updateInterval = function(e, n) {
      n = n || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [0, i.itemSize[1]];
      Yo(
        n,
        a,
        o,
        e,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [Bi(a[0], o, s, !0), Bi(a[1], o, s, !0)];
    }, t.prototype._updateView = function(e) {
      var n = this.visualMapModel, i = n.getExtent(), a = this._shapes, o = [0, n.itemSize[1]], s = e ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, t.prototype._createBarVisual = function(e, n, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(e, o), l = [this.getControllerVisual(e[0], "symbolSize", o), this.getControllerVisual(e[1], "symbolSize", o)], u = this._createBarPoints(i, l);
      return {
        barColor: new Mc(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, t.prototype._makeColorGradient = function(e, n) {
      var i = 100, a = [], o = (e[1] - e[0]) / i;
      a.push({
        color: this.getControllerVisual(e[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = e[0] + o * s;
        if (l > e[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(e[1], "color", n),
        offset: 1
      }), a;
    }, t.prototype._createBarPoints = function(e, n) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - n[0], e[0]], [i[0], e[0]], [i[0], e[1]], [i[0] - n[1], e[1]]];
    }, t.prototype._createBarGroup = function(e) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new Ct(n === "horizontal" && !i ? {
        scaleX: e === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: e === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: e === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: e === "left" ? 1 : -1
      });
    }, t.prototype._updateHandle = function(e, n) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        flt([0, 1], function(f) {
          var h = o[f];
          h.setStyle("fill", n.handlesColor[f]), h.y = e[f];
          var d = Bi(e[f], [0, l[1]], u, !0), p = this.getControllerVisual(d, "symbolSize");
          h.scaleX = h.scaleY = p / l[0], h.x = l[0] - p / 2;
          var g = _i(i.handleLabelPoints[f], sl(h, this.group));
          if (this._orient === "horizontal") {
            var v = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            g[1] += v;
          }
          s[f].setStyle({
            x: g[0],
            y: g[1],
            text: a.formatValueText(this._dataInterval[f]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, t.prototype._showIndicator = function(e, n, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], c = this._shapes, f = c.indicator;
      if (f) {
        f.attr("invisible", !1);
        var h = {
          convertOpacityToAlpha: !0
        }, d = this.getControllerVisual(e, "color", h), p = this.getControllerVisual(e, "symbolSize"), g = Bi(e, s, u, !0), v = l[0] - p / 2, m = {
          x: f.x,
          y: f.y
        };
        f.y = g, f.x = v;
        var y = _i(c.indicatorLabelPoint, sl(f, this.group)), _ = c.indicatorLabel;
        _.attr("invisible", !1);
        var x = this._applyTransform("left", c.mainGroup), b = this._orient, S = b === "horizontal";
        _.setStyle({
          text: (i || "") + o.formatValueText(n),
          verticalAlign: S ? x : "middle",
          align: S ? "center" : x
        });
        var w = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, A = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var T = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          f.x = m.x, f.y = m.y, f.animateTo(w, T), _.animateTo(A, T);
        } else
          f.attr(w), _.attr(A);
        this._firstShowIndicator = !1;
        var M = this._shapes.handleLabels;
        if (M)
          for (var C = 0; C < M.length; C++)
            this.api.enterBlur(M[C]);
      }
    }, t.prototype._enableHoverLinkToSeries = function() {
      var e = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (e._hovering = !0, !e._dragging) {
          var i = e.visualMapModel.itemSize, a = e._applyTransform([n.offsetX, n.offsetY], e._shapes.mainGroup, !0, !0);
          a[1] = IR(k_(0, a[1]), i[1]), e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        e._hovering = !1, !e._dragging && e._clearHoverLinkToSeries();
      });
    }, t.prototype._enableHoverLinkFromSeries = function() {
      var e = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), e.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, t.prototype._doHoverLinkToSeries = function(e, n) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [0, a[1]], s = i.getExtent();
        e = IR(k_(o[0], e), o[1]);
        var l = vlt(i, s, o), u = [e - l, e + l], c = Bi(e, o, s, !0), f = [Bi(u[0], o, s, !0), Bi(u[1], o, s, !0)];
        u[0] < o[0] && (f[0] = -1 / 0), u[1] > o[1] && (f[1] = 1 / 0), n && (f[0] === -1 / 0 ? this._showIndicator(c, f[1], "< ", l) : f[1] === 1 / 0 ? this._showIndicator(c, f[0], "> ", l) : this._showIndicator(c, c, " ", l));
        var h = this._hoverLinkDataIndices, d = [];
        (n || NR(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(f));
        var p = n6(h, d);
        this._dispatchHighDown("downplay", lv(p[0], i)), this._dispatchHighDown("highlight", lv(p[1], i));
      }
    }, t.prototype._hoverLinkFromSeriesMouseOver = function(e) {
      var n;
      if (Qs(e.target, function(l) {
        var u = zt(l);
        if (u.dataIndex != null)
          return n = u, !0;
      }, !0), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, t.prototype._hideIndicator = function() {
      var e = this._shapes;
      e.indicator && e.indicator.attr("invisible", !0), e.indicatorLabel && e.indicatorLabel.attr("invisible", !0);
      var n = this._shapes.handleLabels;
      if (n)
        for (var i = 0; i < n.length; i++)
          this.api.leaveBlur(n[i]);
    }, t.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var e = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", lv(e, this.visualMapModel)), e.length = 0;
    }, t.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var e = this.api.getZr();
      e.off("mouseover", this._hoverLinkFromSeriesMouseOver), e.off("mouseout", this._hideIndicator);
    }, t.prototype._applyTransform = function(e, n, i, a) {
      var o = sl(n, a ? null : this.group);
      return et(e) ? _i(e, o, i) : om(e, o, i);
    }, t.prototype._dispatchHighDown = function(e, n) {
      n && n.length && this.api.dispatchAction({
        type: e,
        batch: n
      });
    }, t.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, t.type = "visualMap.continuous", t;
  }(YV)
);
function PR(r, t, e, n) {
  return new Jr({
    shape: {
      points: r
    },
    draggable: !!e,
    cursor: t,
    drift: e,
    onmousemove: function(i) {
      Ga(i.event);
    },
    ondragend: n
  });
}
function vlt(r, t, e) {
  var n = hlt / 2, i = r.get("hoverLinkDataSize");
  return i && (n = Bi(i, t, e, !0) / 2), n;
}
function NR(r) {
  var t = r.get("hoverLinkOnHandle");
  return !!(t ?? r.get("realtime"));
}
function OR(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
var glt = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, mlt = function(r, t) {
  t.eachComponent({
    mainType: "visualMap",
    query: r
  }, function(e) {
    e.setSelected(r.selected);
  });
}, ylt = [
  {
    createOnAllSeries: !0,
    reset: function(r, t) {
      var e = [];
      return t.eachComponent("visualMap", function(n) {
        var i = r.pipelineContext;
        !n.isTargetSeries(r) || i && i.large || e.push(Fot(n.stateList, n.targetVisuals, gt(n.getValueState, n), n.getDataDimensionIndex(r.getData())));
      }), e;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(r, t) {
      var e = r.getData(), n = [];
      t.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(r)) {
          var a = i.getVisualMeta(gt(_lt, null, r, i)) || {
            stops: [],
            outerColors: []
          }, o = i.getDataDimensionIndex(e);
          o >= 0 && (a.dimension = o, n.push(a));
        }
      }), r.getData().setVisual("visualMeta", n);
    }
  }
];
function _lt(r, t, e, n) {
  for (var i = t.targetVisuals[n], a = Tr.prepareVisualTypes(i), o = {
    color: Gh(r.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(e, f, h);
  }
  return o.color;
  function f(d) {
    return o[d];
  }
  function h(d, p) {
    o[d] = p;
  }
}
var kR = L;
function xlt(r) {
  var t = r && r.visualMap;
  et(t) || (t = t ? [t] : []), kR(t, function(e) {
    if (e) {
      Mu(e, "splitList") && !Mu(e, "pieces") && (e.pieces = e.splitList, delete e.splitList);
      var n = e.pieces;
      n && et(n) && kR(n, function(i) {
        Lt(i) && (Mu(i, "start") && !Mu(i, "min") && (i.min = i.start), Mu(i, "end") && !Mu(i, "max") && (i.max = i.end));
      });
    }
  });
}
function Mu(r, t) {
  return r && r.hasOwnProperty && r.hasOwnProperty(t);
}
var BR = !1;
function ZV(r) {
  BR || (BR = !0, r.registerSubTypeDefaulter("visualMap", function(t) {
    return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
  }), r.registerAction(glt, mlt), L(ylt, function(t) {
    r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, t);
  }), r.registerPreprocessor(xlt));
}
function qV(r) {
  r.registerComponentModel(clt), r.registerComponentView(plt), ZV(r);
}
var Slt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._pieceList = [], e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], blt[this._mode].call(this, this._pieceList), this._resetSelected(e, n);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = Dt(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = rt(this._pieceList, function(l) {
          return l = Dt(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, t.prototype.completeVisualOption = function() {
      var e = this.option, n = {}, i = Tr.listVisualTypes(), a = this.isCategory();
      L(e.pieces, function(s) {
        L(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), L(n, function(s, l) {
        var u = !1;
        L(this.stateList, function(c) {
          u = u || o(e, c, l) || o(e.target, c, l);
        }, this), !u && L(this.stateList, function(c) {
          (e[c] || (e[c] = {}))[l] = XV.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, t.prototype._resetSelected = function(e, n) {
      var i = this.option, a = this._pieceList, o = (n ? i : e).selected || {};
      if (i.selected = o, L(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        L(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = !1 : s = !0);
        }, this);
      }
    }, t.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, t.prototype.getSelectedMapKey = function(e) {
      return this._mode === "categories" ? e.value + "" : e.index + "";
    }, t.prototype.getPieceList = function() {
      return this._pieceList;
    }, t.prototype._determineMode = function() {
      var e = this.option;
      return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, t.prototype.setSelected = function(e) {
      this.option.selected = Dt(e);
    }, t.prototype.getValueState = function(e) {
      var n = Tr.findPieceIndex(e, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Tr.findPieceIndex(l, i);
          c === e && o.push(u);
        }, this), n.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), n;
    }, t.prototype.getRepresentValue = function(e) {
      var n;
      if (this.isCategory())
        n = e.value;
      else if (e.value != null)
        n = e.value;
      else {
        var i = e.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, t.prototype.getVisualMeta = function(e) {
      if (this.isCategory())
        return;
      var n = [], i = ["", ""], a = this;
      function o(c, f) {
        var h = a.getRepresentValue({
          interval: c
        });
        f || (f = a.getValueState(h));
        var d = e(h, f);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : n.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return L(s, function(c) {
        var f = c.interval;
        f && (f[0] > u && o([u, f[0]], "outOfRange"), o(f.slice()), u = f[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, t.type = "visualMap.piecewise", t.defaultOption = Jo(Ag.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), t;
  }(Ag)
), blt = {
  splitNumber: function(r) {
    var t = this.option, e = Math.min(t.precision, 20), n = this.getExtent(), i = t.splitNumber;
    i = Math.max(parseInt(i, 10), 1), t.splitNumber = i;
    for (var a = (n[1] - n[0]) / i; +a.toFixed(e) !== a && e < 5; )
      e++;
    t.precision = e, a = +a.toFixed(e), t.minOpen && r.push({
      interval: [-1 / 0, n[0]],
      close: [0, 0]
    });
    for (var o = 0, s = n[0]; o < i; s += a, o++) {
      var l = o === i - 1 ? n[1] : s + a;
      r.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    t.maxOpen && r.push({
      interval: [n[1], 1 / 0],
      close: [0, 0]
    }), QT(r), L(r, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(r) {
    var t = this.option;
    L(t.categories, function(e) {
      r.push({
        text: this.formatValueText(e, !0),
        value: e
      });
    }, this), VR(t, r);
  },
  pieces: function(r) {
    var t = this.option;
    L(t.pieces, function(e, n) {
      Lt(e) || (e = {
        value: e
      });
      var i = {
        text: "",
        index: n
      };
      if (e.label != null && (i.text = e.label), e.hasOwnProperty("value")) {
        var a = i.value = e.value;
        i.interval = [a, a], i.close = [1, 1];
      } else {
        for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], f = 0; f < 2; f++) {
          for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][f], d = 0; d < 3 && o[f] == null; d++)
            o[f] = e[h[d]], s[f] = l[d], c[f] = d === 2;
          o[f] == null && (o[f] = u[f]);
        }
        c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && o[0] > o[1] && console.warn("Piece " + n + "is illegal: " + o + " lower bound should not greater then uppper bound."), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
      }
      i.visual = Tr.retrieveVisuals(e), r.push(i);
    }, this), VR(t, r), QT(r), L(r, function(e) {
      var n = e.close, i = [["<", ""][n[1]], [">", ""][n[0]]];
      e.text = e.text || this.formatValueText(e.value != null ? e.value : e.interval, !1, i);
    }, this);
  }
};
function VR(r, t) {
  var e = r.inverse;
  (r.orient === "vertical" ? !e : e) && t.reverse();
}
var wlt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.doRender = function() {
      var e = this.group;
      e.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), a = n.textStyleModel, o = this._getItemAlign(), s = n.itemSize, l = this._getViewData(), u = l.endsText, c = mr(n.get("showLabel", !0), !u), f = !n.get("selectedMode");
      u && this._renderEndsText(e, u[0], s, c, o), L(l.viewPieceList, function(h) {
        var d = h.piece, p = new Ct();
        p.onclick = gt(this._onItemClick, this, d), this._enableHoverLink(p, h.indexInModelPieceList);
        var g = n.getRepresentValue(d);
        if (this._createItemSymbol(p, g, [0, 0, s[0], s[1]], f), c) {
          var v = this.visualMapModel.getValueState(g), m = a.get("align") || o;
          p.add(new pe({
            style: Oe(a, {
              x: m === "right" ? -i : s[0] + i,
              y: s[1] / 2,
              text: d.text,
              verticalAlign: a.get("verticalAlign") || "middle",
              align: m,
              opacity: bt(a.get("opacity"), v === "outOfRange" ? 0.5 : 1)
            }),
            silent: f
          }));
        }
        e.add(p);
      }, this), u && this._renderEndsText(e, u[1], s, c, o), ll(n.get("orient"), e, n.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
    }, t.prototype._enableHoverLink = function(e, n) {
      var i = this;
      e.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: lv(s.findTargetDataIndices(n), s)
        });
      };
    }, t.prototype._getItemAlign = function() {
      var e = this.visualMapModel, n = e.option;
      if (n.orient === "vertical")
        return $V(e, this.api, e.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, t.prototype._renderEndsText = function(e, n, i, a, o) {
      if (n) {
        var s = new Ct(), l = this.visualMapModel.textStyleModel;
        s.add(new pe({
          style: Oe(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: n
          })
        })), e.add(s);
      }
    }, t.prototype._getViewData = function() {
      var e = this.visualMapModel, n = rt(e.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = e.get("text"), a = e.get("orient"), o = e.get("inverse");
      return (a === "horizontal" ? o : !o) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, t.prototype._createItemSymbol = function(e, n, i, a) {
      var o = hr(
        // symbol will be string
        this.getControllerVisual(n, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(n, "color")
      );
      o.silent = a, e.add(o);
    }, t.prototype._onItemClick = function(e) {
      var n = this.visualMapModel, i = n.option, a = i.selectedMode;
      if (a) {
        var o = Dt(i.selected), s = n.getSelectedMapKey(e);
        a === "single" || a === !0 ? (o[s] = !0, L(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, t.type = "visualMap.piecewise", t;
  }(YV)
);
function KV(r) {
  r.registerComponentModel(Slt), r.registerComponentView(wlt), ZV(r);
}
function Mlt(r) {
  jt(qV), jt(KV);
}
var Tlt = (
  /** @class */
  function() {
    function r(t) {
      this._thumbnailModel = t;
    }
    return r.prototype.reset = function(t) {
      this._renderVersion = t.getMainProcessVersion();
    }, r.prototype.renderContent = function(t) {
      var e = t.api.getViewOfComponentModel(this._thumbnailModel);
      e && (t.group.silent = !0, e.renderContent({
        group: t.group,
        targetTrans: t.targetTrans,
        z2Range: wN(t.group),
        roamType: t.roamType,
        viewportRect: t.viewportRect,
        renderVersion: this._renderVersion
      }));
    }, r.prototype.updateWindow = function(t, e) {
      var n = e.getViewOfComponentModel(this._thumbnailModel);
      n && n.updateWindow({
        targetTrans: t,
        renderVersion: this._renderVersion
      });
    }, r;
  }()
), Alt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventAutoZ = !0, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      this._updateBridge();
    }, t.prototype._updateBridge = function() {
      var e = this._birdge = this._birdge || new Tlt(this);
      if (this._target = null, this.ecModel.eachSeries(function(i) {
        aL(i, null);
      }), this.shouldShow()) {
        var n = this.getTarget();
        aL(n.baseMapProvider, e);
      }
    }, t.prototype.shouldShow = function() {
      return this.getShallow("show", !0);
    }, t.prototype.getBridge = function() {
      return this._birdge;
    }, t.prototype.getTarget = function() {
      if (this._target)
        return this._target;
      var e = this.getReferringComponents("series", {
        useDefault: !1,
        enableAll: !1,
        enableNone: !1
      }).models[0];
      return e ? e.subType !== "graph" && (e = null, process.env.NODE_ENV !== "production" && ce("series." + e.subType + " is not supported in thumbnail.", !0)) : e = this.ecModel.queryComponents({
        mainType: "series",
        subType: "graph"
      })[0], this._target = {
        baseMapProvider: e
      }, this._target;
    }, t.type = "thumbnail", t.layoutMode = "box", t.dependencies = ["series", "geo"], t.defaultOption = {
      show: !0,
      right: 1,
      bottom: 1,
      height: "25%",
      width: "25%",
      itemStyle: {
        // Use echarts option.backgorundColor by default.
        borderColor: X.color.border,
        borderWidth: 2
      },
      windowStyle: {
        borderWidth: 1,
        color: X.color.neutral30,
        borderColor: X.color.neutral40,
        opacity: 0.3
      },
      z: 10
    }, t;
  }(re)
), Elt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this._api = i, this._model = e, this._coordSys || (this._coordSys = new Nl()), !this._isEnabled()) {
        this._clear();
        return;
      }
      this._renderVersion = i.getMainProcessVersion();
      var a = this.group;
      a.removeAll();
      var o = e.getModel("itemStyle"), s = o.getItemStyle();
      s.fill == null && (s.fill = n.get("backgroundColor") || X.color.neutral00);
      var l = Sr(e, i).refContainer, u = We(XN(e, !0), l), c = s.lineWidth || 0, f = this._contentRect = ml(u.clone(), c / 2, !0, !0), h = new Ct();
      a.add(h), h.setClipPath(new te({
        shape: f.plain()
      }));
      var d = this._targetGroup = new Ct();
      h.add(d);
      var p = u.plain();
      p.r = o.getShallow("borderRadius", !0), a.add(this._bgRect = new te({
        style: s,
        shape: p,
        silent: !1,
        cursor: "grab"
      }));
      var g = e.getModel("windowStyle"), v = g.getShallow("borderRadius", !0);
      h.add(this._windowRect = new te({
        shape: {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          r: v
        },
        style: g.getItemStyle(),
        silent: !1,
        cursor: "grab"
      })), this._dealRenderContent(), this._dealUpdateWindow(), zR(e, this);
    }, t.prototype.renderContent = function(e) {
      this._bridgeRendered = e, this._isEnabled() && (this._dealRenderContent(), this._dealUpdateWindow(), zR(this._model, this));
    }, t.prototype._dealRenderContent = function() {
      var e = this._bridgeRendered;
      if (!(!e || e.renderVersion !== this._renderVersion)) {
        var n = this._targetGroup, i = this._coordSys, a = this._contentRect;
        if (n.removeAll(), !!e) {
          var o = e.group, s = o.getBoundingRect();
          n.add(o), this._bgRect.z2 = e.z2Range.min - 10, i.setBoundingRect(s.x, s.y, s.width, s.height);
          var l = We({
            left: "center",
            top: "center",
            aspect: s.width / s.height
          }, a);
          i.setViewRect(l.x, l.y, l.width, l.height), o.attr(i.getTransformInfo().raw), this._windowRect.z2 = e.z2Range.max + 10, this._resetRoamController(e.roamType);
        }
      }
    }, t.prototype.updateWindow = function(e) {
      var n = this._bridgeRendered;
      n && n.renderVersion === e.renderVersion && (n.targetTrans = e.targetTrans), this._isEnabled() && this._dealUpdateWindow();
    }, t.prototype._dealUpdateWindow = function() {
      var e = this._bridgeRendered;
      if (!(!e || e.renderVersion !== this._renderVersion)) {
        var n = bi([], e.targetTrans), i = Ji([], this._coordSys.transform, n);
        this._transThisToTarget = bi([], i);
        var a = e.viewportRect;
        a ? a = a.clone() : a = new Vt(0, 0, this._api.getWidth(), this._api.getHeight()), a.applyTransform(i);
        var o = this._windowRect, s = o.shape.r;
        o.setShape(Bt({
          r: s
        }, a));
      }
    }, t.prototype._resetRoamController = function(e) {
      var n = this, i = this._api, a = this._roamController;
      if (a || (a = this._roamController = new Pl(i.getZr())), !e || !this._isEnabled()) {
        a.disable();
        return;
      }
      a.enable(e, {
        api: i,
        zInfo: {
          component: this._model
        },
        triggerInfo: {
          roamTrigger: null,
          isInSelf: function(o, s, l) {
            return n._contentRect.contain(s, l);
          }
        }
      }), a.off("pan").off("zoom").on("pan", gt(this._onPan, this)).on("zoom", gt(this._onZoom, this));
    }, t.prototype._onPan = function(e) {
      var n = this._transThisToTarget;
      if (!(!this._isEnabled() || !n)) {
        var i = nr([], [e.oldX, e.oldY], n), a = nr([], [e.oldX - e.dx, e.oldY - e.dy], n);
        this._api.dispatchAction(FR(this._model.getTarget().baseMapProvider, {
          dx: a[0] - i[0],
          dy: a[1] - i[1]
        }));
      }
    }, t.prototype._onZoom = function(e) {
      var n = this._transThisToTarget;
      if (!(!this._isEnabled() || !n)) {
        var i = nr([], [e.originX, e.originY], n);
        this._api.dispatchAction(FR(this._model.getTarget().baseMapProvider, {
          zoom: 1 / e.scale,
          originX: i[0],
          originY: i[1]
        }));
      }
    }, t.prototype._isEnabled = function() {
      var e = this._model;
      if (!e || !e.shouldShow())
        return !1;
      var n = e.getTarget().baseMapProvider;
      return !!n;
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._bridgeRendered = null, this._roamController && this._roamController.disable();
    }, t.prototype.remove = function() {
      this._clear();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "thumbnail", t;
  }(Ge)
);
function FR(r, t) {
  var e = r.mainType === "series" ? r.subType + "Roam" : r.mainType + "Roam", n = {
    type: e
  };
  return n[r.mainType + "Id"] = r.id, j(n, t), n;
}
function zR(r, t) {
  var e = yl(r);
  sm(t.group, e.z, e.zlevel);
}
function Clt(r) {
  r.registerComponentModel(Alt), r.registerComponentView(Elt);
}
var Dlt = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, UR = ee(), Llt = {};
function Rlt(r, t) {
  var e = r.getModel("aria");
  if (!e.get("enabled"))
    return;
  var n = Dt(Dlt);
  qt(n.label, r.getLocaleModel().get("aria"), !1), qt(e.option, n, !1), i(), a();
  function i() {
    var u = e.getModel("decal"), c = u.get("show");
    if (c) {
      var f = wt();
      r.eachSeries(function(h) {
        if (!h.isColorBySeries()) {
          var d = f.get(h.type);
          d || (d = {}, f.set(h.type, d)), UR(h).scope = d;
        }
      }), r.eachRawSeries(function(h) {
        if (r.isSeriesFiltered(h))
          return;
        if (At(h.enableAriaDecal)) {
          h.enableAriaDecal();
          return;
        }
        var d = h.getData();
        if (h.isColorBySeries()) {
          var y = Yx(h.ecModel, h.name, Llt, r.getSeriesCount()), _ = d.getVisual("decal");
          d.setVisual("decal", x(_, y));
        } else {
          var p = h.getRawData(), g = {}, v = UR(h).scope;
          d.each(function(b) {
            var S = d.getRawIndex(b);
            g[S] = b;
          });
          var m = p.count();
          p.each(function(b) {
            var S = g[b], w = p.getName(b) || b + "", A = Yx(h.ecModel, w, v, m), T = d.getItemVisual(S, "decal");
            d.setItemVisual(S, "decal", x(T, A));
          });
        }
        function x(b, S) {
          var w = b ? j(j({}, S), b) : S;
          return w.dirty = !0, w;
        }
      });
    }
  }
  function a() {
    var u = t.getZr().dom;
    if (u) {
      var c = r.getLocaleModel().get("aria"), f = e.getModel("label");
      if (f.option = Bt(f.option, c), !!f.get("enabled")) {
        if (u.setAttribute("role", "img"), f.get("description")) {
          u.setAttribute("aria-label", f.get("description"));
          return;
        }
        var h = r.getSeriesCount(), d = f.get(["data", "maxCount"]) || 10, p = f.get(["series", "maxCount"]) || 10, g = Math.min(h, p), v;
        if (!(h < 1)) {
          var m = s();
          if (m) {
            var y = f.get(["general", "withTitle"]);
            v = o(y, {
              title: m
            });
          } else
            v = f.get(["general", "withoutTitle"]);
          var _ = [], x = h > 1 ? f.get(["series", "multiple", "prefix"]) : f.get(["series", "single", "prefix"]);
          v += o(x, {
            seriesCount: h
          }), r.eachSeries(function(A, T) {
            if (T < g) {
              var M = void 0, C = A.get("name"), R = C ? "withName" : "withoutName";
              M = h > 1 ? f.get(["series", "multiple", R]) : f.get(["series", "single", R]), M = o(M, {
                seriesId: A.seriesIndex,
                seriesName: A.get("name"),
                seriesType: l(A.subType)
              });
              var E = A.getData();
              if (E.count() > d) {
                var D = f.get(["data", "partialData"]);
                M += o(D, {
                  displayCnt: d
                });
              } else
                M += f.get(["data", "allData"]);
              for (var I = f.get(["data", "separator", "middle"]), P = f.get(["data", "separator", "end"]), O = f.get(["data", "excludeDimensionId"]), N = [], B = 0; B < E.count(); B++)
                if (B < d) {
                  var F = E.getName(B), G = O ? Te(E.getValues(B), function(J, U) {
                    return Zt(O, U) === -1;
                  }) : E.getValues(B), W = f.get(["data", F ? "withName" : "withoutName"]);
                  N.push(o(W, {
                    name: F,
                    value: G.join(I)
                  }));
                }
              M += N.join(I) + P, _.push(M);
            }
          });
          var b = f.getModel(["series", "multiple", "separator"]), S = b.get("middle"), w = b.get("end");
          v += _.join(S) + w, u.setAttribute("aria-label", v);
        }
      }
    }
  }
  function o(u, c) {
    if (!pt(u))
      return u;
    var f = u;
    return L(c, function(h, d) {
      f = f.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), h);
    }), f;
  }
  function s() {
    var u = r.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = r.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function Ilt(r) {
  if (!(!r || !r.aria)) {
    var t = r.aria;
    t.show != null && (t.enabled = t.show), t.label = t.label || {}, L(["description", "general", "series", "data"], function(e) {
      t[e] != null && (t.label[e] = t[e]);
    });
  }
}
function Plt(r) {
  r.registerPreprocessor(Ilt), r.registerVisual(r.PRIORITY.VISUAL.ARIA, Rlt);
}
var GR = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, Nlt = (
  /** @class */
  function() {
    function r(t) {
      var e = this._condVal = pt(t) ? new RegExp(t) : JI(t) ? t : null;
      if (e == null) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = dn("Illegal regexp", t, "in")), we(n);
      }
    }
    return r.prototype.evaluate = function(t) {
      var e = typeof t;
      return pt(e) ? this._condVal.test(t) : fe(e) ? this._condVal.test(t + "") : !1;
    }, r;
  }()
), Olt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }()
), klt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++)
        if (!t[e].evaluate())
          return !1;
      return !0;
    }, r;
  }()
), Blt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++)
        if (t[e].evaluate())
          return !0;
      return !1;
    }, r;
  }()
), Vlt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }()
), Flt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = !!this.valueParser, e = this.getValue, n = e(this.valueGetterParam), i = t ? this.valueParser(n) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(t ? i : n))
          return !1;
      return !0;
    }, r;
  }()
);
function Pw(r, t) {
  if (r === !0 || r === !1) {
    var e = new Olt();
    return e.value = r, e;
  }
  var n = "";
  return jV(r) || (process.env.NODE_ENV !== "production" && (n = dn("Illegal config. Expect a plain object but actually", r)), we(n)), r.and ? HR("and", r, t) : r.or ? HR("or", r, t) : r.not ? zlt(r, t) : Ult(r, t);
}
function HR(r, t, e) {
  var n = t[r], i = "";
  process.env.NODE_ENV !== "production" && (i = dn('"and"/"or" condition should only be `' + r + ": [...]` and must not be empty array.", "Illegal condition:", t)), et(n) || we(i), n.length || we(i);
  var a = r === "and" ? new klt() : new Blt();
  return a.children = rt(n, function(o) {
    return Pw(o, e);
  }), a.children.length || we(i), a;
}
function zlt(r, t) {
  var e = r.not, n = "";
  process.env.NODE_ENV !== "production" && (n = dn('"not" condition should only be `not: {}`.', "Illegal condition:", r)), jV(e) || we(n);
  var i = new Vlt();
  return i.child = Pw(e, t), i.child || we(n), i;
}
function Ult(r, t) {
  for (var e = "", n = t.prepareGetValue(r), i = [], a = se(r), o = r.parser, s = o ? hO(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
      var c = _t(GR, u) ? GR[u] : u, f = r[u], h = s ? s(f) : f, d = SX(c, h) || c === "reg" && new Nlt(h);
      d || (process.env.NODE_ENV !== "production" && (e = dn('Illegal relational operation: "' + u + '" in condition:', r)), we(e)), i.push(d);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (e = dn("Relational condition must have at least one operator.", "Illegal condition:", r)), we(e));
  var p = new Flt();
  return p.valueGetterParam = n, p.valueParser = s, p.getValue = t.getValue, p.subCondList = i, p;
}
function jV(r) {
  return Lt(r) && !Kr(r);
}
var Glt = (
  /** @class */
  function() {
    function r(t, e) {
      this._cond = Pw(t, e);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }()
);
function Hlt(r, t) {
  return new Glt(r, t);
}
var Wlt = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(r) {
    for (var t = r.upstream, e, n = Hlt(r.config, {
      valueGetterAttrMap: wt({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        _t(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = dn('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), we(l));
        var c = t.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = dn("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), we(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return t.retrieveValueFromItem(e, s.dimIdx);
      }
    }), i = [], a = 0, o = t.count(); a < o; a++)
      e = t.getRawDataItem(a), n.evaluate() && i.push(e);
    return {
      data: i
    };
  }
}, i1 = "";
process.env.NODE_ENV !== "production" && (i1 = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var Xlt = {
  type: "echarts:sort",
  transform: function(r) {
    var t = r.upstream, e = r.config, n = "", i = Ie(e);
    i.length || (process.env.NODE_ENV !== "production" && (n = "Empty `config` in sort transform."), we(n));
    var a = [];
    L(i, function(c) {
      var f = c.dimension, h = c.order, d = c.parser, p = c.incomparable;
      if (f == null && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "dimension" specified.' + i1), we(n)), h !== "asc" && h !== "desc" && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "order" specified.' + i1), we(n)), p && p !== "min" && p !== "max") {
        var g = "";
        process.env.NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), we(g);
      }
      if (h !== "asc" && h !== "desc") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + h + '".'), we(v);
      }
      var m = t.getDimensionInfo(f);
      m || (process.env.NODE_ENV !== "production" && (n = dn("Can not find dimension info via: " + f + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), we(n));
      var y = d ? hO(d) : null;
      d && !y && (process.env.NODE_ENV !== "production" && (n = dn("Invalid parser name " + d + `.
`, "Illegal config:", c, `.
`)), we(n)), a.push({
        dimIdx: m.index,
        parser: y,
        comparator: new pO(h, p)
      });
    });
    var o = t.sourceFormat;
    o !== Vr && o !== Fn && (process.env.NODE_ENV !== "production" && (n = 'sourceFormat "' + o + '" is not supported yet'), we(n));
    for (var s = [], l = 0, u = t.count(); l < u; l++)
      s.push(t.getRawDataItem(l));
    return s.sort(function(c, f) {
      for (var h = 0; h < a.length; h++) {
        var d = a[h], p = t.retrieveValueFromItem(c, d.dimIdx), g = t.retrieveValueFromItem(f, d.dimIdx);
        d.parser && (p = d.parser(p), g = d.parser(g));
        var v = d.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function Ylt(r) {
  r.registerTransform(Wlt), r.registerTransform(Xlt);
}
var $lt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.prototype.init = function(e, n, i) {
      r.prototype.init.call(this, e, n, i), this._sourceManager = new yO(this), mE(this);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), mE(this);
    }, t.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, t.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, t.type = "dataset", t.defaultOption = {
      seriesLayoutBy: xi
    }, t;
  }(re)
), Zlt = (
  /** @class */
  function(r) {
    $(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.type = "dataset", t;
  }(Ge)
);
function qlt(r) {
  r.registerComponentModel($lt), r.registerComponentView(Zlt);
}
var Oi = oa.CMD;
function zu(r, t) {
  return Math.abs(r - t) < 1e-5;
}
function a1(r) {
  var t = r.data, e = r.len(), n = [], i, a = 0, o = 0, s = 0, l = 0;
  function u(E, D) {
    i && i.length > 2 && n.push(i), i = [E, D];
  }
  function c(E, D, I, P) {
    zu(E, I) && zu(D, P) || i.push(E, D, I, P, I, P);
  }
  function f(E, D, I, P, O, N) {
    var B = Math.abs(D - E), F = Math.tan(B / 4) * 4 / 3, G = D < E ? -1 : 1, W = Math.cos(E), J = Math.sin(E), U = Math.cos(D), Y = Math.sin(D), at = W * O + I, st = J * N + P, ut = U * O + I, lt = Y * N + P, H = O * F * G, ct = N * F * G;
    i.push(at - H * J, st + ct * W, ut + H * Y, lt - ct * U, ut, lt);
  }
  for (var h, d, p, g, v = 0; v < e; ) {
    var m = t[v++], y = v === 1;
    switch (y && (a = t[v], o = t[v + 1], s = a, l = o, (m === Oi.L || m === Oi.C || m === Oi.Q) && (i = [s, l])), m) {
      case Oi.M:
        a = s = t[v++], o = l = t[v++], u(s, l);
        break;
      case Oi.L:
        h = t[v++], d = t[v++], c(a, o, h, d), a = h, o = d;
        break;
      case Oi.C:
        i.push(t[v++], t[v++], t[v++], t[v++], a = t[v++], o = t[v++]);
        break;
      case Oi.Q:
        h = t[v++], d = t[v++], p = t[v++], g = t[v++], i.push(a + 2 / 3 * (h - a), o + 2 / 3 * (d - o), p + 2 / 3 * (h - p), g + 2 / 3 * (d - g), p, g), a = p, o = g;
        break;
      case Oi.A:
        var _ = t[v++], x = t[v++], b = t[v++], S = t[v++], w = t[v++], A = t[v++] + w;
        v += 1;
        var T = !t[v++];
        h = Math.cos(w) * b + _, d = Math.sin(w) * S + x, y ? (s = h, l = d, u(s, l)) : c(a, o, h, d), a = Math.cos(A) * b + _, o = Math.sin(A) * S + x;
        for (var M = (T ? -1 : 1) * Math.PI / 2, C = w; T ? C > A : C < A; C += M) {
          var R = T ? Math.max(C + M, A) : Math.min(C + M, A);
          f(C, R, _, x, b, S);
        }
        break;
      case Oi.R:
        s = a = t[v++], l = o = t[v++], h = s + t[v++], d = l + t[v++], u(h, l), c(h, l, h, d), c(h, d, s, d), c(s, d, s, l), c(s, l, h, l);
        break;
      case Oi.Z:
        i && c(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return i && i.length > 2 && n.push(i), n;
}
function o1(r, t, e, n, i, a, o, s, l, u) {
  if (zu(r, e) && zu(t, n) && zu(i, o) && zu(a, s)) {
    l.push(o, s);
    return;
  }
  var c = 2 / u, f = c * c, h = o - r, d = s - t, p = Math.sqrt(h * h + d * d);
  h /= p, d /= p;
  var g = e - r, v = n - t, m = i - o, y = a - s, _ = g * g + v * v, x = m * m + y * y;
  if (_ < f && x < f) {
    l.push(o, s);
    return;
  }
  var b = h * g + d * v, S = -h * m - d * y, w = _ - b * b, A = x - S * S;
  if (w < f && b >= 0 && A < f && S >= 0) {
    l.push(o, s);
    return;
  }
  var T = [], M = [];
  Uo(r, e, i, o, 0.5, T), Uo(t, n, a, s, 0.5, M), o1(T[0], M[0], T[1], M[1], T[2], M[2], T[3], M[3], l, u), o1(T[4], M[4], T[5], M[5], T[6], M[6], T[7], M[7], l, u);
}
function Klt(r, t) {
  var e = a1(r), n = [];
  t = t || 1;
  for (var i = 0; i < e.length; i++) {
    var a = e[i], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var c = a[u++], f = a[u++], h = a[u++], d = a[u++], p = a[u++], g = a[u++];
      o1(s, l, c, f, h, d, p, g, o, t), s = p, l = g;
    }
    n.push(o);
  }
  return n;
}
function JV(r, t, e) {
  var n = r[t], i = r[1 - t], a = Math.abs(n / i), o = Math.ceil(Math.sqrt(a * e)), s = Math.floor(e / o);
  s === 0 && (s = 1, o = e);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var c = o * s, f = e - c;
  if (f > 0)
    for (var u = 0; u < f; u++)
      l[u % o] += 1;
  return l;
}
function WR(r, t, e) {
  for (var n = r.r0, i = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * i, u = i - n, c = l > Math.abs(u), f = JV([l, u], c ? 0 : 1, t), h = (c ? s : u) / f.length, d = 0; d < f.length; d++)
    for (var p = (c ? u : s) / f[d], g = 0; g < f[d]; g++) {
      var v = {};
      c ? (v.startAngle = a + h * d, v.endAngle = a + h * (d + 1), v.r0 = n + p * g, v.r = n + p * (g + 1)) : (v.startAngle = a + p * g, v.endAngle = a + p * (g + 1), v.r0 = n + h * d, v.r = n + h * (d + 1)), v.clockwise = r.clockwise, v.cx = r.cx, v.cy = r.cy, e.push(v);
    }
}
function jlt(r, t, e) {
  for (var n = r.width, i = r.height, a = n > i, o = JV([n, i], a ? 0 : 1, t), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", f = r[s] / o.length, h = 0; h < o.length; h++)
    for (var d = r[l] / o[h], p = 0; p < o[h]; p++) {
      var g = {};
      g[u] = h * f, g[c] = p * d, g[s] = f, g[l] = d, g.x += r.x, g.y += r.y, e.push(g);
    }
}
function XR(r, t, e, n) {
  return r * n - e * t;
}
function Jlt(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = XR(c, f, l, u);
  if (Math.abs(h) < 1e-6)
    return null;
  var d = r - i, p = t - a, g = XR(d, p, c, f) / h;
  return g < 0 || g > 1 ? null : new Ot(g * l + r, g * u + t);
}
function Qlt(r, t, e) {
  var n = new Ot();
  Ot.sub(n, e, t), n.normalize();
  var i = new Ot();
  Ot.sub(i, r, t);
  var a = i.dot(n);
  return a;
}
function Tu(r, t) {
  var e = r[r.length - 1];
  e && e[0] === t[0] && e[1] === t[1] || r.push(t);
}
function tut(r, t, e) {
  for (var n = r.length, i = [], a = 0; a < n; a++) {
    var o = r[a], s = r[(a + 1) % n], l = Jlt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y);
    l && i.push({
      projPt: Qlt(l, t, e),
      pt: l,
      idx: a
    });
  }
  if (i.length < 2)
    return [{ points: r }, { points: r }];
  i.sort(function(v, m) {
    return v.projPt - m.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var f = u;
    u = c, c = f;
  }
  for (var h = [u.pt.x, u.pt.y], d = [c.pt.x, c.pt.y], p = [h], g = [d], a = u.idx + 1; a <= c.idx; a++)
    Tu(p, r[a].slice());
  Tu(p, d), Tu(p, h);
  for (var a = c.idx + 1; a <= u.idx + n; a++)
    Tu(g, r[a % n].slice());
  return Tu(g, h), Tu(g, d), [{
    points: p
  }, {
    points: g
  }];
}
function YR(r) {
  var t = r.points, e = [], n = [];
  Jg(t, e, n);
  var i = new Vt(e[0], e[1], n[0] - e[0], n[1] - e[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new Ot(), c = new Ot();
  return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), tut(t, u, c);
}
function Eg(r, t, e, n) {
  if (e === 1)
    n.push(t);
  else {
    var i = Math.floor(e / 2), a = r(t);
    Eg(r, a[0], i, n), Eg(r, a[1], e - i, n);
  }
  return n;
}
function eut(r, t) {
  for (var e = [], n = 0; n < t; n++)
    e.push(G1(r));
  return e;
}
function rut(r, t) {
  t.setStyle(r.style), t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel;
}
function nut(r) {
  for (var t = [], e = 0; e < r.length; )
    t.push([r[e++], r[e++]]);
  return t;
}
function iut(r, t) {
  var e = [], n = r.shape, i;
  switch (r.type) {
    case "rect":
      jlt(n, t, e), i = te;
      break;
    case "sector":
      WR(n, t, e), i = jr;
      break;
    case "circle":
      WR({
        r0: 0,
        r: n.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: n.cx,
        cy: n.cy
      }, t, e), i = jr;
      break;
    default:
      var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = rt(Klt(r.getUpdatedPathProxy(), o), function(m) {
        return nut(m);
      }), l = s.length;
      if (l === 0)
        Eg(YR, {
          points: s[0]
        }, t, e);
      else if (l === t)
        for (var u = 0; u < l; u++)
          e.push({
            points: s[u]
          });
      else {
        var c = 0, f = rt(s, function(m) {
          var y = [], _ = [];
          Jg(m, y, _);
          var x = (_[1] - y[1]) * (_[0] - y[0]);
          return c += x, { poly: m, area: x };
        });
        f.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var h = t, u = 0; u < l; u++) {
          var d = f[u];
          if (h <= 0)
            break;
          var p = u === l - 1 ? h : Math.ceil(d.area / c * t);
          p < 0 || (Eg(YR, {
            points: d.poly
          }, p, e), h -= p);
        }
      }
      i = Jr;
      break;
  }
  if (!i)
    return eut(r, t);
  for (var g = [], u = 0; u < e.length; u++) {
    var v = new i();
    v.setShape(e[u]), rut(r, v), g.push(v);
  }
  return g;
}
function aut(r, t) {
  var e = r.length, n = t.length;
  if (e === n)
    return [r, t];
  for (var i = [], a = [], o = e < n ? r : t, s = Math.min(e, n), l = Math.abs(n - e) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, f = [o[0], o[1]], h = l, d = 2; d < s; ) {
    var p = o[d - 2], g = o[d - 1], v = o[d++], m = o[d++], y = o[d++], _ = o[d++], x = o[d++], b = o[d++];
    if (h <= 0) {
      f.push(v, m, y, _, x, b);
      continue;
    }
    for (var S = Math.min(h, c - 1) + 1, w = 1; w <= S; w++) {
      var A = w / S;
      Uo(p, v, y, x, A, i), Uo(g, m, _, b, A, a), p = i[3], g = a[3], f.push(i[1], a[1], i[2], a[2], p, g), v = i[5], m = a[5], y = i[6], _ = a[6];
    }
    h -= S - 1;
  }
  return o === r ? [f, t] : [r, f];
}
function $R(r, t) {
  for (var e = r.length, n = r[e - 2], i = r[e - 1], a = [], o = 0; o < t.length; )
    a[o++] = n, a[o++] = i;
  return a;
}
function out(r, t) {
  for (var e, n, i, a = [], o = [], s = 0; s < Math.max(r.length, t.length); s++) {
    var l = r[s], u = t[s], c = void 0, f = void 0;
    l ? u ? (e = aut(l, u), c = e[0], f = e[1], n = c, i = f) : (f = $R(i || l, l), c = l) : (c = $R(n || u, u), f = u), a.push(c), o.push(f);
  }
  return [a, o];
}
function ZR(r) {
  for (var t = 0, e = 0, n = 0, i = r.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
    var s = r[o], l = r[o + 1], u = r[a], c = r[a + 1], f = s * c - u * l;
    t += f, e += (s + u) * f, n += (l + c) * f;
  }
  return t === 0 ? [r[0] || 0, r[1] || 0] : [e / t / 3, n / t / 3, t];
}
function sut(r, t, e, n) {
  for (var i = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, f = 0, h = 0; h < s; h += 2) {
      var d = h === 0 ? c : (c + h - 2) % l + 2, p = r[d] - e[0], g = r[d + 1] - e[1], v = t[h] - n[0], m = t[h + 1] - n[1], y = v - p, _ = m - g;
      f += y * y + _ * _;
    }
    f < a && (a = f, o = u);
  }
  return o;
}
function lut(r) {
  for (var t = [], e = r.length, n = 0; n < e; n += 2)
    t[n] = r[e - n - 2], t[n + 1] = r[e - n - 1];
  return t;
}
function uut(r, t, e, n) {
  for (var i = [], a, o = 0; o < r.length; o++) {
    var s = r[o], l = t[o], u = ZR(s), c = ZR(l);
    a == null && (a = u[2] < 0 != c[2] < 0);
    var f = [], h = [], d = 0, p = 1 / 0, g = [], v = s.length;
    a && (s = lut(s));
    for (var m = sut(s, l, u, c) * 6, y = v - 2, _ = 0; _ < y; _ += 2) {
      var x = (m + _) % y + 2;
      f[_ + 2] = s[x] - u[0], f[_ + 3] = s[x + 1] - u[1];
    }
    f[0] = s[m] - u[0], f[1] = s[m + 1] - u[1];
    for (var b = n / e, S = -n / 2; S <= n / 2; S += b) {
      for (var w = Math.sin(S), A = Math.cos(S), T = 0, _ = 0; _ < s.length; _ += 2) {
        var M = f[_], C = f[_ + 1], R = l[_] - c[0], E = l[_ + 1] - c[1], D = R * A - E * w, I = R * w + E * A;
        g[_] = D, g[_ + 1] = I;
        var P = D - M, O = I - C;
        T += P * P + O * O;
      }
      if (T < p) {
        p = T, d = S;
        for (var N = 0; N < g.length; N++)
          h[N] = g[N];
      }
    }
    i.push({
      from: f,
      to: h,
      fromCp: u,
      toCp: c,
      rotation: -d
    });
  }
  return i;
}
function Cg(r) {
  return r.__isCombineMorphing;
}
var QV = "__mOriginal_";
function Dg(r, t, e) {
  var n = QV + t, i = r[n] || r[t];
  r[n] || (r[n] = r[t]);
  var a = e.replace, o = e.after, s = e.before;
  r[t] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
  };
}
function Qf(r, t) {
  var e = QV + t;
  r[e] && (r[t] = r[e], r[e] = null);
}
function qR(r, t) {
  for (var e = 0; e < r.length; e++)
    for (var n = r[e], i = 0; i < n.length; ) {
      var a = n[i], o = n[i + 1];
      n[i++] = t[0] * a + t[2] * o + t[4], n[i++] = t[1] * a + t[3] * o + t[5];
    }
}
function tF(r, t) {
  var e = r.getUpdatedPathProxy(), n = t.getUpdatedPathProxy(), i = out(a1(e), a1(n)), a = i[0], o = i[1], s = r.getComputedTransform(), l = t.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && qR(a, s), l && qR(o, l), Dg(t, "updateTransform", { replace: u }), t.transform = null;
  var c = uut(a, o, 10, Math.PI), f = [];
  Dg(t, "buildPath", { replace: function(h) {
    for (var d = t.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
      var m = c[v], y = m.from, _ = m.to, x = m.rotation * d, b = m.fromCp, S = m.toCp, w = Math.sin(x), A = Math.cos(x);
      Wp(g, b, S, d);
      for (var T = 0; T < y.length; T += 2) {
        var M = y[T], C = y[T + 1], R = _[T], E = _[T + 1], D = M * p + R * d, I = C * p + E * d;
        f[T] = D * A - I * w + g[0], f[T + 1] = D * w + I * A + g[1];
      }
      var P = f[0], O = f[1];
      h.moveTo(P, O);
      for (var T = 2; T < y.length; ) {
        var R = f[T++], E = f[T++], N = f[T++], B = f[T++], F = f[T++], G = f[T++];
        P === R && O === E && N === F && B === G ? h.lineTo(F, G) : h.bezierCurveTo(R, E, N, B, F, G), P = F, O = G;
      }
    }
  } });
}
function Nw(r, t, e) {
  if (!r || !t)
    return t;
  var n = e.done, i = e.during;
  tF(r, t), t.__morphT = 0;
  function a() {
    Qf(t, "buildPath"), Qf(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
  }
  return t.animateTo({
    __morphT: 1
  }, Bt({
    during: function(o) {
      t.dirtyShape(), i && i(o);
    },
    done: function() {
      a(), n && n();
    }
  }, e)), t;
}
function cut(r, t, e, n, i, a) {
  var o = 16;
  r = i === e ? 0 : Math.round(32767 * (r - e) / (i - e)), t = a === n ? 0 : Math.round(32767 * (t - n) / (a - n));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0, f = 0;
    (r & u) > 0 && (c = 1), (t & u) > 0 && (f = 1), s += u * u * (3 * c ^ f), f === 0 && (c === 1 && (r = u - 1 - r, t = u - 1 - t), l = r, r = t, t = l);
  }
  return s;
}
function Lg(r) {
  var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = rt(r, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), f = l.y + l.height / 2 + (u ? u[5] : 0);
    return t = Math.min(c, t), e = Math.min(f, e), n = Math.max(c, n), i = Math.max(f, i), [c, f];
  }), o = rt(a, function(s, l) {
    return {
      cp: s,
      z: cut(s[0], s[1], t, e, n, i),
      path: r[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function eF(r) {
  return iut(r.path, r.count);
}
function s1() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function fut(r, t, e) {
  var n = [];
  function i(b) {
    for (var S = 0; S < b.length; S++) {
      var w = b[S];
      Cg(w) ? i(w.childrenRef()) : w instanceof ne && n.push(w);
    }
  }
  i(r);
  var a = n.length;
  if (!a)
    return s1();
  var o = e.dividePath || eF, s = o({
    path: t,
    count: a
  });
  if (s.length !== a)
    return console.error("Invalid morphing: unmatched splitted path"), s1();
  n = Lg(n), s = Lg(s);
  for (var l = e.done, u = e.during, c = e.individualDelay, f = new La(), h = 0; h < a; h++) {
    var d = n[h], p = s[h];
    p.parent = t, p.copyTransform(f), c || tF(d, p);
  }
  t.__isCombineMorphing = !0, t.childrenRef = function() {
    return s;
  };
  function g(b) {
    for (var S = 0; S < s.length; S++)
      s[S].addSelfToZr(b);
  }
  Dg(t, "addSelfToZr", {
    after: function(b) {
      g(b);
    }
  }), Dg(t, "removeSelfFromZr", {
    after: function(b) {
      for (var S = 0; S < s.length; S++)
        s[S].removeSelfFromZr(b);
    }
  });
  function v() {
    t.__isCombineMorphing = !1, t.__morphT = -1, t.childrenRef = null, Qf(t, "addSelfToZr"), Qf(t, "removeSelfFromZr");
  }
  var m = s.length;
  if (c)
    for (var y = m, _ = function() {
      y--, y === 0 && (v(), l && l());
    }, h = 0; h < m; h++) {
      var x = c ? Bt({
        delay: (e.delay || 0) + c(h, m, n[h], s[h]),
        done: _
      }, e) : e;
      Nw(n[h], s[h], x);
    }
  else
    t.__morphT = 0, t.animateTo({
      __morphT: 1
    }, Bt({
      during: function(b) {
        for (var S = 0; S < m; S++) {
          var w = s[S];
          w.__morphT = t.__morphT, w.dirtyShape();
        }
        u && u(b);
      },
      done: function() {
        v();
        for (var b = 0; b < r.length; b++)
          Qf(r[b], "updateTransform");
        l && l();
      }
    }, e));
  return t.__zr && g(t.__zr), {
    fromIndividuals: n,
    toIndividuals: s,
    count: m
  };
}
function hut(r, t, e) {
  var n = t.length, i = [], a = e.dividePath || eF;
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p];
      Cg(g) ? o(g.childrenRef()) : g instanceof ne && i.push(g);
    }
  }
  if (Cg(r)) {
    o(r.childrenRef());
    var s = i.length;
    if (s < n)
      for (var l = 0, u = s; u < n; u++)
        i.push(G1(i[l++ % s]));
    i.length = n;
  } else {
    i = a({ path: r, count: n });
    for (var c = r.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== n)
      return console.error("Invalid morphing: unmatched splitted path"), s1();
  }
  i = Lg(i), t = Lg(t);
  for (var f = e.individualDelay, u = 0; u < n; u++) {
    var h = f ? Bt({
      delay: (e.delay || 0) + f(u, n, i[u], t[u])
    }, e) : e;
    Nw(i[u], t[u], h);
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length
  };
}
function KR(r) {
  return et(r[0]);
}
function jR(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++)
    e.push({
      one: r[i],
      many: []
    });
  for (var i = 0; i < t.length; i++) {
    var a = t[i].length, o = void 0;
    for (o = 0; o < a; o++)
      e[o % n].many.push(t[i][o]);
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!e[i].many.length) {
      var l = e[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return e;
      var a = l.length, u = Math.ceil(a / 2);
      e[i].many = l.slice(u, a), e[s].many = l.slice(0, u), s++;
    }
  return e;
}
var dut = {
  clone: function(r) {
    for (var t = [], e = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), n = 0; n < r.count; n++) {
      var i = G1(r.path);
      i.setStyle("opacity", e), t.push(i);
    }
    return t;
  },
  // Use the default divider
  split: null
};
function B_(r, t, e, n, i, a) {
  if (!r.length || !t.length)
    return;
  var o = Tc("update", n, i);
  if (!(o && o.duration > 0))
    return;
  var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, c;
  KR(r) && (u = r, c = t), KR(t) && (u = t, c = r);
  function f(m, y, _, x, b) {
    var S = m.many, w = m.one;
    if (S.length === 1 && !b) {
      var A = y ? S[0] : w, T = y ? w : S[0];
      if (Cg(A))
        f({
          many: [A],
          one: T
        }, !0, _, x, !0);
      else {
        var M = s ? Bt({
          delay: s(_, x)
        }, l) : l;
        Nw(A, T, M), a(A, T, A, T, M);
      }
    } else
      for (var C = Bt({
        dividePath: dut[e],
        individualDelay: s && function(O, N, B, F) {
          return s(O + _, x);
        }
      }, l), R = y ? fut(S, w, C) : hut(w, S, C), E = R.fromIndividuals, D = R.toIndividuals, I = E.length, P = 0; P < I; P++) {
        var M = s ? Bt({
          delay: s(P, I)
        }, l) : l;
        a(E[P], D[P], y ? S[P] : m.one, y ? m.one : S[P], M);
      }
  }
  for (var h = u ? u === r : r.length > t.length, d = u ? jR(c, u) : jR(h ? t : r, [h ? r : t]), p = 0, g = 0; g < d.length; g++)
    p += d[g].many.length;
  for (var v = 0, g = 0; g < d.length; g++)
    f(d[g], h, v, p), v += d[g].many.length;
}
function zs(r) {
  if (!r)
    return [];
  if (et(r)) {
    for (var t = [], e = 0; e < r.length; e++)
      t.push(zs(r[e]));
    return t;
  }
  var n = [];
  return r.traverse(function(i) {
    i instanceof ne && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
  }), n;
}
var rF = 1e4, put = 0, JR = 1, QR = 2, vut = ee();
function gut(r, t) {
  for (var e = r.dimensions, n = 0; n < e.length; n++) {
    var i = r.getDimensionInfo(e[n]);
    if (i && i.otherDims[t] === 0)
      return e[n];
  }
}
function mut(r, t, e) {
  var n = r.getDimensionInfo(e), i = n && n.ordinalMeta;
  if (n) {
    var a = r.get(n.name, t);
    return i && i.categories[a] || a + "";
  }
}
function tI(r, t, e, n) {
  var i = n ? "itemChildGroupId" : "itemGroupId", a = gut(r, i);
  if (a) {
    var o = mut(r, t, a);
    return o;
  }
  var s = r.getRawDataItem(t), l = n ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!n)
    return e || r.getId(t);
}
function eI(r) {
  var t = [];
  return L(r, function(e) {
    var n = e.data, i = e.dataGroupId;
    if (n.count() > rF) {
      process.env.NODE_ENV !== "production" && Ye("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var a = n.getIndices(), o = 0; o < a.length; o++)
      t.push({
        data: n,
        groupId: tI(n, o, i, !1),
        childGroupId: tI(n, o, i, !0),
        divide: e.divide,
        dataIndex: o
      });
  }), t;
}
function V_(r, t, e) {
  r.traverse(function(n) {
    n instanceof ne && ze(n, {
      style: {
        opacity: 0
      }
    }, t, {
      dataIndex: e,
      isFrom: !0
    });
  });
}
function F_(r) {
  if (r.parent) {
    var t = r.getComputedTransform();
    r.setLocalTransform(t), r.parent.remove(r);
  }
}
function Au(r) {
  r.stopAnimation(), r.isGroup && r.traverse(function(t) {
    t.stopAnimation();
  });
}
function yut(r, t, e) {
  var n = Tc("update", e, t);
  n && r.traverse(function(i) {
    if (i instanceof ai) {
      var a = X7(i);
      a && i.animateFrom({
        style: a
      }, n);
    }
  });
}
function _ut(r, t) {
  var e = r.length;
  if (e !== t.length)
    return !1;
  for (var n = 0; n < e; n++) {
    var i = r[n], a = t[n];
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function nF(r, t, e) {
  var n = eI(r), i = eI(t);
  function a(_, x, b, S, w) {
    (b || _) && x.animateFrom({
      style: b && b !== _ ? j(j({}, b.style), _.style) : _.style
    }, w);
  }
  var o = !1, s = put, l = wt(), u = wt();
  n.forEach(function(_) {
    _.groupId && l.set(_.groupId, !0), _.childGroupId && u.set(_.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var f = i[c].groupId;
    if (u.get(f)) {
      s = JR;
      break;
    }
    var h = i[c].childGroupId;
    if (h && l.get(h)) {
      s = QR;
      break;
    }
  }
  function d(_, x) {
    return function(b) {
      var S = b.data, w = b.dataIndex;
      return x ? S.getId(w) : _ ? s === JR ? b.childGroupId : b.groupId : s === QR ? b.childGroupId : b.groupId;
    };
  }
  var p = _ut(n, i), g = {};
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(_, x) {
    var b = n[x], S = i[_], w = S.data.hostModel, A = b.data.getItemGraphicEl(b.dataIndex), T = S.data.getItemGraphicEl(S.dataIndex);
    if (A === T) {
      T && yut(T, S.dataIndex, w);
      return;
    }
    // We can't use the elements that already being morphed
    A && g[A.id] || T && (Au(T), A ? (Au(A), F_(A), o = !0, B_(zs(A), zs(T), S.divide, w, _, a)) : V_(T, w, _));
  }
  new Ya(n, i, d(!0, p), d(!1, p), null, "multiple").update(y).updateManyToOne(function(_, x) {
    var b = i[_], S = b.data, w = S.hostModel, A = S.getItemGraphicEl(b.dataIndex), T = Te(rt(x, function(M) {
      return n[M].data.getItemGraphicEl(n[M].dataIndex);
    }), function(M) {
      return M && M !== A && !g[M.id];
    });
    A && (Au(A), T.length ? (L(T, function(M) {
      Au(M), F_(M);
    }), o = !0, B_(zs(T), zs(A), b.divide, w, _, a)) : V_(A, w, b.dataIndex));
  }).updateOneToMany(function(_, x) {
    var b = n[x], S = b.data.getItemGraphicEl(b.dataIndex);
    if (!(S && g[S.id])) {
      var w = Te(rt(_, function(T) {
        return i[T].data.getItemGraphicEl(i[T].dataIndex);
      }), function(T) {
        return T && T !== S;
      }), A = i[_[0]].data.hostModel;
      w.length && (L(w, function(T) {
        return Au(T);
      }), S ? (Au(S), F_(S), o = !0, B_(
        zs(S),
        zs(w),
        b.divide,
        // Use divide on old.
        A,
        _[0],
        a
      )) : L(w, function(T) {
        return V_(T, A, _[0]);
      }));
    }
  }).updateManyToMany(function(_, x) {
    new Ya(x, _, function(b) {
      return n[b].data.getId(n[b].dataIndex);
    }, function(b) {
      return i[b].data.getId(i[b].dataIndex);
    }).update(function(b, S) {
      y(_[b], x[S]);
    }).execute();
  }).execute(), o && L(t, function(_) {
    var x = _.data, b = x.hostModel, S = b && e.getViewOfSeriesModel(b), w = Tc("update", b, 0);
    S && b.isAnimationEnabled() && w && w.duration > 0 && S.group.traverse(function(A) {
      A instanceof ne && !A.animators.length && A.animateFrom({
        style: {
          opacity: 0
        }
      }, w);
    });
  });
}
function rI(r) {
  var t = r.getModel("universalTransition").get("seriesKey");
  return t || r.id;
}
function nI(r) {
  return et(r) ? r.sort().join(",") : r;
}
function _o(r) {
  if (r.hostModel)
    return r.hostModel.getModel("universalTransition").get("divideShape");
}
function xut(r, t) {
  var e = wt(), n = wt(), i = wt();
  L(r.oldSeries, function(o, s) {
    var l = r.oldDataGroupIds[s], u = r.oldData[s], c = rI(o), f = nI(c);
    n.set(f, {
      dataGroupId: l,
      data: u
    }), et(c) && L(c, function(h) {
      i.set(h, {
        key: f,
        dataGroupId: l,
        data: u
      });
    });
  });
  function a(o) {
    e.get(o) && Ye("Duplicated seriesKey in universalTransition " + o);
  }
  return L(t.updatedSeries, function(o) {
    if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
      var s = o.get("dataGroupId"), l = o.getData(), u = rI(o), c = nI(u), f = n.get(c);
      if (f)
        process.env.NODE_ENV !== "production" && a(c), e.set(c, {
          oldSeries: [{
            dataGroupId: f.dataGroupId,
            divide: _o(f.data),
            data: f.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: _o(l),
            data: l
          }]
        });
      else if (et(u)) {
        process.env.NODE_ENV !== "production" && a(c);
        var h = [];
        L(u, function(g) {
          var v = n.get(g);
          v.data && h.push({
            dataGroupId: v.dataGroupId,
            divide: _o(v.data),
            data: v.data
          });
        }), h.length && e.set(c, {
          oldSeries: h,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: _o(l)
          }]
        });
      } else {
        var d = i.get(u);
        if (d) {
          var p = e.get(d.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: d.dataGroupId,
              data: d.data,
              divide: _o(d.data)
            }],
            newSeries: []
          }, e.set(d.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: _o(l)
          });
        }
      }
    }
  }), e;
}
function iI(r, t) {
  for (var e = 0; e < r.length; e++) {
    var n = t.seriesIndex != null && t.seriesIndex === r[e].seriesIndex || t.seriesId != null && t.seriesId === r[e].id;
    if (n)
      return e;
  }
}
function Sut(r, t, e, n) {
  var i = [], a = [];
  L(Ie(r.from), function(o) {
    var s = iI(t.oldSeries, o);
    s >= 0 && i.push({
      dataGroupId: t.oldDataGroupIds[s],
      data: t.oldData[s],
      // TODO can specify divideShape in transition.
      divide: _o(t.oldData[s]),
      groupIdDim: o.dimension
    });
  }), L(Ie(r.to), function(o) {
    var s = iI(e.updatedSeries, o);
    if (s >= 0) {
      var l = e.updatedSeries[s].getData();
      a.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: l,
        divide: _o(l),
        groupIdDim: o.dimension
      });
    }
  }), i.length > 0 && a.length > 0 && nF(i, a, n);
}
function but(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(t, e, n) {
    L(Ie(n.seriesTransition), function(i) {
      L(Ie(i.to), function(a) {
        for (var o = n.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][ev] = !0);
      });
    });
  }), r.registerUpdateLifecycle("series:transition", function(t, e, n) {
    var i = vut(e);
    if (i.oldSeries && n.updatedSeries && n.optionChanged) {
      var a = n.seriesTransition;
      if (a)
        L(Ie(a), function(d) {
          Sut(d, i, n, e);
        });
      else {
        var o = xut(i, n);
        L(o.keys(), function(d) {
          var p = o.get(d);
          nF(p.oldSeries, p.newSeries, e);
        });
      }
      L(n.updatedSeries, function(d) {
        d[ev] && (d[ev] = !1);
      });
    }
    for (var s = t.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], f = 0; f < s.length; f++) {
      var h = s[f].getData();
      h.count() < rF && (l.push(s[f]), u.push(s[f].get("dataGroupId")), c.push(h));
    }
  });
}
var wut = (
  /** @class */
  function() {
    function r() {
      this.breaks = [], this._elapsedExtent = [1 / 0, -1 / 0];
    }
    return r.prototype.setBreaks = function(t) {
      this.breaks = t.breaks;
    }, r.prototype.update = function(t) {
      Tut(this, t);
      var e = this._elapsedExtent;
      e[0] = this.elapse(t[0]), e[1] = this.elapse(t[1]);
    }, r.prototype.hasBreaks = function() {
      return !!this.breaks.length;
    }, r.prototype.calcNiceTickMultiple = function(t, e) {
      for (var n = 0; n < this.breaks.length; n++) {
        var i = this.breaks[n];
        if (i.vmin < t && t < i.vmax) {
          var a = e(t, i.vmax);
          return process.env.NODE_ENV !== "production" && St(a >= 0 && Math.round(a) === a), a;
        }
      }
      return 0;
    }, r.prototype.getExtentSpan = function() {
      return this._elapsedExtent[1] - this._elapsedExtent[0];
    }, r.prototype.normalize = function(t) {
      var e = this._elapsedExtent[1] - this._elapsedExtent[0];
      return e === 0 ? 0.5 : (this.elapse(t) - this._elapsedExtent[0]) / e;
    }, r.prototype.scale = function(t) {
      return this.unelapse(t * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);
    }, r.prototype.elapse = function(t) {
      for (var e = aI, n = oI, i = !0, a = 0; a < this.breaks.length; a++) {
        var o = this.breaks[a];
        if (t <= o.vmax) {
          t > o.vmin ? e += o.vmin - n + (t - o.vmin) / (o.vmax - o.vmin) * o.gapReal : e += t - n, n = o.vmax, i = !1;
          break;
        }
        e += o.vmin - n + o.gapReal, n = o.vmax;
      }
      return i && (e += t - n), e;
    }, r.prototype.unelapse = function(t) {
      for (var e = aI, n = oI, i = !0, a = 0, o = 0; o < this.breaks.length; o++) {
        var s = this.breaks[o], l = e + s.vmin - n, u = l + s.gapReal;
        if (t <= u) {
          t > l ? a = s.vmin + (t - l) / (u - l) * (s.vmax - s.vmin) : a = n + t - e, n = s.vmax, i = !1;
          break;
        }
        e = u, n = s.vmax;
      }
      return i && (a = n + t - e), a;
    }, r;
  }()
);
function Mut() {
  return new wut();
}
var aI = 0, oI = 0;
function Tut(r, t) {
  var e = 0, n = {
    tpAbs: {
      span: 0,
      val: 0
    },
    tpPrct: {
      span: 0,
      val: 0
    }
  }, i = function() {
    return {
      has: !1,
      span: NaN,
      inExtFrac: NaN,
      val: NaN
    };
  }, a = {
    S: {
      tpAbs: i(),
      tpPrct: i()
    },
    E: {
      tpAbs: i(),
      tpPrct: i()
    }
  };
  L(r.breaks, function(s) {
    var l = s.gapParsed;
    l.type === "tpPrct" && (e += l.val);
    var u = Ow(s, t);
    if (u) {
      var c = u.vmin !== s.vmin, f = u.vmax !== s.vmax, h = u.vmax - u.vmin;
      if (!(c && f))
        if (c || f) {
          var d = c ? "S" : "E";
          a[d][l.type].has = !0, a[d][l.type].span = h, a[d][l.type].inExtFrac = h / (s.vmax - s.vmin), a[d][l.type].val = l.val;
        } else
          n[l.type].span += h, n[l.type].val += l.val;
    }
  });
  var o = e * (0 + (t[1] - t[0]) + (n.tpAbs.val - n.tpAbs.span) + (a.S.tpAbs.has ? (a.S.tpAbs.val - a.S.tpAbs.span) * a.S.tpAbs.inExtFrac : 0) + (a.E.tpAbs.has ? (a.E.tpAbs.val - a.E.tpAbs.span) * a.E.tpAbs.inExtFrac : 0) - n.tpPrct.span - (a.S.tpPrct.has ? a.S.tpPrct.span * a.S.tpPrct.inExtFrac : 0) - (a.E.tpPrct.has ? a.E.tpPrct.span * a.E.tpPrct.inExtFrac : 0)) / (1 - n.tpPrct.val - (a.S.tpPrct.has ? a.S.tpPrct.val * a.S.tpPrct.inExtFrac : 0) - (a.E.tpPrct.has ? a.E.tpPrct.val * a.E.tpPrct.inExtFrac : 0));
  L(r.breaks, function(s) {
    var l = s.gapParsed;
    l.type === "tpPrct" && (s.gapReal = e !== 0 ? Math.max(o, 0) * l.val / e : 0), l.type === "tpAbs" && (s.gapReal = l.val), s.gapReal == null && (s.gapReal = 0);
  });
}
function Aut(r, t, e, n, i, a) {
  r !== "no" && L(e, function(o) {
    var s = Ow(o, a);
    if (s)
      for (var l = t.length - 1; l >= 0; l--) {
        var u = t[l], c = n(u), f = i * 3 / 4;
        c > s.vmin - f && c < s.vmax + f && (r !== "preserve_extent_bound" || c !== a[0] && c !== a[1]) && t.splice(l, 1);
      }
  });
}
function Eut(r, t, e, n) {
  L(t, function(i) {
    var a = Ow(i, e);
    a && (r.push({
      value: a.vmin,
      break: {
        type: "vmin",
        parsedBreak: a
      },
      time: n ? n(a) : void 0
    }), r.push({
      value: a.vmax,
      break: {
        type: "vmax",
        parsedBreak: a
      },
      time: n ? n(a) : void 0
    }));
  }), t.length && r.sort(function(i, a) {
    return i.value - a.value;
  });
}
function Ow(r, t) {
  var e = Math.max(r.vmin, t[0]), n = Math.min(r.vmax, t[1]);
  return e < n || e === n && e > t[0] && e < t[1] ? {
    vmin: e,
    vmax: n,
    breakOption: r.breakOption,
    gapParsed: r.gapParsed,
    gapReal: r.gapReal
  } : null;
}
function l1(r, t, e) {
  var n = [];
  if (!r)
    return {
      breaks: n
    };
  function i(o, s) {
    return o >= 0 && o < 1 - 1e-5 ? !0 : (process.env.NODE_ENV !== "production" && ce(s + " must be >= 0 and < 1, rather than " + o + " ."), !1);
  }
  L(r, function(o) {
    if (!o || o.start == null || o.end == null) {
      process.env.NODE_ENV !== "production" && ce("The input axis breaks start/end should not be empty.");
      return;
    }
    if (!o.isExpanded) {
      var s = {
        breakOption: Dt(o),
        vmin: t(o.start),
        vmax: t(o.end),
        gapParsed: {
          type: "tpAbs",
          val: 0
        },
        gapReal: null
      };
      if (o.gap != null) {
        var l = !1;
        if (pt(o.gap)) {
          var u = ei(o.gap);
          if (u.match(/%$/)) {
            var c = parseFloat(u) / 100;
            i(c, "Percent gap") || (c = 0), s.gapParsed.type = "tpPrct", s.gapParsed.val = c, l = !0;
          }
        }
        if (!l) {
          var f = t(o.gap);
          (!isFinite(f) || f < 0) && (process.env.NODE_ENV !== "production" && ce("Axis breaks gap must positive finite rather than (" + o.gap + ")."), f = 0), s.gapParsed.type = "tpAbs", s.gapParsed.val = f;
        }
      }
      if (s.vmin === s.vmax && (s.gapParsed.type = "tpAbs", s.gapParsed.val = 0), e && e.noNegative && L(["vmin", "vmax"], function(d) {
        s[d] < 0 && (process.env.NODE_ENV !== "production" && ce("Axis break." + d + " must not be negative."), s[d] = 0);
      }), s.vmin > s.vmax) {
        var h = s.vmax;
        s.vmax = s.vmin, s.vmin = h;
      }
      n.push(s);
    }
  }), n.sort(function(o, s) {
    return o.vmin - s.vmin;
  });
  var a = -1 / 0;
  return L(n, function(o, s) {
    a > o.vmin && (process.env.NODE_ENV !== "production" && ce("Axis breaks must not overlap."), n[s] = null), a = o.vmax;
  }), {
    breaks: n.filter(function(o) {
      return !!o;
    })
  };
}
function kw(r, t) {
  return u1(t) === u1(r);
}
function u1(r) {
  return r.start + "_\0_" + r.end;
}
function Cut(r, t, e) {
  var n = [];
  L(r, function(a, o) {
    var s = t(a);
    s && s.type === "vmin" && n.push([o]);
  }), L(r, function(a, o) {
    var s = t(a);
    if (s && s.type === "vmax") {
      var l = Ml(
        n,
        // parsedBreak may be changed, can only use breakOption to match them.
        function(u) {
          return kw(t(r[u[0]]).parsedBreak.breakOption, s.parsedBreak.breakOption);
        }
      );
      l && l.push(o);
    }
  });
  var i = [];
  return L(n, function(a) {
    a.length === 2 && i.push(e ? a : [r[a[0]], r[a[1]]]);
  }), i;
}
function Dut(r, t, e, n) {
  var i, a;
  if (r.break) {
    var o = r.break.parsedBreak, s = Ml(e, function(f) {
      return kw(f.breakOption, r.break.parsedBreak.breakOption);
    }), l = n(Math.pow(t, o.vmin), s.vmin), u = n(Math.pow(t, o.vmax), s.vmax), c = {
      type: o.gapParsed.type,
      val: o.gapParsed.type === "tpAbs" ? sr(Math.pow(t, o.vmin + o.gapParsed.val)) - l : o.gapParsed.val
    };
    i = {
      type: r.break.type,
      parsedBreak: {
        breakOption: o.breakOption,
        vmin: l,
        vmax: u,
        gapParsed: c,
        gapReal: o.gapReal
      }
    }, a = s[r.break.type];
  }
  return {
    brkRoundingCriterion: a,
    vBreak: i
  };
}
function Lut(r, t, e) {
  var n = {
    noNegative: !0
  }, i = l1(r, e, n), a = l1(r, e, n), o = Math.log(t);
  return a.breaks = rt(a.breaks, function(s) {
    var l = Math.log(s.vmin) / o, u = Math.log(s.vmax) / o, c = {
      type: s.gapParsed.type,
      val: s.gapParsed.type === "tpAbs" ? Math.log(s.vmin + s.gapParsed.val) / o - l : s.gapParsed.val
    };
    return {
      vmin: l,
      vmax: u,
      gapParsed: c,
      gapReal: s.gapReal,
      breakOption: s.breakOption
    };
  }), {
    parsedOriginal: i,
    parsedLogged: a
  };
}
var Rut = {
  vmin: "start",
  vmax: "end"
};
function Iut(r, t) {
  return t && (r = r || {}, r.break = {
    type: Rut[t.type],
    start: t.parsedBreak.vmin,
    end: t.parsedBreak.vmax
  }), r;
}
function Put() {
  p9({
    createScaleBreakContext: Mut,
    pruneTicksByBreak: Aut,
    addBreaksToTicks: Eut,
    parseAxisBreakOption: l1,
    identifyAxisBreak: kw,
    serializeAxisBreakIdentifier: u1,
    retrieveAxisBreakPairs: Cut,
    getTicksLogTransformBreak: Dut,
    logarithmicParseBreaksFromOption: Lut,
    makeAxisLabelFormatterParamBreak: Iut
  });
}
var sI = ee();
function Nut(r, t) {
  var e = Ml(r, function(n) {
    return ur().identifyAxisBreak(n.parsedBreak.breakOption, t.breakOption);
  });
  return e || r.push(e = {
    zigzagRandomList: [],
    parsedBreak: t,
    shouldRemove: !1
  }), e;
}
function Out(r) {
  L(r, function(t) {
    return t.shouldRemove = !0;
  });
}
function kut(r) {
  for (var t = r.length - 1; t >= 0; t--)
    r[t].shouldRemove && r.splice(t, 1);
}
function But(r, t, e, n, i) {
  var a = e.axis;
  if (a.scale.isBlank() || !ur())
    return;
  var o = ur().retrieveAxisBreakPairs(a.scale.getTicks({
    breakTicks: "only_break"
  }), function(T) {
    return T.break;
  }, !1);
  if (!o.length)
    return;
  var s = e.getModel("breakArea"), l = s.get("zigzagAmplitude"), u = s.get("zigzagMinSpan"), c = s.get("zigzagMaxSpan");
  u = Math.max(2, u || 0), c = Math.max(u, c || 0);
  var f = s.get("expandOnClick"), h = s.get("zigzagZ"), d = s.getModel("itemStyle"), p = d.getItemStyle(), g = p.stroke, v = p.lineWidth, m = p.lineDash, y = p.fill, _ = new Ct({
    ignoreModelZ: !0
  }), x = a.isHorizontal(), b = sI(t).visualList || (sI(t).visualList = []);
  Out(b);
  for (var S = function(T) {
    var M = o[T][0].break.parsedBreak, C = [];
    C[0] = a.toGlobalCoord(a.dataToCoord(M.vmin, !0)), C[1] = a.toGlobalCoord(a.dataToCoord(M.vmax, !0)), C[1] < C[0] && C.reverse();
    var R = Nut(b, M);
    R.shouldRemove = !1;
    var E = new Ct();
    A(R.zigzagRandomList, E, C[0], C[1], x, M), f && E.on("click", function() {
      var D = {
        type: ym,
        breaks: [{
          start: M.breakOption.start,
          end: M.breakOption.end
        }]
      };
      D[a.dim + "AxisIndex"] = e.componentIndex, i.dispatchAction(D);
    }), E.silent = !f, _.add(E);
  }, w = 0; w < o.length; w++)
    S(w);
  r.add(_), kut(b);
  function A(T, M, C, R, E, D) {
    var I = {
      stroke: g,
      lineWidth: v,
      lineDash: m,
      fill: "none"
    }, P = E ? 0 : 1, O = 1 - P, N = n[Wt[O]] + n[cr[O]];
    function B(Gt) {
      var yt = [], Mt = [];
      yt[P] = Mt[P] = Gt, yt[O] = n[Wt[O]], Mt[O] = N;
      var Rt = {
        x1: yt[0],
        y1: yt[1],
        x2: Mt[0],
        y2: Mt[1]
      };
      return tm(Rt, Rt, {
        lineWidth: 1
      }), yt[0] = Rt.x1, yt[1] = Rt.y1, yt[P];
    }
    C = B(C), R = B(R);
    for (var F = [], G = [], W = !0, J = n[Wt[O]], U = 0; ; U++) {
      var Y = J === n[Wt[O]], at = J >= N;
      at && (J = N);
      var st = [], ut = [];
      st[P] = C, ut[P] = R, !Y && !at && (st[P] += W ? -l : l, ut[P] -= W ? l : -l), st[O] = J, ut[O] = J, F.push(st), G.push(ut);
      var lt = void 0;
      if (U < T.length ? lt = T[U] : (lt = Math.random(), T.push(lt)), J += lt * (c - u) + u, W = !W, at)
        break;
    }
    var H = ur().serializeAxisBreakIdentifier(D.breakOption);
    if (M.add(new Gr({
      anid: "break_a_" + H,
      shape: {
        points: F
      },
      style: I,
      z: h
    })), D.gapReal !== 0) {
      M.add(new Gr({
        anid: "break_b_" + H,
        shape: {
          // Not reverse to keep the dash stable when dragging resizing.
          points: G
        },
        style: I,
        z: h
      }));
      var ct = G.slice();
      ct.reverse();
      var ot = F.concat(ct);
      M.add(new Jr({
        anid: "break_c_" + H,
        shape: {
          points: ot
        },
        style: {
          fill: y,
          opacity: p.opacity
        },
        z: h
      }));
    }
  }
}
function Vut(r, t, e, n) {
  var i = r.axis, a = e.transform;
  St(n.style);
  var o = i.getExtent();
  i.inverse && (o = o.slice(), o.reverse());
  var s = ur().retrieveAxisBreakPairs(i.scale.getTicks({
    breakTicks: "only_break"
  }), function(v) {
    return v.break;
  }, !1), l = rt(s, function(v) {
    var m = v[0].break.parsedBreak, y = [i.dataToCoord(m.vmin, !0), i.dataToCoord(m.vmax, !0)];
    return y[0] > y[1] && y.reverse(), {
      coordPair: y,
      brkId: ur().serializeAxisBreakIdentifier(m.breakOption)
    };
  });
  l.sort(function(v, m) {
    return v.coordPair[0] - m.coordPair[0];
  });
  for (var u = o[0], c = null, f = 0; f < l.length; f++) {
    var h = l[f], d = Math.max(h.coordPair[0], o[0]), p = Math.min(h.coordPair[1], o[1]);
    u <= d && g(u, d, c, h), u = p, c = h;
  }
  u <= o[1] && g(u, o[1], c, null);
  function g(v, m, y, _) {
    function x(C, R) {
      a && (nr(C, C, a), nr(R, R, a));
    }
    function b(C, R) {
      var E = {
        x1: C[0],
        y1: C[1],
        x2: R[0],
        y2: R[1]
      };
      tm(E, E, n.style), C[0] = E.x1, C[1] = E.y1, R[0] = E.x2, R[1] = E.y2;
    }
    var S = [v, 0], w = [m, 0], A = [v, 5], T = [m, 5];
    x(S, A), b(S, A), x(w, T), b(w, T), b(S, w);
    var M = new lr(j({
      shape: {
        x1: S[0],
        y1: S[1],
        x2: w[0],
        y2: w[1]
      }
    }, n));
    t.add(M), M.anid = "breakLine_" + (y ? y.brkId : "\0") + "_\0_" + (_ ? _.brkId : "\0");
  }
}
function Fut(r, t, e) {
  if (Ml(e, function(y) {
    return !y;
  }))
    return;
  var n = new Ot();
  if (!gm(e[0], e[1], n, {
    // Assert `labelPair` is `[break_min, break_max]`.
    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.
    // The axisRotation indicates mtv direction of OBB intersecting.
    direction: -(r ? t + Math.PI : t),
    touchThreshold: 0,
    // If need to resovle intersection align axis by moving labels according to MTV,
    // the direction must not be opposite, otherwise cause misleading.
    bidirectional: !1
  }))
    return;
  var i = Br();
  Ko(i, i, -t);
  var a = rt(e, function(y) {
    return y.transform ? Ji(Br(), i, y.transform) : i;
  });
  function o(y) {
    var _ = e[0].localRect, x = new Ot(_[cr[y]] * a[0][0], _[cr[y]] * a[0][1]);
    return Math.abs(x.y) < 1e-5;
  }
  var s = 0.5;
  if (o(0) || o(1)) {
    var l = rt(e, function(y, _) {
      var x = y.localRect.clone();
      return x.applyTransform(a[_]), x;
    }), u = new Ot();
    u.copy(e[0].label).add(e[1].label).scale(0.5), u.transform(i);
    var c = n.clone().transform(i), f = l[0].x + l[1].x + (c.x >= 0 ? l[0].width : l[1].width), h = (f + c.x) / 2 - u.x, d = Math.min(h, h - c.x), p = Math.max(h, h - c.x), g = p < 0 ? p : d > 0 ? d : 0;
    s = (h - g) / c.x;
  }
  var v = new Ot(), m = new Ot();
  Ot.scale(v, n, -s), Ot.scale(m, n, 1 - s), cS(e[0], v), cS(e[1], m);
}
function zut(r, t) {
  var e = {
    breaks: []
  };
  return L(t.breaks, function(n) {
    if (n) {
      var i = Ml(r.get("breaks", !0), function(s) {
        return ur().identifyAxisBreak(s, n);
      });
      if (!i) {
        process.env.NODE_ENV !== "production" && Ye("Can not find axis break by start: " + n.start + ", end: " + n.end);
        return;
      }
      var a = t.type, o = {
        isExpanded: !!i.isExpanded
      };
      i.isExpanded = a === ym ? !0 : a === w3 ? !1 : a === M3 ? !i.isExpanded : i.isExpanded, e.breaks.push({
        start: i.start,
        end: i.end,
        isExpanded: !!i.isExpanded,
        old: o
      });
    }
  }), e;
}
function Uut() {
  OK({
    adjustBreakLabelPair: Fut,
    buildAxisBreakLine: Vut,
    rectCoordBuildBreakAxis: But,
    updateModelAxisBreak: zut
  });
}
function Gut(r) {
  UK(r), Put(), Uut();
}
function Hut() {
  lj(Wut);
}
function Wut(r, t) {
  L(r, function(e) {
    if (!e.model.get(["axisLabel", "inside"])) {
      var n = Xut(e);
      if (n) {
        var i = e.isHorizontal() ? "height" : "width", a = e.model.get(["axisLabel", "margin"]);
        t[i] -= n[i] + a, e.position === "top" ? t.y += n.height + a : e.position === "left" && (t.x += n.width + a);
      }
    }
  });
}
function Xut(r) {
  var t = r.model, e = r.scale;
  if (!t.get(["axisLabel", "show"]) || e.isBlank())
    return;
  var n, i, a = e.getExtent();
  e instanceof sc ? i = e.count() : (n = e.getTicks(), i = n.length);
  var o = r.getLabelModel(), s = Ic(r), l, u = 1;
  i > 40 && (u = Math.ceil(i / 40));
  for (var c = 0; c < i; c += u) {
    var f = n ? n[c] : {
      value: a[0] + c
    }, h = s(f, c), d = o.getTextRect(h), p = g(d, o.get("rotate") || 0);
    l ? l.union(p) : l = p;
  }
  return l;
  function g(v, m) {
    var y = m * Math.PI / 180, _ = v.width, x = v.height, b = _ * Math.abs(Math.cos(y)) + Math.abs(x * Math.sin(y)), S = _ * Math.abs(Math.sin(y)) + Math.abs(x * Math.cos(y)), w = new Vt(v.x, v.y, b, S);
    return w;
  }
}
jt([Pq]);
jt([Cq]);
jt([Qq, pK, MK, Ej, Vj, EJ, tQ, BQ, itt, ftt, mtt, Ttt, _et, Wet, ert, mrt, Srt, Rrt, Vrt, qrt, ent, fnt, Znt]);
jt(dit);
jt(Vit);
jt(K3);
jt(Kit);
jt(kB);
jt(tat);
jt(xat);
jt(Dat);
jt(vot);
jt(Not);
jt(Kh);
jt(Kot);
jt(Qot);
jt(ust);
jt(mst);
jt(wst);
jt(Dst);
jt(Fst);
jt(ilt);
jt(HV);
jt(WV);
jt(Mlt);
jt(qV);
jt(KV);
jt(Clt);
jt(Plt);
jt(Ylt);
jt(qlt);
jt(but);
jt(ZZ);
jt(Gut);
jt(Hut);
jt(Cj);
const Yut = /* @__PURE__ */ Object.assign({ name: "JBRadarChart" }, {
  __name: "RadarChart",
  props: {
    // 
    names: {
      type: Array,
      required: !0
    },
    // 
    maxValues: {
      type: Array,
      required: !0
    },
    // [{ name: '', value: [], color: '#xxx' }]
    seriesData: {
      type: Array,
      required: !0,
      validator: (r) => r.every((t) => t.name && Array.isArray(t.value) && t.color)
    },
    // 
    height: {
      type: String,
      default: "400px"
    }
  },
  setup(r, { expose: t }) {
    const e = r, n = Ir(null);
    let i = null;
    const a = () => {
      const l = e.names.map((c, f) => ({
        name: c,
        max: e.maxValues[f]
      })), u = e.seriesData.map((c) => ({
        name: c.name,
        type: "radar",
        symbol: "none",
        symbolSize: 6,
        areaStyle: {
          opacity: 0.3,
          color: c.color
        },
        itemStyle: {
          color: c.color
        },
        lineStyle: {
          color: c.color,
          width: 2
        },
        data: [c.value]
      }));
      return {
        tooltip: {
          show: !0,
          trigger: "item"
        },
        legend: {
          data: e.seriesData.map((c) => c.name),
          type: "scroll",
          orient: "vertical",
          icon: "roundRect",
          right: "20",
          top: "center",
          itemGap: 30,
          itemWidth: 16,
          itemHeight: 16,
          textStyle: {
            fontSize: 15,
            color: "#656565"
          }
        },
        radar: {
          center: ["50%", "50%"],
          radius: "65%",
          startAngle: 90,
          splitNumber: 5,
          splitArea: {
            areaStyle: {
              color: ["#FFFFFF", "#F5F9FF"].reverse()
            }
          },
          axisLabel: { show: !1 },
          axisLine: {
            show: !0,
            lineStyle: { color: "#D2E4F8" }
          },
          splitLine: {
            show: !0,
            lineStyle: { color: "#D2E4F8" }
          },
          name: {
            formatter: "{value}",
            textStyle: {
              color: "#656565",
              fontSize: 15
            }
          },
          indicator: l
        },
        series: u
      };
    }, o = () => {
      n.value && (i = f$(n.value), i.setOption(a()));
    };
    Fp(
      () => e,
      () => {
        i && i.setOption(a(), !0);
      },
      { deep: !0 }
    );
    const s = () => {
      i == null || i.resize();
    };
    return Rg(() => {
      o(), window.addEventListener("resize", s);
    }), yF(() => {
      window.removeEventListener("resize", s), i == null || i.dispose();
    }), t({
      getChart: () => i
    }), (l, u) => (Ia(), Lo("div", {
      ref_key: "chartRef",
      ref: n,
      style: { width: "100%", height: "400px" }
    }, null, 512));
  }
}), $ut = Dh(Yut), lI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JBHeatMap2: Z4,
  JBHeatMap2D: rW,
  JBRadarChart: $ut,
  WyButton: SF,
  WyHeatMap: W4
}, Symbol.toStringTag, { value: "Module" })), ect = (r) => {
  for (const t in lI)
    r.use(lI[t]);
};
export {
  gc as E,
  Z4 as J,
  qut as M,
  Ps as P,
  Ih as Q,
  d1 as R,
  tct as S,
  Kut as T,
  K as V,
  SF as W,
  Ce as a,
  jut as b,
  W4 as c,
  rW as d,
  $ut as e,
  ect as i
};
